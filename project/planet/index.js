/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/apps/algo-apps/marching-app.ts":
/*!********************************************!*\
  !*** ./src/apps/algo-apps/marching-app.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MarchingCubeApp\": () => (/* binding */ MarchingCubeApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n/* harmony import */ var Engine_render_shaders_DepthMeshShader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Engine/render/shaders/DepthMeshShader */ \"../engine/src/render/shaders/DepthMeshShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    geometry-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: a 3d voxel environment to toy around in. Uses several features of geon\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MarchingCubeApp extends Geon__WEBPACK_IMPORTED_MODULE_5__.App {\r\n    constructor(gl) {\r\n        // setup render env\r\n        super(gl);\r\n        // geo data\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_5__.Plane.WorldXY();\r\n        this.dots = [];\r\n        this.geo = [];\r\n        this.mapGeo = [];\r\n        // logic data\r\n        this.size = 50;\r\n        this.cellSize = 1;\r\n        this.perlinScale = 0.1;\r\n        this.chunks = [];\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_5__.Camera(gl.canvas, 10, true);\r\n        camera.zFar = 10000000;\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_5__.Scene(camera);\r\n        this.chunkShaders = [];\r\n        this.dr = Geon__WEBPACK_IMPORTED_MODULE_5__.DebugRenderer.new(gl);\r\n        this.ds = new Engine_render_shaders_DepthMeshShader__WEBPACK_IMPORTED_MODULE_4__.DepthMeshShader(gl);\r\n        this.dotsShader = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_2__.DotShader(gl);\r\n        this.skyShader = new Geon__WEBPACK_IMPORTED_MODULE_5__.SkyBoxShader(gl);\r\n    }\r\n    start() {\r\n        this.terrain = VoxelTerrain.fromPerlin(this.size, this.cellSize, this.perlinScale);\r\n        this.onTerrainChange();\r\n        // create the world: skybox | sun | planet\r\n        this.skyShader.load([\r\n            \"./data/textures/corona_ft.png\",\r\n            \"./data/textures/corona_bk.png\",\r\n            \"./data/textures/corona_up.png\",\r\n            \"./data/textures/corona_dn.png\",\r\n            \"./data/textures/corona_rt.png\",\r\n            \"./data/textures/corona_lf.png\"\r\n        ]);\r\n        let sunpos = Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(-1000000, -1000000, 0);\r\n        this.scene.sun.pos.copy(sunpos);\r\n        let sunmesh = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.newSphere(sunpos, 50000, 20, 20);\r\n        this.sunShader = Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_3__.PhongShader.new(this.gl);\r\n        this.sunShader.load(Geon__WEBPACK_IMPORTED_MODULE_5__.Entity.new(undefined, Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__.Model.new(sunmesh, Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material.neutral())));\r\n        let planetpos = Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(-10000, 10000, 1000);\r\n        let planetMesh = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.newSphere(planetpos, 5000, 40, 40);\r\n        planetMesh.calcAndSetVertexNormals();\r\n        this.planetShader = Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_3__.PhongShader.new(this.gl);\r\n        let planetMat = Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material.default();\r\n        planetMat.specularDampner = 0.0001;\r\n        planetMat.specular = Geon__WEBPACK_IMPORTED_MODULE_5__.COLOR.black;\r\n        this.planetShader.load(Geon__WEBPACK_IMPORTED_MODULE_5__.Entity.new(undefined, Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__.Model.new(planetMesh, Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material.default())));\r\n    }\r\n    update(input) {\r\n        this.scene.camera.update(input);\r\n        this.scene.sun.pos = this.scene.camera.getActualPosition();\r\n        this.updateCursor(input);\r\n    }\r\n    draw() {\r\n        this.dr.render(this.scene);\r\n        this.ds.draw(this.scene);\r\n        // this.dotsShader.render(this.scene);\r\n        this.drawChunks(this.scene);\r\n        this.skyShader.draw(this.scene);\r\n        this.sunShader.draw(this.scene);\r\n        this.planetShader.draw(this.scene);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////////////////////\r\n    drawChunks(scene) {\r\n        for (let c of this.chunkShaders) {\r\n            c.draw(scene);\r\n        }\r\n    }\r\n    onTerrainChange() {\r\n        // let mcMesh = this.terrain.bufferToMarchingCubes();\r\n        this.chunkShaders = [];\r\n        this.chunks = this.terrain.bufferToMarchingCubesChunks();\r\n        const lBrown = Geon__WEBPACK_IMPORTED_MODULE_5__.Color.fromHex(\"7c5835\");\r\n        const brown = Geon__WEBPACK_IMPORTED_MODULE_5__.Color.fromHex(\"66442c\");\r\n        const browner = Geon__WEBPACK_IMPORTED_MODULE_5__.Color.fromHex(\"4c2b21\");\r\n        const brownst = Geon__WEBPACK_IMPORTED_MODULE_5__.Color.fromHex(\"2e1915\");\r\n        const black = Geon__WEBPACK_IMPORTED_MODULE_5__.COLOR.black;\r\n        const none = Geon__WEBPACK_IMPORTED_MODULE_5__.Color.fromHex(\"00000000\");\r\n        let rockMaterial = new Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material(black, lBrown, brown, none, 10, 1);\r\n        for (let chunk of this.chunks) {\r\n            let ps = new Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_3__.PhongShader(this.gl);\r\n            let e = Geon__WEBPACK_IMPORTED_MODULE_5__.Entity.new(undefined, Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__.Model.new(chunk, rockMaterial));\r\n            ps.load(e);\r\n            this.chunkShaders.push(ps);\r\n        }\r\n        // this.terrainEntity.model.mesh = mcMesh;\r\n        // this.phongShader.load(this.terrainEntity, DrawSpeed.StaticDraw);\r\n        this.dotsShader.set(this.terrain.bufferToPoints());\r\n        // this.dr.set(mcMesh, \"mc\");\r\n    }\r\n    addPreviewCube(point) {\r\n        let cubeCenter = this.terrain.mapToWorld(point);\r\n        let cube = Geon__WEBPACK_IMPORTED_MODULE_5__.Cube.fromRadius(cubeCenter, this.terrain.cellSize / 2);\r\n        let m = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.fromCube(cube).ToShaderMesh();\r\n        m.calculateFaceNormals();\r\n        this.dr.set(m, \"preview-cube\");\r\n    }\r\n    flushPreviewCubes() {\r\n        this.geo = [];\r\n    }\r\n    updateCursor(input) {\r\n        var _a;\r\n        // render mouse to world line\r\n        let mouseRay = this.scene.camera.getMouseWorldRay(input.width, input.height);\r\n        // snap to world\r\n        // let cursor = mouseRay.at(mouseRay.xPlane(this.plane));\r\n        // let mapCursor = this.worldToMap(cursor);\r\n        // let coord = this.mapToWorld(mapCursor);\r\n        // place circle at cursor\r\n        // let plane = this.plane.clone();\r\n        // plane.matrix = plane.matrix.multiply(Matrix4.newTranslation(cursor.x, cursor.y, cursor.z));\r\n        // this.cursorVisual = LineArray.fromCircle(new Circle3(plane, 0.1));\r\n        // figure out which cube we are pointing to\r\n        this.flushPreviewCubes();\r\n        let [cubeID, cubeIDprevious] = this.terrain.raycast(mouseRay, 40);\r\n        if (cubeID == -1) {\r\n            // this.dr.set(Mesh.zero(), \"preview-cube\");\r\n            return;\r\n        }\r\n        let cubeCursor = this.terrain.intCube.getCoord(cubeIDprevious);\r\n        this.addPreviewCube(cubeCursor);\r\n        // render cube at this position\r\n        // this.geo.push(Mesh.fromCube(cube));\r\n        // click\r\n        if (input.mouse.leftPressed) {\r\n            if ((_a = input.keys) === null || _a === void 0 ? void 0 : _a.isDown(Geon__WEBPACK_IMPORTED_MODULE_5__.Key.Space)) {\r\n                if (this.terrain.intCube.data[cubeID] == 0)\r\n                    return;\r\n                this.terrain.intCube.data[cubeID] = 0;\r\n                this.onTerrainChange();\r\n            }\r\n            else if (this.terrain.intCube.data[cubeIDprevious] != 1) {\r\n                this.terrain.intCube.data[cubeIDprevious] = 1;\r\n                this.onTerrainChange();\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Represents a 3D interactible terrain, minecraft style.\r\n */\r\nclass VoxelTerrain {\r\n    constructor(intCube, size, cellSize, halfSize, halfSizePlus) {\r\n        this.intCube = intCube;\r\n        this.size = size;\r\n        this.cellSize = cellSize;\r\n        this.halfSize = halfSize;\r\n        this.halfSizePlus = halfSizePlus;\r\n    }\r\n    static new(size, cellSize) {\r\n        let intCube = Geon__WEBPACK_IMPORTED_MODULE_5__.IntCube.new(size, size, size);\r\n        // let dimentions = Vector3.new(size, size, size);\r\n        let halfSize = size / 2;\r\n        let halfSizePlus = halfSize + cellSize / 2;\r\n        return new VoxelTerrain(intCube, size, cellSize, halfSize, halfSizePlus);\r\n    }\r\n    static fromPerlin(size, cellSize, scale = 0.20, offset = Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.zero()) {\r\n        let terrain = VoxelTerrain.new(size, cellSize);\r\n        let perlin = new Geon__WEBPACK_IMPORTED_MODULE_5__.Perlin();\r\n        terrain.intCube.map((value, i) => {\r\n            let c = terrain.intCube.getCoord(i);\r\n            if (terrain.intCube.isOnEdge(c.x, c.y, c.z)) {\r\n                return 0;\r\n            }\r\n            let noise = perlin.noise(offset.x + c.x * scale, offset.y + c.y * scale, offset.z + c.z * scale);\r\n            if (i < 10) {\r\n                // console.log(c);\r\n                // console.log(noise);\r\n            }\r\n            if (noise > 0.60) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return value;\r\n            }\r\n        });\r\n        return terrain;\r\n    }\r\n    worldToMap(coord) {\r\n        return coord.clone().addN(this.halfSizePlus).floored();\r\n    }\r\n    mapToWorld(point) {\r\n        return point.clone().addN(-this.halfSize);\r\n    }\r\n    bufferToPoints() {\r\n        let centers = [];\r\n        this.intCube.iter((value, index) => {\r\n            if (value == 1) {\r\n                let mapCoord = this.intCube.getCoord(index);\r\n                let coord = this.mapToWorld(mapCoord);\r\n                centers.push(coord);\r\n            }\r\n        });\r\n        return centers;\r\n    }\r\n    bufferToVoxels() {\r\n        let mapGeo = [];\r\n        this.intCube.iter((entry, index) => {\r\n            if (entry == 1) {\r\n                let mapCoord = this.intCube.getCoord(index);\r\n                let coord = this.mapToWorld(mapCoord);\r\n                let cube = Geon__WEBPACK_IMPORTED_MODULE_5__.Cube.fromRadius(coord, this.cellSize / 2);\r\n                mapGeo.push(Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.fromCube(cube));\r\n            }\r\n        });\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.fromJoin(mapGeo);\r\n        mesh = mesh.toLinearMesh();\r\n        mesh.ensureMultiFaceNormals();\r\n        mesh.ensureUVs();\r\n        return mesh;\r\n    }\r\n    bufferToMarchingCubes(level = 0.5) {\r\n        // get the marching cubes function\r\n        let mc = Geon__WEBPACK_IMPORTED_MODULE_5__.marchingCubes;\r\n        let vertices = [];\r\n        this.intCube.iter((value, index) => {\r\n            let coord = this.intCube.getCoord(index);\r\n            // stay away from the last ones \r\n            if (coord.x > this.intCube._width - 2 ||\r\n                coord.y > this.intCube._height - 2 ||\r\n                coord.z > this.intCube._depth - 2) {\r\n                return;\r\n            }\r\n            ;\r\n            // gather a 2x2x2 cube of values\r\n            let coords = [\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y + 1, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y + 1, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y, coord.z + 1),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y, coord.z + 1),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y + 1, coord.z + 1),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y + 1, coord.z + 1),\r\n            ];\r\n            let values = coords.map((v) => this.intCube.tryGet(v.x, v.y, v.z, 0));\r\n            let corners = coords.map((v) => this.mapToWorld(Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(v.x, v.y, v.z)));\r\n            vertices.push(...mc(corners, values, level));\r\n        });\r\n        let intMatrix = Geon__WEBPACK_IMPORTED_MODULE_5__.IntMatrix.new(vertices.length / 3, 3, (0,Geon__WEBPACK_IMPORTED_MODULE_5__.getLongDefaultIndices)(vertices.length));\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.new(Geon__WEBPACK_IMPORTED_MODULE_5__.MultiVector3.fromList(vertices), intMatrix);\r\n        mesh = mesh.toLinearMesh();\r\n        mesh.ensureMultiFaceNormals();\r\n        mesh.ensureUVs();\r\n        return mesh;\r\n    }\r\n    bufferToMarchingCubesChunks(level = 0.5) {\r\n        // get the marching cubes function\r\n        let mc = Geon__WEBPACK_IMPORTED_MODULE_5__.marchingCubes;\r\n        let vertices = [];\r\n        let chunks = [];\r\n        let createChunk = () => {\r\n            let intMatrix = Geon__WEBPACK_IMPORTED_MODULE_5__.IntMatrix.new(vertices.length / 3, 3, (0,Geon__WEBPACK_IMPORTED_MODULE_5__.getDefaultIndices)(vertices.length));\r\n            let chunk = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.new(Geon__WEBPACK_IMPORTED_MODULE_5__.MultiVector3.fromList(vertices), intMatrix);\r\n            chunk.calcAndSetFaceNormals();\r\n            chunk = chunk.toLinearMesh();\r\n            // chunk.ensureMultiFaceNormals();\r\n            chunk.ensureUVs();\r\n            chunks.push(chunk);\r\n        };\r\n        this.intCube.iter((value, index) => {\r\n            if (vertices.length > 60000) {\r\n                createChunk();\r\n                // flush vertices, to create a new chunk\r\n                vertices = [];\r\n            }\r\n            let coord = this.intCube.getCoord(index);\r\n            // stay away from the last ones \r\n            if (coord.x > this.intCube._width - 2 ||\r\n                coord.y > this.intCube._height - 2 ||\r\n                coord.z > this.intCube._depth - 2) {\r\n                return;\r\n            }\r\n            ;\r\n            // gather a 2x2x2 cube of values\r\n            let coords = [\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y + 1, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y + 1, coord.z),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y, coord.z + 1),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y, coord.z + 1),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x + 1, coord.y + 1, coord.z + 1),\r\n                Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(coord.x, coord.y + 1, coord.z + 1),\r\n            ];\r\n            let values = coords.map((v) => this.intCube.tryGet(v.x, v.y, v.z, 0));\r\n            let corners = coords.map((v) => this.mapToWorld(Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.new(v.x, v.y, v.z)));\r\n            vertices.push(...mc(corners, values, level));\r\n        });\r\n        createChunk();\r\n        return chunks;\r\n    }\r\n    /**\r\n     * return the ID of the\r\n     * A Fast Voxel Traversal Algorithm for Ray Tracing\r\n     * Amanatides, Woo\r\n     * Dept. of Computer Science\r\n     */\r\n    raycast(ray, range) {\r\n        let startPoint = this.worldToMap(ray.origin);\r\n        let voxelCenter = this.mapToWorld(startPoint);\r\n        // integers\r\n        let x = startPoint.x;\r\n        let y = startPoint.y;\r\n        let z = startPoint.z;\r\n        let xprev = x;\r\n        let yprev = y;\r\n        let zprev = z;\r\n        let stepX = ray.normal.x > 0 ? 1 : -1;\r\n        let stepY = ray.normal.y > 0 ? 1 : -1;\r\n        let stepZ = ray.normal.z > 0 ? 1 : -1;\r\n        // floats\r\n        let voxelsize = this.cellSize;\r\n        let deltax = voxelsize / Math.abs(ray.normal.x);\r\n        let deltay = voxelsize / Math.abs(ray.normal.y);\r\n        let deltaz = voxelsize / Math.abs(ray.normal.z);\r\n        // intit tx, ty, and tz, at their first intersection with corresponding plane\r\n        voxelCenter.add(new Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3((voxelsize / 2) * stepX, (voxelsize / 2) * stepY, (voxelsize / 2) * stepZ));\r\n        let move = Geon__WEBPACK_IMPORTED_MODULE_5__.Matrix4.newTranslation(voxelCenter.x, voxelCenter.y, voxelCenter.z);\r\n        let xy = Geon__WEBPACK_IMPORTED_MODULE_5__.Plane.WorldXY();\r\n        xy._matrix.multiply(move);\r\n        let yz = Geon__WEBPACK_IMPORTED_MODULE_5__.Plane.WorldYZ();\r\n        yz._matrix.multiply(move);\r\n        let xz = Geon__WEBPACK_IMPORTED_MODULE_5__.Plane.WorldXZ();\r\n        xz._matrix.multiply(move);\r\n        let tx = ray.xPlane(yz);\r\n        let ty = ray.xPlane(xz);\r\n        let tz = ray.xPlane(xy);\r\n        if (tx < 0 || ty < 0 || tz < 0) {\r\n            console.log(\"something critical went wrong!\");\r\n            return [-1, -1];\r\n        }\r\n        // debug ray\r\n        // let lineSets: MultiLine[] = [ray.toLine(100), MultiLine.fromPlane(xy), MultiLine.fromPlane(yz), MultiLine.fromPlane(xz)];\r\n        // this.whiteLineRenderer.set(this.gl, LineArray.fromJoin(lineSets), DrawSpeed.StaticDraw);\r\n        // console.log(\"voxel raycast initialized with:\");\r\n        // console.log(\"deltas: \", deltax, deltay, deltaz);\r\n        // console.log(\"t's: \", tx, ty, tz);\r\n        // start iterating\r\n        // console.log(\"cast away!\");\r\n        // this.addPreviewCube(new Vector3(x,y,z));\r\n        // console.log(x,y,z);\r\n        let intCube = this.intCube;\r\n        for (let i = 0; i < range; i++) {\r\n            // this.addPreviewCube(new Vector3(xprev,yprev,zprev));\r\n            // if hit, return previous\r\n            let value = intCube.tryGet(x, y, z, -1);\r\n            if (value == 1) {\r\n                // console.log(\"found a cube after \" + i + \"steps...\");\r\n                // this.addPreviewCube(new Vector3(xprev,yprev,zprev));\r\n                return [intCube.getIndex(x, y, z), intCube.getIndex(xprev, yprev, zprev)];\r\n            }\r\n            else {\r\n                xprev = x;\r\n                yprev = y;\r\n                zprev = z;\r\n            }\r\n            // to the next cube!\r\n            if (tx < ty && tx < tz) {\r\n                // x\r\n                tx += deltax;\r\n                x += stepX;\r\n            }\r\n            else if (ty < tz) {\r\n                // y\r\n                ty += deltay;\r\n                y += stepY;\r\n            }\r\n            else {\r\n                // z\r\n                tz += deltaz;\r\n                z += stepZ;\r\n            }\r\n        }\r\n        return [-1, -1];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/algo-apps/marching-app.ts?");

/***/ }),

/***/ "./src/apps/algo-apps/wave-app.ts":
/*!****************************************!*\
  !*** ./src/apps/algo-apps/wave-app.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WaveApp\": () => (/* binding */ WaveApp)\n/* harmony export */ });\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n/* harmony import */ var Engine_algorithms_TileSolver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/algorithms/TileSolver */ \"../engine/src/algorithms/TileSolver.ts\");\n/* harmony import */ var Engine_algorithms_TileAtlas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/algorithms/TileAtlas */ \"../engine/src/algorithms/TileAtlas.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass WaveApp extends Geon__WEBPACK_IMPORTED_MODULE_0__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        let canvas = gl.canvas;\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_0__.Camera(canvas, -2, true);\r\n        camera.setState([-25.673, -0.51242, -6.2000, -2, 1.4800000000000004, 4.699999999999986]);\r\n        this.grid = new Geon__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.debug = Geon__WEBPACK_IMPORTED_MODULE_0__.DebugRenderer.new(gl);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_0__.Scene(camera);\r\n        // init some state\r\n    }\r\n    customTiles() {\r\n        // console.log(atlas);\r\n        // let tileData = [\r\n        //     [\r\n        //         _, _, _,\r\n        //         B, B, B,\r\n        //         _, _, _,\r\n        //     ],\r\n        //     [\r\n        //         B, B, B,\r\n        //         _, _, _,\r\n        //         B, B, B,\r\n        //     ],\r\n        //     [\r\n        //         B, _, B,\r\n        //         _, _, _,\r\n        //         B, _, B,\r\n        //     ],\r\n        //     [\r\n        //         B, _, B,\r\n        //         B, _, B,\r\n        //         _, _, _,\r\n        //     ],\r\n        //     [\r\n        //         _, _, _,\r\n        //         B, _, B,\r\n        //         B, _, B,\r\n        //     ],\r\n        //     [\r\n        //         _, B, B,\r\n        //         _, _, _,\r\n        //         _, B, B,\r\n        //     ],\r\n        //     [\r\n        //         B, B, _,\r\n        //         _, _, _,\r\n        //         B, B, _,\r\n        //     ],\r\n        // ];\r\n        // let tiles: Bitmap[] = [];\r\n        // for (let td of tileData) {\r\n        //     let tile = Bitmap.new(3,3);\r\n        //     tile.fillWithColors(td);\r\n        //     tiles.push(tile);\r\n        // }\r\n    }\r\n    start() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.startGrid();\r\n            let plane = Geon__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldYZ().moveTo(Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(-10, 0, 4));\r\n            // fill some state | fill up shaders\r\n            let _ = Geon__WEBPACK_IMPORTED_MODULE_0__.COLOR.white.toInt();\r\n            let B = Geon__WEBPACK_IMPORTED_MODULE_0__.COLOR.black.toInt();\r\n            let U = Geon__WEBPACK_IMPORTED_MODULE_0__.COLOR.blue.toInt();\r\n            // let sample = Bitmap.new(9,9);\r\n            // sample.fillWithColors([\r\n            //    B, B, B, B, _, B, B, B, B,\r\n            //    B, B, B, B, _, B, B, B, B,\r\n            //    B, B, _, _, _, _, _, B, B,\r\n            //    B, B, _, _, _, _, _, B, B,\r\n            //    _, _, _, _, _, _, _, _, _,\r\n            //    B, B, _, _, _, _, _, B, B,\r\n            //    B, B, _, _, _, _, _, B, B,\r\n            //    B, B, B, B, _, B, B, B, B,\r\n            //    B, B, B, B, _, B, B, B, B,\r\n            // ])\r\n            let sample = Geon__WEBPACK_IMPORTED_MODULE_0__.Bitmap.new(4, 4);\r\n            sample.fillWithColors([\r\n                _, B, B, B,\r\n                _, B, U, B,\r\n                _, B, B, B,\r\n                _, _, _, _,\r\n            ]);\r\n            // this.debug.set(ImageMesh.new(sample, Plane.WorldXY(), 1, false, true), \"sample\");\r\n            this.debug.set(Geon__WEBPACK_IMPORTED_MODULE_0__.ImageMesh.new(sample, Geon__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(1, 0, 0)), 1, false, true), \"sample2\");\r\n            sample.fillWithColors([\r\n                _, U, B, U,\r\n                _, B, _, B,\r\n                _, U, B, U,\r\n                _, _, _, _,\r\n            ]);\r\n            // let sample = Bitmap.new(3,3);\r\n            // sample.fillWithColors([\r\n            //     B, B, B,\r\n            //     _, _, _,\r\n            //     B, B, B,\r\n            //  ])\r\n            // create atlas \r\n            let atlas = Engine_algorithms_TileAtlas__WEBPACK_IMPORTED_MODULE_2__.TileAtlas.fromPeriodicSourceImage(sample, 2);\r\n            // TileAtlas.fromSourceImageBetter(sample2, 3);\r\n            console.log(atlas.prototypes);\r\n            // atlas.printAllConnections();\r\n            // console.log(atlas.canBeConnected(0, 1, D8.Right))\r\n            // create wave\r\n            let solver = Engine_algorithms_TileSolver__WEBPACK_IMPORTED_MODULE_1__.TileSolver.new(atlas, 32, 32);\r\n            // let wave = WFC.new(sample, 3, 15, 15);\r\n            // console.log(\"done!\");\r\n            // solver.solve();\r\n            while (!solver.isCollapsed()) {\r\n                solver.solveStep();\r\n                this.debug.set(Geon__WEBPACK_IMPORTED_MODULE_0__.ImageMesh.new(solver.renderResult(), plane), \"result\");\r\n                yield Geon__WEBPACK_IMPORTED_MODULE_0__.Time.sleep(10);\r\n            }\r\n            // this.debug.set(ImageMesh.new(solver.renderResult(), plane), \"result\");\r\n            // let index = 50\r\n            // wave.setOption(index, 0);\r\n            // wave.removeInvalidOptions(index);\r\n            // for (let i = 0 ; i < 1; i++) {\r\n            //     wave.collapseStep();\r\n            // }\r\n            // wave.isCollapsed(true);\r\n            // console.log(\"is collapsed?\", wave.isCollapsed());\r\n            // // console.log(doImagesOverlap(sample2, sample, Vector2.new(-1,-1)));\r\n            for (let i = 0; i < solver.atlas.tiles.length; i++) {\r\n                let plane = Geon__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(i * 3, 5, 0));\r\n                this.debug.set(Geon__WEBPACK_IMPORTED_MODULE_0__.ImageMesh.new(solver.atlas.tiles[i], plane));\r\n            }\r\n        });\r\n    }\r\n    ui(ui) { }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)), 100, 2);\r\n        this.grid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(state) {\r\n        this.scene.camera.update(state);\r\n        // update state | fill up shaders\r\n    }\r\n    draw() {\r\n        this.grid.render(this.scene);\r\n        this.debug.render(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/algo-apps/wave-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/bezier-app.ts":
/*!**********************************************!*\
  !*** ./src/apps/geometry-apps/bezier-app.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BezierApp\": () => (/* binding */ BezierApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\nclass BezierApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, -2, true);\r\n        this.camera.set(-10, 1, 1);\r\n        this.dots = [];\r\n        this.lines = [];\r\n        this.drRed = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 0, 0, 1], false);\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lrRed = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 0, 0, 1]);\r\n        this.lrBlue = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0, 0, 1, 1]);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [1, 0, 0, 0.5], [1, 1, 1, 0.5]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"t\", 0.6, 0, 1, 0.001));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"increase degree\", 0, 0, 10, 1));\r\n        ui.addParameter(this.params[1], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"cut\", 1, 0, 1, 0.001));\r\n        ui.addParameter(this.params[2], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"expand\", 0, 0, 1, 0.001));\r\n        ui.addParameter(this.params[3], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"detail\", 50, 2, 100, 1));\r\n        ui.addParameter(this.params[this.params.length - 1], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        // get all parameters\r\n        let t = this.params[0].get();\r\n        let sub = this.params[1].get();\r\n        let cut = this.params[2].get();\r\n        let exp = this.params[3].get();\r\n        let detail = this.params[this.params.length - 1].get();\r\n        // 1 - bezier\r\n        let bezier = Geon__WEBPACK_IMPORTED_MODULE_3__.Bezier.fromList([\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-2, -2, 0),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-2, 2, 0),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(2, 2, 0),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(2, -2, 0),\r\n        ]);\r\n        let leftover;\r\n        [bezier, leftover] = bezier.splitAt(cut);\r\n        // subdivide bezier `sub` times\r\n        for (let i = 0; i < sub; i++) {\r\n            bezier = bezier.increaseDegree();\r\n        }\r\n        // extend the curve\r\n        bezier.extend(exp);\r\n        // show decastejau triangle\r\n        let tri = Geon__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejau(bezier.verts, t);\r\n        // turn this triangle to lines\r\n        // iterate over this triangle, starting at the base\r\n        let lines = [];\r\n        let size = bezier.degree + 1;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            if (col < 1)\r\n                continue;\r\n            let verts = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiVector3.new(col + 1);\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = Geon__WEBPACK_IMPORTED_MODULE_3__.Util.iterateTriangle(col, row);\r\n                verts.set(row, tri.get(idx));\r\n            }\r\n            lines.push(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromPolyline(Geon__WEBPACK_IMPORTED_MODULE_3__.Polyline.new(verts)));\r\n        }\r\n        // lines.push(leftover.buffer(detail));\r\n        this.lrBlue.set(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(lines));\r\n        this.drBlue.set(tri);\r\n        // dots\r\n        this.dots = [];\r\n        this.dots.push(...bezier.verts.toList());\r\n        this.dots.push(bezier.pointAt(t));\r\n        this.dots.push(bezier.pointAt(t).add(bezier.tangentAt(t)));\r\n        this.dots.push(bezier.pointAt(t).add(bezier.normalAt(t)));\r\n        // lines\r\n        this.lines = [];\r\n        this.lines.push(bezier.buffer(detail));\r\n        this.lines.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Circle3.newPlanar(bezier.pointAt(t), 0.1).buffer());\r\n        // for (let curve of loftcurves) {\r\n        //     this.lines.push(curve.buffer(100));\r\n        // }\r\n        // for (let dot of this.dots) {\r\n        //     this.lines.push(Circle3.newPlanar(dot, 0.1).buffer());\r\n        // }\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY(), 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(state) {\r\n        this.camera.update(state);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.lrGrid.render(c);\r\n        this.drRed.setAndRender(this.dots, c);\r\n        this.drBlue.render(c);\r\n        this.lrRed.setAndRender(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(this.lines), c);\r\n        this.lrBlue.render(c);\r\n        // this.mr.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/bezier-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/bezier-cp-app.ts":
/*!*************************************************!*\
  !*** ./src/apps/geometry-apps/bezier-cp-app.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BezierCpApp\": () => (/* binding */ BezierCpApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\nclass BezierCpApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY();\r\n        this.point = Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, -2, true);\r\n        this.camera.set(-10, 1, 1);\r\n        this.dots = [];\r\n        this.lines = [];\r\n        this.drRed = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 0, 0, 1], false);\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lrRed = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 0, 0, 1]);\r\n        this.lrBlue = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0, 0, 1, 1]);\r\n        this.lrWhite = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 1, 1, 1]);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [1, 0, 0, 0.5], [1, 1, 1, 0.5]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"t\", 0.6, 0, 1, 0.001));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"detail\", 50, 2, 100, 1));\r\n        ui.addParameter(this.params[this.params.length - 1], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        // get all parameters\r\n        let t = this.params[0].get();\r\n        let detail = this.params[this.params.length - 1].get();\r\n        // 1 - bezier\r\n        this.bezier = Geon__WEBPACK_IMPORTED_MODULE_3__.Bezier.fromList([\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-2, -2, 0),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-2, 2, 0),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(2, 2, 0),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(2, -2, 0),\r\n        ]);\r\n        let bezier = this.bezier;\r\n        // dots\r\n        this.dots = [];\r\n        this.dots.push(...bezier.verts.toList());\r\n        this.dots.push(bezier.pointAt(t));\r\n        this.dots.push(bezier.pointAt(t).add(bezier.tangentAt(t)));\r\n        this.dots.push(bezier.pointAt(t).add(bezier.normalAt(t)));\r\n        // lines\r\n        this.lines = [];\r\n        this.lines.push(bezier.buffer(detail));\r\n        this.lines.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Circle3.newPlanar(bezier.pointAt(t), 0.1).buffer());\r\n        // for (let curve of loftcurves) {\r\n        //     this.lines.push(curve.buffer(100));\r\n        // }\r\n        // for (let dot of this.dots) {\r\n        //     this.lines.push(Circle3.newPlanar(dot, 0.1).buffer());\r\n        // }\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromGrid(this.plane, 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        this.updateCursor(input);\r\n    }\r\n    updateCursor(state) {\r\n        // render mouse to world line\r\n        let ray = this.camera.getMouseWorldRay(state.width, state.height);\r\n        let t = ray.xPlane(this.plane);\r\n        this.point = ray.at(t);\r\n        let lines = [];\r\n        lines.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Circle3.newPlanar(this.point, 0.1).buffer());\r\n        t = this.bezier.ApproxClosestPoint(this.point);\r\n        let p2 = this.bezier.pointAt(t);\r\n        lines.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Circle3.newPlanar(p2, 0.1).buffer());\r\n        this.lrBlue.set(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(lines));\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.lrGrid.render(c);\r\n        this.drRed.setAndRender(this.dots, c);\r\n        this.drBlue.render(c);\r\n        this.lrRed.setAndRender(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(this.lines), c);\r\n        this.lrBlue.render(c);\r\n        this.lrWhite.render(c);\r\n        // this.mr.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/bezier-cp-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/icosahedron-app.ts":
/*!***************************************************!*\
  !*** ./src/apps/geometry-apps/icosahedron-app.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IcosahedronApp\": () => (/* binding */ IcosahedronApp),\n/* harmony export */   \"graphToMultiMesh\": () => (/* binding */ graphToMultiMesh)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_mesh_normals_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-normals-shader */ \"../engine/src/render/shaders-old/mesh-normals-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    obj-loader-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: test statistic functionalties\r\n\r\n\r\nclass IcosahedronApp extends Geon__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        this.radius = 0.1; // radius!: Parameter;\r\n        this.detail = 10; // detail!: Parameter;\r\n        this.alpha = 0;\r\n        let canvas = gl.canvas;\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_1__.Scene(new Geon__WEBPACK_IMPORTED_MODULE_1__.Camera(canvas, 8, true));\r\n        this.meshRend = new Geon__WEBPACK_IMPORTED_MODULE_1__.PhongShader(gl);\r\n        this.normalRend = new Engine_render_shaders_old_mesh_normals_shader__WEBPACK_IMPORTED_MODULE_0__.NormalShader(gl);\r\n        this.skyboxShader = new Geon__WEBPACK_IMPORTED_MODULE_1__.SkyBoxShader(gl);\r\n    }\r\n    getIcosahedron() {\r\n        let graph = Geon__WEBPACK_IMPORTED_MODULE_1__.Mesh.newIcosahedron(1).toGraph();\r\n        // let graph = Mesh.newCylinder(Vector3.new(0,0,-1), Vector3.new(0,0,1), 1, 4).toGraph();\r\n        // let graph = Mesh.newSphere(Vector3.new(0,0,0), 1, 5, 10).toGraph().toMesh().toGraph();\r\n        // graph.print();\r\n        return graph;\r\n    }\r\n    getDemoShape() {\r\n        let graph = Geon__WEBPACK_IMPORTED_MODULE_1__.Graph.new();\r\n        function addVert(v) {\r\n            graph.addVert(v, v);\r\n        }\r\n        addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(-1, 0, -1)); // 0\r\n        addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, -1)); // 1\r\n        addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 0, -1)); // 2\r\n        addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, -1)); // 3\r\n        addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 1)); // 4\r\n        addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(-1, 1, 0)); // 5 (should be inserted between 0 and 1)\r\n        graph.addEdge(4, 0);\r\n        graph.addEdge(4, 1);\r\n        graph.addEdge(4, 2);\r\n        graph.addEdge(4, 3);\r\n        // graph.addEdge(4,5);\r\n        graph.addEdge(0, 1);\r\n        graph.addEdge(1, 2);\r\n        graph.addEdge(2, 3);\r\n        graph.addEdge(3, 0);\r\n        graph.addEdge(1, 3);\r\n        graph.print();\r\n        return graph;\r\n    }\r\n    demo() {\r\n        let graph = new Geon__WEBPACK_IMPORTED_MODULE_1__.Graph();\r\n        let normal = new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 1);\r\n        graph.addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0), normal); // 0\r\n        graph.addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(1, 0, 0), normal); // 1\r\n        graph.addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 1, 0), normal); //\r\n        graph.addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(-1, 0, 0), normal); //\r\n        graph.addVert(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, -1, 0), normal); //\r\n        graph.addEdge(0, 1);\r\n        graph.addEdge(0, 2);\r\n        graph.addEdge(0, 3);\r\n        graph.addEdge(0, 4);\r\n        graph.addEdge(1, 2);\r\n        return graph;\r\n    }\r\n    ui(ui) {\r\n        this.rotate = new Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter(\"rotate\", 1, 0, 1, 1);\r\n        this.inner = new Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter(\"inner\", 1, 0, 1, 1);\r\n        // this.radius = new Parameter(\"radius\", 0.1, 0, 0.5, 0.01)\r\n        // this.detail = new Parameter(\"detail\", 6, 3, 20, 1)\r\n        let reset = () => {\r\n            // this.rotate.set(0);\r\n            this.start();\r\n        };\r\n        ui.addBooleanParameter(this.rotate);\r\n        ui.addBooleanParameter(this.inner, reset);\r\n        // ui.addParameter(this.radius, reset);\r\n        // ui.addParameter(this.detail, reset);\r\n        // ui.addButton(() => {this.start()})\r\n    }\r\n    start() {\r\n        this.graph = this.getIcosahedron();\r\n        let mesh = graphToMultiMesh(this.graph, this.radius, this.detail, this.inner.get() == 1);\r\n        let e = Geon__WEBPACK_IMPORTED_MODULE_1__.Entity.new(undefined, Geon__WEBPACK_IMPORTED_MODULE_1__.Model.new(mesh, undefined));\r\n        this.meshRend.load(e);\r\n        this.isocahedron = e;\r\n        this.skyboxShader.load([\r\n            \"./data/textures/corona_ft.png\",\r\n            \"./data/textures/corona_bk.png\",\r\n            \"./data/textures/corona_up.png\",\r\n            \"./data/textures/corona_dn.png\",\r\n            \"./data/textures/corona_rt.png\",\r\n            \"./data/textures/corona_lf.png\"\r\n        ]);\r\n    }\r\n    update(input) {\r\n        this.scene.camera.update(input);\r\n        if (this.rotate.get() == 1) {\r\n            this.alpha += 0.0002 * input.time.tick;\r\n            // let rot = Matrix4.newXRotation(alpha).multiply(Matrix4.newYRotation(alpha));\r\n            // this.isocahedron!.xform.rot.multiply(rot);\r\n            this.isocahedron.xform.rot.setEuler(this.alpha, this.alpha, 0);\r\n            this.meshRend.loadTransform(this.isocahedron.xform);\r\n        }\r\n    }\r\n    draw() {\r\n        this.meshRend.draw(this.scene);\r\n        this.skyboxShader.draw(this.scene);\r\n    }\r\n}\r\nfunction graphToMultiMesh(graph, radius, detail, inner, balls = true) {\r\n    let meshes = [];\r\n    if (balls) {\r\n        graph.allVertPositions().forEach((v) => {\r\n            meshes.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Mesh.newSphere(v, radius * 2, detail, detail * 2));\r\n        });\r\n    }\r\n    let edges = graph.allEdgeVerts();\r\n    for (let i = 0; i < edges.length; i += 2) {\r\n        let from = graph.getVertexPos(edges[i]);\r\n        let to = graph.getVertexPos(edges[i + 1]);\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_1__.Mesh.newCylinder(from, to, radius, detail);\r\n        meshes.push(mesh);\r\n    }\r\n    if (inner) {\r\n        meshes.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Mesh.fromGraph(graph));\r\n    }\r\n    let rmesh = Geon__WEBPACK_IMPORTED_MODULE_1__.Mesh.fromJoin(meshes);\r\n    rmesh.ensureUVs();\r\n    rmesh.calcAndSetVertexNormals();\r\n    return rmesh;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/icosahedron-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/loft-app.ts":
/*!********************************************!*\
  !*** ./src/apps/geometry-apps/loft-app.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LoftApp\": () => (/* binding */ LoftApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\nclass LoftApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, -2, true);\r\n        this.camera.set(-10, 1, 1);\r\n        this.dots = [];\r\n        this.lines = [];\r\n        this.drRed = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 0, 0, 1], false);\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lrRed = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 0, 0, 1]);\r\n        this.lrBlue = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0, 0, 1, 1]);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [1, 0, 0, 0.5], [1, 1, 1, 0.5]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"u\", 0.5, 0, 1, 0.001));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"v\", 0.5, 0, 1, 0.001));\r\n        ui.addParameter(this.params[1], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"displace bottom\", 0, -5, 5, 0.001));\r\n        ui.addParameter(this.params[2], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"detail\", 10, 2, 100, 1));\r\n        ui.addParameter(this.params[this.params.length - 1], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        // get all parameters\r\n        let u = this.params[0].get();\r\n        let v = this.params[1].get();\r\n        let y = this.params[2].get();\r\n        let detail = this.params[this.params.length - 1].get();\r\n        // 2 - loft\r\n        let loftcurves = [\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Bezier.fromList([\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(3, -1, 4),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(1, -2, 4),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(1, 2, 4.5),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-1, 1, 4),\r\n            ]),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Bezier.fromList([\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(3, -1, 2),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(1, -1, 1.5),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(1, 1, 1.5),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-1, 1, 2),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-2, 1, 2),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-4, 2, 3),\r\n            ]),\r\n            Geon__WEBPACK_IMPORTED_MODULE_3__.Bezier.fromList([\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(3, -1, 0),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(1, -1, 0),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(1, 1, 0),\r\n                Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(-1, 1, 0),\r\n            ]),\r\n        ];\r\n        loftcurves[2].move(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.new(0, y, 0));\r\n        let loft = Geon__WEBPACK_IMPORTED_MODULE_3__.Loft.new(loftcurves);\r\n        // dots\r\n        this.dots = [];\r\n        this.dots.push(loft.pointAt(u, v));\r\n        // lines\r\n        this.lines = [];\r\n        this.lines.push(loft.isoCurveV(u).buffer(detail));\r\n        this.lines.push(loft.isoCurveU(v).buffer(detail));\r\n        // mesh\r\n        this.mr.set(loft.buffer(detail, detail).ToShaderMesh());\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY(), 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.lrGrid.render(c);\r\n        this.drRed.setAndRender(this.dots, c);\r\n        this.drBlue.render(c);\r\n        this.lrRed.setAndRender(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(this.lines), c);\r\n        this.lrBlue.render(c);\r\n        this.mr.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/loft-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/spline.app.ts":
/*!**********************************************!*\
  !*** ./src/apps/geometry-apps/spline.app.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SplineApp\": () => (/* binding */ SplineApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\nclass SplineApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, -2, true);\r\n        this.camera.set(-10, 1, 1);\r\n        this.dots = [];\r\n        this.lines = [];\r\n        this.drRed = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 0, 0, 1], false);\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lrRed = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 0, 0, 1]);\r\n        this.lrBlue = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0, 0, 1, 1]);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [1, 0, 0, 0.5], [1, 1, 1, 0.5]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"t\", 0.6, 0, 1, 0.001));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"degree\", 1, 1, 10, 1));\r\n        ui.addParameter(this.params[1], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"n control points\", 4, 0, 1000, 1));\r\n        ui.addParameter(this.params[2], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"detail\", 50, 2, 1000, 1));\r\n        ui.addParameter(this.params[this.params.length - 1], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        console.clear();\r\n        // get all parameters\r\n        let t = this.params[0].get();\r\n        let degree = this.params[1].get();\r\n        let count = this.params[2].get();\r\n        // let increaseDegree = this.params[2].get();\r\n        let detail = this.params[this.params.length - 1].get();\r\n        // 1 - bezier\r\n        let domain = Geon__WEBPACK_IMPORTED_MODULE_3__.Domain3.fromRadii(5, 5, 1);\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.fromSeed(1234);\r\n        let spline = Geon__WEBPACK_IMPORTED_MODULE_3__.Spline.new(domain.populate(count, rng), degree);\r\n        // dots\r\n        this.dots = [];\r\n        this.dots.push(...spline.verts.toList());\r\n        this.dots.push(spline.pointAt(t));\r\n        // lines\r\n        this.lines = [];\r\n        this.lines.push(spline.buffer(detail));\r\n        this.lines.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Circle3.newPlanar(spline.pointAt(t), 0.1).buffer());\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY(), 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.lrGrid.render(c);\r\n        this.drRed.setAndRender(this.dots, c);\r\n        this.drBlue.render(c);\r\n        this.lrRed.setAndRender(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(this.lines), c);\r\n        this.lrBlue.render(c);\r\n        // this.mr.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/spline.app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/surface-app.ts":
/*!***********************************************!*\
  !*** ./src/apps/geometry-apps/surface-app.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SurfaceApp\": () => (/* binding */ SurfaceApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\nclass SurfaceApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, -2, true);\r\n        this.camera.setState([21.926, 11.337, -10.04, -10, 1.12, 1.08]);\r\n        this.seed = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.randomSeed();\r\n        this.dots = [];\r\n        this.lines = [];\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lrRed = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 0, 0, 1]);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [1, 0, 0, 0.5], [1, 1, 1, 0.5]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"degree\", 3, 2, 6, 1));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"displace\", 4, 0, 10, 0.001));\r\n        ui.addParameter(this.params[1], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"detail\", 50, 2, 100, 1));\r\n        ui.addParameter(this.params[2], this.start.bind(this));\r\n        // this.params.push(Parameter.new(\"select\", 0, 0, 20, 1));\r\n        // ui.addParameter(this.params[3], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        // get all parameters\r\n        let degree = this.params[0].get();\r\n        let displace = this.params[1].get();\r\n        let detail = this.params[2].get();\r\n        // let select = this.params[3].get();\r\n        // get some points\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.fromSeed(this.seed);\r\n        let vecs = Geon__WEBPACK_IMPORTED_MODULE_3__.Domain2.fromRadius(-11) // span a (-size to size)**2 domain\r\n            .offset([-22, 22, 0, 0]) // flip it\r\n            .spawn(degree + 1, degree + 1) // spawn a bunch of points, the exact amound needed for the surface\r\n            .to3D()\r\n            .forEach((v) => {\r\n            return v\r\n                .add(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromRandomUnit(rng).scale(displace))\r\n                .add(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.unitZ().scale(5)); // and displace them slightly\r\n        });\r\n        // create a surface from it\r\n        let surface = Geon__WEBPACK_IMPORTED_MODULE_3__.BezierSquare.new(vecs, degree, degree);\r\n        this.drBlue.set(vecs);\r\n        // lines\r\n        this.lines = [];\r\n        // this.lines.push(Circle3.newPlanar(vecs.get(select), 1).buffer());\r\n        // mesh\r\n        // this.drBlue.set(surface.buffer(detail, detail).verts);\r\n        this.mr.set(surface.buffer(detail, detail).ToShaderMesh());\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY(), 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.lrRed.setAndRender(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(this.lines), c);\r\n        this.drBlue.render(c);\r\n        this.lrGrid.render(c);\r\n        this.mr.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/surface-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/surface-cp-app.ts":
/*!**************************************************!*\
  !*** ./src/apps/geometry-apps/surface-cp-app.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SurfaceCpApp\": () => (/* binding */ SurfaceCpApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\nclass SurfaceCpApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY();\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, -2, true);\r\n        this.camera.setState([21.926, 11.337, -10.04, -10, 1.12, 1.08]);\r\n        this.seed = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.randomSeed();\r\n        this.dots = [];\r\n        this.lines = [];\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lrRed = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [1, 0, 0, 1]);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [1, 0, 0, 0.5], [1, 0.5, 0.5, 0.5]);\r\n        this.mr2 = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [0, 1, 1, 0.25], [0, 1, 1, 0.75]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"degree\", 3, 2, 6, 1));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"displace\", 4, 0, 10, 0.001));\r\n        ui.addParameter(this.params[1], this.start.bind(this));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.new(\"detail\", 50, 2, 100, 1));\r\n        ui.addParameter(this.params[2], this.start.bind(this));\r\n        // this.params.push(Parameter.new(\"select\", 0, 0, 20, 1));\r\n        // ui.addParameter(this.params[3], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        // get all parameters\r\n        let degree = this.params[0].get();\r\n        let displace = this.params[1].get();\r\n        let detail = this.params[2].get();\r\n        // let select = this.params[3].get();\r\n        // get some points\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.fromSeed(this.seed);\r\n        let vecs = Geon__WEBPACK_IMPORTED_MODULE_3__.Domain2.fromRadius(-11) // span a (-size to size)**2 domain\r\n            .offset([-22, 22, 0, 0]) // flip it\r\n            .spawn(degree + 1, degree + 1) // spawn a bunch of points, the exact amound needed for the surface\r\n            .to3D()\r\n            .forEach((v) => {\r\n            return v\r\n                .add(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromRandomUnit(rng).scale(displace))\r\n                .add(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.unitZ().scale(5)); // and displace them slightly\r\n        });\r\n        // create a surface from it\r\n        let surface = Geon__WEBPACK_IMPORTED_MODULE_3__.BezierSquare.new(vecs, degree, degree);\r\n        this.surface = surface;\r\n        this.drBlue.set(vecs);\r\n        // lines\r\n        this.lines = [];\r\n        // this.lines.push(Circle3.newPlanar(vecs.get(select), 1).buffer());\r\n        // mesh\r\n        // this.drBlue.set(surface.buffer(detail, detail).verts);\r\n        this.mr.set(surface.buffer(detail, detail).ToShaderMesh());\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY(), 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        this.updateCursor(input);\r\n    }\r\n    updateCursor(state) {\r\n        // render mouse to world line\r\n        let ray = this.camera.getMouseWorldRay(state.width, state.height);\r\n        let t = ray.xPlane(this.plane);\r\n        let point = ray.at(20);\r\n        let meshes = [];\r\n        meshes.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Mesh.newSphere(point, 1, 10, 10));\r\n        let uv = this.surface.approxClosestPoint(point);\r\n        let p2 = this.surface.pointAtUV(uv);\r\n        meshes.push(Geon__WEBPACK_IMPORTED_MODULE_3__.Mesh.newSphere(p2, 1, 10, 10));\r\n        this.mr2.set(Geon__WEBPACK_IMPORTED_MODULE_3__.Mesh.fromJoin(meshes).ToShaderMesh(), Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.DynamicDraw);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.lrRed.setAndRender(Geon__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromJoin(this.lines), c);\r\n        this.drBlue.render(c);\r\n        this.lrGrid.render(c);\r\n        this.mr.render(c);\r\n        this.mr2.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/surface-cp-app.ts?");

/***/ }),

/***/ "./src/apps/geometry-apps/torus-app.ts":
/*!*********************************************!*\
  !*** ./src/apps/geometry-apps/torus-app.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TorusApp\": () => (/* binding */ TorusApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\n\r\n\r\nclass TorusApp extends Geon__WEBPACK_IMPORTED_MODULE_4__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        this.r = 0;\r\n        let canvas = gl.canvas;\r\n        this.gs = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_2__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.dr = Geon__WEBPACK_IMPORTED_MODULE_4__.DebugRenderer.new(gl);\r\n        this.ps = Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_3__.PhongShader.new(gl);\r\n        this.entity = Geon__WEBPACK_IMPORTED_MODULE_4__.Entity.new(undefined, Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__.Model.new(undefined, Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material.newPurple()));\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_4__.Camera(canvas, -2, true);\r\n        camera.set(-50, 1, 1);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_4__.Scene(camera);\r\n    }\r\n    start() {\r\n        this.startGrid();\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.newTorus(5, 1, 30, 20);\r\n        mesh.ensureUVs();\r\n        this.entity.model.mesh = mesh;\r\n        this.ps.load(this.entity, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.StaticDraw);\r\n        // create something!\r\n    }\r\n    ui(ui) {\r\n        ui.add3DParameter(\"sun\", Geon__WEBPACK_IMPORTED_MODULE_4__.Domain3.fromRadius(5), 0.01, this.scene.sun.pos);\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_4__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_4__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, -1)), 100, 2);\r\n        this.gs.set(grid, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.scene.camera.update(input);\r\n        this.r += 0.0005 * input.time.tick;\r\n        this.entity.xform.rot.setEuler(this.r, -this.r, this.r);\r\n        this.ps.loadTransform(this.entity.xform);\r\n    }\r\n    draw() {\r\n        this.gs.render(this.scene);\r\n        this.dr.render(this.scene);\r\n        this.ps.draw(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/geometry-apps/torus-app.ts?");

/***/ }),

/***/ "./src/apps/math-apps/least-squares-app.ts":
/*!*************************************************!*\
  !*** ./src/apps/math-apps/least-squares-app.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LeastSquaresApp\": () => (/* binding */ LeastSquaresApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// good sites explaining the power of least squares\r\n// https://courses.physics.illinois.edu/cs357/sp2020/notes/ref-17-least-squares.html\r\n// http://textbooks.math.gatech.edu/ila/least-squares.html\r\n// https://www.cc.gatech.edu/classes/AY2016/cs4476_fall/results/proj3/html/cpaulus3/index.html\r\n\r\n\r\n\r\nclass LeastSquaresApp extends Geon__WEBPACK_IMPORTED_MODULE_2__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        this.count = 2;\r\n        let canvas = gl.canvas;\r\n        this.rng = Geon__WEBPACK_IMPORTED_MODULE_2__.Random.fromSeed(1234);\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_2__.Camera(canvas, -2, true);\r\n        this.drRed = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 0, 0, 1], false);\r\n        this.drGreen = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 1, 0, 1], false);\r\n        this.drBlue = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [0, 0, 1, 1], false);\r\n        this.lineRenderer = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.points = createRandomPoints(16, 1, this.rng);\r\n        this.resetCamera();\r\n    }\r\n    ui(ui) {\r\n        const factor = 5;\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"x\", 0, -factor, factor, 0.1));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"y\", 0, -factor, factor, 0.1));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"z\", 0, -factor, factor, 0.1));\r\n        const two_pi = 3.1415 * 2;\r\n        const piPart = (two_pi * 2) / 100;\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"a\", 0.0, -two_pi, two_pi, piPart));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"b\", 0.0, -two_pi, two_pi, piPart));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"g\", 0.0, -two_pi, two_pi, piPart));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"sx\", 1, -factor, factor, 0.1));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"sy\", 1, -factor, factor, 0.1));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"sz\", 1, -factor, factor, 0.1));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"noise\", 0, 0, 1, 0.01));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter.newBoolean(\"realtime\", true));\r\n        this.params.push(new Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter(\"point count\", 16, 1, 100, 1));\r\n        let p = this.params;\r\n        let recalc = () => {\r\n            if (this.params[10].state == 1) {\r\n                this.start();\r\n            }\r\n        };\r\n        ui.addText(\"Using least squares adjustment & singular value decomposition to solve a 3D transformation between points. F12 for more info\");\r\n        ui.addText(\"translate\");\r\n        ui.addParameter(p[0], recalc);\r\n        ui.addParameter(p[1], recalc);\r\n        ui.addParameter(p[2], recalc);\r\n        ui.addText(\"rotate\");\r\n        ui.addParameter(p[3], recalc);\r\n        ui.addParameter(p[4], recalc);\r\n        ui.addParameter(p[5], recalc);\r\n        ui.addText(\"scale\");\r\n        ui.addParameter(p[6], recalc);\r\n        ui.addParameter(p[7], recalc);\r\n        ui.addParameter(p[8], recalc);\r\n        ui.addText(\"\");\r\n        ui.addParameter(p[9], recalc);\r\n        ui.addParameter(p[11], () => {\r\n            this.points = createRandomPoints(this.params[11].get(), 1, this.rng);\r\n            this.start();\r\n        });\r\n        ui.addBooleanParameter(p[10]);\r\n        ui.addButton(\"recalculate\", () => {\r\n            this.start();\r\n        });\r\n    }\r\n    resetCamera() {\r\n        this.camera.zoom = -10;\r\n        this.camera.angleAlpha = Math.PI * 0.25;\r\n        this.camera.angleBeta = Math.PI * 0.25;\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -1)), 100, 2);\r\n        this.lineRenderer.set(grid, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n    }\r\n    start() {\r\n        console.clear();\r\n        // translate\r\n        let mov = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newTranslation(this.params[0].get(), this.params[1].get(), this.params[2].get());\r\n        // rotate\r\n        let rotx = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newXRotation(this.params[3].get());\r\n        let roty = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newYRotation(this.params[4].get());\r\n        let rotz = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newZRotation(this.params[5].get());\r\n        let rot = rotx.multiplied(roty).multiplied(rotz);\r\n        // scale\r\n        let sca = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newScaler(this.params[6].get(), this.params[7].get(), this.params[8].get());\r\n        // compound\r\n        let M = sca.multiplied(rot.multiplied(mov));\r\n        // transform the points\r\n        this.Pnormal = this.points.clone().transform(M);\r\n        // apply noise\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_2__.Random.fromSeed(123494854);\r\n        let noise = this.params[9].get();\r\n        this.Pnormal = this.Pnormal.map((v, i) => {\r\n            return v.add(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.fromRandomUnit(rng).scale(noise));\r\n        });\r\n        // approximate using least squares adjustment\r\n        let lsa_matrix = leastSquares(this.points, this.Pnormal);\r\n        this.Plsa = this.points.clone().transform(lsa_matrix);\r\n        // also just take the average of translation vectors\r\n        // let translated = combine(this.points, this.Pnormal, (a, b) => {\r\n        //     return b.subbed(a);\r\n        // });\r\n        // let average = translated.average();\r\n        // let avg_matrix = Matrix4.newTranslation(average.x, average.y, average.z);\r\n        // this.Plsa = this.points.clone().transform(avg_matrix);\r\n        console.log(\"original matrix: (blue)\");\r\n        M.print();\r\n        console.log(M.get(0, 3));\r\n        console.log(\"lsa+svd recovered matrix from nothing but the points: (green)\");\r\n        lsa_matrix.print();\r\n        // let lsa_trans_matrix = leastSquaresTranslation(this.points, this.Pnormal);\r\n        // console.log(\"only translation matrix: (green)\");\r\n        // lsa_trans_matrix.print();\r\n        // TODO something is going wrong with setting, so we are using set&render in the draw step every time...\r\n        this.startGrid();\r\n    }\r\n    update(input) {\r\n        // move the camera with the mouse\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        // get to-screen matrix\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_2__.Scene(this.camera);\r\n        this.lineRenderer.render(c);\r\n        this.drRed.setAndRender(this.points, c);\r\n        this.drBlue.setAndRender(this.Pnormal, c);\r\n        this.drGreen.setAndRender(this.Plsa, c);\r\n    }\r\n}\r\nfunction combine(va, vb, callback) {\r\n    let result = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiVector3.new(va.count);\r\n    if (va.count != vb.count) {\r\n        console.warn(\"not same length!\");\r\n        return result;\r\n    }\r\n    let count = va.count;\r\n    for (let i = 0; i < count; i++) {\r\n        result.set(i, callback(va.get(i), vb.get(i)));\r\n    }\r\n    return result;\r\n}\r\nfunction createRandomPoints(count, range, rng) {\r\n    let bounds = Geon__WEBPACK_IMPORTED_MODULE_2__.Domain3.fromBounds(-range, range, -range, range, -range, range);\r\n    let multi = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiVector3.new(count);\r\n    for (let i = 0; i < count; i++) {\r\n        multi.set(i, bounds.elevate(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.fromRandom(rng)));\r\n    }\r\n    return multi;\r\n}\r\n// solve x for Ax = b, where in this case, A = left, b = right.\r\nfunction leastSquares(left, right) {\r\n    if (left.count != right.count) {\r\n        throw \"matrices need to be of equal width & height\";\r\n    }\r\n    // construct linear system of equations\r\n    let n = left.count;\r\n    let left_width = 4;\r\n    let right_width = 3;\r\n    let height = right_width * n;\r\n    let width = 16;\r\n    let M = new Geon__WEBPACK_IMPORTED_MODULE_2__.FloatMatrix(width, height);\r\n    // per row in floatmatrix\r\n    for (let f = 0; f < n; f++) {\r\n        let l_vec = [...left.slice().getRow(f), 1];\r\n        let r_vec = [...right.slice().getRow(f), 1];\r\n        // go over x', y', z', 1 on the right side\r\n        for (let part = 0; part < right_width; part++) {\r\n            //\r\n            let i = f * right_width + part;\r\n            let offset = left_width * part;\r\n            // X  Y  Z  1  0  0  0  0 ...\r\n            for (let j = 0; j < l_vec.length; j++) {\r\n                M.set(i, j + offset, l_vec[j]);\r\n            }\r\n            // ... -v*X  -v*Y  -v*Z   -v*1\r\n            offset = width - left_width;\r\n            for (let j = 0; j < l_vec.length; j++) {\r\n                let v = M.get(i, j + offset);\r\n                M.set(i, j + offset, v + -1 * r_vec[part] * l_vec[j]);\r\n            }\r\n        }\r\n    }\r\n    let [U, S, V] = Geon__WEBPACK_IMPORTED_MODULE_2__.Stat.svd(M);\r\n    let col = V.getColumn(V.width - 1);\r\n    let scaler = 1 / col[15];\r\n    for (let i = 0; i < col.length; i++) {\r\n        col[i] = Math.round(col[i] * scaler * 100000) / 100000;\r\n    }\r\n    // create the actual matrix\r\n    let matrix = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.new([...col]);\r\n    return matrix.transpose();\r\n}\r\n// The Same, but only recover the translation between the vectors\r\nfunction leastSquaresTranslation(left, right) {\r\n    if (left.count != right.count) {\r\n        throw \"matrices need to be of equal width & height\";\r\n    }\r\n    // construct linear system of equations\r\n    let n = left.count;\r\n    let left_width = 4;\r\n    let right_width = 3;\r\n    let height = right_width * n;\r\n    let width = 16;\r\n    let M = new Geon__WEBPACK_IMPORTED_MODULE_2__.FloatMatrix(width, height);\r\n    // per row in floatmatrix\r\n    for (let f = 0; f < n; f++) {\r\n        let l_vec = [...left.slice().getRow(f), 1];\r\n        let r_vec = [...right.slice().getRow(f), 1];\r\n        // go over x', y', z', 1 on the right side\r\n        for (let part = 0; part < right_width; part++) {\r\n            //\r\n            let i = f * right_width + part;\r\n            let offset = left_width * part;\r\n            // X  Y  Z  1  0  0  0  0 ...\r\n            for (let j = 0; j < l_vec.length; j++) {\r\n                M.set(i, j + offset, l_vec[j]);\r\n            }\r\n            // ... -v*X  -v*Y  -v*Z   -v*1\r\n            offset = width - left_width;\r\n            for (let j = 0; j < l_vec.length; j++) {\r\n                let v = M.get(i, j + offset);\r\n                M.set(i, j + offset, v + -1 * r_vec[part] * l_vec[j]);\r\n            }\r\n        }\r\n    }\r\n    M.print();\r\n    let [U, S, V] = Geon__WEBPACK_IMPORTED_MODULE_2__.Stat.svd(M);\r\n    let col = V.getColumn(V.width - 1);\r\n    let scaler = 1 / col[15];\r\n    for (let i = 0; i < col.length; i++) {\r\n        col[i] = Math.round(col[i] * scaler * 100000) / 100000;\r\n    }\r\n    // create the actual matrix\r\n    let matrix = Geon__WEBPACK_IMPORTED_MODULE_2__.Matrix4.new([...col]);\r\n    return matrix.transpose();\r\n}\r\nfunction leastSquaresGeneral(A, b) {\r\n    return b;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/math-apps/least-squares-app.ts?");

/***/ }),

/***/ "./src/apps/math-apps/least-squares-circle-app.ts":
/*!********************************************************!*\
  !*** ./src/apps/math-apps/least-squares-circle-app.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LeastSquaresCircleApp\": () => (/* binding */ LeastSquaresCircleApp)\n/* harmony export */ });\n/* harmony import */ var Engine_math_LSA__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/math/LSA */ \"../engine/src/math/LSA.ts\");\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// good sites explaining the power of least squares\r\n// https://courses.physics.illinois.edu/cs357/sp2020/notes/ref-17-least-squares.html\r\n// http://textbooks.math.gatech.edu/ila/least-squares.html\r\n// https://www.cc.gatech.edu/classes/AY2016/cs4476_fall/results/proj3/html/cpaulus3/index.html\r\n\r\n\r\n\r\nclass LeastSquaresCircleApp extends Geon__WEBPACK_IMPORTED_MODULE_2__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        this.points = [];\r\n        let canvas = gl.canvas;\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_2__.Camera(canvas, 10, true);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_2__.Scene(camera);\r\n        this.omni = Geon__WEBPACK_IMPORTED_MODULE_2__.DebugRenderer.new(gl);\r\n        this.ds = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_1__.DotShader(gl);\r\n        this.dsYellow = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_1__.DotShader(gl, 10, [0, 1, 1, 1], false);\r\n    }\r\n    ui(ui) {\r\n        let button = Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter.newBoolean(\"remove outliers\", false);\r\n        let error = Geon__WEBPACK_IMPORTED_MODULE_2__.Parameter.new(\"max allowed error\", 10, 0.5, 100);\r\n        // ui.addBooleanParameter(button);\r\n        // ui.addParameter(error);\r\n        this.params.push(button, error);\r\n    }\r\n    resetCamera() {\r\n        this.scene.camera.zoom = -10;\r\n        this.scene.camera.angleAlpha = Math.PI * 0.25;\r\n        this.scene.camera.angleBeta = Math.PI * 0.25;\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY(), 100, 1);\r\n        this.omni.set(grid, \"grid\", [0.3, 0.3, 0.3, 1]);\r\n    }\r\n    start() {\r\n        this.startGrid();\r\n        let seed = Math.random() * 100000;\r\n        let someSeed = 49289.2005200531;\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_2__.Random.fromSeed(seed);\r\n        console.log(seed);\r\n        // this.points = Domain2.fromRadius(2).populate(10, rng).to3D().toList();\r\n        let useOutlierRemoval = this.params[0].get() == 1;\r\n        let maxError = this.params[1].get();\r\n        this.lsa(useOutlierRemoval, maxError);\r\n    }\r\n    update(input) {\r\n        var _a, _b;\r\n        // move the camera with the mouse\r\n        this.scene.camera.update(input);\r\n        if (((_a = input.mouse) === null || _a === void 0 ? void 0 : _a.leftDown) || ((_b = input.touch) === null || _b === void 0 ? void 0 : _b.tab)) {\r\n            let ray = this.scene.camera.getMouseWorldRay(this.gl.canvas.width, this.gl.canvas.height, true);\r\n            let point = ray.at(ray.xPlane(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY()));\r\n            this.points.push(point);\r\n            this.lsa();\r\n        }\r\n    }\r\n    draw() {\r\n        this.omni.render(this.scene);\r\n        this.ds.render(this.scene);\r\n        this.dsYellow.render(this.scene);\r\n    }\r\n    lsa(progressive = false, maxError = 5) {\r\n        this.ds.set(this.points, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n        if (this.points.length < 5) {\r\n            return;\r\n        }\r\n        let plane = Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY();\r\n        let points2d = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiVector2.fromList(this.points.map((p) => plane.pullToPlane(p).to2D()));\r\n        if (progressive) {\r\n            let results = Engine_math_LSA__WEBPACK_IMPORTED_MODULE_0__.LSA.circle2Progressive(points2d, maxError);\r\n            if (!results) {\r\n                return;\r\n            }\r\n            let { circle, included, excluded } = results;\r\n            this.omni.set(Geon__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromCircle(Geon__WEBPACK_IMPORTED_MODULE_2__.Circle3.fromCircle2(circle)), \"circle\", [1, 0, 1, 1]);\r\n            this.dsYellow.set(included, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n            this.ds.set(excluded, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n        }\r\n        else {\r\n            let circle = Geon__WEBPACK_IMPORTED_MODULE_2__.Circle2.fromLSA(points2d);\r\n            this.omni.set(Geon__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromCircle(Geon__WEBPACK_IMPORTED_MODULE_2__.Circle3.fromCircle2(circle)), \"circle\", [1, 0, 1, 1]);\r\n        }\r\n    }\r\n}\r\nfunction test() {\r\n    // matrix.print();\r\n    // A.intb().mul(inv.mul(matrix)).print();\r\n    // inv.mul(matrix).print();\r\n    // inv2.mul(matrix).print();\r\n    // let vec = FloatMatrix.fromNative([[1,0],[0,1]]);\r\n    // vec.print();\r\n    // matrix.mul(vec).print();\r\n    // let pinv = matrix.inv();\r\n    // console.log(pinv);\r\n    // pinv.print();\r\n    // let result = matrix.mul(pinv);\r\n    // result.print();\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/math-apps/least-squares-circle-app.ts?");

/***/ }),

/***/ "./src/apps/math-apps/perlin-app.ts":
/*!******************************************!*\
  !*** ./src/apps/math-apps/perlin-app.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PerlinApp\": () => (/* binding */ PerlinApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\nclass PerlinApp extends Geon__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_1__.Camera(canvas, -2, true);\r\n        this.camera.setState([21.919, -0.26769, -16.72, -10, 0.9, 1.5700000000000014]);\r\n        this.perlin = Geon__WEBPACK_IMPORTED_MODULE_1__.Perlin.new();\r\n        this.seed = Geon__WEBPACK_IMPORTED_MODULE_1__.Random.randomSeed();\r\n        this.drRed = new Geon__WEBPACK_IMPORTED_MODULE_1__.DotShaderWithHeight(gl, 15, [1, 0, 0, 1], 5, false);\r\n        this.lrGrid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n    }\r\n    ui(ui) {\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter.new(\"count\", 200, 2, 500, 1));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter.new(\"displace\", 0, 0, 1, 0.001));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter.newBoolean(\"perlin move\", true));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter.new(\"perlin amp\", 5, 1, 10, 0.01));\r\n        this.params.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Parameter.new(\"perlin speed\", 2.5, 0.5, 10, 0.1));\r\n        ui.addParameter(this.params[0], this.start.bind(this));\r\n        ui.addParameter(this.params[1], this.start.bind(this));\r\n        ui.addBooleanParameter(this.params[2], this.start.bind(this));\r\n        ui.addParameter(this.params[3], this.start.bind(this));\r\n        ui.addParameter(this.params[4], this.start.bind(this));\r\n    }\r\n    start() {\r\n        // create a base grid\r\n        this.startGrid();\r\n        // get all parameters\r\n        let degree = this.params[0].get();\r\n        let displace = this.params[1].get();\r\n        // get some points\r\n        // BUG: something's wrong here....\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_1__.Random.fromSeed(this.seed);\r\n        let vecs3 = Geon__WEBPACK_IMPORTED_MODULE_1__.Domain2.fromRadius(11)\r\n            .spawn(degree + 1, degree + 1)\r\n            .to3D()\r\n            .forEach((v) => {\r\n            return v.add(Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3.fromRandomUnit(rng).scale(displace));\r\n        });\r\n        // save them, and put them in the renderer, which we need if we are not updating for perlin effect\r\n        this.dots = vecs3;\r\n        this.drRed.load(vecs3, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw);\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_1__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_1__.Plane.WorldXY(), 100, 2);\r\n        this.lrGrid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        let perlinMove = this.params[2].get() == 1;\r\n        if (perlinMove) {\r\n            let factor = this.params[3].get();\r\n            let speed = this.params[4].get();\r\n            let news = Geon__WEBPACK_IMPORTED_MODULE_1__.MultiVector3.new(this.dots.count);\r\n            for (let i = 0; i < this.dots.count; i++) {\r\n                let v = this.dots.get(i);\r\n                let n = this.perlin.noise(v.x, v.y, input.time.newTime * 0.0001 * speed) * factor;\r\n                v.z = n;\r\n                news.set(i, v);\r\n            }\r\n            this.drRed.load(news, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.DynamicDraw);\r\n        }\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_1__.Scene(this.camera);\r\n        this.lrGrid.render(c);\r\n        this.drRed.draw(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/math-apps/perlin-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/billboard-app.ts":
/*!***********************************************!*\
  !*** ./src/apps/render-apps/billboard-app.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BillboardApp\": () => (/* binding */ BillboardApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass BillboardApp extends Geon__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_1__.Camera(canvas, -2, true);\r\n        this.camera.set(-2, 1, 1);\r\n        this.gs = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = Geon__WEBPACK_IMPORTED_MODULE_1__.DebugRenderer.new(gl);\r\n        this.ir = Geon__WEBPACK_IMPORTED_MODULE_1__.ImageRenderer.new(gl);\r\n        this.ir.scale = 0.2;\r\n        this.br = new Geon__WEBPACK_IMPORTED_MODULE_1__.BillboardShader(gl);\r\n    }\r\n    start() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.startGrid();\r\n            let imgData = yield (0,Geon__WEBPACK_IMPORTED_MODULE_1__.loadImageFromSrc)(\"./data/textures/minecraft.png\");\r\n            let texture = Geon__WEBPACK_IMPORTED_MODULE_1__.Bitmap.fromImageData(imgData);\r\n            // img = img.trim(16,16,32,32);\r\n            this.ir.add(texture);\r\n            this.ir.buffer();\r\n            let xcount = 16;\r\n            let ycount = 16;\r\n            let spriteWidth = texture.width / xcount;\r\n            let spriteHeight = texture.height / ycount;\r\n            // console.log(spriteWidth, spriteHeight);\r\n            let positions = Geon__WEBPACK_IMPORTED_MODULE_1__.Domain2.fromRadius(10).spawn(xcount, ycount).to3D();\r\n            let uvs = Geon__WEBPACK_IMPORTED_MODULE_1__.Domain2.fromBounds(0, texture.width - spriteWidth, 0, texture.height - spriteHeight).spawn(xcount, ycount);\r\n            // console.log(uvs);\r\n            let sizes = [];\r\n            for (let i = 0; i < uvs.count; i++) {\r\n                sizes.push(Geon__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(spriteWidth, spriteHeight));\r\n            }\r\n            let uvSizes = Geon__WEBPACK_IMPORTED_MODULE_1__.MultiVector2.fromList(sizes);\r\n            // console.log(sizes);\r\n            let payload = { positions, uvs, uvSizes, texture };\r\n            this.br.load(payload, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw);\r\n        });\r\n    }\r\n    ui(ui) { }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_1__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_1__.Plane.WorldXY().moveTo(Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3.new(0, 0, -1)), 100, 2);\r\n        this.gs.set(grid, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_1__.Scene(this.camera);\r\n        this.gs.render(c);\r\n        this.mr.render(c);\r\n        this.ir.render(c);\r\n        this.br.draw(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/billboard-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/cubes-phong-app.ts":
/*!*************************************************!*\
  !*** ./src/apps/render-apps/cubes-phong-app.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubesPhongApp\": () => (/* binding */ CubesPhongApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n/* harmony import */ var Engine_render_shaders_DepthMeshShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/shaders/DepthMeshShader */ \"../engine/src/render/shaders/DepthMeshShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    geometry-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: a 3d voxel environment to toy around in. Uses several features of geon\r\n\r\n\r\n\r\n\r\n\r\nclass CubesPhongApp extends Geon__WEBPACK_IMPORTED_MODULE_4__.App {\r\n    constructor(gl) {\r\n        // setup render env\r\n        super(gl);\r\n        // geo data\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_4__.Plane.WorldXY();\r\n        this.dots = [];\r\n        this.geo = [];\r\n        this.mapGeo = [];\r\n        // logic data\r\n        this.size = 50;\r\n        this.cellSize = 1;\r\n        this.fov = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"fov\", 80, 10, 100, 1);\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_4__.Camera(gl.canvas, 10, true);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_4__.Scene(camera);\r\n        this.phongShader = new Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_2__.PhongShader(gl);\r\n        this.dr = Geon__WEBPACK_IMPORTED_MODULE_4__.DebugRenderer.new(gl);\r\n        this.ds = new Engine_render_shaders_DepthMeshShader__WEBPACK_IMPORTED_MODULE_3__.DepthMeshShader(gl);\r\n    }\r\n    // called after init\r\n    start() {\r\n        this.map = new Geon__WEBPACK_IMPORTED_MODULE_4__.IntCube(this.size, this.size, this.size);\r\n        this.map.fill(0);\r\n        // add random blocks in the world\r\n        this.map.map((value, index) => {\r\n            if (Math.random() > 0.99) {\r\n                return 1;\r\n            }\r\n            else {\r\n                return value;\r\n            }\r\n        });\r\n        // let perlin = new Perlin();\r\n        // this.map.map((value, i) => {\r\n        //     let c = this.map.getCoords(i);\r\n        //     let scale = 0.05;\r\n        //     let noise = perlin.noise(c.x * scale, c.y * scale, c.z * scale);\r\n        //     if (i < 10) {\r\n        //         console.log(c);\r\n        //         console.log(noise);\r\n        //     }\r\n        //     if (noise > 0.60) {\r\n        //         return 1;\r\n        //     } else {\r\n        //         return value;\r\n        //     }\r\n        // })\r\n        // console.log(\"done setting\")\r\n        // after change, buffer\r\n        this.bufferMap();\r\n        // console.log(\"done\")\r\n        this.gridLarge = Geon__WEBPACK_IMPORTED_MODULE_4__.MultiLine.fromGrid(this.plane, this.size, this.cellSize);\r\n        this.gridSmall = Geon__WEBPACK_IMPORTED_MODULE_4__.MultiLine.fromGrid(this.plane, this.size * 10 - 1, this.cellSize / 10);\r\n        // this.whiteLineRenderer.set(this.gl, this.gridLarge, DrawSpeed.StaticDraw);\r\n        // this.greyLineRenderer.set(this.gl, this.gridSmall, DrawSpeed.StaticDraw);\r\n    }\r\n    ui(ui) {\r\n        ui.addParameter(this.fov, (v) => {\r\n            this.scene.camera.fov = v;\r\n        });\r\n    }\r\n    update(input) {\r\n        // move the camera with the mouse\r\n        this.scene.camera.update(input);\r\n        this.scene.sun.pos = this.scene.camera.getActualPosition();\r\n        this.updateCursor(input);\r\n    }\r\n    draw() {\r\n        // render the grid\r\n        // this.greyLineRenderer.render(gl, matrix);\r\n        // this.whiteLineRenderer.render(gl, matrix);\r\n        // this.redLineRenderer.setAndRender(gl, matrix, this.cursorVisual!);\r\n        // render the map\r\n        // TODO create MeshArray\r\n        this.phongShader.draw(this.scene);\r\n        this.dr.render(this.scene);\r\n        this.ds.draw(this.scene);\r\n    }\r\n    addPreviewCube(point) {\r\n        let cubeCenter = this.mapToWorld(point);\r\n        let cube = this.createCube(cubeCenter);\r\n        let m = Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromCube(cube).ToShaderMesh();\r\n        m.calculateFaceNormals();\r\n        this.dr.set(m, \"preview-cube\");\r\n    }\r\n    flushPreviewCubes() {\r\n        this.geo = [];\r\n    }\r\n    updateCursor(input) {\r\n        var _a, _b, _c;\r\n        // render mouse to world line\r\n        let mouseRay = this.scene.camera.getMouseWorldRay(input.width, input.height);\r\n        // snap to world\r\n        // let cursor = mouseRay.at(mouseRay.xPlane(this.plane));\r\n        // let mapCursor = this.worldToMap(cursor);\r\n        // let coord = this.mapToWorld(mapCursor);\r\n        // place circle at cursor\r\n        // let plane = this.plane.clone();\r\n        // plane.matrix = plane.matrix.multiply(Matrix4.newTranslation(cursor.x, cursor.y, cursor.z));\r\n        // this.cursorVisual = LineArray.fromCircle(new Circle3(plane, 0.1));\r\n        // figure out which cube we are pointing to\r\n        this.flushPreviewCubes();\r\n        let [cubeID, cubeIDprevious] = this.voxelRaycast(mouseRay, 40);\r\n        if (cubeID == -1) {\r\n            // nothing else to do\r\n            return;\r\n        }\r\n        let cubeCursor = this.map.getCoord(cubeIDprevious);\r\n        this.addPreviewCube(cubeCursor);\r\n        // render cube at this position\r\n        // this.geo.push(Mesh.fromCube(cube));\r\n        // click\r\n        if (((_a = input.mouse) === null || _a === void 0 ? void 0 : _a.leftPressed) || ((_b = input.touch) === null || _b === void 0 ? void 0 : _b.tab)) {\r\n            console.log(\"click\");\r\n            if ((_c = input.keys) === null || _c === void 0 ? void 0 : _c.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.Space)) {\r\n                if (this.map.data[cubeID] == 0)\r\n                    return;\r\n                this.map.data[cubeID] = 0;\r\n                this.bufferMap();\r\n            }\r\n            else if (this.map.data[cubeIDprevious] != 1) {\r\n                this.map.data[cubeIDprevious] = 1;\r\n                this.bufferMap();\r\n            }\r\n        }\r\n    }\r\n    // return the ID of the\r\n    // A Fast Voxel Traversal Algorithm for Ray Tracing\r\n    // Amanatides, Woo\r\n    // Dept. of Computer Science\r\n    voxelRaycast(ray, range) {\r\n        let startPoint = this.worldToMap(ray.origin);\r\n        let voxelCenter = this.mapToWorld(startPoint);\r\n        // integers\r\n        let x = startPoint.x;\r\n        let y = startPoint.y;\r\n        let z = startPoint.z;\r\n        let xprev = x;\r\n        let yprev = y;\r\n        let zprev = z;\r\n        let stepX = ray.normal.x > 0 ? 1 : -1;\r\n        let stepY = ray.normal.y > 0 ? 1 : -1;\r\n        let stepZ = ray.normal.z > 0 ? 1 : -1;\r\n        // floats\r\n        let voxelsize = this.cellSize;\r\n        let deltax = voxelsize / Math.abs(ray.normal.x);\r\n        let deltay = voxelsize / Math.abs(ray.normal.y);\r\n        let deltaz = voxelsize / Math.abs(ray.normal.z);\r\n        // intit tx, ty, and tz, at their first intersection with corresponding plane\r\n        voxelCenter.add(new Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3((voxelsize / 2) * stepX, (voxelsize / 2) * stepY, (voxelsize / 2) * stepZ));\r\n        let move = Geon__WEBPACK_IMPORTED_MODULE_4__.Matrix4.newTranslation(voxelCenter.x, voxelCenter.y, voxelCenter.z);\r\n        let xy = Geon__WEBPACK_IMPORTED_MODULE_4__.Plane.WorldXY();\r\n        xy._matrix.multiply(move);\r\n        let yz = Geon__WEBPACK_IMPORTED_MODULE_4__.Plane.WorldYZ();\r\n        yz._matrix.multiply(move);\r\n        let xz = Geon__WEBPACK_IMPORTED_MODULE_4__.Plane.WorldXZ();\r\n        xz._matrix.multiply(move);\r\n        let tx = ray.xPlane(yz);\r\n        let ty = ray.xPlane(xz);\r\n        let tz = ray.xPlane(xy);\r\n        if (tx < 0 || ty < 0 || tz < 0) {\r\n            console.log(\"something critical went wrong!\");\r\n            return [-1, -1];\r\n        }\r\n        // debug ray\r\n        // let lineSets: LineArray[] = [ray.toLine(100), LineArray.fromPlane(xy), LineArray.fromPlane(yz), LineArray.fromPlane(xz)];\r\n        // this.whiteLineRenderer.set(this.gl, LineArray.fromJoin(lineSets), DrawSpeed.StaticDraw);\r\n        // console.log(\"voxel raycast initialized with:\");\r\n        // console.log(\"deltas: \", deltax, deltay, deltaz);\r\n        // console.log(\"t's: \", tx, ty, tz);\r\n        // start iterating\r\n        // console.log(\"cast away!\");\r\n        // this.addPreviewCube(new Vector3(x,y,z));\r\n        // console.log(x,y,z);\r\n        for (let i = 0; i < range; i++) {\r\n            // this.addPreviewCube(new Vector3(xprev,yprev,zprev));\r\n            // if hit, return previous\r\n            let value = this.map.tryGet(x, y, z, -1);\r\n            if (value == 1) {\r\n                // console.log(\"found a cube after \" + i + \"steps...\");\r\n                // this.addPreviewCube(new Vector3(xprev,yprev,zprev));\r\n                return [this.map.getIndex(x, y, z), this.map.getIndex(xprev, yprev, zprev)];\r\n            }\r\n            else {\r\n                xprev = x;\r\n                yprev = y;\r\n                zprev = z;\r\n            }\r\n            // to the next cube!\r\n            if (tx < ty && tx < tz) {\r\n                // x\r\n                tx += deltax;\r\n                x += stepX;\r\n            }\r\n            else if (ty < tz) {\r\n                // y\r\n                ty += deltay;\r\n                y += stepY;\r\n            }\r\n            else {\r\n                // z\r\n                tz += deltaz;\r\n                z += stepZ;\r\n            }\r\n        }\r\n        return [-1, -1];\r\n    }\r\n    // flush this.meshRenderer\r\n    // turn this.map into this.mapGeo\r\n    bufferMap() {\r\n        let mapGeo = [];\r\n        this.map.iter((entry, index) => {\r\n            if (entry == 1) {\r\n                let mapCoord = this.map.getCoord(index);\r\n                let coord = this.mapToWorld(mapCoord);\r\n                let cube = this.createCube(coord);\r\n                mapGeo.push(Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromCube(cube));\r\n            }\r\n        });\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromJoin(mapGeo);\r\n        mesh = mesh.toLinearMesh();\r\n        mesh.ensureMultiFaceNormals();\r\n        mesh.ensureUVs();\r\n        let e = Geon__WEBPACK_IMPORTED_MODULE_4__.Entity.new(undefined, Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__.Model.new(mesh, Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material.newPurple()));\r\n        e.model.material.specularDampner = 2;\r\n        e.model.mesh = mesh;\r\n        this.phongShader.load(e, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.StaticDraw);\r\n    }\r\n    worldToMap(coord) {\r\n        let halfsize = this.size / 2 + this.cellSize / 2;\r\n        return coord.added(new Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3(halfsize, halfsize, halfsize)).floored();\r\n    }\r\n    mapToWorld(point) {\r\n        let halfsize = this.size / 2;\r\n        return point.added(new Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3(-halfsize, -halfsize, -halfsize));\r\n    }\r\n    createCube(center) {\r\n        let hs = this.cellSize / 2;\r\n        let move = Geon__WEBPACK_IMPORTED_MODULE_4__.Matrix4.newTranslation(center.x, center.y, center.z);\r\n        let cube = new Geon__WEBPACK_IMPORTED_MODULE_4__.Cube(Geon__WEBPACK_IMPORTED_MODULE_4__.Plane.WorldXY().transform(move), Geon__WEBPACK_IMPORTED_MODULE_4__.Domain3.fromBounds(-hs, hs, -hs, hs, -hs, hs));\r\n        return cube;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/cubes-phong-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/dot-app3.ts":
/*!******************************************!*\
  !*** ./src/apps/render-apps/dot-app3.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotApp3\": () => (/* binding */ DotApp3)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// dot-app3.ts\r\n//\r\n// author : Jos Feenstra\r\n// purpose : test with Renderers, Domains & Vectors\r\n\r\n\r\nclass DotApp3 extends Geon__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        this.dots = [];\r\n        this.dirs = [];\r\n        let canvas = gl.canvas;\r\n        let n = 1;\r\n        this.bounds = Geon__WEBPACK_IMPORTED_MODULE_1__.Domain3.fromBounds(-n, n, -n, n, -n, n);\r\n        this.whiteDotRend = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 1, 1, 1], false);\r\n        this.redDotRend = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader(gl, 10, [1, 0, 0, 1], false);\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_1__.Camera(canvas);\r\n    }\r\n    start() {\r\n        this.spawnSome(100, 0.001);\r\n    }\r\n    spawnSome(count, normrange) {\r\n        const normSpace = Geon__WEBPACK_IMPORTED_MODULE_1__.Domain3.fromBounds(-normrange, normrange, -normrange, normrange, -normrange, normrange);\r\n        let rng = Geon__WEBPACK_IMPORTED_MODULE_1__.Random.fromRandom();\r\n        for (let i = 0; i < count; i++) {\r\n            this.dots.push(this.bounds.elevate(Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3.fromRandom(rng)));\r\n            this.dirs.push(normSpace.elevate(Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3.fromRandom(rng)));\r\n        }\r\n    }\r\n    update(input) {\r\n        var _a, _b;\r\n        // move the camera with the mouse\r\n        this.camera.update(input);\r\n        if (((_a = input.mouse) === null || _a === void 0 ? void 0 : _a.leftPressed) || ((_b = input.touch) === null || _b === void 0 ? void 0 : _b.tab)) {\r\n            this.spawnSome(100, 0.001);\r\n        }\r\n        // update the position of all dots\r\n        for (let i = 0; i < this.dots.length; i++) {\r\n            // this gives us a pointer apparantly\r\n            let dot = this.dots[i];\r\n            let dir = this.dirs[i];\r\n            // bounce of the edges\r\n            if (!this.bounds.x.includes(dot.x))\r\n                dir.x = -dir.x;\r\n            if (!this.bounds.y.includes(dot.y))\r\n                dir.y = -dir.y;\r\n            if (!this.bounds.z.includes(dot.z))\r\n                dir.z = -dir.z;\r\n            // update position\r\n            dot.add(dir);\r\n        }\r\n    }\r\n    draw() {\r\n        // get to-screen matrix\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_1__.Scene(this.camera);\r\n        // render the corners of the box with the red renderer,\r\n        // and the dots themselves with the white renderer\r\n        this.redDotRend.setAndRender(this.bounds.corners(Geon__WEBPACK_IMPORTED_MODULE_1__.Matrix4.newIdentity()), c);\r\n        this.whiteDotRend.setAndRender(this.dots, c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/dot-app3.ts?");

/***/ }),

/***/ "./src/apps/render-apps/draw-target-app.ts":
/*!*************************************************!*\
  !*** ./src/apps/render-apps/draw-target-app.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawTargetApp\": () => (/* binding */ DrawTargetApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\n\r\n\r\nclass DrawTargetApp extends Geon__WEBPACK_IMPORTED_MODULE_2__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.gs = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.ts = new Geon__WEBPACK_IMPORTED_MODULE_2__.TexturedMeshShader(gl);\r\n        this.ps = Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_1__.PhongShader.new(gl);\r\n        this.entity = Geon__WEBPACK_IMPORTED_MODULE_2__.Entity.new();\r\n        this.drawTarget = Geon__WEBPACK_IMPORTED_MODULE_2__.DrawTarget.createAndBind(gl, canvas.width, canvas.height);\r\n        // this.drawTarget.unbind(gl);\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_2__.Camera(canvas, -2, true);\r\n        camera.set(-50, 1, 1);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_2__.Scene(camera);\r\n    }\r\n    start() {\r\n        this.startGrid();\r\n        this.entity.model.mesh = this.entity.model.mesh.toLinearMesh();\r\n        let m = this.entity.model.mesh;\r\n        m.calcAndSetVertexNormals();\r\n        m.ensureUVs();\r\n        this.ps.load(this.entity, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n    }\r\n    ui(ui) {\r\n        ui.add3DParameter(\"sun\", Geon__WEBPACK_IMPORTED_MODULE_2__.Domain3.fromRadius(5), 0.01, this.scene.sun.pos);\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -1)), 100, 2);\r\n        this.gs.set(grid, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n        this.ts.load(Geon__WEBPACK_IMPORTED_MODULE_2__.Mesh.fromRectDoubleSided(Geon__WEBPACK_IMPORTED_MODULE_2__.Rectangle3.new(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldYZ().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(3, 0, 3)), Geon__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromRadius(4))));\r\n    }\r\n    update(input) {\r\n        this.scene.camera.update(input);\r\n        let r = 0.0005 * input.time.tick;\r\n        this.entity.xform.rot.add(Geon__WEBPACK_IMPORTED_MODULE_2__.Quaternion.fromEuler(r, -r, r));\r\n        this.ps.loadTransform(this.entity.xform);\r\n    }\r\n    draw() {\r\n        // unload to prevent a cyclical pattern\r\n        this.ts.loadTexture(this.drawTarget.width, this.drawTarget.height, null);\r\n        // set a texture\r\n        this.drawTarget.bind(this.gl);\r\n        this.gs.render(this.scene);\r\n        this.ts.draw(this.scene);\r\n        this.ps.draw(this.scene);\r\n        this.drawTarget.unbind(this.gl);\r\n        this.ts.loadTexture(this.drawTarget.width, this.drawTarget.height, this.drawTarget.texture);\r\n        this.gs.render(this.scene);\r\n        this.ts.draw(this.scene);\r\n        this.ps.draw(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/draw-target-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/mesh-inspector-app.ts":
/*!****************************************************!*\
  !*** ./src/apps/render-apps/mesh-inspector-app.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshInspectorApp\": () => (/* binding */ MeshInspectorApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! Engine/render/shaders-old/shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var Engine_render_shaders_AmbientMeshShader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! Engine/render/shaders/AmbientMeshShader */ \"../engine/src/render/shaders/AmbientMeshShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    shapes-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: test creation of basic mesh shapes. Test UI\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MeshInspectorApp extends Geon__WEBPACK_IMPORTED_MODULE_7__.App {\r\n    constructor(gl) {\r\n        // setup render env\r\n        super(gl);\r\n        // geo data\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_7__.Plane.WorldXY();\r\n        this.geo = [];\r\n        // logic data\r\n        this.size = 10;\r\n        this.cellSize = 0.5;\r\n        this.distance = new Geon__WEBPACK_IMPORTED_MODULE_7__.Parameter(\"distance\", 3.0, 0, 4.0, 0.01);\r\n        this.radius = new Geon__WEBPACK_IMPORTED_MODULE_7__.Parameter(\"radius\", 1.0, 0, 4.0, 0.01);\r\n        this.detail = new Geon__WEBPACK_IMPORTED_MODULE_7__.Parameter(\"detail\", 5, 0, 100, 1);\r\n        this.shademethod = Geon__WEBPACK_IMPORTED_MODULE_7__.EnumParameter.new(\"render method\", 3, [\"debug\", \"vertex shaded\", \"face shaded\", \"ambient only\"]);\r\n        let canvas = gl.canvas;\r\n        // TODO abstract this to scene\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_7__.Camera(canvas, undefined, true);\r\n        this.camera.zoom = -10;\r\n        this.camera.angleAlpha = 0.4;\r\n        this.camera.angleBeta = 0.5;\r\n        this.dotRenderer = new Engine_render_shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_2__.DotShader(gl, 4, [0, 1, 0, 1]);\r\n        this.meshRenderer = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_4__.MeshDebugShader(gl, [0.6, 0, 0, 1], [1, 0, 0, 1]);\r\n        this.lineRenderer = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_3__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.shadedMeshRenderer = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_5__.ShadedMeshShader(gl);\r\n        this.ams = new Engine_render_shaders_AmbientMeshShader__WEBPACK_IMPORTED_MODULE_6__.AmbientMeshShader(gl);\r\n    }\r\n    ui(ui) {\r\n        // TODO : think of a system that ties parameter & slider together fully\r\n        ui.addParameter(this.radius, (value) => {\r\n            this.start();\r\n        });\r\n        ui.addParameter(this.distance, (value) => {\r\n            this.start();\r\n        });\r\n        ui.addParameter(this.detail, (value) => {\r\n            this.start();\r\n        });\r\n        // render methods\r\n        ui.addParameter(this.shademethod, (val) => {\r\n            this.start();\r\n        });\r\n    }\r\n    start() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_7__.MultiLine.fromGrid(this.plane.clone().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_7__.Vector3(0, 0, -this.radius.get())), 100, 2);\r\n        let spherePerRing = this.detail.get() * 2;\r\n        let rad = this.radius.get();\r\n        let dis = this.distance.get();\r\n        let det = this.detail.get();\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_7__.Mesh.fromJoin([\r\n            Geon__WEBPACK_IMPORTED_MODULE_7__.Mesh.newSphere(new Geon__WEBPACK_IMPORTED_MODULE_7__.Vector3(dis, 0, 0), this.radius.get(), this.detail.get(), spherePerRing),\r\n            // PureMesh.fromCube(new Cube(this.plane, Domain3.fromRadius(this.radius.get()))),\r\n            Geon__WEBPACK_IMPORTED_MODULE_7__.Mesh.newCone(new Geon__WEBPACK_IMPORTED_MODULE_7__.Vector3(-dis, 0, -this.radius.get()), this.radius.get(), this.radius.get() * 2, spherePerRing),\r\n            Geon__WEBPACK_IMPORTED_MODULE_7__.Mesh.newCylinder(new Geon__WEBPACK_IMPORTED_MODULE_7__.Vector3(0, 0, -rad), new Geon__WEBPACK_IMPORTED_MODULE_7__.Vector3(0, 0, rad), rad, det),\r\n        ]);\r\n        let rend = mesh.ToShaderMesh();\r\n        rend.calculateVertexNormals();\r\n        // TODO abstract this to scene\r\n        console.log(\"normal type\", rend.getNormalType());\r\n        switch (this.shademethod.get()) {\r\n            case 0:\r\n                this.meshRenderer.set(rend);\r\n                break;\r\n            case 1:\r\n                this.shadedMeshRenderer.set(rend);\r\n                break;\r\n            case 2:\r\n                rend.calculateFaceNormals();\r\n                this.shadedMeshRenderer.set(rend);\r\n                break;\r\n            case 3:\r\n                this.ams.load(rend.mesh, Geon__WEBPACK_IMPORTED_MODULE_7__.DrawSpeed.StaticDraw);\r\n                break;\r\n            case 4:\r\n                let model = Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_1__.Model.new(rend.mesh, Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_0__.Material.default()).spawn();\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        this.lineRenderer.set(grid);\r\n        // this.dotRenderer.set(mesh.verts, DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        // move the camera with the mouse\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        // TODO abstract this to 'scene'\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_7__.Scene(this.camera);\r\n        this.dotRenderer.render(c);\r\n        switch (this.shademethod.get()) {\r\n            case 0:\r\n                this.meshRenderer.render(c);\r\n                break;\r\n            case 1:\r\n            case 2:\r\n                this.shadedMeshRenderer.render(c);\r\n                break;\r\n            case 3:\r\n                this.ams.draw(c);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        this.lineRenderer.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/mesh-inspector-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/phong-app.ts":
/*!*******************************************!*\
  !*** ./src/apps/render-apps/phong-app.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhongApp\": () => (/* binding */ PhongApp)\n/* harmony export */ });\n/* harmony import */ var Engine_image_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/image/Color */ \"../engine/src/image/Color.ts\");\n/* harmony import */ var Engine_math_Transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/math/Transform */ \"../engine/src/math/Transform.ts\");\n/* harmony import */ var Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! Engine/render/shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    shapes-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: test creation of basic mesh shapes. Test UI\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PhongApp extends Geon__WEBPACK_IMPORTED_MODULE_6__.App {\r\n    constructor(gl) {\r\n        // setup render env\r\n        super(gl);\r\n        this.material = Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_2__.Material.default();\r\n        // geo data\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_6__.Plane.WorldXY();\r\n        this.geo = [];\r\n        // logic data\r\n        this.size = 10;\r\n        this.cellSize = 0.5;\r\n        this.somePos = Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3.zero();\r\n        this.distance = new Geon__WEBPACK_IMPORTED_MODULE_6__.Parameter(\"distance\", 3.0, 0, 4.0, 0.01);\r\n        this.radius = new Geon__WEBPACK_IMPORTED_MODULE_6__.Parameter(\"radius\", 1.0, 0, 4.0, 0.01);\r\n        this.detail = new Geon__WEBPACK_IMPORTED_MODULE_6__.Parameter(\"detail\", 5, 0, 100, 1);\r\n        this.shademethod = Geon__WEBPACK_IMPORTED_MODULE_6__.EnumParameter.new(\"render method\", 3, [\"debug\", \"vertex shaded\", \"face shaded\", \"ambient only\", \"phong\"]);\r\n        let canvas = gl.canvas;\r\n        // TODO abstract this to scene\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_6__.Camera(canvas, undefined, true);\r\n        this.camera.zoom = -10;\r\n        this.camera.angleAlpha = 0.4;\r\n        this.camera.angleBeta = 0.5;\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_6__.Scene(this.camera);\r\n        this.lineRenderer = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_4__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        // this.phong = new PhongShader(gl);\r\n        this.phong = new Engine_render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_5__.PhongShader(gl);\r\n    }\r\n    ui(ui) {\r\n        // TODO : think of a system that ties parameter & slider together fully\r\n        ui.addParameter(this.detail, () => { this.start(); });\r\n        ui.add3DParameter(\"sun\", Geon__WEBPACK_IMPORTED_MODULE_6__.Domain3.fromRadius(50), 1, this.scene.sun.pos);\r\n        ui.add3DParameter(\"position\", Geon__WEBPACK_IMPORTED_MODULE_6__.Domain3.fromRadius(3), 0.01, this.somePos, () => {\r\n            this.start();\r\n        });\r\n        ui.addParameter(Geon__WEBPACK_IMPORTED_MODULE_6__.Parameter.new(\"specular-dampner\", 0.2, 0, 10, 0.001), (v) => {\r\n            this.material.specularDampner = v;\r\n            this.start();\r\n        });\r\n        ui.addColorParameter(\"ambient\", this.material.ambient.toHex6(), (hex) => {\r\n            console.log(hex);\r\n            let color = Engine_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(hex);\r\n            if (color) {\r\n                this.material.ambient = color;\r\n                this.phong.loadMaterial(this.material);\r\n            }\r\n        });\r\n        ui.addColorParameter(\"diffuse\", this.material.diffuse.toHex6(), (hex) => {\r\n            console.log(hex);\r\n            let color = Engine_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(hex);\r\n            if (color) {\r\n                this.material.diffuse = color;\r\n                this.phong.loadMaterial(this.material);\r\n            }\r\n        });\r\n        ui.addColorParameter(\"specular\", this.material.specular.toHex6(), (hex) => {\r\n            console.log(hex);\r\n            let color = Engine_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(hex);\r\n            if (color) {\r\n                this.material.specular = color;\r\n                this.phong.loadMaterial(this.material);\r\n            }\r\n        });\r\n        ui.addColorParameter(\"occluded\", this.material.occluded.toHex6(), (hex) => {\r\n            console.log(hex);\r\n            let color = Engine_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(hex);\r\n            if (color) {\r\n                this.material.occluded = color;\r\n                this.phong.loadMaterial(this.material);\r\n            }\r\n        });\r\n    }\r\n    start() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_6__.MultiLine.fromGrid(this.plane.clone().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, -this.radius.get())), 100, 2);\r\n        let spherePerRing = this.detail.get() * 2;\r\n        let rad = this.radius.get();\r\n        let dis = this.distance.get();\r\n        let det = this.detail.get();\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_6__.Mesh.fromJoin([\r\n            Geon__WEBPACK_IMPORTED_MODULE_6__.Mesh.newSphere(new Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3(dis, 0, 0), this.radius.get(), this.detail.get(), spherePerRing),\r\n            // PureMesh.fromCube(new Cube(this.plane, Domain3.fromRadius(this.radius.get()))),\r\n            Geon__WEBPACK_IMPORTED_MODULE_6__.Mesh.newCone(new Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3(-dis, 0, -this.radius.get()), this.radius.get(), this.radius.get() * 2, spherePerRing),\r\n            Geon__WEBPACK_IMPORTED_MODULE_6__.Mesh.newCylinder(new Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, -rad), new Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3(0, 0, rad), rad, det),\r\n        ]);\r\n        mesh.ensureUVs();\r\n        mesh.calcAndSetVertexNormals();\r\n        this.calcAmbientOcclusion(mesh, this.plane);\r\n        // let model = new Model(Matrix4.newIdentity(), rend.mesh, this.material);\r\n        let model = Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_3__.Model.new(mesh, this.material);\r\n        let e = Geon__WEBPACK_IMPORTED_MODULE_6__.Entity.new(Engine_math_Transform__WEBPACK_IMPORTED_MODULE_1__.Transform.new(this.somePos), model);\r\n        // this.phong.load(model, DrawSpeed.StaticDraw);\r\n        this.phong.load(e, Geon__WEBPACK_IMPORTED_MODULE_6__.DrawSpeed.StaticDraw);\r\n        this.lineRenderer.set(grid);\r\n    }\r\n    /**\r\n     * A very dumb version of ambient occlusion\r\n     */\r\n    calcAmbientOcclusion(mesh, plane) {\r\n        let count = mesh.verts.count;\r\n        let data = new Float32Array(count);\r\n        let maxDistance = 0.5;\r\n        for (let i = 0; i < count; i++) {\r\n            // the closer to the base plane, the more ambient occlusion\r\n            let v = mesh.verts.get(i).added(this.somePos);\r\n            let distance = plane.distanceTo(v);\r\n            data[i] = Math.max(Math.min(maxDistance - (distance / maxDistance), 0.5), 0.0);\r\n        }\r\n        this.phong.loadOcclusion(data, Geon__WEBPACK_IMPORTED_MODULE_6__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        var _a;\r\n        // move the camera with the mouse\r\n        this.camera.update(input);\r\n        if ((_a = input.keys) === null || _a === void 0 ? void 0 : _a.isPressed(Geon__WEBPACK_IMPORTED_MODULE_6__.Key.K)) {\r\n            console.log(this.camera.worldMatrix.inverse().multiplyVector(Geon__WEBPACK_IMPORTED_MODULE_6__.Vector3.new()));\r\n            console.log(this.camera.pos);\r\n            console.log(this.camera.getState());\r\n            console.log(this.camera.offset);\r\n            this.camera.worldMatrix.print();\r\n            this.camera.worldMatrix.inverse().print();\r\n        }\r\n    }\r\n    draw() {\r\n        // this.phong.draw(this.scene);\r\n        this.phong.draw(this.scene);\r\n        this.lineRenderer.render(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/phong-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/skybox-app.ts":
/*!********************************************!*\
  !*** ./src/apps/render-apps/skybox-app.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SkyboxApp\": () => (/* binding */ SkyboxApp)\n/* harmony export */ });\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\nclass SkyboxApp extends Geon__WEBPACK_IMPORTED_MODULE_0__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_0__.Camera(canvas, -2, true);\r\n        this.camera.set(-2, 1, 1);\r\n        this.gs = new Geon__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.skyboxShader = new Geon__WEBPACK_IMPORTED_MODULE_0__.SkyBoxShader(gl);\r\n    }\r\n    start() {\r\n        this.startGrid();\r\n        this.skyboxShader.load([\r\n            \"./data/textures/ducks/rechts.png\",\r\n            \"./data/textures/ducks/links.png\",\r\n            \"./data/textures/ducks/midden-1.png\",\r\n            \"./data/textures/ducks/midden-3.png\",\r\n            \"./data/textures/ducks/midden-2.png\",\r\n            \"./data/textures/ducks/midden-4.png\"\r\n        ]);\r\n        // this.skyboxShader.load([\r\n        //     \"./data/textures/corona_ft.png\", \r\n        //     \"./data/textures/corona_bk.png\", \r\n        //     \"./data/textures/corona_up.png\", \r\n        //     \"./data/textures/corona_dn.png\", \r\n        //     \"./data/textures/corona_rt.png\", \r\n        //     \"./data/textures/corona_lf.png\"]);\r\n    }\r\n    ui(ui) { }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1)), 100, 2);\r\n        this.gs.set(grid, Geon__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_0__.Scene(this.camera);\r\n        this.gs.render(c);\r\n        this.skyboxShader.draw(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/skybox-app.ts?");

/***/ }),

/***/ "./src/apps/render-apps/zebra-app.ts":
/*!*******************************************!*\
  !*** ./src/apps/render-apps/zebra-app.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZebraApp\": () => (/* binding */ ZebraApp)\n/* harmony export */ });\n/* harmony import */ var Engine_math_Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/math/Transform */ \"../engine/src/math/Transform.ts\");\n/* harmony import */ var Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_ZebraShader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Engine/render/shaders/ZebraShader */ \"../engine/src/render/shaders/ZebraShader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    shapes-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: test creation of basic mesh shapes. Test UI\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ZebraApp extends Geon__WEBPACK_IMPORTED_MODULE_5__.App {\r\n    constructor(gl) {\r\n        // setup render env\r\n        super(gl);\r\n        this.material = Engine_render_basics_Material__WEBPACK_IMPORTED_MODULE_1__.Material.default();\r\n        // geo data\r\n        this.plane = Geon__WEBPACK_IMPORTED_MODULE_5__.Plane.WorldXY();\r\n        this.geo = [];\r\n        // logic data\r\n        this.size = 10;\r\n        this.cellSize = 0.5;\r\n        this.somePos = Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3.zero();\r\n        this.distance = new Geon__WEBPACK_IMPORTED_MODULE_5__.Parameter(\"distance\", 3.0, 0, 4.0, 0.01);\r\n        this.radius = new Geon__WEBPACK_IMPORTED_MODULE_5__.Parameter(\"radius\", 1.0, 0, 4.0, 0.01);\r\n        this.detail = new Geon__WEBPACK_IMPORTED_MODULE_5__.Parameter(\"detail\", 20, 0, 100, 1);\r\n        this.shademethod = Geon__WEBPACK_IMPORTED_MODULE_5__.EnumParameter.new(\"render method\", 3, [\"debug\", \"vertex shaded\", \"face shaded\", \"ambient only\", \"phong\"]);\r\n        let canvas = gl.canvas;\r\n        // TODO abstract this to scene\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_5__.Camera(canvas, undefined, true);\r\n        this.camera.zoom = -10;\r\n        this.camera.angleAlpha = 0.4;\r\n        this.camera.angleBeta = 0.5;\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_5__.Scene(this.camera);\r\n        this.lineRenderer = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_3__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        // this.phong = new PhongShader(gl);\r\n        this.phong = new Engine_render_shaders_ZebraShader__WEBPACK_IMPORTED_MODULE_4__.ZebraShader(gl, true);\r\n    }\r\n    ui(ui) {\r\n        // TODO : think of a system that ties parameter & slider together fully\r\n        ui.addParameter(this.detail, () => { this.start(); });\r\n        ui.add3DParameter(\"sun\", Geon__WEBPACK_IMPORTED_MODULE_5__.Domain3.fromRadius(50), 1, this.scene.sun.pos);\r\n        ui.add3DParameter(\"position\", Geon__WEBPACK_IMPORTED_MODULE_5__.Domain3.fromRadius(3), 0.01, this.somePos, () => {\r\n            this.start();\r\n        });\r\n        ui.addParameter(Geon__WEBPACK_IMPORTED_MODULE_5__.Parameter.new(\"specular-dampner\", 0.2, 0, 10, 0.001), (v) => {\r\n            this.material.specularDampner = v;\r\n            this.start();\r\n        });\r\n    }\r\n    start() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromGrid(this.plane.clone().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 0, -this.radius.get())), 100, 2);\r\n        let spherePerRing = this.detail.get() * 2;\r\n        let rad = this.radius.get();\r\n        let dis = this.distance.get();\r\n        let det = this.detail.get();\r\n        let mesh = Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.fromJoin([\r\n            Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.newSphere(new Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3(dis, 0, 0), this.radius.get(), this.detail.get(), spherePerRing),\r\n            // PureMesh.fromCube(new Cube(this.plane, Domain3.fromRadius(this.radius.get()))),\r\n            Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.newCone(new Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3(-dis, 0, -this.radius.get()), this.radius.get(), this.radius.get() * 2, spherePerRing),\r\n            Geon__WEBPACK_IMPORTED_MODULE_5__.Mesh.newCylinder(new Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 0, -rad), new Geon__WEBPACK_IMPORTED_MODULE_5__.Vector3(0, 0, rad), rad, det),\r\n        ]);\r\n        mesh.ensureUVs();\r\n        mesh.calcAndSetVertexNormals();\r\n        // let model = new Model(Matrix4.newIdentity(), rend.mesh, this.material);\r\n        let model = Engine_render_basics_Model__WEBPACK_IMPORTED_MODULE_2__.Model.new(mesh, this.material);\r\n        let e = Geon__WEBPACK_IMPORTED_MODULE_5__.Entity.new(Engine_math_Transform__WEBPACK_IMPORTED_MODULE_0__.Transform.new(this.somePos), model);\r\n        // this.phong.load(model, DrawSpeed.StaticDraw);\r\n        this.phong.load(e, Geon__WEBPACK_IMPORTED_MODULE_5__.DrawSpeed.StaticDraw);\r\n        this.lineRenderer.set(grid);\r\n    }\r\n    update(input) {\r\n        // move the camera with the mouse\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        // this.phong.draw(this.scene);\r\n        this.phong.draw(this.scene);\r\n        this.lineRenderer.render(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/render-apps/zebra-app.ts?");

/***/ }),

/***/ "./src/apps/scientific-apps/canny-app.ts":
/*!***********************************************!*\
  !*** ./src/apps/scientific-apps/canny-app.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CannyApp\": () => (/* binding */ CannyApp)\n/* harmony export */ });\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n// const PATHS_TO_TEXTURE = [\"./data/eyes/eyes-1.jpeg\", \"./data/eyes/eyes-2.jpeg\",\"./data/eyes/eyes-3.jpeg\"];\r\nconst PATHS_TO_TEXTURE = [\r\n    \"./data/textures/earth.png\",\r\n    \"./data/textures/prague-darker.png\",\r\n    \"./data/textures/prague.png\",\r\n    \"./data/textures/prague-lighter.png\"\r\n];\r\nclass Settings {\r\n    constructor() {\r\n        this.parameters = new Map();\r\n    }\r\n    get(key) {\r\n        return this.parameters.get(key).state;\r\n    }\r\n    getParam(key) {\r\n        return this.parameters.get(key);\r\n    }\r\n    add(p) {\r\n        this.parameters.set(p.name, p);\r\n    }\r\n    publish(gui, onTrigger) {\r\n        for (let param of this.parameters.values()) {\r\n            gui.addParameter(param, (v) => onTrigger());\r\n        }\r\n    }\r\n}\r\nclass CannyApp extends Geon__WEBPACK_IMPORTED_MODULE_0__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        this.guiPublished = false;\r\n        let canvas = gl.canvas;\r\n        this.dr = Geon__WEBPACK_IMPORTED_MODULE_0__.DebugRenderer.new(gl);\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_0__.Camera(canvas, -2, true);\r\n        camera.setState([493.30, -156.98, 135.77, -50, 1.5999999999999928, 1.5707963267948966]);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_0__.Scene(camera);\r\n        this.settings = new Settings();\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.EnumParameter.new(\"choose-image\", 0, PATHS_TO_TEXTURE));\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.new(\"blur-size\", 3, 3, 7, 2));\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.new(\"blur-sigma\", 1.40, 0.25, 4.00, 0.01));\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.new(\"lower\", 130, 1, 255, 1));\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.new(\"upper\", 246, 1, 255, 1));\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.newBoolean(\"equalize-histogram\", true));\r\n        this.settings.add(Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.newBoolean(\"dynamic-threshold\", true));\r\n    }\r\n    start() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let settings = this.settings;\r\n            let imgData = yield (0,Geon__WEBPACK_IMPORTED_MODULE_0__.loadImageFromSrc)(PATHS_TO_TEXTURE[settings.get(\"choose-image\")]);\r\n            let texture = Geon__WEBPACK_IMPORTED_MODULE_0__.Bitmap.fromImageData(imgData);\r\n            // this.dr.clear();\r\n            // this.dr.set(ImageMesh.new(texture, Plane.WorldYZ().moveTo(Vector3.new(0, 0, 0)), 1, false, true), \"original\");\r\n            // let grey = ImageProcessing.trueGreyscale(texture);\r\n            // this.dr.set(ImageMesh.new(grey, Plane.WorldYZ().moveTo(Vector3.new(0, 0, 0)), 1, false, true), \"grey\");\r\n            Geon__WEBPACK_IMPORTED_MODULE_0__.ImageProcessing.canny(texture, settings.get(\"blur-sigma\"), settings.get(\"blur-size\"), settings.get(\"lower\"), settings.get(\"upper\"), settings.get(\"equalize-histogram\") === 1, settings.get(\"dynamic-threshold\") === 1, this.dr);\r\n            if (this.guiPublished)\r\n                return;\r\n            this.gui.setContext(\"image-toggles-wrapper\");\r\n            this.dr.addUi(this.gui);\r\n            this.guiPublished = true;\r\n        });\r\n    }\r\n    ui(ui) {\r\n        this.gui = ui;\r\n        this.gui.addDiv(\"image-toggles-wrapper\");\r\n        this.settings.publish(this.gui, () => {\r\n            if (this.settings.get(\"auto-recalc\") == 1) {\r\n                this.start();\r\n            }\r\n        });\r\n        // published the auto-recalc differently\r\n        let bool = Geon__WEBPACK_IMPORTED_MODULE_0__.Parameter.newBoolean(\"auto-recalc\", true);\r\n        this.settings.add(bool);\r\n        this.gui.addBooleanParameter(bool);\r\n        this.gui.addButton(\"recalc\", () => {\r\n            this.start();\r\n        });\r\n    }\r\n    update(input) {\r\n        this.scene.camera.update(input);\r\n    }\r\n    draw() {\r\n        this.dr.render(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/scientific-apps/canny-app.ts?");

/***/ }),

/***/ "./src/apps/spherical-apps/spherical-app.ts":
/*!**************************************************!*\
  !*** ./src/apps/spherical-apps/spherical-app.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SphericalApp\": () => (/* binding */ SphericalApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/graph-debug-shader */ \"../engine/src/render/shaders-old/graph-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n/* harmony import */ var _spherical__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./spherical */ \"./src/apps/spherical-apps/spherical.ts\");\n// TODO\r\n// - improve quadification: less triangles!\r\n// - improve squarification: speed & equal sizes\r\n// - Make big sphere and funky texture dancing around on it\r\n\r\n\r\n\r\n\r\n\r\n//\r\n//\r\n//\r\nclass SphericalApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl, \"Multiple Layers of spherical geometry\");\r\n        // state\r\n        this.radius = 1.0;\r\n        this.smoothlimit = 0;\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, 1, true);\r\n        this.camera.set(-2, 1.24, -0.71);\r\n        this.meshRend = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__.ShadedMeshShader(gl);\r\n        this.floorRend = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__.ShadedMeshShader(gl);\r\n        // this.meshRend = new MeshDebugRenderer(gl, [0, 0, 0, 1], [0.3, 0.3, 0.3, 1], false);\r\n        this.debugRend = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_1__.MeshDebugShader(gl, [0.5, 0, 0, 1], [0, 0, 0, 1], false);\r\n        this.graphRend = new Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_0__.GraphDebugShader(gl, [0.5, 0.5, 0.5, 1], [1, 1, 1, 1]);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.newMeshShader = new Geon__WEBPACK_IMPORTED_MODULE_3__.PhongShader(gl);\r\n        this.skyboxShader = new Geon__WEBPACK_IMPORTED_MODULE_3__.SkyBoxShader(gl);\r\n    }\r\n    ui(ui) {\r\n        let reset = () => {\r\n            // this.rotate.set(0);\r\n            this.start();\r\n        };\r\n        this.rotate = Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.newBoolean(\"rotate\", false);\r\n        this.randomEdges = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"randomEdges\", 1, 0, 1, 1);\r\n        this.smooth = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"smooth\", 0, 0, 1, 1);\r\n        this.subCount = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"sub count\", 2, 0, 4, 1);\r\n        this.quadSubCount = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"sub count quad\", 1, 0, 2, 1);\r\n        ui.addBooleanParameter(this.rotate);\r\n        ui.addBooleanParameter(this.randomEdges, reset);\r\n        ui.addBooleanParameter(this.smooth);\r\n        ui.addParameter(this.subCount, reset);\r\n        ui.addParameter(this.quadSubCount, reset);\r\n        ui.addButton(\"recalculate\", reset);\r\n    }\r\n    start() {\r\n        // set some values\r\n        this.radius = 1;\r\n        this.smoothlimit = 0;\r\n        // create the graph\r\n        let random = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.fromSeed(13894);\r\n        this.graph = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.createGraph)(1, this.subCount.get(), this.quadSubCount.get(), this.randomEdges.get(), random);\r\n        // create the tile data\r\n        this.tiles = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.createTileWorld)(this.graph.allVertLoopsAsInts().length, 1);\r\n        // set renderers\r\n        // this.graphRend.set(this.graph, DrawSpeed.DynamicDraw);\r\n        this.avEdgeLength = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.averageEdgeLength)(this.graph);\r\n        // this.skybox.load([\r\n        //     \"./data/textures/corona_ft.png\", \r\n        //     \"./data/textures/corona_bk.png\", \r\n        //     \"./data/textures/corona_up.png\", \r\n        //     \"./data/textures/corona_dn.png\", \r\n        //     \"./data/textures/corona_rt.png\", \r\n        //     \"./data/textures/corona_lf.png\"]);\r\n        // buffer\r\n        this.bufferWorld();\r\n        this.skyboxShader.load([\r\n            \"./data/textures/ducks/links.png\",\r\n            \"./data/textures/ducks/rechts.png\",\r\n            \"./data/textures/ducks/midden-1.png\",\r\n            \"./data/textures/ducks/midden-3.png\",\r\n            \"./data/textures/ducks/midden-2.png\",\r\n            \"./data/textures/ducks/midden-4.png\"\r\n        ]);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        this.scene.sun.pos = this.scene.camera.getActualPosition();\r\n        let pulse = Math.sin(input.time.newTime);\r\n        // rotate\r\n        if (this.rotate.get() == 1) {\r\n            let rot = Geon__WEBPACK_IMPORTED_MODULE_3__.Matrix4.newAxisRotation(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.unitZ(), input.time.tick * 0.0001);\r\n            this.world.position.multiply(rot);\r\n            this.worldFloor.position.multiply(rot);\r\n            // this.meshRend.setShallow(this.gl, this.world);\r\n            this.floorRend.setShallow(this.gl, this.worldFloor);\r\n            this.newMeshShader.loadTransform(this.world.position.toTransform());\r\n        }\r\n        this.smoothWorld();\r\n    }\r\n    draw() {\r\n        this.skyboxShader.draw(this.scene);\r\n        this.floorRend.render(this.scene);\r\n        this.newMeshShader.draw(this.scene);\r\n    }\r\n    bufferWorld() {\r\n        this.world = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.meshifyTileWorld)(this.graph, this.tiles, this.radius, 0.1);\r\n        // this.world.calculateFaceNormals();\r\n        let mesh = this.world.mesh;\r\n        mesh = mesh.toLinearMesh();\r\n        mesh.ensureMultiFaceNormals();\r\n        mesh.ensureUVs();\r\n        let m = Geon__WEBPACK_IMPORTED_MODULE_3__.Model.new(mesh, Geon__WEBPACK_IMPORTED_MODULE_3__.Material.newPurple());\r\n        this.newMeshShader.load(m.spawn());\r\n        this.world.color = [0.9, 0.9, 0.9, 1];\r\n        this.meshRend.set(this.world, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n        this.worldFloor = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.meshifyGraphSurface)(this.graph);\r\n        this.worldFloor.calculateFaceNormals();\r\n        this.worldFloor.color = [0.3, 0.3, 0.3, 1];\r\n        this.floorRend.set(this.worldFloor, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    smoothWorld() {\r\n        // sucessive over relaxation\r\n        if (this.smooth.get() == 1) {\r\n            if (this.smoothlimit < 1000) {\r\n                // squarification smoother\r\n                this.cca = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.squarification)(this.graph, this.cca);\r\n                // this.cca = this.squarification(this.graph);\r\n                // console.log(this.cca);\r\n                (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.laPlacian)(this.graph);\r\n                // project back to sphere\r\n                this.graph.verts.forEach((v) => {\r\n                    let normal = v.pos;\r\n                    let lift = this.radius - v.pos.length();\r\n                    v.pos.add(normal.normalized().scaled(lift));\r\n                });\r\n                this.smoothlimit += 1;\r\n                // this.graphRend.set(this.graph, DrawSpeed.DynamicDraw);\r\n                this.bufferWorld();\r\n            }\r\n        }\r\n        else {\r\n            this.smoothlimit = 0;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/spherical-apps/spherical-app.ts?");

/***/ }),

/***/ "./src/apps/spherical-apps/spherical-noise.ts":
/*!****************************************************!*\
  !*** ./src/apps/spherical-apps/spherical-noise.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SphericalNoise\": () => (/* binding */ SphericalNoise)\n/* harmony export */ });\n/* harmony import */ var Engine_math_Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/math/Transform */ \"../engine/src/math/Transform.ts\");\n/* harmony import */ var Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/graph-debug-shader */ \"../engine/src/render/shaders-old/graph-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/render/shaders-old/shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// TODO\r\n// - improve quadification: less triangles!\r\n// - improve squarification: speed & equal sizes\r\n\r\n\r\n\r\n\r\n\r\nclass SphericalNoise extends Geon__WEBPACK_IMPORTED_MODULE_4__.App {\r\n    constructor(gl) {\r\n        super(gl, \"\");\r\n        this.radius = 0.1;\r\n        this.smoothlimit = 0;\r\n        this.lockedHeight = 1.3;\r\n        this.entityVelocity = 0.005;\r\n        this.entityDirection = Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3.unitX().scale(this.entityVelocity);\r\n        this.n = 0;\r\n        this.myangle = 0;\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_4__.Camera(canvas, 1, false, true);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_4__.Scene(this.camera);\r\n        this.camera.set(-4.48, 1.24, -0.71);\r\n        this.meshRend = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_3__.ShadedMeshShader(gl);\r\n        this.debugRend = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl, [0.5, 0, 0, 1], [1, 0, 0, 1], false);\r\n        this.graphRend = new Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_1__.GraphDebugShader(gl, [0.5, 0, 0, 1], [255 / 255, 69 / 255, 0, 1]);\r\n        this.phong = new Geon__WEBPACK_IMPORTED_MODULE_4__.PhongShader(gl);\r\n        this.entityShader = new Geon__WEBPACK_IMPORTED_MODULE_4__.PhongShader(gl);\r\n    }\r\n    ui(ui) {\r\n        let reset = () => {\r\n            // this.rotate.set(0);\r\n            this.start();\r\n        };\r\n        this.rotate = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"rotate\", 0, 0, 1, 1);\r\n        this.randomEdges = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"randomEdges\", 1, 0, 1, 1);\r\n        this.smooth = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"smooth\", 0, 0, 1, 1);\r\n        this.subCount = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"sub count\", 5, 0, 4, 1);\r\n        this.liftType = Geon__WEBPACK_IMPORTED_MODULE_4__.EnumParameter.new(\"lift type\", 1, [\"none\", \"sphere\", \"buggy\"]);\r\n        this.noiseScale = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"noise scale\", 1, 0, 10, 0.1);\r\n        this.offset = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"noise offset\", 1, 0, 1, 0.001);\r\n        this.amplitude = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"noise applitude\", 1, 0, 5, 0.1);\r\n        this.noiseOctaves = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"noise octaves\", 1, 0, 10, 1);\r\n        this.noiseOctaveBlend = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"noise octaves blend\", 0.5, 0.0, 1.0, 0.01);\r\n        this.noiseStride = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"noise stride\", 0.06, 0, 1, 0.01);\r\n        ui.addParameter(this.subCount, reset);\r\n        ui.addParameter(this.liftType, reset);\r\n        ui.addParameter(this.offset, reset);\r\n        ui.addParameter(this.noiseScale, reset);\r\n        ui.addParameter(this.amplitude, reset);\r\n        ui.addParameter(this.noiseOctaves, reset);\r\n        ui.addParameter(this.noiseOctaveBlend, reset);\r\n        ui.addParameter(this.noiseStride, reset);\r\n        ui.addButton(\"recalculate\", reset);\r\n    }\r\n    startEntity() {\r\n        let model = new Geon__WEBPACK_IMPORTED_MODULE_4__.Model(Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromCube(Geon__WEBPACK_IMPORTED_MODULE_4__.Cube.fromRadius(Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3.zero(), 0.05)), Geon__WEBPACK_IMPORTED_MODULE_4__.Material.default());\r\n        let e = new Geon__WEBPACK_IMPORTED_MODULE_4__.Entity(Engine_math_Transform__WEBPACK_IMPORTED_MODULE_0__.Transform.new(Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3.new(0, 0, 1.3)), model);\r\n        this.entity = e;\r\n        this.entityShader.load(e);\r\n    }\r\n    start() {\r\n        this.startEntity();\r\n        this.quatTest();\r\n        let liftType = this.liftType.get();\r\n        // 0 | setup\r\n        let perlin = Geon__WEBPACK_IMPORTED_MODULE_4__.Perlin.new();\r\n        const mesh = Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.newIcosahedron(0.5);\r\n        let graph = mesh.toGraph();\r\n        let center = new Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);\r\n        this.smoothlimit = 0;\r\n        if (liftType == 2) {\r\n            this.radius = 1;\r\n        }\r\n        else {\r\n            this.radius = graph.getVertexPos(0).disTo(center);\r\n        }\r\n        // lift to sphere after every subdivision\r\n        for (let i = 0; i < this.subCount.get(); i++) {\r\n            graph.subdivide();\r\n            // lift to sphere after every subdivision\r\n            if (liftType > 0) {\r\n                let count = graph.getVertexCount();\r\n                for (let i = 0; i < count; i++) {\r\n                    let pos = graph.getVertexPos(i);\r\n                    let normal = pos;\r\n                    let dis = center.disTo(pos);\r\n                    let lift = this.radius - dis;\r\n                    if (liftType > 1) {\r\n                        pos.add(normal.scaled(lift));\r\n                    }\r\n                    else {\r\n                        pos.add(normal.normalized().scaled(lift));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // 4 | quad relaxation\r\n        this.graph = graph;\r\n        // NOISE\r\n        for (let i = 0; i < this.graph.verts.length; i++) {\r\n            let v = this.graph.verts[i].pos;\r\n            let o = this.offset.get();\r\n            let noise = perlin.octaveNoise(v.x * this.noiseScale.get() + o, v.y * this.noiseScale.get() + 0, v.z * this.noiseScale.get() + o, this.noiseOctaves.get(), this.noiseOctaveBlend.get());\r\n            let parts = 1 / this.noiseStride.get();\r\n            let rounded = Math.round(noise * parts) / parts;\r\n            v.add(v.scaled(rounded * this.amplitude.get()));\r\n        }\r\n        let theMesh = this.graph.meshify();\r\n        theMesh.calcAndSetVertexNormals();\r\n        // this.debugRend.set(theMesh, DrawSpeed.StaticDraw)\r\n        this.phong.load(Geon__WEBPACK_IMPORTED_MODULE_4__.Entity.new(Engine_math_Transform__WEBPACK_IMPORTED_MODULE_0__.Transform.new(), Geon__WEBPACK_IMPORTED_MODULE_4__.Model.new(theMesh, Geon__WEBPACK_IMPORTED_MODULE_4__.Material.newPurple())));\r\n        // console.log(\"edges: \", this.graph.allEdges());\r\n        // console.log(\"loops: \", this.graph.allVertLoops());\r\n    }\r\n    quatTest() {\r\n        let xform = this.entity.xform;\r\n        console.log(xform);\r\n        let m = xform.toMatrix();\r\n        let xform2 = m.toTransform();\r\n        // console.log(xform2);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        this.updateEntity(input);\r\n    }\r\n    updateEntity(input) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        // update position\r\n        let pos = this.entity.xform.pos;\r\n        let newPos = pos.add(this.entityDirection).setLength(this.lockedHeight);\r\n        // get new entityDirection\r\n        let cross = newPos.cross(this.entityDirection);\r\n        this.entityDirection = newPos.cross(cross).setLength(-this.entityVelocity);\r\n        // rotate \r\n        this.n = (this.n + 0.01);\r\n        this.entity.xform.rot.setPose(cross, this.entityDirection);\r\n        if ((_a = input.keys) === null || _a === void 0 ? void 0 : _a.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.A)) {\r\n            this.myangle += 0.01;\r\n        }\r\n        if ((_b = input.keys) === null || _b === void 0 ? void 0 : _b.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.D)) {\r\n            this.myangle -= 0.01;\r\n        }\r\n        // set camera\r\n        this.camera.zoom = -2;\r\n        this.camera.xform = Engine_math_Transform__WEBPACK_IMPORTED_MODULE_0__.Transform.new();\r\n        this.camera.xform.pos.copy(this.entity.xform.pos);\r\n        // this.camera.xform.rot.setAxisAngle(Vector3.unitZ(), this.myangle);\r\n        this.camera.xform.rot.copy(this.entity.xform.rot).multiply(Geon__WEBPACK_IMPORTED_MODULE_4__.Quaternion.fromEuler(Math.PI, 0.4, 0));\r\n        // console.log(this.entity.xform);\r\n        // console.log(this.camera.xform);\r\n        // this.camera.transform.pos.copy(newPos.scaled(-1.0));\r\n        // this.camera.transform.rot.setPose(cross.scaled(-1), this.entityDirection.scaled(-1)); \r\n        // rot.x = 0;\r\n        // rot.y = 1;\r\n        // rot.z = 0;\r\n        // rot.w += 0;\r\n        // rot.addN(0.01);\r\n        // create plane\r\n        // let plane = Plane.fromPVV(newPos, this.entityDirection.normalized(), cross.normalized());        \r\n        // rotate based upon input\r\n        if ((_c = input.keys) === null || _c === void 0 ? void 0 : _c.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.LeftArrow)) {\r\n            this.entityDirection = this.entityDirection.rotated(newPos, 0.01);\r\n        }\r\n        if ((_d = input.keys) === null || _d === void 0 ? void 0 : _d.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.RightArrow)) {\r\n            this.entityDirection = this.entityDirection.rotated(newPos, -0.01);\r\n        }\r\n        if ((_e = input.keys) === null || _e === void 0 ? void 0 : _e.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.UpArrow)) {\r\n            this.lockedHeight += 0.01;\r\n        }\r\n        if ((_f = input.keys) === null || _f === void 0 ? void 0 : _f.isDown(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.DownArrow)) {\r\n            this.lockedHeight -= 0.01;\r\n        }\r\n        if ((_g = input.keys) === null || _g === void 0 ? void 0 : _g.isPressed(Geon__WEBPACK_IMPORTED_MODULE_4__.Key.Space)) {\r\n            this.quatTest();\r\n        }\r\n        // this.entity.xform = plane.matrix;\r\n        this.entityShader.loadTransform(this.entity.xform);\r\n    }\r\n    draw() {\r\n        this.meshRend.render(this.scene);\r\n        this.graphRend.render(this.scene);\r\n        this.debugRend.render(this.scene);\r\n        this.phong.draw(this.scene);\r\n        this.entityShader.draw(this.scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/spherical-apps/spherical-noise.ts?");

/***/ }),

/***/ "./src/apps/spherical-apps/spherical-one-app.ts":
/*!******************************************************!*\
  !*** ./src/apps/spherical-apps/spherical-one-app.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SphericalOneApp\": () => (/* binding */ SphericalOneApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/graph-debug-shader */ \"../engine/src/render/shaders-old/graph-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var Engine_util_Stopwatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Engine/util/Stopwatch */ \"../engine/src/util/Stopwatch.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n/* harmony import */ var _spherical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./spherical */ \"./src/apps/spherical-apps/spherical.ts\");\n// TODO\r\n// - improve quadification: less triangles!\r\n// - improve squarification: speed & equal sizes\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass SphericalOneApp extends Geon__WEBPACK_IMPORTED_MODULE_4__.App {\r\n    constructor(gl) {\r\n        super(gl, \"setup for trying out different partitions of a sphere. Based on Oskar Stalberg's irregular quad grid\");\r\n        this.radius = 0.1;\r\n        this.smoothlimit = 0;\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_4__.Camera(canvas, 1, true);\r\n        this.camera.set(-4.48, 1.24, -0.71);\r\n        this.meshRend = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__.ShadedMeshShader(gl);\r\n        this.debugRend = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_1__.MeshDebugShader(gl, [0.5, 0, 0, 1], [1, 0, 0, 1], false);\r\n        this.graphRend = new Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_0__.GraphDebugShader(gl, [0.5, 0, 0, 1], [255 / 255, 69 / 255, 0, 1]);\r\n    }\r\n    ui(ui) {\r\n        let reset = () => {\r\n            // this.rotate.set(0);\r\n            this.start();\r\n        };\r\n        this.rotate = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"rotate\", 0, 0, 1, 1);\r\n        this.randomEdges = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"randomEdges\", 1, 0, 1, 1);\r\n        this.smooth = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"smooth\", 0, 0, 1, 1);\r\n        this.subCount = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"sub count\", 2, 0, 4, 1);\r\n        this.quadSubCount = new Geon__WEBPACK_IMPORTED_MODULE_4__.Parameter(\"sub count quad\", 1, 0, 2, 1);\r\n        this.liftType = Geon__WEBPACK_IMPORTED_MODULE_4__.EnumParameter.new(\"lift type\", 1, [\"none\", \"sphere\", \"buggy\"]);\r\n        ui.addBooleanParameter(this.rotate);\r\n        ui.addBooleanParameter(this.randomEdges, reset);\r\n        ui.addBooleanParameter(this.smooth);\r\n        ui.addParameter(this.subCount, reset);\r\n        ui.addParameter(this.quadSubCount, reset);\r\n        ui.addParameter(this.liftType, reset);\r\n        ui.addButton(\"recalculate\", reset);\r\n    }\r\n    start() {\r\n        let liftType = this.liftType.get();\r\n        // 0 | setup\r\n        const mesh = Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.newIcosahedron(0.5);\r\n        let graph = mesh.toGraph();\r\n        let center = new Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);\r\n        this.smoothlimit = 0;\r\n        if (liftType == 2) {\r\n            this.radius = 1;\r\n        }\r\n        else {\r\n            this.radius = graph.getVertexPos(0).disTo(center);\r\n        }\r\n        // DEBUG: PERFORMANCE\r\n        console.log(\"lets start subdivisions!\");\r\n        let stopwatch = Engine_util_Stopwatch__WEBPACK_IMPORTED_MODULE_3__.Stopwatch.new();\r\n        // 1 | subdivide\r\n        for (let i = 0; i < this.subCount.get(); i++) {\r\n            graph.subdivide();\r\n            // lift to sphere after every subdivision\r\n            if (liftType > 0) {\r\n                let count = graph.getVertexCount();\r\n                for (let i = 0; i < count; i++) {\r\n                    let pos = graph.getVertexPos(i);\r\n                    let normal = pos;\r\n                    let dis = center.disTo(pos);\r\n                    let lift = this.radius - dis;\r\n                    if (liftType > 1) {\r\n                        pos.add(normal.scaled(lift));\r\n                    }\r\n                    else {\r\n                        pos.add(normal.normalized().scaled(lift));\r\n                    }\r\n                }\r\n                console.log(\"lift in \", stopwatch.time(), \"ms\");\r\n            }\r\n        }\r\n        // DEBUG: PERFORMANCE\r\n        console.log(\"subdivision in \", stopwatch.time(), \"ms\");\r\n        // 2 | remove random edges\r\n        let random = Geon__WEBPACK_IMPORTED_MODULE_4__.Random.fromSeed(19384);\r\n        if (this.randomEdges.get() == 1) {\r\n            (0,_spherical__WEBPACK_IMPORTED_MODULE_5__.quadification)(graph, random);\r\n            // graph.print();\r\n            // 2 | remove random edges\r\n            // let edges = graph.all();\r\n            // let picks: number[] = [];\r\n            // let pickCount = 100;\r\n            // for (let i = 0 ; i < pickCount; i++) {\r\n            //     let p = randomInt(edges.length);\r\n            //     picks.push(edges[p]);\r\n            // }\r\n            // // // console.log(picks);\r\n            // for (let i = 0 ; i < edges.length; i++) {\r\n            //     if (Math.random() > 0.0) {\r\n            //         let ei = edges[i];\r\n            //         let loops = graph.getLoopsAdjacentToEdge(ei);\r\n            //         if (loops[0].length == 3 && loops[1].length == 3) {\r\n            //             graph.deleteEdgeFromIndex(edges[i]);\r\n            //         }\r\n            //     }\r\n            // }\r\n        }\r\n        console.log(\"edge removal in \", stopwatch.time(), \"ms\");\r\n        // 3 | subdivide quad\r\n        for (let i = 0; i < this.quadSubCount.get(); i++) {\r\n            graph.subdivideQuad();\r\n        }\r\n        // DEBUG: PERFORMANCE\r\n        console.log(\"quad subdivision in \", stopwatch.time(), \"ms\");\r\n        // lift to sphere after every subdivision\r\n        if (liftType > 0) {\r\n            let count = graph.getVertexCount();\r\n            for (let i = 0; i < count; i++) {\r\n                let pos = graph.getVertexPos(i);\r\n                let normal = graph.getVertexNormal(i);\r\n                let dis = center.disTo(pos);\r\n                let lift = this.radius - dis;\r\n                if (liftType > 1) {\r\n                    pos.add(normal.scaled(lift));\r\n                }\r\n                else {\r\n                    pos.add(normal.normalized().scaled(lift));\r\n                }\r\n            }\r\n            console.log(\"lift in \", stopwatch.time(), \"ms\");\r\n        }\r\n        // 4 | quad relaxation\r\n        this.graph = graph;\r\n        // this.rend = this.graph.toRenderable();\r\n        // this.rend = graphToMultiMesh(this.graph, 0.02, 3, false, true);\r\n        // this.rend.calculateVertexNormals();\r\n        // console.log(\"num triangles = \", this.rend.mesh.links.count());\r\n        // console.log(\"to renderable in \", stopwatch.time(), \"ms\");\r\n        // this.graph.print();\r\n        // let loops = graph.allVertLoopsAsInts();\r\n        // console.log(\"allVertLoops in \", stopwatch.time(), \"ms\");\r\n        //console.log(loops);\r\n        // 5 | convert\r\n        if (liftType == 1) {\r\n            let somesphere = Geon__WEBPACK_IMPORTED_MODULE_4__.Mesh.newSphere(Geon__WEBPACK_IMPORTED_MODULE_4__.Vector3.zero(), this.radius * 0.99, 6, 10).ToShaderMesh();\r\n            somesphere.calculateVertexNormals();\r\n            this.meshRend.set(somesphere, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.StaticDraw);\r\n        }\r\n        else if (liftType == 0) {\r\n            let something = mesh.ToShaderMesh();\r\n            something.transform(Geon__WEBPACK_IMPORTED_MODULE_4__.Matrix4.newScaler(0.99, 0.99, 0.99));\r\n            something.calculateFaceNormals();\r\n            this.meshRend.set(something, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.StaticDraw);\r\n        }\r\n        this.graphRend.set(this.graph, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.DynamicDraw);\r\n        this.average = (0,_spherical__WEBPACK_IMPORTED_MODULE_5__.averageEdgeLength)(this.graph);\r\n        // console.log(\"edges: \", this.graph.allEdges());\r\n        // console.log(\"loops: \", this.graph.allVertLoops());\r\n    }\r\n    update(input) {\r\n        var _a;\r\n        this.camera.update(input);\r\n        if (((_a = input.mouse) === null || _a === void 0 ? void 0 : _a.rightDown) && this.rotate.get() == 1) {\r\n            // rotate\r\n            let alpha = 0.0001 * input.time.tick;\r\n            let rot = Geon__WEBPACK_IMPORTED_MODULE_4__.Matrix4.newXRotation(alpha).multiply(Geon__WEBPACK_IMPORTED_MODULE_4__.Matrix4.newYRotation(alpha));\r\n            this.graph.transform(rot);\r\n        }\r\n        // sucessive over relaxation\r\n        if (this.smooth.get() == 1) {\r\n            if (this.smoothlimit < 1000) {\r\n                // squarification smoother\r\n                this.cca = (0,_spherical__WEBPACK_IMPORTED_MODULE_5__.squarification)(this.graph, this.cca);\r\n                // this.cca = this.squarification(this.graph);\r\n                // console.log(this.cca);\r\n                (0,_spherical__WEBPACK_IMPORTED_MODULE_5__.laPlacian)(this.graph);\r\n                // project back to sphere\r\n                this.graph.verts.forEach((v) => {\r\n                    let normal = v.pos;\r\n                    let lift = this.radius - v.pos.length();\r\n                    v.pos.add(normal.normalized().scaled(lift));\r\n                });\r\n                this.smoothlimit += 1;\r\n            }\r\n        }\r\n        else {\r\n            this.smoothlimit = 0;\r\n        }\r\n        this.graphRend.set(this.graph, Geon__WEBPACK_IMPORTED_MODULE_4__.DrawSpeed.DynamicDraw);\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_4__.Scene(this.camera);\r\n        this.meshRend.render(c);\r\n        this.graphRend.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/spherical-apps/spherical-one-app.ts?");

/***/ }),

/***/ "./src/apps/spherical-apps/spherical-three-app.ts":
/*!********************************************************!*\
  !*** ./src/apps/spherical-apps/spherical-three-app.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SphericalThreeApp\": () => (/* binding */ SphericalThreeApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/graph-debug-shader */ \"../engine/src/render/shaders-old/graph-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Engine/render/shaders-old/shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n/* harmony import */ var _spherical__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./spherical */ \"./src/apps/spherical-apps/spherical.ts\");\n// TODO\r\n// - improve quadification: less triangles!\r\n// - improve squarification: speed & equal sizes\r\n// - Make big sphere and funky texture dancing around on it\r\n\r\n\r\n\r\n\r\n\r\n//\r\n//\r\n//\r\nclass SphericalThreeApp extends Geon__WEBPACK_IMPORTED_MODULE_3__.App {\r\n    constructor(gl) {\r\n        super(gl, \"Multiple Layers of spherical geometry\");\r\n        // state\r\n        this.radius = 1.0;\r\n        this.smoothlimit = 0;\r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_3__.Camera(canvas, 1, true);\r\n        this.camera.set(-2, 1.24, -0.71);\r\n        this.meshRend = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__.ShadedMeshShader(gl);\r\n        this.floorRend = new Engine_render_shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_2__.ShadedMeshShader(gl);\r\n        // this.meshRend = new MeshDebugRenderer(gl, [0, 0, 0, 1], [0.3, 0.3, 0.3, 1], false);\r\n        this.debugRend = new Engine_render_shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_1__.MeshDebugShader(gl, [0.5, 0, 0, 1], [0, 0, 0, 1], false);\r\n        this.graphRend = new Engine_render_shaders_old_graph_debug_shader__WEBPACK_IMPORTED_MODULE_0__.GraphDebugShader(gl, [0.5, 0.5, 0.5, 1], [1, 1, 1, 1]);\r\n    }\r\n    ui(ui) {\r\n        let reset = () => {\r\n            // this.rotate.set(0);\r\n            this.start();\r\n        };\r\n        this.rotate = Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter.newBoolean(\"rotate\", false);\r\n        this.randomEdges = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"randomEdges\", 1, 0, 1, 1);\r\n        this.smooth = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"smooth\", 0, 0, 1, 1);\r\n        this.subCount = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"sub count\", 2, 0, 4, 1);\r\n        this.quadSubCount = new Geon__WEBPACK_IMPORTED_MODULE_3__.Parameter(\"sub count quad\", 1, 0, 2, 1);\r\n        ui.addBooleanParameter(this.rotate);\r\n        ui.addBooleanParameter(this.randomEdges, reset);\r\n        ui.addBooleanParameter(this.smooth);\r\n        ui.addParameter(this.subCount, reset);\r\n        ui.addParameter(this.quadSubCount, reset);\r\n        ui.addButton(\"recalculate\", reset);\r\n    }\r\n    start() {\r\n        // set some values\r\n        this.radius = 1;\r\n        this.smoothlimit = 0;\r\n        // create the graph\r\n        let random = Geon__WEBPACK_IMPORTED_MODULE_3__.Random.fromSeed(194845);\r\n        this.graph = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.createGraph)(1, this.subCount.get(), this.quadSubCount.get(), this.randomEdges.get(), random);\r\n        // create the tile data\r\n        this.tiles = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.createTileWorld)(this.graph.allVertLoopsAsInts().length, 4);\r\n        // set renderers\r\n        // this.graphRend.set(this.graph, DrawSpeed.DynamicDraw);\r\n        this.avEdgeLength = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.averageEdgeLength)(this.graph);\r\n        // buffer\r\n        this.bufferWorld();\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        let pulse = Math.sin(input.time.newTime);\r\n        // rotate\r\n        if (this.rotate.get() == 1) {\r\n            let rot = Geon__WEBPACK_IMPORTED_MODULE_3__.Matrix4.newAxisRotation(Geon__WEBPACK_IMPORTED_MODULE_3__.Vector3.unitZ(), input.time.tick * 0.0001);\r\n            this.world.position.multiply(rot);\r\n            this.worldFloor.position.multiply(rot);\r\n            this.meshRend.setShallow(this.gl, this.world);\r\n            this.floorRend.setShallow(this.gl, this.worldFloor);\r\n        }\r\n        this.smoothWorld();\r\n    }\r\n    draw() {\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_3__.Scene(this.camera);\r\n        this.meshRend.setShallow(this.gl, this.world);\r\n        this.meshRend.render(c);\r\n        this.meshRend.render(c);\r\n        this.floorRend.render(c);\r\n    }\r\n    bufferWorld() {\r\n        this.world = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.meshifyTileWorld)(this.graph, this.tiles, this.radius, 0.1);\r\n        this.world.calculateFaceNormals();\r\n        this.world.color = [0.9, 0.9, 0.9, 1];\r\n        this.meshRend.set(this.world, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n        this.worldFloor = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.meshifyGraphSurface)(this.graph);\r\n        this.worldFloor.calculateFaceNormals();\r\n        this.worldFloor.color = [0.3, 0.3, 0.3, 1];\r\n        this.floorRend.set(this.worldFloor, Geon__WEBPACK_IMPORTED_MODULE_3__.DrawSpeed.StaticDraw);\r\n    }\r\n    smoothWorld() {\r\n        // sucessive over relaxation\r\n        if (this.smooth.get() == 1) {\r\n            if (this.smoothlimit < 1000) {\r\n                // squarification smoother\r\n                this.cca = (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.squarification)(this.graph, this.cca);\r\n                // this.cca = this.squarification(this.graph);\r\n                // console.log(this.cca);\r\n                (0,_spherical__WEBPACK_IMPORTED_MODULE_4__.laPlacian)(this.graph);\r\n                // project back to sphere\r\n                this.graph.verts.forEach((v) => {\r\n                    let normal = v.pos;\r\n                    let lift = this.radius - v.pos.length();\r\n                    v.pos.add(normal.normalized().scaled(lift));\r\n                });\r\n                this.smoothlimit += 1;\r\n                // this.graphRend.set(this.graph, DrawSpeed.DynamicDraw);\r\n                this.bufferWorld();\r\n            }\r\n        }\r\n        else {\r\n            this.smoothlimit = 0;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/spherical-apps/spherical-three-app.ts?");

/***/ }),

/***/ "./src/apps/spherical-apps/spherical.ts":
/*!**********************************************!*\
  !*** ./src/apps/spherical-apps/spherical.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Spherical\": () => (/* binding */ Spherical),\n/* harmony export */   \"createGraph\": () => (/* binding */ createGraph),\n/* harmony export */   \"createTileWorld\": () => (/* binding */ createTileWorld),\n/* harmony export */   \"meshifyGraphSurface\": () => (/* binding */ meshifyGraphSurface),\n/* harmony export */   \"meshifyTileWorld\": () => (/* binding */ meshifyTileWorld),\n/* harmony export */   \"constructMeshFromSphereGraph\": () => (/* binding */ constructMeshFromSphereGraph),\n/* harmony export */   \"averageEdgeLength\": () => (/* binding */ averageEdgeLength),\n/* harmony export */   \"edgeSmooth\": () => (/* binding */ edgeSmooth),\n/* harmony export */   \"laPlacian\": () => (/* binding */ laPlacian),\n/* harmony export */   \"squarification\": () => (/* binding */ squarification),\n/* harmony export */   \"quadification\": () => (/* binding */ quadification),\n/* harmony export */   \"randomInt\": () => (/* binding */ randomInt)\n/* harmony export */ });\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n\r\nvar Spherical;\r\n(function (Spherical) {\r\n    function createSphere(liftType = 1, subCount = 2, quadSubCount = 1, randomEdges = true, smooth = true, random) {\r\n        // 0 | setup\r\n        const mesh = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.newIcosahedron(0.5);\r\n        let graph = mesh.toGraph();\r\n        let center = new Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\r\n        let radius = 1;\r\n        let smoothlimit = 0;\r\n        if (liftType == 2) {\r\n            radius = 1;\r\n        }\r\n        else {\r\n            radius = graph.getVertexPos(0).disTo(center);\r\n        }\r\n        // 1 | subdivide\r\n        for (let i = 0; i < subCount; i++) {\r\n            graph.subdivide();\r\n            // lift to sphere after every subdivision\r\n            if (liftType > 0) {\r\n                let count = graph.getVertexCount();\r\n                for (let i = 0; i < count; i++) {\r\n                    let pos = graph.getVertexPos(i);\r\n                    let normal = pos;\r\n                    let dis = center.disTo(pos);\r\n                    let lift = radius - dis;\r\n                    if (liftType > 1) {\r\n                        pos.add(normal.scaled(lift));\r\n                    }\r\n                    else {\r\n                        pos.add(normal.normalized().scaled(lift));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // 2 | remove random edges\r\n        if (randomEdges) {\r\n            quadification(graph, random);\r\n            // graph.print();\r\n            // 2 | remove random edges\r\n            // let edges = graph.all();\r\n            // let picks: number[] = [];\r\n            // let pickCount = 100;\r\n            // for (let i = 0 ; i < pickCount; i++) {\r\n            //     let p = randomInt(edges.length);\r\n            //     picks.push(edges[p]);\r\n            // }\r\n            // // // console.log(picks);\r\n            // for (let i = 0 ; i < edges.length; i++) {\r\n            //     if (Math.random() > 0.0) {\r\n            //         let ei = edges[i];\r\n            //         let loops = graph.getLoopsAdjacentToEdge(ei);\r\n            //         if (loops[0].length == 3 && loops[1].length == 3) {\r\n            //             graph.deleteEdgeFromIndex(edges[i]);\r\n            //         }\r\n            //     }\r\n            // }\r\n        }\r\n        // 3 | subdivide quad\r\n        for (let i = 0; i < quadSubCount; i++) {\r\n            graph.subdivideQuad();\r\n        }\r\n        // lift to sphere after every subdivision\r\n        if (liftType > 0) {\r\n            let count = graph.getVertexCount();\r\n            for (let i = 0; i < count; i++) {\r\n                let pos = graph.getVertexPos(i);\r\n                let normal = graph.getVertexNormal(i);\r\n                let dis = center.disTo(pos);\r\n                let lift = radius - dis;\r\n                if (liftType > 1) {\r\n                    pos.add(normal.scaled(lift));\r\n                }\r\n                else {\r\n                    pos.add(normal.normalized().scaled(lift));\r\n                }\r\n            }\r\n        }\r\n        return graph;\r\n    }\r\n    Spherical.createSphere = createSphere;\r\n})(Spherical || (Spherical = {}));\r\nfunction createGraph(liftType, subcount, quadsubcount, randomEdges, random) {\r\n    // 0 | setup\r\n    const mesh = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.newIcosahedron(0.5);\r\n    let graph = mesh.toGraph();\r\n    let center = new Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\r\n    let radius = 1;\r\n    // 1 | subdivide\r\n    for (let i = 0; i < subcount; i++) {\r\n        graph.subdivide();\r\n        // lift to sphere after every subdivision\r\n        if (liftType > 0) {\r\n            let count = graph.getVertexCount();\r\n            for (let i = 0; i < count; i++) {\r\n                let pos = graph.getVertexPos(i);\r\n                let normal = pos;\r\n                let dis = center.disTo(pos);\r\n                let lift = radius - dis;\r\n                if (liftType > 1) {\r\n                    pos.add(normal.scaled(lift));\r\n                }\r\n                else {\r\n                    pos.add(normal.normalized().scaled(lift));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 2 | remove random edges\r\n    if (randomEdges == 1) {\r\n        quadification(graph, random);\r\n    }\r\n    // 3 | subdivide quad\r\n    for (let i = 0; i < quadsubcount; i++) {\r\n        graph.subdivideQuad();\r\n    }\r\n    // lift to sphere after every subdivision\r\n    if (liftType > 0) {\r\n        let count = graph.getVertexCount();\r\n        for (let i = 0; i < count; i++) {\r\n            let pos = graph.getVertexPos(i);\r\n            let normal = graph.getVertexNormal(i);\r\n            let dis = center.disTo(pos);\r\n            let lift = radius - dis;\r\n            if (liftType > 1) {\r\n                pos.add(normal.scaled(lift));\r\n            }\r\n            else {\r\n                pos.add(normal.normalized().scaled(lift));\r\n            }\r\n        }\r\n    }\r\n    // quad relaxation from beginning?\r\n    return graph;\r\n}\r\nfunction createTileWorld(count, height) {\r\n    let m = new Geon__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(count, height);\r\n    for (let i = 0; i < m._height; i++) {\r\n        let val = randomInt(m._width + 1);\r\n        for (let j = 0; j < m._width; j++) {\r\n            if (j < val) {\r\n                m.set(i, j, 1);\r\n            }\r\n            else {\r\n                m.set(i, j, 0);\r\n            }\r\n        }\r\n    }\r\n    return m;\r\n}\r\nfunction meshifyGraphSurface(graph) {\r\n    // init result\r\n    let meshes = [];\r\n    // per quad\r\n    let loops = graph.allVertLoopsAsInts();\r\n    for (let i = 0; i < loops.length; i++) {\r\n        const loop = loops[i];\r\n        if (loop.length < 4) {\r\n            console.log(\"invalids\");\r\n            continue;\r\n        }\r\n        let vecs = loop.map((j) => graph.getVertexPos(j));\r\n        let m = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.newQuad([vecs[0], vecs[3], vecs[1], vecs[2]]);\r\n        meshes.push(m);\r\n    }\r\n    let rend = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromJoin(meshes).ToShaderMesh();\r\n    rend.calculateVertexNormals();\r\n    return rend;\r\n}\r\nfunction meshifyTileWorld(graph, tiles, radius, // base\r\nstoreyHeight) {\r\n    // init result\r\n    let meshes = [];\r\n    // per quad\r\n    let loops = graph.allVertLoopsAsInts();\r\n    for (let i = 0; i < loops.length; i++) {\r\n        const loop = loops[i];\r\n        if (loop.length < 4) {\r\n            console.log(\"invalids\");\r\n            continue;\r\n        }\r\n        let vecs = loop.map((j) => graph.getVertexPos(j));\r\n        let row = tiles.getRow(i);\r\n        // fill row\r\n        for (let j = 0; j < tiles._width; j++) {\r\n            let tileType = row[j];\r\n            if (tileType == 0) {\r\n                continue;\r\n            }\r\n            let level = radius + j * storeyHeight;\r\n            let level2 = radius + (j + 1) * storeyHeight;\r\n            let m = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.newOct([\r\n                vecs[0].scaled(level),\r\n                vecs[1].scaled(level),\r\n                vecs[3].scaled(level),\r\n                vecs[2].scaled(level),\r\n                vecs[0].scaled(level2),\r\n                vecs[1].scaled(level2),\r\n                vecs[3].scaled(level2),\r\n                vecs[2].scaled(level2),\r\n            ]);\r\n            meshes.push(m);\r\n        }\r\n    }\r\n    let rend = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromJoin(meshes).ToShaderMesh();\r\n    rend.calculateVertexNormals();\r\n    return rend;\r\n}\r\nfunction constructMeshFromSphereGraph(graph, radius, // to project back\r\nliftBot, //\r\nliftTop, //\r\nrand) {\r\n    // recalculate world mesh\r\n    let scaler1 = 1 + liftBot / radius;\r\n    let scaler2 = 1 + liftTop / radius;\r\n    let meshes = [];\r\n    let loops = graph.allVertLoopsAsInts();\r\n    for (let loop of loops) {\r\n        if (Math.random() > rand) {\r\n            continue;\r\n        }\r\n        if (loop.length < 4) {\r\n            continue;\r\n        }\r\n        let vecs = loop.map((j) => graph.getVertexPos(j));\r\n        let m = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.newOct([\r\n            vecs[0].scaled(scaler1),\r\n            vecs[1].scaled(scaler1),\r\n            vecs[3].scaled(scaler1),\r\n            vecs[2].scaled(scaler1),\r\n            vecs[0].scaled(scaler2),\r\n            vecs[1].scaled(scaler2),\r\n            vecs[3].scaled(scaler2),\r\n            vecs[2].scaled(scaler2),\r\n        ]);\r\n        meshes.push(m);\r\n    }\r\n    let rend = Geon__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromJoin(meshes);\r\n    return rend;\r\n}\r\nfunction averageEdgeLength(graph) {\r\n    let count = 0;\r\n    let sum = 0;\r\n    graph.forEveryEdgeVerts((a, b) => {\r\n        sum += a.disTo(b);\r\n        count += 1;\r\n    });\r\n    let average = sum / count;\r\n    return average;\r\n}\r\nfunction edgeSmooth(graph, average, scale) {\r\n    graph.forEveryEdgeVerts((a, b) => {\r\n        let distance = a.disTo(b);\r\n        let diff = average - distance;\r\n        let vector = b.subbed(a);\r\n        a.add(vector.scaled(-diff * scale));\r\n        b.add(vector.scaled(diff * scale));\r\n    });\r\n}\r\nfunction laPlacian(graph) {\r\n    let count = graph.getVertexCount();\r\n    let news = [];\r\n    // get center of nbs\r\n    for (let vi = 0; vi < count; vi++) {\r\n        let v = graph.getVert(vi);\r\n        if (v.dead)\r\n            continue;\r\n        let sum = Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        let nbs = graph.getVertNeighbors(vi);\r\n        for (let nb of nbs) {\r\n            sum.add(graph.getVertexPos(nb));\r\n        }\r\n        sum.scale(1 / nbs.length);\r\n        news.push(sum);\r\n    }\r\n    // set\r\n    for (let vi = 0; vi < count; vi++) {\r\n        graph.getVertexPos(vi).copy(news[vi]);\r\n    }\r\n}\r\nfunction squarification(graph, centerCornerAverage) {\r\n    // make the quad graph as 'square' as possible\r\n    // prepare\r\n    let faces = graph.allVertLoopsAsInts();\r\n    let count = faces.length;\r\n    let centers = new Array(count);\r\n    let movers = new Array(graph.verts.length);\r\n    let counters = new Array(graph.verts.length);\r\n    for (let i = 0; i < movers.length; i++) {\r\n        movers[i] = Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(0, 0, 0);\r\n        counters[i] = 0;\r\n    }\r\n    let cca = 0;\r\n    // iterate per face\r\n    for (let i = 0; i < count; i++) {\r\n        // get face, center and corners\r\n        let center = centers[i];\r\n        let face = faces[i];\r\n        let faceCount = face.length;\r\n        if (face.length == 0) {\r\n            throw \"HELP, WE ARE NOT DEALING WITH QUADS HERE!\";\r\n        }\r\n        center = Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(0, 0, 0);\r\n        let corners = new Array(faceCount);\r\n        for (let j = 0; j < faceCount; j++) {\r\n            let vi = face[j];\r\n            corners[j] = graph.getVertexPos(vi);\r\n            center.add(corners[j]);\r\n        }\r\n        center.scale(1 / faceCount);\r\n        // now that we have center, calculate cca\r\n        let local_cca = 0;\r\n        for (let j = 0; j < faceCount; j++) {\r\n            local_cca = center.disTo(corners[j]);\r\n        }\r\n        local_cca /= faceCount;\r\n        cca += local_cca;\r\n        // but use the given one if present\r\n        let scaler;\r\n        let cca_diff;\r\n        if (centerCornerAverage) {\r\n            scaler = centerCornerAverage;\r\n            cca_diff = centerCornerAverage - local_cca;\r\n        }\r\n        else {\r\n            scaler = local_cca;\r\n            cca_diff = 0;\r\n        }\r\n        // rotate all corners into the same space, and get the average of that\r\n        // TODO SAVE TIME BY DOING THIS:\r\n        // new Vector2(v.dot(ihat), v.dot(jhat)).angle()\r\n        let plane = Geon__WEBPACK_IMPORTED_MODULE_0__.Plane.from3pt(center, corners[0], corners[1]);\r\n        let normedCorners = new Array(face.length);\r\n        let normedCenter = Geon__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(0, 0, 0);\r\n        let delta = 2 / faceCount;\r\n        for (let j = 0; j < faceCount; j++) {\r\n            normedCorners[j] = plane.rotateVector(corners[j], j * Math.PI * delta);\r\n            normedCenter.add(normedCorners[j]);\r\n        }\r\n        // scale this averaged to the center corner average\r\n        normedCenter.scale(1 / 4);\r\n        let normal = normedCenter.subbed(center).normalize();\r\n        let perfectCorner = center.added(normal.scaled(local_cca));\r\n        // increate gunfactor if square is very small (awww)\r\n        let gunfactor = 1;\r\n        let equalizer = 200;\r\n        gunfactor += Math.max(-1 * cca_diff * equalizer, 0);\r\n        // console.log(gunfactor);\r\n        // rotate this average back, and add it to the movers of every vertex\r\n        for (let j = 0; j < faceCount; j++) {\r\n            let vi = face[j];\r\n            let v = plane.rotateVector(perfectCorner, j * Math.PI * delta);\r\n            movers[vi].add(v.scaled(gunfactor));\r\n            counters[vi] += 1;\r\n        }\r\n    }\r\n    // now, move the graph\r\n    for (let i = 0; i < movers.length; i++) {\r\n        let mover = movers[i];\r\n        let counter = counters[i];\r\n        if (counter < 1) {\r\n            continue;\r\n        }\r\n        let v = graph.getVertexPos(i);\r\n        v.add(mover.scale(1 / counter));\r\n    }\r\n    // return the center corner average, to be used in the next cycle\r\n    cca /= count;\r\n    return cca;\r\n}\r\nfunction quadification(graph, random) {\r\n    // edge deletion heuristic:\r\n    // remove edges between two triangles to create a quad.\r\n    // keep removing edges until no triangle neighbors another triangle.\r\n    // prepare\r\n    let count = graph.edges.length;\r\n    let edgeIds = new Array(count);\r\n    let visited = new Array(count);\r\n    graph.edges.forEach((e, i) => {\r\n        edgeIds[i] = i;\r\n        visited[i] = false;\r\n    });\r\n    // shuffle\r\n    let shuffler = (a, b) => {\r\n        return 0.5 - random.get();\r\n    };\r\n    edgeIds.sort(shuffler);\r\n    // per edge\r\n    for (let i = 0; i < count; i++) {\r\n        let ei = edgeIds[i];\r\n        let e = graph.edges[ei];\r\n        if (e.dead || visited[ei]) {\r\n            continue;\r\n        }\r\n        let loops = graph.getLoopsAdjacentToEdge(ei);\r\n        // only delete edges between triangles\r\n        if (loops[0].length > 3 || loops[1].length > 3) {\r\n            continue;\r\n        }\r\n        // the edges of this new quad should not be touched!\r\n        for (let loop of loops) {\r\n            for (let edgeIndex of loop) {\r\n                visited[edgeIndex] = true;\r\n            }\r\n        }\r\n        // now remove this edge itself\r\n        graph.deleteEdgeByIndex(ei);\r\n    }\r\n}\r\nfunction randomInt(max) {\r\n    return Math.floor(Math.random() * max);\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/spherical-apps/spherical.ts?");

/***/ }),

/***/ "./src/apps/util-apps/mic-app.ts":
/*!***************************************!*\
  !*** ./src/apps/util-apps/mic-app.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MicApp\": () => (/* binding */ MicApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass MicApp extends Geon__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        let canvas = gl.canvas;\r\n        let camera = new Geon__WEBPACK_IMPORTED_MODULE_1__.Camera(canvas, -2, true);\r\n        camera.set(-2, 1, 1);\r\n        this.grid = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.debug = Geon__WEBPACK_IMPORTED_MODULE_1__.DebugRenderer.new(gl);\r\n        this.scene = new Geon__WEBPACK_IMPORTED_MODULE_1__.Scene(camera);\r\n        this.circles = [];\r\n        for (let i = 0; i < 32; i++) {\r\n            this.circles[i] = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, Geon__WEBPACK_IMPORTED_MODULE_1__.Color.fromHSL(i / 32).data);\r\n        }\r\n    }\r\n    start() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.startGrid();\r\n            this.mic = yield Geon__WEBPACK_IMPORTED_MODULE_1__.Microphone.new(64);\r\n            // create something!\r\n        });\r\n    }\r\n    ui(ui) { }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_1__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_1__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, -1)), 100, 2);\r\n        this.grid.set(grid, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.scene.camera.update(input);\r\n        if (!this.mic)\r\n            return;\r\n        let samples = this.mic.getTimeDomainDelayed();\r\n        let plane = Geon__WEBPACK_IMPORTED_MODULE_1__.Plane.WorldXY();\r\n        for (let i = 0; i < 32; i++) {\r\n            let value = Math.abs(samples[i]);\r\n            plane.center = Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3.new(0, 0, value * 5);\r\n            this.circles[i].set(Geon__WEBPACK_IMPORTED_MODULE_1__.Circle3.new(plane, 0.1 + (i / 32)).buffer());\r\n        }\r\n    }\r\n    draw() {\r\n        this.grid.render(this.scene);\r\n        this.debug.render(this.scene);\r\n        for (let i = 0; i < 32; i++) {\r\n            this.circles[i].render(this.scene);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/util-apps/mic-app.ts?");

/***/ }),

/***/ "./src/apps/util-apps/obj-loader-app.ts":
/*!**********************************************!*\
  !*** ./src/apps/util-apps/obj-loader-app.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjLoaderApp\": () => (/* binding */ ObjLoaderApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/texture-mesh-shader */ \"../engine/src/render/shaders-old/texture-mesh-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// name:    obj-loader-app.ts\r\n// author:  Jos Feenstra\r\n// purpose: drag an obj to the canvas, and view it on the web\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\nclass ObjLoaderApp extends Geon__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        let canvas = gl.canvas;\r\n        this.dr = Geon__WEBPACK_IMPORTED_MODULE_1__.DebugRenderer.new(gl);\r\n        this.tr = Engine_render_shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_0__.TextureMeshShader.new(gl);\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_1__.Camera(canvas, undefined, true);\r\n        (0,Geon__WEBPACK_IMPORTED_MODULE_1__.addDropFileEventListeners)(canvas, processFiles.bind(this));\r\n    }\r\n    start() {\r\n        // nothing\r\n    }\r\n    update(input) {\r\n        // move the camera with the mouse\r\n        this.camera.update(input);\r\n    }\r\n    draw() {\r\n        // get to-screen matrix\r\n        let c = new Geon__WEBPACK_IMPORTED_MODULE_1__.Scene(this.camera);\r\n        this.dr.render(c);\r\n        this.tr.render(c);\r\n        // if (this.obj == undefined)\r\n        //     this.dotRenderer.setAndRender(\r\n        //         MultiVector3.fromList([new Vector3(0, 0, 0), new Vector3(1, 1, 1)]),\r\n        //         c,\r\n        //     );\r\n        // else {\r\n        //     this.dotRenderer.setAndRender(this.obj!.mesh.verts, c);\r\n        //     // this.meshRenderer.render(gl, matrix);\r\n        //     this.lineRenderer.render(c);\r\n        // }\r\n    }\r\n}\r\nfunction processFiles(files) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // assume its 1 file, the obj file.\r\n        let objFile;\r\n        let textureFile;\r\n        for (let file of files) {\r\n            if (file.name.includes(\".obj\")) {\r\n                objFile = file;\r\n            }\r\n            else if (file.name.includes(\".jpg\") || file.name.includes(\".png\")) {\r\n                textureFile = file;\r\n            }\r\n            else {\r\n                console.warn(`dont know what to do with file: [${file.name}]`);\r\n            }\r\n        }\r\n        if (!objFile) {\r\n            alert(\"no obj found\");\r\n            return;\r\n        }\r\n        // see if we can build an correct obj from the files\r\n        let objString = yield (0,Geon__WEBPACK_IMPORTED_MODULE_1__.loadTextFromFile)(objFile);\r\n        let model = (0,Geon__WEBPACK_IMPORTED_MODULE_1__.meshFromObj)(objString);\r\n        // this.lines = MultiLine.fromMesh(this.obj);\r\n        // scale the vertices\r\n        let bounds = Geon__WEBPACK_IMPORTED_MODULE_1__.Domain3.fromInclude(model.mesh.verts);\r\n        let factor = 1 / bounds.size().largestValue();\r\n        model.mesh.verts.scale(Geon__WEBPACK_IMPORTED_MODULE_1__.Vector3.new(factor, factor, factor));\r\n        // set\r\n        if (textureFile) {\r\n            console.log(\"flipping texture\");\r\n            let texture = yield (0,Geon__WEBPACK_IMPORTED_MODULE_1__.loadImageFromFile)(textureFile);\r\n            texture = Geon__WEBPACK_IMPORTED_MODULE_1__.Bitmap.fromImageData(texture).flipVer().toImageData();\r\n            model.setTexture(texture);\r\n            console.log(\"done flipping\");\r\n            this.tr.set(model, Geon__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw);\r\n        }\r\n        else {\r\n            this.dr.set(model.mesh);\r\n        }\r\n        console.log(\"done!\");\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/util-apps/obj-loader-app.ts?");

/***/ }),

/***/ "./src/apps/util-apps/renderer-app.ts":
/*!********************************************!*\
  !*** ./src/apps/util-apps/renderer-app.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiRendererApp\": () => (/* binding */ MultiRendererApp)\n/* harmony export */ });\n/* harmony import */ var Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Engine/render/shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var Engine_render_shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! Engine/render/shaders-old/texture-mesh-shader */ \"../engine/src/render/shaders-old/texture-mesh-shader.ts\");\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n// purpose: demonstrate new renderer capabilities\r\n\r\n\r\n\r\nclass MultiRendererApp extends Geon__WEBPACK_IMPORTED_MODULE_2__.App {\r\n    constructor(gl) {\r\n        super(gl);\r\n        // ui\r\n        this.params = [];\r\n        // setup the render environment \r\n        let canvas = gl.canvas;\r\n        this.camera = new Geon__WEBPACK_IMPORTED_MODULE_2__.Camera(canvas, -2, true);\r\n        this.camera.set(-2, 1, 1);\r\n        this.gs = new Engine_render_shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_0__.LineShader(gl, [0.3, 0.3, 0.3, 1]);\r\n        this.mr = Geon__WEBPACK_IMPORTED_MODULE_2__.DebugRenderer.new(gl);\r\n        this.tms = Engine_render_shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_1__.TextureMeshShader.new(gl);\r\n    }\r\n    start() {\r\n        this.startGrid();\r\n        this.rng = Geon__WEBPACK_IMPORTED_MODULE_2__.Random.fromSeed(10394);\r\n        // render a bunch of dots\r\n        this.points = Geon__WEBPACK_IMPORTED_MODULE_2__.Domain3.fromRadius(10).populate(100, this.rng);\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.Domain3.fromRadius(10).populate(100, this.rng), \"dots2\", 10, [0, 1, 0, 1]);\r\n        this.mr.set(this.points, \"dots\", 10, [1, 0, 0, 1]);\r\n        // render vectors \r\n        this.points.forEach(v => v.add(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.fromRandomUnit(this.rng)));\r\n        // three images\r\n        let w = 8;\r\n        let h = 8;\r\n        let img = Geon__WEBPACK_IMPORTED_MODULE_2__.Bitmap.new(w, h);\r\n        img.forEach((x, y) => { return [Math.random() * 255, y, 255, 1]; });\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.ImageMesh.new(img, Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldYZ().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(4, 0, 0))), \"image1\");\r\n        img.forEach((x, y) => { return [255, Math.random() * 255, 255, 1]; });\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.ImageMesh.new(img, Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldYZ().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(-4, 0, 0)), 1), \"image2\");\r\n        img.forEach((x, y) => { return [255, 255, Math.random() * 255, 1]; });\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.ImageMesh.new(img, Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXZ().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(0, 4, 0)), 1), \"image3\");\r\n        img.forEach((x, y) => { return [Math.random() * 255, y, 255, 1]; });\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.ImageMesh.new(img, Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXZ().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(0, -4, 0)), 1), \"image4\");\r\n        img.forEach((x, y) => { return [255, Math.random() * 255, 255, 1]; });\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.ImageMesh.new(img, Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(0, 0, 4)), 1), \"image5\");\r\n        img.forEach((x, y) => { return [255, 255, Math.random() * 255, 1]; });\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.ImageMesh.new(img, Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY().moveTo(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.new(0, 0, -4)), 1), \"image6\");\r\n        // render a line\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.Polyline.new(this.points));\r\n        this.mr.set(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXZ().moveTo(this.points.get(0)), \"plane\");\r\n        // render a plane at each point\r\n        // this.points.forEach(v => this.mr.set(Plane.WorldXZ().moveTo(v)));\r\n        this.mr.addUi(this.interface);\r\n    }\r\n    ui(ui) {\r\n        this.interface = ui;\r\n    }\r\n    startGrid() {\r\n        let grid = Geon__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromGrid(Geon__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY().moveTo(new Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -1)), 100, 2);\r\n        this.gs.set(grid, Geon__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw);\r\n    }\r\n    update(input) {\r\n        this.camera.update(input);\r\n        this.points.forEach(v => v.add(Geon__WEBPACK_IMPORTED_MODULE_2__.Vector3.fromRandomUnit(this.rng)));\r\n        this.mr.set(this.points, \"dots\");\r\n    }\r\n    draw() {\r\n        let scene = new Geon__WEBPACK_IMPORTED_MODULE_2__.Scene(this.camera);\r\n        this.gs.render(scene);\r\n        this.mr.render(scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/./src/apps/util-apps/renderer-app.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var Geon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Geon */ \"../engine/src/lib.ts\");\n/* harmony import */ var _apps_geometry_apps_bezier_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./apps/geometry-apps/bezier-app */ \"./src/apps/geometry-apps/bezier-app.ts\");\n/* harmony import */ var _apps_geometry_apps_bezier_cp_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./apps/geometry-apps/bezier-cp-app */ \"./src/apps/geometry-apps/bezier-cp-app.ts\");\n/* harmony import */ var _apps_geometry_apps_icosahedron_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./apps/geometry-apps/icosahedron-app */ \"./src/apps/geometry-apps/icosahedron-app.ts\");\n/* harmony import */ var _apps_geometry_apps_loft_app__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./apps/geometry-apps/loft-app */ \"./src/apps/geometry-apps/loft-app.ts\");\n/* harmony import */ var _apps_geometry_apps_spline_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./apps/geometry-apps/spline.app */ \"./src/apps/geometry-apps/spline.app.ts\");\n/* harmony import */ var _apps_geometry_apps_surface_app__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./apps/geometry-apps/surface-app */ \"./src/apps/geometry-apps/surface-app.ts\");\n/* harmony import */ var _apps_geometry_apps_surface_cp_app__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./apps/geometry-apps/surface-cp-app */ \"./src/apps/geometry-apps/surface-cp-app.ts\");\n/* harmony import */ var _apps_math_apps_least_squares_app__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./apps/math-apps/least-squares-app */ \"./src/apps/math-apps/least-squares-app.ts\");\n/* harmony import */ var _apps_math_apps_perlin_app__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./apps/math-apps/perlin-app */ \"./src/apps/math-apps/perlin-app.ts\");\n/* harmony import */ var _apps_render_apps_billboard_app__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./apps/render-apps/billboard-app */ \"./src/apps/render-apps/billboard-app.ts\");\n/* harmony import */ var _apps_render_apps_dot_app3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./apps/render-apps/dot-app3 */ \"./src/apps/render-apps/dot-app3.ts\");\n/* harmony import */ var _apps_spherical_apps_spherical_one_app__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./apps/spherical-apps/spherical-one-app */ \"./src/apps/spherical-apps/spherical-one-app.ts\");\n/* harmony import */ var _apps_spherical_apps_spherical_three_app__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./apps/spherical-apps/spherical-three-app */ \"./src/apps/spherical-apps/spherical-three-app.ts\");\n/* harmony import */ var _apps_render_apps_mesh_inspector_app__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./apps/render-apps/mesh-inspector-app */ \"./src/apps/render-apps/mesh-inspector-app.ts\");\n/* harmony import */ var _apps_util_apps_obj_loader_app__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./apps/util-apps/obj-loader-app */ \"./src/apps/util-apps/obj-loader-app.ts\");\n/* harmony import */ var _apps_util_apps_renderer_app__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./apps/util-apps/renderer-app */ \"./src/apps/util-apps/renderer-app.ts\");\n/* harmony import */ var _apps_render_apps_phong_app__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./apps/render-apps/phong-app */ \"./src/apps/render-apps/phong-app.ts\");\n/* harmony import */ var _apps_render_apps_cubes_phong_app__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./apps/render-apps/cubes-phong-app */ \"./src/apps/render-apps/cubes-phong-app.ts\");\n/* harmony import */ var _apps_render_apps_zebra_app__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./apps/render-apps/zebra-app */ \"./src/apps/render-apps/zebra-app.ts\");\n/* harmony import */ var _apps_geometry_apps_torus_app__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./apps/geometry-apps/torus-app */ \"./src/apps/geometry-apps/torus-app.ts\");\n/* harmony import */ var _apps_scientific_apps_canny_app__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./apps/scientific-apps/canny-app */ \"./src/apps/scientific-apps/canny-app.ts\");\n/* harmony import */ var _apps_render_apps_draw_target_app__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./apps/render-apps/draw-target-app */ \"./src/apps/render-apps/draw-target-app.ts\");\n/* harmony import */ var _apps_math_apps_least_squares_circle_app__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./apps/math-apps/least-squares-circle-app */ \"./src/apps/math-apps/least-squares-circle-app.ts\");\n/* harmony import */ var _apps_render_apps_skybox_app__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./apps/render-apps/skybox-app */ \"./src/apps/render-apps/skybox-app.ts\");\n/* harmony import */ var _apps_spherical_apps_spherical_app__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./apps/spherical-apps/spherical-app */ \"./src/apps/spherical-apps/spherical-app.ts\");\n/* harmony import */ var _apps_algo_apps_marching_app__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./apps/algo-apps/marching-app */ \"./src/apps/algo-apps/marching-app.ts\");\n/* harmony import */ var _apps_util_apps_mic_app__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./apps/util-apps/mic-app */ \"./src/apps/util-apps/mic-app.ts\");\n/* harmony import */ var _apps_algo_apps_wave_app__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./apps/algo-apps/wave-app */ \"./src/apps/algo-apps/wave-app.ts\");\n/* harmony import */ var _apps_spherical_apps_spherical_noise__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./apps/spherical-apps/spherical-noise */ \"./src/apps/spherical-apps/spherical-noise.ts\");\n// Name:    index.ts\r\n// Author:  Jos Feenstra\r\n// Purpose: Entry point\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction main() {\r\n    // get references of all items on the canvas\r\n    let canvas = document.getElementById(\"canvas\");\r\n    let ui = document.getElementById(\"interface\");\r\n    // init core\r\n    let gl = Geon__WEBPACK_IMPORTED_MODULE_0__.HelpGl.initWebglContext(canvas);\r\n    let core = new Geon__WEBPACK_IMPORTED_MODULE_0__.Core(canvas, gl, ui);\r\n    Geon__WEBPACK_IMPORTED_MODULE_0__.HelpGl.resizeViewportToCanvas(gl);\r\n    //@ts-ignore\r\n    window.core = core;\r\n    // init swap app\r\n    let appCollection = [\r\n        _apps_spherical_apps_spherical_noise__WEBPACK_IMPORTED_MODULE_29__.SphericalNoise,\r\n        _apps_algo_apps_wave_app__WEBPACK_IMPORTED_MODULE_28__.WaveApp,\r\n        _apps_util_apps_mic_app__WEBPACK_IMPORTED_MODULE_27__.MicApp,\r\n        _apps_algo_apps_marching_app__WEBPACK_IMPORTED_MODULE_26__.MarchingCubeApp,\r\n        _apps_render_apps_skybox_app__WEBPACK_IMPORTED_MODULE_24__.SkyboxApp,\r\n        _apps_math_apps_least_squares_circle_app__WEBPACK_IMPORTED_MODULE_23__.LeastSquaresCircleApp,\r\n        _apps_render_apps_draw_target_app__WEBPACK_IMPORTED_MODULE_22__.DrawTargetApp,\r\n        _apps_scientific_apps_canny_app__WEBPACK_IMPORTED_MODULE_21__.CannyApp,\r\n        _apps_geometry_apps_torus_app__WEBPACK_IMPORTED_MODULE_20__.TorusApp,\r\n        _apps_render_apps_zebra_app__WEBPACK_IMPORTED_MODULE_19__.ZebraApp,\r\n        _apps_render_apps_cubes_phong_app__WEBPACK_IMPORTED_MODULE_18__.CubesPhongApp,\r\n        _apps_render_apps_phong_app__WEBPACK_IMPORTED_MODULE_17__.PhongApp,\r\n        _apps_util_apps_renderer_app__WEBPACK_IMPORTED_MODULE_16__.MultiRendererApp,\r\n        _apps_render_apps_billboard_app__WEBPACK_IMPORTED_MODULE_10__.BillboardApp,\r\n        _apps_math_apps_perlin_app__WEBPACK_IMPORTED_MODULE_9__.PerlinApp,\r\n        _apps_geometry_apps_surface_app__WEBPACK_IMPORTED_MODULE_6__.SurfaceApp,\r\n        _apps_geometry_apps_bezier_app__WEBPACK_IMPORTED_MODULE_1__.BezierApp,\r\n        _apps_geometry_apps_bezier_cp_app__WEBPACK_IMPORTED_MODULE_2__.BezierCpApp,\r\n        _apps_geometry_apps_surface_cp_app__WEBPACK_IMPORTED_MODULE_7__.SurfaceCpApp,\r\n        _apps_geometry_apps_spline_app__WEBPACK_IMPORTED_MODULE_5__.SplineApp,\r\n        _apps_geometry_apps_loft_app__WEBPACK_IMPORTED_MODULE_4__.LoftApp,\r\n        _apps_spherical_apps_spherical_app__WEBPACK_IMPORTED_MODULE_25__.SphericalApp,\r\n        _apps_spherical_apps_spherical_three_app__WEBPACK_IMPORTED_MODULE_13__.SphericalThreeApp,\r\n        // SphericalTwoApp, // I broke this...\r\n        _apps_spherical_apps_spherical_one_app__WEBPACK_IMPORTED_MODULE_12__.SphericalOneApp,\r\n        _apps_geometry_apps_icosahedron_app__WEBPACK_IMPORTED_MODULE_3__.IcosahedronApp,\r\n        _apps_render_apps_dot_app3__WEBPACK_IMPORTED_MODULE_11__.DotApp3,\r\n        _apps_math_apps_least_squares_app__WEBPACK_IMPORTED_MODULE_8__.LeastSquaresApp,\r\n        _apps_render_apps_mesh_inspector_app__WEBPACK_IMPORTED_MODULE_14__.MeshInspectorApp,\r\n        _apps_util_apps_obj_loader_app__WEBPACK_IMPORTED_MODULE_15__.ObjLoaderApp,\r\n    ];\r\n    let swapApp = new Geon__WEBPACK_IMPORTED_MODULE_0__.SwapApp(gl, core, appCollection);\r\n    core.addApp(swapApp);\r\n    // check if the hash matches one of the app names, if so, switch to that app. if not, goto the default start app.\r\n    let defaultIndex = 0;\r\n    swapApp.swapFromUrl(location.hash, defaultIndex);\r\n    // time\r\n    let accumulated = 0;\r\n    let counter = Geon__WEBPACK_IMPORTED_MODULE_0__.FpsCounter.new();\r\n    // infinite loop\r\n    function loop(elapsed) {\r\n        let dt = elapsed - accumulated;\r\n        accumulated = elapsed;\r\n        counter._update(dt);\r\n        document.title = \"fps: \" + counter.getFps();\r\n        core.update(dt);\r\n        core.draw();\r\n        requestAnimationFrame(loop);\r\n    }\r\n    requestAnimationFrame(loop);\r\n}\r\nwindow.addEventListener(\"load\", main, false);\r\n\n\n//# sourceURL=webpack://geon-demo/./src/index.ts?");

/***/ }),

/***/ "../engine/src/algorithms/MarchingCubes.ts":
/*!*************************************************!*\
  !*** ../engine/src/algorithms/MarchingCubes.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"marchingCubes\": () => (/* binding */ marchingCubes)\n/* harmony export */ });\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n// name:    marching-cubes.ts\r\n// author:  Jos Feenstra\r\n// purpose: a marching cubes implementation useful for converting scalar discrete fields to contours\r\n\r\n// based upon:\r\n// http://paulbourke.net/geometry/polygonise/\r\n// Polygonising a scalar field\r\n// Also known as: \"3D Contouring\", \"Marching Cubes\", \"Surface Reconstruction\"\r\n// Written by Paul Bourke\r\n// May 1994\r\n//\r\n//\r\n// The cube model used:\r\n//\r\n//     (4) ------ 4 ------ (5)\r\n//     /|                  /|\r\n//    7 |                 5 |\r\n//   /  |                /  |\r\n// (7) ------ 6 ------ (6)  |\r\n//  |   8               |   9\r\n//  |   |               |   |\r\n//  |   |               |   |\r\n//  |  (0) ------ 0 ------ (1)\r\n//  11 /               10  /\r\n//  | 3                 | 1\r\n//  |/                  |/\r\n// (3) ------ 2 ------ (2)\r\n/*\r\n    Given a grid cell and an isolevel, calculate the triangular\r\n    facets required to represent the isosurface through the cell.\r\n    Return the number of triangular facets, the array \"triangles\"\r\n    will be loaded up with the vertices at most 5 triangular facets.\r\n     0 will be returned if the grid cell is either totally above\r\n    of totally below the isolevel.\r\n */\r\n// typedef struct {\r\n//     XYZ p[3];\r\n//  } TRIANGLE;\r\n//  typedef struct {\r\n//     XYZ p[8];\r\n//     double val[8];\r\n//  } GRIDCELL;\r\nclass Gridcell {\r\n    constructor() {\r\n        this.points = []; // 8\r\n        this.corner = []; // 8\r\n    }\r\n}\r\nclass Triangle {\r\n    constructor() {\r\n        this.xyz = []; // 3\r\n    }\r\n}\r\nconst edgeTable = [\r\n    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03,\r\n    0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96,\r\n    0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35,\r\n    0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,\r\n    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f,\r\n    0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3,\r\n    0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650,\r\n    0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859,\r\n    0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca,\r\n    0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf,\r\n    0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,\r\n    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff,\r\n    0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a,\r\n    0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9,\r\n    0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,\r\n    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33,\r\n    0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f,\r\n    0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c,\r\n    0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0,\r\n];\r\nconst triTable = [\r\n    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],\r\n    [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],\r\n    [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],\r\n    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],\r\n    [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],\r\n    [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],\r\n    [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],\r\n    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],\r\n    [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],\r\n    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],\r\n    [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],\r\n    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],\r\n    [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],\r\n    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],\r\n    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],\r\n    [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],\r\n    [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],\r\n    [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],\r\n    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],\r\n    [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],\r\n    [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],\r\n    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],\r\n    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],\r\n    [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],\r\n    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],\r\n    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],\r\n    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],\r\n    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],\r\n    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],\r\n    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],\r\n    [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],\r\n    [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],\r\n    [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],\r\n    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],\r\n    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],\r\n    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],\r\n    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],\r\n    [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],\r\n    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],\r\n    [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],\r\n    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],\r\n    [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],\r\n    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],\r\n    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],\r\n    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],\r\n    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],\r\n    [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],\r\n    [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],\r\n    [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],\r\n    [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],\r\n    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],\r\n    [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],\r\n    [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],\r\n    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],\r\n    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],\r\n    [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],\r\n    [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],\r\n    [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],\r\n    [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],\r\n    [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],\r\n    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],\r\n    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],\r\n    [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],\r\n    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],\r\n    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],\r\n    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],\r\n    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],\r\n    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],\r\n    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],\r\n    [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],\r\n    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],\r\n    [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],\r\n    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],\r\n    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],\r\n    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],\r\n    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],\r\n    [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],\r\n    [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],\r\n    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],\r\n    [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],\r\n    [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],\r\n    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],\r\n    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],\r\n    [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],\r\n    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],\r\n    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],\r\n    [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],\r\n    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],\r\n    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],\r\n    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],\r\n    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],\r\n    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],\r\n    [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],\r\n    [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],\r\n    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],\r\n    [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],\r\n    [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],\r\n    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],\r\n    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],\r\n    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],\r\n    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],\r\n    [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],\r\n    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],\r\n    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],\r\n    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],\r\n    [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],\r\n    [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],\r\n    [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],\r\n    [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n];\r\nfunction marchingCubes(corners, values, level) {\r\n    // get the marching cube index based on corners\r\n    let cubeindex = 0;\r\n    if (values[0] < level)\r\n        cubeindex |= 1;\r\n    if (values[1] < level)\r\n        cubeindex |= 2;\r\n    if (values[2] < level)\r\n        cubeindex |= 4;\r\n    if (values[3] < level)\r\n        cubeindex |= 8;\r\n    if (values[4] < level)\r\n        cubeindex |= 16;\r\n    if (values[5] < level)\r\n        cubeindex |= 32;\r\n    if (values[6] < level)\r\n        cubeindex |= 64;\r\n    if (values[7] < level)\r\n        cubeindex |= 128;\r\n    // early out\r\n    if (edgeTable[cubeindex] == 0)\r\n        return [];\r\n    let vertlist = []; // 12\r\n    /* Find the vertices where the surface intersects the cube */\r\n    if (edgeTable[cubeindex] & 1)\r\n        vertlist[0] = lerp(level, corners[0], corners[1], values[0], values[1]);\r\n    if (edgeTable[cubeindex] & 2)\r\n        vertlist[1] = lerp(level, corners[1], corners[2], values[1], values[2]);\r\n    if (edgeTable[cubeindex] & 4)\r\n        vertlist[2] = lerp(level, corners[2], corners[3], values[2], values[3]);\r\n    if (edgeTable[cubeindex] & 8)\r\n        vertlist[3] = lerp(level, corners[3], corners[0], values[3], values[0]);\r\n    if (edgeTable[cubeindex] & 16)\r\n        vertlist[4] = lerp(level, corners[4], corners[5], values[4], values[5]);\r\n    if (edgeTable[cubeindex] & 32)\r\n        vertlist[5] = lerp(level, corners[5], corners[6], values[5], values[6]);\r\n    if (edgeTable[cubeindex] & 64)\r\n        vertlist[6] = lerp(level, corners[6], corners[7], values[6], values[7]);\r\n    if (edgeTable[cubeindex] & 128)\r\n        vertlist[7] = lerp(level, corners[7], corners[4], values[7], values[4]);\r\n    if (edgeTable[cubeindex] & 256)\r\n        vertlist[8] = lerp(level, corners[0], corners[4], values[0], values[4]);\r\n    if (edgeTable[cubeindex] & 512)\r\n        vertlist[9] = lerp(level, corners[1], corners[5], values[1], values[5]);\r\n    if (edgeTable[cubeindex] & 1024)\r\n        vertlist[10] = lerp(level, corners[2], corners[6], values[2], values[6]);\r\n    if (edgeTable[cubeindex] & 2048)\r\n        vertlist[11] = lerp(level, corners[3], corners[7], values[3], values[7]);\r\n    // create triangles\r\n    let triangles = [];\r\n    let triangleIds = triTable[cubeindex];\r\n    for (let i = 0; triangleIds[i] != -1; i++) {\r\n        triangles.push(vertlist[triangleIds[i]]);\r\n    }\r\n    // return(ntriang);\r\n    return triangles;\r\n}\r\n/*\r\n    Linearly interpolate the position where an isosurface cuts\r\n    an edge between two vertices, each with their own scalar value\r\n */\r\nfunction lerp(level, p1, p2, valp1, valp2) {\r\n    return _math_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromLerpWeights(p1, p2, valp1, valp2, level);\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/algorithms/MarchingCubes.ts?");

/***/ }),

/***/ "../engine/src/algorithms/Perlin.ts":
/*!******************************************!*\
  !*** ../engine/src/algorithms/Perlin.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Perlin\": () => (/* binding */ Perlin)\n/* harmony export */ });\n/* harmony import */ var _math_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Math */ \"../engine/src/math/Math.ts\");\n// name:        perlin-noise.ts\r\n// author:      Jos Feenstra\r\n// purpose:     Generate Perin Noise\r\n\r\n// a javascript implementation of:\r\n// Ref : https://adrianb.io/2014/08/09/perlinnoise.html\r\n// Hash lookup table as defined by Ken Perlin.  This is a randomly\r\n// arranged array of all numbers from 0-255 inclusive.\r\nclass Perlin {\r\n    constructor() {\r\n        this.permutation = [\r\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69,\r\n            142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252,\r\n            219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168,\r\n            68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211,\r\n            133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80,\r\n            73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100,\r\n            109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82,\r\n            85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248,\r\n            152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,\r\n            108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238,\r\n            210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31,\r\n            181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205,\r\n            93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,\r\n        ];\r\n        this.repeat = 0;\r\n        this.repeat = 0;\r\n        this.p = new Array(512);\r\n        for (let x = 0; x < 512; x++) {\r\n            this.p[x] = this.permutation[x % 256];\r\n        }\r\n    }\r\n    static new() {\r\n        return new Perlin();\r\n    }\r\n    grad(hash, x, y, z) {\r\n        switch (hash & 0xf) {\r\n            case 0x0:\r\n                return x + y;\r\n            case 0x1:\r\n                return -x + y;\r\n            case 0x2:\r\n                return x - y;\r\n            case 0x3:\r\n                return -x - y;\r\n            case 0x4:\r\n                return x + z;\r\n            case 0x5:\r\n                return -x + z;\r\n            case 0x6:\r\n                return x - z;\r\n            case 0x7:\r\n                return -x - z;\r\n            case 0x8:\r\n                return y + z;\r\n            case 0x9:\r\n                return -y + z;\r\n            case 0xa:\r\n                return y - z;\r\n            case 0xb:\r\n                return -y - z;\r\n            case 0xc:\r\n                return y + x;\r\n            case 0xd:\r\n                return -y + z;\r\n            case 0xe:\r\n                return y - x;\r\n            case 0xf:\r\n                return -y - z;\r\n            default:\r\n                return 0; // never happens\r\n        }\r\n    }\r\n    inc(num) {\r\n        num++;\r\n        if (this.repeat > 0)\r\n            num %= this.repeat;\r\n        return num;\r\n    }\r\n    leveledNoise() {\r\n        // input 0.2, 0.5, 0.8,\r\n        // bouw plateaus op deze hoogtes\r\n        // \r\n    }\r\n    octaveNoise(x, y, z, offset = 1, frequency = 1, amplitude = 1, octaves = 1, octaveBlend = 0.5) {\r\n        let total = 0;\r\n        let maxValue = 0;\r\n        for (let i = 0; i < octaves; i++) {\r\n            total += this.noise(x * frequency + offset, y * frequency + offset, z * frequency + offset) * amplitude;\r\n            maxValue += amplitude;\r\n            amplitude *= octaveBlend;\r\n            frequency *= 2;\r\n        }\r\n        return total / maxValue;\r\n    }\r\n    noise(x, y, z) {\r\n        // If we have any repeat on, change the coordinates to their \"local\" repetitions\r\n        if (this.repeat > 0) {\r\n            x = x % this.repeat;\r\n            y = y % this.repeat;\r\n            z = z % this.repeat;\r\n        }\r\n        let xi = Math.floor(x) & 255; // Calculate the \"unit cube\" that the point asked will be located in\r\n        let yi = Math.floor(y) & 255; // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\r\n        let zi = Math.floor(z) & 255; // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\r\n        let xf = x - Math.floor(x);\r\n        let yf = y - Math.floor(y);\r\n        let zf = z - Math.floor(z);\r\n        let p = this.p;\r\n        let aaa = p[p[p[xi] + yi] + zi];\r\n        let aba = p[p[p[xi] + this.inc(yi)] + zi];\r\n        let aab = p[p[p[xi] + yi] + this.inc(zi)];\r\n        let abb = p[p[p[xi] + this.inc(yi)] + this.inc(zi)];\r\n        let baa = p[p[p[this.inc(xi)] + yi] + zi];\r\n        let bba = p[p[p[this.inc(xi)] + this.inc(yi)] + zi];\r\n        let bab = p[p[p[this.inc(xi)] + yi] + this.inc(zi)];\r\n        let bbb = p[p[p[this.inc(xi)] + this.inc(yi)] + this.inc(zi)];\r\n        let u = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.smooth(xf);\r\n        let v = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.smooth(yf);\r\n        let w = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.smooth(zf);\r\n        let x1, x2, y1, y2;\r\n        x1 = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(aaa, xf, yf, zf), // The gradient function calculates the dot product between a pseudorandom\r\n        this.grad(baa, xf - 1, yf, zf), // gradient vector and the vector from the input coordinate to the 8\r\n        u); // surrounding points in its unit cube.\r\n        x2 = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(aba, xf, yf - 1, zf), // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\r\n        this.grad(bba, xf - 1, yf - 1, zf), // values we made earlier.\r\n        u);\r\n        y1 = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(x1, x2, v);\r\n        x1 = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(aab, xf, yf, zf - 1), this.grad(bab, xf - 1, yf, zf - 1), u);\r\n        x2 = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(abb, xf, yf - 1, zf - 1), this.grad(bbb, xf - 1, yf - 1, zf - 1), u);\r\n        y2 = _math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(x1, x2, v);\r\n        return (_math_Math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(y1, y2, w) + 1) / 2;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/algorithms/Perlin.ts?");

/***/ }),

/***/ "../engine/src/algorithms/TileAtlas.ts":
/*!*********************************************!*\
  !*** ../engine/src/algorithms/TileAtlas.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TileAtlas\": () => (/* binding */ TileAtlas),\n/* harmony export */   \"doImagesOverlap\": () => (/* binding */ doImagesOverlap)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Directions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Directions */ \"../engine/src/math/Directions.ts\");\n\r\n\r\n/**\r\n * Contains all tiles, and connectivity data between different tiles\r\n *\r\n * TODO create an interface for making this work with meshes and stuff\r\n */\r\nclass TileAtlas {\r\n    constructor(tiles, prototypes, connections, connectionHash) {\r\n        this.tiles = tiles;\r\n        this.prototypes = prototypes;\r\n        this.connections = connections;\r\n        this.connectionHash = connectionHash;\r\n    }\r\n    static fromPeriodicSourceImage(input, kernelSize) {\r\n        // generate tiles themselves from the source image \r\n        let tiles = [];\r\n        let weights = [];\r\n        let total = 0;\r\n        for (let y = 0; y < input.height; y++) {\r\n            for (let x = 0; x < input.width; x++) {\r\n                // trim periodically, so that the tile pattern will be repeated\r\n                let tile = input.periodicTrim(x, y, x + kernelSize, y + kernelSize);\r\n                // for (let tile of [cutout, cutout.rot90(), cutout.rot180(), cutout.rot270()]) {\r\n                let overlapTileId = tiles.findIndex(((t) => doImagesOverlap(t, tile)));\r\n                if (overlapTileId == -1) {\r\n                    weights.push(1);\r\n                    tiles.push(tile);\r\n                }\r\n                else {\r\n                    weights[overlapTileId] += 1;\r\n                }\r\n                total += 1;\r\n                // }\r\n            }\r\n        }\r\n        // generate prototypes\r\n        let prototypes = [];\r\n        for (let i = 0; i < tiles.length; i++) {\r\n            prototypes.push({ tile: i, rotation: 0, mirrored: false, probability: weights[i] / total });\r\n        }\r\n        // calculate connections based on correct image overlap\r\n        let connections = [];\r\n        for (let i = 0; i < prototypes.length; i++) {\r\n            let tileA = tiles[prototypes[i].tile];\r\n            for (let j = 0; j < prototypes.length; j++) {\r\n                // if (i == j) continue;\r\n                if (i > j)\r\n                    continue; // dont do double checks, we dont need to\r\n                let tileB = tiles[prototypes[j].tile];\r\n                for (let dir of _math_Directions__WEBPACK_IMPORTED_MODULE_1__.Direction.Eight) {\r\n                    let offset = _math_Directions__WEBPACK_IMPORTED_MODULE_1__.Direction.D8ToVector(dir);\r\n                    if (doImagesOverlap(tileA, tileB, offset)) {\r\n                        connections.push({ from: i, to: j, dir });\r\n                        connections.push({ from: j, to: i, dir: _math_Directions__WEBPACK_IMPORTED_MODULE_1__.Direction.opposite(dir) });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // because js is stupid and has no tuple set, we need to to the hashing by calling json.stringify...\r\n        let connectionHash = new Set();\r\n        for (let con of connections) {\r\n            connectionHash.add(JSON.stringify(con));\r\n        }\r\n        return new TileAtlas(tiles, prototypes, connections, connectionHash);\r\n    }\r\n    // static fromSourceImageBetter(input: Bitmap, kernelSize: number) {\r\n    //     // generate tiles themselves from the source image \r\n    //     let tiles: Bitmap[] = [];\r\n    //     let tileOGID = new Array<number>();\r\n    //     let idMapper = new Map<number, number>();\r\n    //     let frequency = new Array<number>();\r\n    //     let frequencies: number[] = [];\r\n    //     let i = 0;\r\n    //     for (let y = 0; y < input.height; y++) {\r\n    //         for (let x = 0; x < input.width; x++) {\r\n    //             // trim periodically, so that the tile pattern will be repeated\r\n    //             let tile = input.periodicTrim(x, y, x + kernelSize, y + kernelSize);\r\n    //             // // deal with indices\r\n    //             // let overlapTileId = tiles.findIndex(((tile) => doImagesOverlap(tile, tile)));\r\n    //             // let index;\r\n    //             // if (overlapTileId == -1) {\r\n    //             //     // new tile\r\n    //             //     index = tiles.length;\r\n    //             //     tiles.push(tile);\r\n    //             //     frequencies.push(1);\r\n    //             //     idMapper.set(i, i);\r\n    //             // } else {\r\n    //             //     // existing tile \r\n    //             //     // increase frequency, and add an index to point back to this other tile\r\n    //             //     index = overlapTileId\r\n    //             //     frequencies[overlapTileId] += 1;\r\n    //             // }\r\n    //             // idMapper.set(i, index);\r\n    //             // i++\r\n    //             // deal with connections\r\n    //             for (let dir of Direction.Four) {\r\n    //                 let offset = Direction.D8ToVector(dir);\r\n    //                 // nbIndex = \r\n    //                 // if (doImagesOverlap(tileA, tileB, offset)) {\r\n    //                 //     connections.push({from: i, to: j, dir});\r\n    //                 //     connections.push({from: j, to: i, dir: Direction.opposite(dir)});\r\n    //                 // }\r\n    //             }\r\n    //         }\r\n    //     }\r\n    //     console.log(idMapper);\r\n    //     let prototypes = new Array<Prototype>();\r\n    //     let connections = new Array<Connection>();\r\n    //     let connectionHash = new Set<string>();\r\n    //     for (let con of connections) {\r\n    //         connectionHash.add(JSON.stringify(con));\r\n    //     }\r\n    //     return new TileAtlas(tiles, prototypes, connections, connectionHash)\r\n    // }\r\n    getConcatConnections(ptts) {\r\n        let data = {};\r\n        for (let dir of _math_Directions__WEBPACK_IMPORTED_MODULE_1__.Direction.Four) {\r\n            data[_math_Directions__WEBPACK_IMPORTED_MODULE_1__.D8[dir]] = [];\r\n        }\r\n        for (let con of this.connections) {\r\n            if (ptts.includes(con.from)) {\r\n                if (!data[_math_Directions__WEBPACK_IMPORTED_MODULE_1__.D8[con.dir]].includes(con.to)) {\r\n                    data[_math_Directions__WEBPACK_IMPORTED_MODULE_1__.D8[con.dir]].push(con.to);\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    printConcatConnections(ptts) {\r\n        console.log(\"connections of tiles \", ptts, \":\");\r\n        console.log(this.getConcatConnections(ptts));\r\n    }\r\n    printConnections(ptt) {\r\n        console.log(\"connections of tile \", ptt, \":\");\r\n        let data = {};\r\n        for (let dir of _math_Directions__WEBPACK_IMPORTED_MODULE_1__.Direction.Four) {\r\n            data[_math_Directions__WEBPACK_IMPORTED_MODULE_1__.D8[dir]] = [];\r\n        }\r\n        for (let con of this.connections) {\r\n            if (con.from == ptt) {\r\n                // console.log(con);\r\n                data[_math_Directions__WEBPACK_IMPORTED_MODULE_1__.D8[con.dir]].push(con.to);\r\n            }\r\n        }\r\n        console.log(data);\r\n    }\r\n    /**\r\n     * ask if 'to', which is to the 'dir' of 'from', is allowed to be there, due to connectivity constraints\r\n     */\r\n    canBeConnected(from, to, dir) {\r\n        return this.connectionHash.has(JSON.stringify({ from, to, dir }));\r\n    }\r\n    printAllConnections() {\r\n        for (let ptt of this.prototypes) {\r\n            this.printConnections(ptt.tile);\r\n        }\r\n    }\r\n}\r\nfunction doImagesOverlap(a, b, offset = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero(), debug = false) {\r\n    let aoff = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n    if (offset.x > 0)\r\n        aoff.x += offset.x;\r\n    if (offset.y > 0)\r\n        aoff.y += offset.y;\r\n    let boff = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n    if (offset.x < 0)\r\n        boff.x += offset.x * -1;\r\n    if (offset.y < 0)\r\n        boff.y += offset.y * -1;\r\n    for (let y = 0; y < a.height - Math.abs(offset.y); y++) {\r\n        for (let x = 0; x < a.width - Math.abs(offset.x); x++) {\r\n            if (debug) {\r\n                console.log(\"a_coords\", x + aoff.x, y + aoff.y);\r\n                console.log(\"b_coords\", x + boff.x, y + boff.y);\r\n                let colorA = a.get(x + aoff.x, y + aoff.y);\r\n                let colorB = b.get(x + boff.x, y + boff.y);\r\n                console.log(\"a\", colorA, \"b\", colorB, \"same\", _lib__WEBPACK_IMPORTED_MODULE_0__.Color.isTheSame(colorA, colorB));\r\n            }\r\n            if (!_lib__WEBPACK_IMPORTED_MODULE_0__.Color.isTheSame(a.get(x + aoff.x, y + aoff.y), b.get(x + boff.x, y + boff.y))) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (debug) {\r\n        for (let y = 0; y < a.height; y++) {\r\n            for (let x = 0; x < a.width; x++) {\r\n                let colorA = a.get(x, y);\r\n                let colorB = b.get(x, y);\r\n                console.log(\"a\", colorA);\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/algorithms/TileAtlas.ts?");

/***/ }),

/***/ "../engine/src/algorithms/TileSolver.ts":
/*!**********************************************!*\
  !*** ../engine/src/algorithms/TileSolver.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TileSolver\": () => (/* binding */ TileSolver)\n/* harmony export */ });\n/* harmony import */ var _data_GenMatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/GenMatrix */ \"../engine/src/data/GenMatrix.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Directions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Directions */ \"../engine/src/math/Directions.ts\");\n\r\n\r\n\r\n/**\r\n * Implementation of the famous and fascinating WaveFunctionCollapse algorithm\r\n * https://github.com/mxgmn/WaveFunctionCollapse\r\n *\r\n * Some video's\r\n * https://www.youtube.com/watch?v=DOQTr2Xmlz0\r\n * https://www.youtube.com/watch?v=fnFj3dOKcIQ\r\n *\r\n * Terminology\r\n * Tile:\r\n * Prototype: A pairing between a tile and adjacency information. One tile can occur in multiple prototypes, due to rotation\r\n * Cell: a spot in the output image\r\n *\r\n *\r\n */\r\nclass TileSolver {\r\n    constructor(cells, // sometimes called 'wave'. every uint8 represents a 'present' flag for one of 'atlas''s prototypes\r\n    atlas, random) {\r\n        this.cells = cells;\r\n        this.atlas = atlas;\r\n        this.random = random;\r\n    }\r\n    static new(atlas, width, height) {\r\n        // init all cells containing all options\r\n        let maxOptions = atlas.prototypes.length;\r\n        let cells = _data_GenMatrix__WEBPACK_IMPORTED_MODULE_0__.GenMatrix.new(width, height);\r\n        for (let i = 0; i < cells.data.length; i++) {\r\n            // add the indices of all options\r\n            cells.data[i] = new Uint8Array(maxOptions);\r\n            cells.data[i].fill(1);\r\n            // cells.data[i] = Util.range(options.length);\r\n        }\r\n        return new TileSolver(cells, atlas, _lib__WEBPACK_IMPORTED_MODULE_1__.Random.fromRandom());\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    solve() {\r\n        // after doing this, all cell lists should contain just a single pointer\r\n        let maxIterations = 10000000; // we will never have to iterate more times than cells in the target image\r\n        for (let i = 0; i < maxIterations; i++) {\r\n            if (this.isCollapsed()) {\r\n                return true;\r\n            }\r\n            this.solveStep();\r\n        }\r\n        console.error(\"max iteration reached in solve!\");\r\n        return false;\r\n    }\r\n    solveStep() {\r\n        // pick a cell, and a choice for that cell \r\n        // let cells = this.getCellsWithLeastOptions();\r\n        let cells = this.getCellsWithLeastEntrophy();\r\n        // Debug.logOnce(cells, entr);\r\n        let cell = cells[0];\r\n        let cellChoicesBackup = new Uint8Array(this.cells.data[cell]);\r\n        let choice = this.pickRandomOption(cell);\r\n        // try to propagate this constraint\r\n        // if this did not work: backtracking. \r\n        // revert the changes, and remove this choice from the possible choices\r\n        let success = this.removeInvalidOptions(cell);\r\n        if (!success) {\r\n            console.count(\"backing up...\");\r\n            this.cells.data[cell] = cellChoicesBackup;\r\n            this.removeOption(cell, choice);\r\n        }\r\n        return success;\r\n    }\r\n    pickRandomOption(cell) {\r\n        // get choices + weights\r\n        let data = this.cells.data[cell];\r\n        let options = [];\r\n        let weights = [];\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i] == 1) {\r\n                options.push(i);\r\n                weights.push(this.atlas.prototypes[i].probability);\r\n            }\r\n        }\r\n        // now pick one\r\n        let choice = this.random.choose(options);\r\n        let choicew = this.random.chooseWeighted(options, weights);\r\n        _lib__WEBPACK_IMPORTED_MODULE_1__.Debug.logTimes(10, { choice, choicew, options, weights });\r\n        this.setOption(cell, choicew);\r\n        return choice;\r\n    }\r\n    /**\r\n     * The core\r\n     */\r\n    removeInvalidOptions(startCell, maxIterations = 10000000, debug = false) {\r\n        let stack = new Array();\r\n        let visited = new Set();\r\n        let backup = new Array();\r\n        // use the backup to restore the original state if this state does not resolve\r\n        let restoreState = () => {\r\n            for (let entry of backup) {\r\n                this.addOption(entry[0], entry[1]);\r\n            }\r\n        };\r\n        stack.push(startCell);\r\n        // protected while loop\r\n        for (let i = 0; i < maxIterations; i++) {\r\n            if (stack.length < 1) {\r\n                return true;\r\n            }\r\n            // visit this cell\r\n            let cell = stack.pop();\r\n            visited.add(cell);\r\n            // debug \r\n            if (debug) {\r\n                console.log(\"-----------------\");\r\n                console.log(\"SOURCE:\", cell, \"|\", this.getOptions(cell).length);\r\n                this.atlas.printConcatConnections(this.getOptions(cell));\r\n            }\r\n            // per unvisited neighbor\r\n            for (let neighbor of this.cells.getNbCells8(cell)) {\r\n                if (visited.has(neighbor))\r\n                    continue;\r\n                let ops = this.getOptions(neighbor);\r\n                let changed = this.removeInvalidOptionsOfNeighbor(cell, neighbor, backup, debug);\r\n                // saveguard\r\n                if (ops.length == 0) {\r\n                    // console.info(\"All options were removed from node\", neighbor, \"!!\");\r\n                    restoreState();\r\n                    return false;\r\n                    // console.log(\"SOURCE:\", cell, \"|\", this.getOptions(cell).length);\r\n                    // console.log(\"TARGET TO THE\", D8[this.cells.getDirectionFromDifference(neighbor - cell)!])\r\n                    // this.atlas.printConcatConnections(this.getOptions(cell));\r\n                    // console.log(\"ORIGINAL OPTIONS\", ops);\r\n                }\r\n                if (changed) {\r\n                    stack.push(neighbor);\r\n                }\r\n            }\r\n            // debug | return after one cycle\r\n            // return false;\r\n        }\r\n        console.error(\"max iteration reached!\");\r\n        restoreState();\r\n        return false;\r\n    }\r\n    removeInvalidOptionsOfNeighbor(cell, neighbor, backup, debug = false) {\r\n        let isTargetAllowed = (sourceOptions, target, direction) => {\r\n            for (let source of sourceOptions) {\r\n                if (this.atlas.canBeConnected(source, target, direction)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n        let changed = false;\r\n        // first, we require the direction\r\n        let direction = this.cells.getDirectionFromDifference(neighbor - cell);\r\n        // console.log(\"direction:\", D8[direction], \" means offset\", offset);\r\n        let sourceOptions = this.getOptions(cell);\r\n        let targetOptions = this.getOptions(neighbor);\r\n        let ogCount = targetOptions.length;\r\n        // console.log(\"I have \", sourceOptions, \"options\");\r\n        // console.log(\"target has\", targetOptions, \"options\");\r\n        // go over target options\r\n        for (let target of targetOptions) {\r\n            // if target matches NONE of the source options, it should be removed\r\n            if (!isTargetAllowed(sourceOptions, target, direction)) {\r\n                // console.log(\"incorrect!\");\r\n                this.removeOption(neighbor, target);\r\n                backup.push([neighbor, target]);\r\n                changed = true;\r\n            }\r\n        }\r\n        // debug\r\n        if (debug) {\r\n            let newCount = this.getOptions(neighbor).length;\r\n            // debug\r\n            console.log(\"NB\", _math_Directions__WEBPACK_IMPORTED_MODULE_2__.D8[direction], \":\", neighbor, \"|\", ogCount, \"->\", newCount);\r\n        }\r\n        return changed;\r\n    }\r\n    isCollapsed(debug = false) {\r\n        for (let i = 0; i < this.cells.data.length; i++) {\r\n            let options = this.getOptions(i);\r\n            if (debug) {\r\n                console.log(options);\r\n            }\r\n            if (options.length !== 1) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    getOptions(cell) {\r\n        let ops = [];\r\n        let flags = this.cells.data[cell];\r\n        for (let i = 0; i < flags.length; i++) {\r\n            if (flags[i] == 1) {\r\n                ops.push(i);\r\n            }\r\n        }\r\n        return ops;\r\n    }\r\n    getEntrophy(cell) {\r\n        let entrophy = 0;\r\n        let flags = this.cells.data[cell];\r\n        for (let i = 0; i < flags.length; i++) {\r\n            if (flags[i] == 1) {\r\n                let p = this.atlas.prototypes[i].probability;\r\n                entrophy += p * Math.log(p);\r\n            }\r\n        }\r\n        return -entrophy;\r\n    }\r\n    setOption(cell, choice) {\r\n        let data = this.cells.data[cell];\r\n        data.fill(0);\r\n        data[choice] = 1;\r\n    }\r\n    removeOption(cell, option) {\r\n        this.cells.data[cell][option] = 0;\r\n    }\r\n    addOption(cell, option) {\r\n        this.cells.data[cell][option] = 1;\r\n    }\r\n    getTileOptions(cell) {\r\n        return this.getOptions(cell).map(i => this.atlas.tiles[this.atlas.prototypes[i].tile]);\r\n    }\r\n    /**\r\n     * or 'minimum entrophy', if you wanna be all fancy\r\n     */\r\n    getCellsWithLeastOptions() {\r\n        let least = [];\r\n        let leastOptions = Infinity;\r\n        for (let i = 0; i < this.cells.data.length; i++) {\r\n            let options = this.getOptions(i);\r\n            if (options.length == 1) {\r\n                continue;\r\n            }\r\n            if (options.length == leastOptions) {\r\n                least.push(i);\r\n            }\r\n            else if (options.length < leastOptions) {\r\n                least = [];\r\n                least.push(i);\r\n                leastOptions = options.length;\r\n            }\r\n        }\r\n        // console.log(\"least options\", leastOptions)\r\n        // console.log(\"least\", least)\r\n        return least;\r\n    }\r\n    getCellsWithLeastEntrophy() {\r\n        let least = [];\r\n        let leastEntrophy = Infinity;\r\n        for (let i = 0; i < this.cells.data.length; i++) {\r\n            let options = this.getOptions(i);\r\n            let entrophy = this.getEntrophy(i);\r\n            // console.log(options);\r\n            if (options.length == 1) {\r\n                continue;\r\n            }\r\n            if (entrophy == leastEntrophy) {\r\n                least.push(i);\r\n            }\r\n            else if (entrophy < leastEntrophy) {\r\n                least = [];\r\n                least.push(i);\r\n                leastEntrophy = entrophy;\r\n            }\r\n        }\r\n        // console.log(\"least options\", leastOptions)\r\n        // console.log(\"least\", least)\r\n        return least;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    renderResult() {\r\n        let image = _lib__WEBPACK_IMPORTED_MODULE_1__.Bitmap.new(this.cells.width, this.cells.height);\r\n        for (let i = 0; i < image.pixelCount; i++) {\r\n            // get average pixel\r\n            let options = this.getTileOptions(i);\r\n            if (options.length == 0) {\r\n                console.warn(\"optionless cell encountered!\");\r\n                image.setWithIndex(i, [255, 0, 0, 255]);\r\n            }\r\n            else {\r\n                image.setWithIndex(i, getAverageCenterPixel(options));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n}\r\nfunction getAverageCenterPixel(imageSeries) {\r\n    let pixel = [0, 0, 0, 0];\r\n    let count = imageSeries.length;\r\n    let oneOverCount = 1 / count;\r\n    let k = Math.floor(imageSeries[0].width / 2);\r\n    // k = 1;\r\n    for (let image of imageSeries) {\r\n        let newPixel = image.get(k, k);\r\n        for (let i = 0; i < 4; i++) {\r\n            pixel[i] += newPixel[i] * oneOverCount;\r\n        }\r\n    }\r\n    return pixel;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/algorithms/TileSolver.ts?");

/***/ }),

/***/ "../engine/src/app/App.ts":
/*!********************************!*\
  !*** ../engine/src/app/App.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"App\": () => (/* binding */ App)\n/* harmony export */ });\nclass App {\r\n    constructor(gl, des = \"\") {\r\n        // unique constructor\r\n        this.gl = gl;\r\n        this.name = this.constructor.name;\r\n        this.description = des;\r\n    }\r\n    ui(ui) {\r\n        // setup for UI\r\n    }\r\n    start() {\r\n        // additional setup of state\r\n    }\r\n    update(input) {\r\n        // updating state\r\n    }\r\n    draw() {\r\n        // drawing state\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/app/App.ts?");

/***/ }),

/***/ "../engine/src/app/Core.ts":
/*!*********************************!*\
  !*** ../engine/src/app/Core.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Core\": () => (/* binding */ Core)\n/* harmony export */ });\n/* harmony import */ var _util_FpsCounter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/FpsCounter */ \"../engine/src/util/FpsCounter.ts\");\n/* harmony import */ var _dom_UI__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom/UI */ \"../engine/src/dom/UI.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// Author: Jos Feenstra\r\n// Purpose: The Core app. This can hold multiple other apps with their own Update and Draw calls.\r\n// Use this to switch between Apps, or run multiple Apps.\r\n\r\n\r\n\r\nclass Core {\r\n    constructor(canvas, gl, uiFrame) {\r\n        this.fullscreen = true;\r\n        this.fpsInTitle = true;\r\n        this.canvas = canvas;\r\n        this.gl = gl;\r\n        this.input = _lib__WEBPACK_IMPORTED_MODULE_2__.InputHandler.fromCanvas(canvas);\r\n        this.fpsCounter = new _util_FpsCounter__WEBPACK_IMPORTED_MODULE_0__.FpsCounter();\r\n        this.ui = new _dom_UI__WEBPACK_IMPORTED_MODULE_1__.UI(uiFrame);\r\n        this.apps = new Map();\r\n        this.gl.clearColor(0, 0, 0, 0);\r\n    }\r\n    // todo: cycle through apps\r\n    addApp(app) {\r\n        this.apps.set(app.name, app);\r\n        this.activateApp(app);\r\n    }\r\n    removeApp(appName) {\r\n        this.ui.removeContext(appName);\r\n        this.apps.delete(appName);\r\n    }\r\n    activateApp(app) {\r\n        this.ui.addContext(app.name);\r\n        this.ui.addText(app.description);\r\n        app.ui(this.ui);\r\n        app.start();\r\n    }\r\n    update(time) {\r\n        this.input.update();\r\n        this.fpsCounter.update(this.input.time.tick);\r\n        this.apps.forEach((app) => {\r\n            app.update(this.input);\r\n        });\r\n        this.input.postUpdate();\r\n    }\r\n    draw(clear = true) {\r\n        const canvas = this.canvas;\r\n        const gl = this.gl;\r\n        if (this.fullscreen) {\r\n            // pre-gl business\r\n            if (window.innerHeight != canvas.height || window.innerWidth != canvas.width) {\r\n                canvas.height = window.innerHeight;\r\n                // canvas.clientHeight = window.innerHeight;\r\n                canvas.style.height = window.innerHeight.toString();\r\n                canvas.width = window.innerWidth;\r\n                // canvas.clientWidth = window.innerWidth;\r\n                canvas.style.width = window.innerWidth.toString();\r\n                gl.viewport(0, 0, window.innerWidth, window.innerHeight);\r\n            }\r\n        }\r\n        if (clear) {\r\n            _lib__WEBPACK_IMPORTED_MODULE_2__.HelpGl.clear(gl);\r\n        }\r\n        // render all apps\r\n        // TODO : reverse order\r\n        this.apps.forEach((app) => {\r\n            app.draw();\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/app/Core.ts?");

/***/ }),

/***/ "../engine/src/app/SwapApp.ts":
/*!************************************!*\
  !*** ../engine/src/app/SwapApp.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SwapApp\": () => (/* binding */ SwapApp)\n/* harmony export */ });\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ \"../engine/src/app/App.ts\");\n/* harmony import */ var _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parametric/EnumParameter */ \"../engine/src/parametric/EnumParameter.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    swap-app\r\n// author:  Jos Feenstra\r\n// purpose: swap between different apps.\r\n//          - factory for initiazing these apps\r\n//          - making sure core deletes old apps\r\n\r\n\r\n\r\nclass SwapApp extends _App__WEBPACK_IMPORTED_MODULE_0__.App {\r\n    constructor(gl, core, possibleApps) {\r\n        super(gl);\r\n        this.currentAppIndex = -1;\r\n        this.isuihidden = false;\r\n        this.core = core;\r\n        this.possibleApps = possibleApps;\r\n    }\r\n    getAppNames() {\r\n        let names = [];\r\n        let count = this.possibleApps.length;\r\n        for (let i = 0; i < count; i++) {\r\n            names.push(this.possibleApps[i].name.replace(\"App\", \"\"));\r\n        }\r\n        return names;\r\n    }\r\n    ui(ui) {\r\n        let names = this.getAppNames();\r\n        this.param = _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_1__.EnumParameter.new(\"apps\", 0, names);\r\n        ui.addDropdown(this.param, (i) => {\r\n            this.swap(i);\r\n        });\r\n    }\r\n    swapFromUrl(hash, ifnot) {\r\n        // select one of the apps based on an url\r\n        let test = hash.substr(1);\r\n        let names = this.getAppNames();\r\n        for (let i = 0; i < names.length; i++) {\r\n            if (names[i].toLowerCase() === test) {\r\n                this.swap(i);\r\n                return;\r\n            }\r\n        }\r\n        // no match\r\n        console.log(\"no hash match, defaulting...\");\r\n        this.swap(ifnot);\r\n    }\r\n    swap(index) {\r\n        // todo do some range checking\r\n        let AppType = this.possibleApps[index];\r\n        if (this.currentAppIndex > -1) {\r\n            let PreviousType = this.possibleApps[this.currentAppIndex];\r\n            console.log(\"removing\", PreviousType.name);\r\n            this.core.removeApp(PreviousType.name);\r\n        }\r\n        console.log(\"constructing\", AppType.name);\r\n        this.currentAppIndex = index;\r\n        let app = new AppType(this.gl);\r\n        location.hash = \"#\" + AppType.name.replace(\"App\", \"\").toLowerCase();\r\n        this.core.addApp(app);\r\n    }\r\n    update(state) {\r\n        var _a;\r\n        if ((_a = state.keys) === null || _a === void 0 ? void 0 : _a.isPressed(_lib__WEBPACK_IMPORTED_MODULE_2__.Key.M)) {\r\n            // simple toggle\r\n            // this.core.ui.toggleVisibility();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/app/SwapApp.ts?");

/***/ }),

/***/ "../engine/src/data/FloatMatrix.ts":
/*!*****************************************!*\
  !*** ../engine/src/data/FloatMatrix.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FloatMatrix\": () => (/* binding */ FloatMatrix)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\n// generic all-pupose matrix of floats\r\nclass FloatMatrix {\r\n    constructor(width, height, data = []) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.data = new Float32Array(this.width * this.height);\r\n        if (data == [] || data.length == 0) {\r\n            // this.fill(0); // not needed, and not efficient ;)\r\n        }\r\n        else {\r\n            this.setData(data);\r\n        }\r\n    }\r\n    static mulBtoA(A, B) {\r\n        // / matrix multiplications are weird. Sometimes, A*B is noted in some book, when they mean B*A in actuality\r\n        // console.log(`attempting to multiply A [${A.width}x${A.height}] to B [${B.width}x${B.height}]`)\r\n        return B.mul(A);\r\n    }\r\n    static mulAtoB(A, B) {\r\n        // / matrix multiplications are weird. Sometimes, A*B is noted in some book, when they mean B*A in actuality\r\n        console.log(`attempting to multiply A [${A.width}x${A.height}] to B [${B.width}x${B.height}]`);\r\n        return A.mul(B);\r\n    }\r\n    static multiply(a, b) {\r\n        return b.mul(a);\r\n    }\r\n    static zeros(width = 1, height = 1) {\r\n        return new FloatMatrix(width, height);\r\n    }\r\n    /**\r\n     * stack a bunch of equal-length arrays horizontally\r\n     */\r\n    static vstack(...arrays) {\r\n        if (arrays.length == 0)\r\n            throw new Error(\"need minimum of one array...\");\r\n        let height = arrays.length;\r\n        let width = arrays[0].length;\r\n        let matrix = FloatMatrix.zeros(width, height);\r\n        for (let i = 0; i < height; i++) {\r\n            if (arrays[i].length != width)\r\n                throw new Error(\"all arrays need to be the same length\");\r\n            for (let j = 0; j < width; j++) {\r\n                matrix.set(i, j, arrays[i][j]);\r\n            }\r\n        }\r\n    }\r\n    static fromNative(native) {\r\n        // assume all subarrays have the same shape!!\r\n        let height = native.length;\r\n        let width = native[0].length;\r\n        let matrix = new FloatMatrix(width, height);\r\n        for (var i = 0; i < native.length; i++) {\r\n            for (var j = 0; j < native[0].length; j++) {\r\n                matrix.set(i, j, native[i][j]);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n    clone() {\r\n        let clone = new FloatMatrix(this.width, this.height);\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            clone.data[i] = this.data[i];\r\n        }\r\n        return clone;\r\n    }\r\n    // [GETTING & SETTING]\r\n    print() {\r\n        let strings = [];\r\n        const WIDTH = 8;\r\n        for (var i = 0; i < this.height; i++) {\r\n            strings.push(\"|\");\r\n            for (var j = 0; j < this.width; j++) {\r\n                let str = this.get(i, j).toFixed(2); // TODO THIS IS INCORRECT\r\n                str = str.padStart(WIDTH, \" \");\r\n                strings.push(str);\r\n                if (j < this.width - 2) {\r\n                    strings.push(\"  \");\r\n                }\r\n            }\r\n            strings.push(\"  |\\n\");\r\n        }\r\n        console.log(strings.join(\"\"));\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.height * this.width)\r\n            throw \"data.length does not match width * height \" + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    count() {\r\n        // number of entries / rows.\r\n        // when derrived classes ask for 'how many of x?' they usually mean this.\r\n        return this.height;\r\n    }\r\n    get size() {\r\n        return this.width * this.height;\r\n    }\r\n    getDimensions() {\r\n        return [this.height, this.width];\r\n    }\r\n    fill(value) {\r\n        let size = this.height * this.width;\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    fillWith(data, valuesPerEntry = this.width) {\r\n        // values per entry can be used to setData which is not of the same shape.\r\n        let vpe = valuesPerEntry;\r\n        if (vpe > this.width)\r\n            throw \"values per entry is larger than this._width. This will spill over.\";\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < vpe; j++) {\r\n                this.set(i, j, data[i * vpe + j]);\r\n            }\r\n        }\r\n    }\r\n    fillFrom(other) {\r\n        if (other.height < this.height || other.width < this.width) {\r\n            throw new Error(\"need same dimentions\");\r\n        }\r\n        for (let i = 0; i < other.height; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                this.set(i, j, other.get(i, j));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    get(i, j) {\r\n        return this.data[i * this.width + j];\r\n    }\r\n    getRow(i) {\r\n        // if (i < 0 || i > this.height) throw \"column is out of bounds for FloatArray\"\r\n        let data = new Float32Array(this.width);\r\n        for (let j = 0; j < this.width; j++) {\r\n            data[j] = this.get(i, j);\r\n        }\r\n        return data;\r\n    }\r\n    getColumn(j) {\r\n        // if (j < 0 || j > this.width) throw \"column is out of bounds for FloatArray\"\r\n        let data = new Float32Array(this.height);\r\n        for (let i = 0; i < this.height; i++) {\r\n            let index = i * this.width + j;\r\n            data[i] = this.data[index];\r\n        }\r\n        return data;\r\n    }\r\n    set(i, j, value) {\r\n        this.data[i * this.width + j] = value;\r\n    }\r\n    setRow(rowIndex, row) {\r\n        // if (this.width != row.length) throw \"dimention of floatarray is not \" + row.length;\r\n        for (let j = 0; j < this.width; j++) {\r\n            this.set(rowIndex, j, row[j]);\r\n        }\r\n    }\r\n    forEachValue(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n        return this;\r\n    }\r\n    takeRows(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = new FloatMatrix(count, this.width);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setRow(i, this.getRow(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    // create a new floatmatrix, processed by iterating\r\n    mapWith(other, callback) {\r\n        let result = this.clone();\r\n        let width = Math.min(this.width, other.height);\r\n        let height = Math.min(this.height, other.height);\r\n        for (var i = 0; i < height; i++) {\r\n            for (var j = 0; j < width; j++) {\r\n                result.set(i, j, callback(this.get(i, j), other.get(i, j)));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    toNative() {\r\n        let native = [];\r\n        for (var i = 0; i < this.height; i++) {\r\n            native[i] = [];\r\n            for (var j = 0; j < this.width; j++) {\r\n                native[i][j] = this.get(i, j);\r\n            }\r\n        }\r\n        return native;\r\n    }\r\n    // [CALCULATIONS]\r\n    // generalized multiplication\r\n    mul(b) {\r\n        let a = this;\r\n        if (b.height !== a.width) {\r\n            throw new Error(`Columns in A should be the same as the number of rows in B\r\n                a.width ${a.width},\r\n                b.height ${b.height}`);\r\n        }\r\n        let size = a.width;\r\n        var product = new FloatMatrix(b.width, a.height);\r\n        for (var i = 0; i < product.height; i++) {\r\n            for (var j = 0; j < product.width; j++) {\r\n                let sum = 0;\r\n                for (var k = 0; k < size; k++) {\r\n                    sum += a.get(i, k) * b.get(k, j);\r\n                }\r\n                product.set(i, j, sum);\r\n            }\r\n        }\r\n        return product;\r\n    }\r\n    tp() {\r\n        let tp = FloatMatrix.zeros(this.height, this.width);\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                tp.set(j, i, this.get(i, j));\r\n            }\r\n        }\r\n        return tp;\r\n    }\r\n    inv() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.pinv(this);\r\n    }\r\n    inv2() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.pinv2(this);\r\n    }\r\n}\r\n// stolen something from https://jamesmccaffrey.wordpress.com/2020/04/24/matrix-inverse-with-javascript/\r\n// James D. McCaffrey\r\n// function matInverse(m)\r\n// {\r\n//   // assumes determinant is not 0\r\n//   // that is, the matrix does have an inverse\r\n//   let n = m.length;\r\n//   let result = matMake(n, n, 0.0); // make a copy\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     for (let j = 0; j less-than n; ++j) {\r\n//       result[i][j] = m[i][j];\r\n//     }\r\n//   }\r\n//   let lum = matMake(n, n, 0.0); // combined lower & upper\r\n//   let perm = vecMake(n, 0.0);  // out parameter\r\n//   matDecompose(m, lum, perm);  // ignore return\r\n//   let b = vecMake(n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     for (let j = 0; j less-than n; ++j) {\r\n//       if (i == perm[j])\r\n//         b[j] = 1.0;\r\n//       else\r\n//         b[j] = 0.0;\r\n//     }\r\n//     let x = reduce(lum, b); //\r\n//     for (let j = 0; j less-than n; ++j)\r\n//       result[j][i] = x[j];\r\n//   }\r\n//   return result;\r\n// }\r\n// function matDeterminant(m)\r\n// {\r\n//   let n = m.length;\r\n//   let lum = matMake(n, n, 0.0);;\r\n//   let perm = vecMake(n, 0.0);\r\n//   let result = matDecompose(m, lum, perm);  // -1 or +1\r\n//   for (let i = 0; i less-than n; ++i)\r\n//     result *= lum[i][i];\r\n//   return result;\r\n// }\r\n// function matDecompose(m, lum, perm)\r\n// {\r\n//   // Crout's LU decomposition for matrix determinant and inverse\r\n//   // stores combined lower & upper in lum[][]\r\n//   // stores row permuations into perm[]\r\n//   // returns +1 or -1 according to even or odd perms\r\n//   // lower gets dummy 1.0s on diagonal (0.0s above)\r\n//   // upper gets lum values on diagonal (0.0s below)\r\n//   let toggle = +1; // even (+1) or odd (-1) row permutatuions\r\n//   let n = m.length;\r\n//   // make a copy of m[][] into result lum[][]\r\n//   //lum = matMake(n, n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     for (let j = 0; j less-than n; ++j) {\r\n//       lum[i][j] = m[i][j];\r\n//     }\r\n//   }\r\n//   // make perm[]\r\n//   //perm = vecMake(n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i)\r\n//     perm[i] = i;\r\n//   for (let j = 0; j less-than n - 1; ++j) {  // note n-1\r\n//     let max = Math.abs(lum[j][j]);\r\n//     let piv = j;\r\n//     for (let i = j + 1; i less-than n; ++i) {  // pivot index\r\n//       let xij = Math.abs(lum[i][j]);\r\n//       if (xij greater-than max) {\r\n//         max = xij;\r\n//         piv = i;\r\n//       }\r\n//     } // i\r\n//     if (piv != j) {\r\n//       let tmp = lum[piv];  // swap rows j, piv\r\n//       lum[piv] = lum[j];\r\n//       lum[j] = tmp;\r\n//       let t = perm[piv];  // swap perm elements\r\n//       perm[piv] = perm[j];\r\n//       perm[j] = t;\r\n//       toggle = -toggle;\r\n//     }\r\n//     let xjj = lum[j][j];\r\n//     if (xjj != 0.0) {  // TODO: fix bad compare here\r\n//       for (let i = j + 1; i less-than n; ++i) {\r\n//         let xij = lum[i][j] / xjj;\r\n//         lum[i][j] = xij;\r\n//         for (let k = j + 1; k less-than n; ++k) {\r\n//           lum[i][k] -= xij * lum[j][k];\r\n//         }\r\n//       }\r\n//     }\r\n//   } // j\r\n//   return toggle;  // for determinant\r\n// } // matDecompose\r\n// function reduce(lum, b) // helper\r\n// {\r\n//   let n = lum.length;\r\n//   let x = vecMake(n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     x[i] = b[i];\r\n//   }\r\n//   for (let i = 1; i less-than n; ++i) {\r\n//     let sum = x[i];\r\n//     for (let j = 0; j less-than i; ++j) {\r\n//       sum -= lum[i][j] * x[j];\r\n//     }\r\n//     x[i] = sum;\r\n//   }\r\n//   x[n - 1] /= lum[n - 1][n - 1];\r\n//   for (let i = n - 2; i greater-than-equal 0; --i) {\r\n//     let sum = x[i];\r\n//     for (let j = i + 1; j less-than n; ++j) {\r\n//       sum -= lum[i][j] * x[j];\r\n//     }\r\n//     x[i] = sum / lum[i][i];\r\n//   }\r\n//   return x;\r\n// } // reduce\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/FloatMatrix.ts?");

/***/ }),

/***/ "../engine/src/data/GenMatrix.ts":
/*!***************************************!*\
  !*** ../engine/src/data/GenMatrix.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GenMatrix\": () => (/* binding */ GenMatrix)\n/* harmony export */ });\n/* harmony import */ var _math_Directions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Directions */ \"../engine/src/math/Directions.ts\");\n\r\n/**\r\n * Generic matrix\r\n */\r\nclass GenMatrix {\r\n    constructor(width, height, data) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.data = data;\r\n    }\r\n    static new(width, height) {\r\n        let data = new Array(width * height);\r\n        return new GenMatrix(width, height, data);\r\n    }\r\n    get(x, y) {\r\n        return this.data[y * this.width + x];\r\n    }\r\n    set(x, y, item) {\r\n        this.data[y * this.width + x] = item;\r\n    }\r\n    /**\r\n     * protected by a range check\r\n     */\r\n    tryGet(x, y) {\r\n        if (this.inRange(x, y)) {\r\n            return this.get(x, y);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    /**\r\n     * protected by a range check\r\n     */\r\n    trySet(x, y, cell) {\r\n        if (this.inRange(x, y)) {\r\n            return this.set(x, y, cell);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    inRange(x, y) {\r\n        return !(x < 0 || x >= this.width || y < 0 || y >= this.height);\r\n    }\r\n    getNbCellsDelta(cell) {\r\n        let deltas = new Array();\r\n        let size = this.width * this.height;\r\n        if (cell >= size)\r\n            return deltas;\r\n        let hasLeft = cell % this.width != 0;\r\n        let hasRight = (cell + 1) % this.width != 0;\r\n        let hasTop = cell - this.width > 0;\r\n        let hasBot = cell + this.width < size;\r\n        if (hasRight)\r\n            deltas.push(1);\r\n        if (hasTop)\r\n            deltas.push(-this.width);\r\n        if (hasLeft)\r\n            deltas.push(-1);\r\n        if (hasBot)\r\n            deltas.push(this.width);\r\n        return deltas;\r\n    }\r\n    getNbCells(cell) {\r\n        return this.getNbCellsDelta(cell).map((i) => cell + i);\r\n    }\r\n    getNbCells8(cell) {\r\n        return this.getNbCells8Delta(cell).map((i) => cell + i);\r\n    }\r\n    getNbCells8Delta(cell) {\r\n        let deltas = new Array();\r\n        let size = this.width * this.height;\r\n        if (cell >= size)\r\n            return deltas;\r\n        let hasRight = cell % this.width != 0;\r\n        let hasLeft = (cell + 1) % this.width != 0;\r\n        let hasTop = cell - this.width > 0;\r\n        let hasBot = cell + this.width < size;\r\n        if (hasLeft)\r\n            deltas.push(1);\r\n        if (hasTop && hasLeft)\r\n            deltas.push(-this.width + 1);\r\n        if (hasTop)\r\n            deltas.push(-this.width);\r\n        if (hasTop && hasRight)\r\n            deltas.push(-this.width - 1);\r\n        if (hasRight)\r\n            deltas.push(-1);\r\n        if (hasBot && hasRight)\r\n            deltas.push(this.width - 1);\r\n        if (hasBot)\r\n            deltas.push(this.width);\r\n        if (hasBot && hasLeft)\r\n            deltas.push(this.width + 1);\r\n        return deltas;\r\n    }\r\n    /**\r\n     * NOTE this is not allowed on images smaller than 3x3,\r\n     * and this does not work for non-neighbors. so DONT use this to blindly check if two cells are neighbors...\r\n     */\r\n    getDirectionFromDifference(delta) {\r\n        if (delta === 1)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.Right;\r\n        if (delta === -this.width + 1)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.UpRight;\r\n        if (delta === -this.width)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.Up;\r\n        if (delta === -this.width - 1)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.UpLeft;\r\n        if (delta === -1)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.Left;\r\n        if (delta === this.width - 1)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.DownLeft;\r\n        if (delta === this.width)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.Down;\r\n        if (delta === this.width + 1)\r\n            return _math_Directions__WEBPACK_IMPORTED_MODULE_0__.D8.DownRight;\r\n        return undefined;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/GenMatrix.ts?");

/***/ }),

/***/ "../engine/src/data/HashTable.ts":
/*!***************************************!*\
  !*** ../engine/src/data/HashTable.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HashTable\": () => (/* binding */ HashTable)\n/* harmony export */ });\n// note: this wont always work, but it does in most cases\r\n// todo: implement proper hashtable\r\nclass HashTable {\r\n    constructor() {\r\n        this.data = new Map();\r\n    }\r\n    stringify(key) {\r\n        return key.toString();\r\n    }\r\n    set(key, value) {\r\n        return this.data.set(this.stringify(key), value);\r\n    }\r\n    has(key) {\r\n        return this.data.has(this.stringify(key));\r\n    }\r\n    get(key) {\r\n        return this.data.get(this.stringify(key));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/HashTable.ts?");

/***/ }),

/***/ "../engine/src/data/IntCube.ts":
/*!*************************************!*\
  !*** ../engine/src/data/IntCube.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntCube\": () => (/* binding */ IntCube)\n/* harmony export */ });\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n\r\n// a Cube of voxels\r\nclass IntCube {\r\n    constructor(height, width, depth, data = []) {\r\n        this._width = width;\r\n        this._height = height;\r\n        this._depth = depth;\r\n        let size = this._width * this._height * this._depth;\r\n        this.data = new Int32Array(size);\r\n        if (data == [] || data.length == 0) {\r\n        }\r\n        else {\r\n            this.setData(data);\r\n        }\r\n    }\r\n    static new(width, height, depth, data = []) {\r\n        return new IntCube(width, height, depth, data);\r\n    }\r\n    size() {\r\n        return this._width * this._height * this._depth;\r\n    }\r\n    // shallow copy\r\n    clone() {\r\n        let clone = new IntCube(this._height, this._width, this._depth);\r\n        clone.data = this.data;\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.size())\r\n            throw \"data.length does not match width * height \" + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    fill(value) {\r\n        let size = this.size();\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    inRange(i, j, k) {\r\n        return !(i < 0 ||\r\n            j < 0 ||\r\n            k < 0 ||\r\n            i > this._width - 1 ||\r\n            j > this._height - 1 ||\r\n            k > this._depth - 1);\r\n    }\r\n    isOnEdge(i, j, k, buffer = 1) {\r\n        return (i < buffer ||\r\n            j < buffer ||\r\n            k < buffer ||\r\n            i > this._width - 1 - buffer ||\r\n            j > this._height - 1 - buffer ||\r\n            k > this._depth - 1 - buffer);\r\n    }\r\n    getIndex(i, j, k) {\r\n        return i * (this._height * this._depth) + j * this._depth + k;\r\n    }\r\n    getCoord(index) {\r\n        // javascript, dont you dare turn  'int / int' into a float...\r\n        let i = Math.floor(index / (this._height * this._depth)) % this._width;\r\n        let j = Math.floor(index / this._depth) % this._height;\r\n        let k = index % this._depth;\r\n        return new _math_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3(i, j, k);\r\n    }\r\n    get(i, j, k) {\r\n        return this.data[this.getIndex(i, j, k)];\r\n    }\r\n    tryGet(i, j, k, outOfRange) {\r\n        if (this.inRange(i, j, k)) {\r\n            return this.data[this.getIndex(i, j, k)];\r\n        }\r\n        else {\r\n            return outOfRange;\r\n        }\r\n    }\r\n    set(i, j, k, value) {\r\n        this.data[this.getIndex(i, j, k)] = value;\r\n    }\r\n    trySet(i, j, k, value) {\r\n        if (this.inRange(i, j, k)) {\r\n            this.data[this.getIndex(i, j, k)] = value;\r\n        }\r\n    }\r\n    iter(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            callbackfn(this.data[i], i);\r\n        }\r\n    }\r\n    map(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n    }\r\n    trueForAll(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (!callbackfn(this.data[i], i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/IntCube.ts?");

/***/ }),

/***/ "../engine/src/data/IntMatrix.ts":
/*!***************************************!*\
  !*** ../engine/src/data/IntMatrix.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntMatrix\": () => (/* binding */ IntMatrix)\n/* harmony export */ });\n// generic all-pupose matrix of ints\r\nclass IntMatrix {\r\n    constructor(height, width, data) {\r\n        this._height = height;\r\n        this._width = width;\r\n        this.data = new Uint16Array(this._width * this._height);\r\n        if (data)\r\n            this.setData(data);\r\n    }\r\n    static new(height, width, data) {\r\n        return new IntMatrix(height, width, data);\r\n    }\r\n    static fromList(list, width) {\r\n        let height = list.length / width;\r\n        let array = new IntMatrix(height, width);\r\n        for (let i = 0; i < list.length; i++) {\r\n            array.data[i] = list[i];\r\n        }\r\n        return array;\r\n    }\r\n    print() {\r\n        let strings = [];\r\n        const WIDTH = 8;\r\n        for (var i = 0; i < this._height; i++) {\r\n            strings.push(\"|\");\r\n            for (var j = 0; j < this._width; j++) {\r\n                let str = this.get(i, j).toFixed(2);\r\n                str = str.padStart(WIDTH, \" \");\r\n                strings.push(str);\r\n                if (j < this._width - 2) {\r\n                    strings.push(\"  \");\r\n                }\r\n            }\r\n            strings.push(\"  |\\n\");\r\n        }\r\n        console.log(strings.join(\"\"));\r\n    }\r\n    clone() {\r\n        let clone = new IntMatrix(this._height, this._width);\r\n        clone.data = this.data;\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        // if (data.length != this._height * this._width)\r\n        //     throw \"data.length does not match width * height \" + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    count() {\r\n        // number of entries / rows.\r\n        // when derrived classes ask for 'how many of x?' they usually mean this.\r\n        return this._height;\r\n    }\r\n    getDimensions() {\r\n        return [this._height, this._width];\r\n    }\r\n    inRange(i, j) {\r\n        return !(i < 0 || i > this._height - 1 || j < 0 || j > this._width - 1);\r\n    }\r\n    fill(value) {\r\n        let size = this._height * this._width;\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    fillWith(data, valuesPerEntry = this._width) {\r\n        // values per entry can be used to setData which is not of the same shape.\r\n        let vpe = valuesPerEntry;\r\n        if (vpe > this._width)\r\n            throw \"values per entry is larger than this._width. This will spill over.\";\r\n        for (let i = 0; i < this._height; i++) {\r\n            for (let j = 0; j < vpe; j++) {\r\n                this.set(i, j, data[i * vpe + j]);\r\n            }\r\n        }\r\n    }\r\n    get(i, j) {\r\n        if (!this.inRange(i, j)) {\r\n            console.warn(\"out of range!\");\r\n            return 0;\r\n        }\r\n        return this.data[i * this._width + j];\r\n    }\r\n    getRow(i) {\r\n        // if (i < 0 || i > this.height) throw \"column is out of bounds for Array\"\r\n        let data = new Uint16Array(this._width);\r\n        for (let j = 0; j < this._width; j++) {\r\n            data[j] = this.get(i, j);\r\n        }\r\n        return data;\r\n    }\r\n    getColumn(j) {\r\n        // if (j < 0 || j > this.width) throw \"column is out of bounds for Array\"\r\n        let data = new Uint16Array(this._height);\r\n        for (let i = 0; i < this._height; i++) {\r\n            let index = i * this._width + j;\r\n            data[i] = this.data[index];\r\n        }\r\n        return data;\r\n    }\r\n    set(i, j, value) {\r\n        if (!this.inRange(i, j)) {\r\n            console.warn(\"out of range!\");\r\n            return;\r\n        }\r\n        this.data[i * this._width + j] = value;\r\n    }\r\n    setRow(rowIndex, row) {\r\n        // if (this.width != row.length) throw \"dimention of floatarray is not \" + row.length;\r\n        for (let j = 0; j < this._width; j++) {\r\n            this.set(rowIndex, j, row[j]);\r\n        }\r\n    }\r\n    takeRows(indices) {\r\n        // create a new array from a couple of rows\r\n        console.log(this._height, this._width);\r\n        const count = indices.length;\r\n        let array = new IntMatrix(count, this._width);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setRow(i, this.getRow(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    getData() {\r\n        return this.data;\r\n    }\r\n    forEachValue(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n        return this;\r\n    }\r\n    forEachRow(callbackfn) {\r\n        for (let i = 0; i < this._height; i++) {\r\n            let row = this.getRow(i);\r\n            callbackfn(row, i);\r\n            this.setRow(i, row);\r\n        }\r\n        return this;\r\n    }\r\n    trueForAll(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (!callbackfn(this.data[i], i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/IntMatrix.ts?");

/***/ }),

/***/ "../engine/src/data/LinkedList.ts":
/*!****************************************!*\
  !*** ../engine/src/data/LinkedList.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LinkedList\": () => (/* binding */ LinkedList)\n/* harmony export */ });\n//\r\n// note: taken from\r\n// https://medium.com/everything-javascript/implementing-a-hash-table-in-javascript-29aca1edfe2b\r\n// NOTE: Not used anymore, but i still find it interesting, so leave it here\r\nclass LinkedList {\r\n    constructor() {\r\n        this.head = null;\r\n    }\r\n    empty() {\r\n        if (this.head)\r\n            return false;\r\n        return true;\r\n    }\r\n    last() {\r\n        var cursor = this.head;\r\n        while (cursor.getNext()) {\r\n            cursor = cursor.getNext();\r\n        }\r\n        return cursor;\r\n    }\r\n    find(key) {\r\n        var cursor = this.head;\r\n        while (cursor) {\r\n            if (cursor.getKey() == key)\r\n                return cursor.value();\r\n            cursor = cursor.getNext();\r\n        }\r\n        return false;\r\n    }\r\n    insert(value, key) {\r\n        var node = new ListNode(value, key);\r\n        if (!this.head)\r\n            this.head = node;\r\n        else\r\n            this.last().next(node);\r\n    }\r\n    print() {\r\n        var cursor = this.head;\r\n        while (cursor) {\r\n            console.log(cursor.value() + \" \");\r\n            cursor = cursor.getNext();\r\n        }\r\n    }\r\n}\r\n//node\r\nclass ListNode {\r\n    constructor(value, key) {\r\n        this.nextNode = null;\r\n        this.key = key;\r\n        this.val = value;\r\n    }\r\n    getNext() {\r\n        return this.nextNode;\r\n    }\r\n    next(node) {\r\n        this.nextNode = node;\r\n    }\r\n    getKey() {\r\n        return this.key;\r\n    }\r\n    value() {\r\n        return this.val;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/LinkedList.ts?");

/***/ }),

/***/ "../engine/src/data/MultiVector.ts":
/*!*****************************************!*\
  !*** ../engine/src/data/MultiVector.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ToFloatMatrix\": () => (/* binding */ ToFloatMatrix)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    array.ts\r\n// author:  Jos Feenstra\r\n// purpose: Small wrapper around Float32Array / FloatMatrix to add interoperability with Vector2 & Vector3,\r\n//          while remaining a datastructure thats easy to pass over to webgl\r\n//\r\n// NOTE:    all these small wrappers might not be good pratice, but I\r\n//          like to extract simple logic like this to not clutter the code too much\r\n\r\nfunction ToFloatMatrix(vectors) {\r\n    if (vectors instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix) {\r\n        return vectors;\r\n    }\r\n    else if (vectors instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2) {\r\n        return vectors.toMatrixSlice();\r\n    }\r\n    else if (vectors instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3) {\r\n        return vectors.slice();\r\n    }\r\n    else if (vectors[0] instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2) {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList(vectors).toMatrixSlice();\r\n    }\r\n    else {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(vectors).slice();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/MultiVector.ts?");

/***/ }),

/***/ "../engine/src/data/MultiVector2.ts":
/*!******************************************!*\
  !*** ../engine/src/data/MultiVector2.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiVector2\": () => (/* binding */ MultiVector2)\n/* harmony export */ });\n/* harmony import */ var _geometry_Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Geometry */ \"../engine/src/geometry/Geometry.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n/* harmony import */ var _FloatMatrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FloatMatrix */ \"../engine/src/data/FloatMatrix.ts\");\n/* harmony import */ var _MultiVector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n\r\n\r\n\r\n\r\nclass MultiVector2 extends _geometry_Geometry__WEBPACK_IMPORTED_MODULE_0__.Geometry {\r\n    constructor(_matrix) {\r\n        super();\r\n        this._matrix = _matrix;\r\n    }\r\n    get data() {\r\n        return this._matrix.data;\r\n    }\r\n    static new(length) {\r\n        return new MultiVector2(new _FloatMatrix__WEBPACK_IMPORTED_MODULE_2__.FloatMatrix(2, length));\r\n    }\r\n    static fromList(vecs) {\r\n        let length = vecs.length;\r\n        let multiVector = MultiVector2.new(length);\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            multiVector._matrix.set(i, 0, vecs[i].x);\r\n            multiVector._matrix.set(i, 1, vecs[i].y);\r\n        }\r\n        return multiVector;\r\n    }\r\n    static fromMatrix(data) {\r\n        if (data.width != 2) {\r\n            throw new Error(\"incorrect.\");\r\n        }\r\n        return new MultiVector2(data);\r\n    }\r\n    static fromData(data) {\r\n        let multi = MultiVector2.new(data.length / 2);\r\n        multi._matrix.fillWith(data);\r\n        return multi;\r\n    }\r\n    // pass through\r\n    get width() {\r\n        return this._matrix.width;\r\n    }\r\n    get height() {\r\n        return this._matrix.height;\r\n    }\r\n    get dimensions() {\r\n        return this._matrix.width;\r\n    }\r\n    get count() {\r\n        return this._matrix.height;\r\n    }\r\n    get matrix() {\r\n        return this._matrix;\r\n    }\r\n    forEach(callbackfn) {\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            callbackfn(vec, i);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    map(callbackfn) {\r\n        let result = this.clone();\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            result.set(i, callbackfn(vec, i));\r\n        }\r\n        return result;\r\n    }\r\n    take(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = MultiVector2.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.set(i, this.get(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    remove(indices) {\r\n        // create a new floatarray\r\n        const count = this.count - indices.length;\r\n        let array = MultiVector2.new(count);\r\n        for (let i = 0, j = 0; i < this.count; i++) {\r\n            if (indices.includes(i)) {\r\n                continue;\r\n            }\r\n            array.set(j, this.get(i));\r\n            j++;\r\n        }\r\n        return array;\r\n    }\r\n    set(i, vec) {\r\n        this._matrix.data[i * this._matrix.width + 0] = vec.x;\r\n        this._matrix.data[i * this._matrix.width + 1] = vec.y;\r\n    }\r\n    setXY(i, x, y) {\r\n        this._matrix.data[i * this._matrix.width + 0] = x;\r\n        this._matrix.data[i * this._matrix.width + 1] = y;\r\n    }\r\n    get(i) {\r\n        return new _math_Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(this._matrix.data[i * this.width + 0], this._matrix.data[i * this.width + 1]);\r\n    }\r\n    /**\r\n     *  This is a Slice! Edit the matrix = edit the MultiVector!\r\n     */\r\n    toMatrixSlice() {\r\n        return this._matrix;\r\n    }\r\n    toList() {\r\n        let vecs = [];\r\n        for (let i = 0; i < this.height; i++) {\r\n            vecs.push(this.get(i));\r\n        }\r\n        return vecs;\r\n    }\r\n    to3D() {\r\n        let vecs = _MultiVector3__WEBPACK_IMPORTED_MODULE_3__.MultiVector3.new(this.count);\r\n        for (let i = 0; i < this.count; i++) {\r\n            let row = this._matrix.getRow(i);\r\n            vecs.setXYZ(i, row[0], row[1], 0);\r\n        }\r\n        return vecs;\r\n    }\r\n    clone() {\r\n        let clone = MultiVector2.new(this.count);\r\n        clone._matrix = this._matrix.clone();\r\n        return clone;\r\n    }\r\n    transform(m) {\r\n        this._matrix.mul(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        let clone = MultiVector2.new(this.count);\r\n        clone._matrix = this._matrix.mul(m);\r\n        return clone;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/MultiVector2.ts?");

/***/ }),

/***/ "../engine/src/data/MultiVector3.ts":
/*!******************************************!*\
  !*** ../engine/src/data/MultiVector3.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiVector3\": () => (/* binding */ MultiVector3)\n/* harmony export */ });\n/* harmony import */ var _geometry_Geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/Geometry */ \"../engine/src/geometry/Geometry.ts\");\n/* harmony import */ var _math_Matrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Matrix4 */ \"../engine/src/math/Matrix4.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _FloatMatrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FloatMatrix */ \"../engine/src/data/FloatMatrix.ts\");\n/* harmony import */ var _MultiVector2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MultiVector2 */ \"../engine/src/data/MultiVector2.ts\");\n\r\n\r\n\r\n\r\n\r\nclass MultiVector3 extends _geometry_Geometry__WEBPACK_IMPORTED_MODULE_0__.Geometry {\r\n    constructor(_matrix) {\r\n        super();\r\n        this._matrix = _matrix;\r\n    }\r\n    static new(count) {\r\n        return new MultiVector3(new _FloatMatrix__WEBPACK_IMPORTED_MODULE_3__.FloatMatrix(3, count));\r\n    }\r\n    static fromList(vecs) {\r\n        let length = vecs.length;\r\n        let multi = MultiVector3.new(length);\r\n        multi.fillFromList(vecs);\r\n        return multi;\r\n    }\r\n    static fromNative(native) {\r\n        // assume all subarrays have the same shape!!\r\n        return new MultiVector3(_FloatMatrix__WEBPACK_IMPORTED_MODULE_3__.FloatMatrix.fromNative(native));\r\n    }\r\n    static fromData(data) {\r\n        let multi = MultiVector3.new(data.length / 3);\r\n        multi._matrix.fillWith(data);\r\n        return multi;\r\n    }\r\n    static fromMatrix(data) {\r\n        if (data.width != 3) {\r\n            throw new Error(\"incorrect.\");\r\n        }\r\n        return new MultiVector3(data);\r\n    }\r\n    // pass through\r\n    get width() {\r\n        return this._matrix.width;\r\n    }\r\n    get height() {\r\n        return this._matrix.height;\r\n    }\r\n    get dimensions() {\r\n        return this._matrix.width;\r\n    }\r\n    get count() {\r\n        return this._matrix.height;\r\n    }\r\n    get matrix() {\r\n        return this._matrix;\r\n    }\r\n    setXYZ(i, x, y, z) {\r\n        this._matrix.data[i * this.width + 0] = x;\r\n        this._matrix.data[i * this.width + 1] = y;\r\n        this._matrix.data[i * this.width + 2] = z;\r\n    }\r\n    set(i, vec) {\r\n        this._matrix.data[i * this.width + 0] = vec.x;\r\n        this._matrix.data[i * this.width + 1] = vec.y;\r\n        this._matrix.data[i * this.width + 2] = vec.z;\r\n    }\r\n    get(i) {\r\n        return new _math_Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3(this._matrix.data[i * this.width + 0], this._matrix.data[i * this.width + 1], this._matrix.data[i * this.width + 2]);\r\n    }\r\n    /**\r\n     * this copies the data to an existing vector\r\n     */\r\n    getCopy(vec, i) {\r\n        vec.x = this._matrix.data[i * this.width + 0];\r\n        vec.y = this._matrix.data[i * this.width + 1];\r\n        vec.z = this._matrix.data[i * this.width + 2];\r\n    }\r\n    slice() {\r\n        return this._matrix;\r\n    }\r\n    fillFromList(vecs) {\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            this.set(i, vecs[i]);\r\n        }\r\n    }\r\n    forEach(callbackfn) {\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            vec = callbackfn(vec, i);\r\n            if (vec instanceof _math_Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3) {\r\n                this.set(i, vec);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    take(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.set(i, this.get(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    takeRange(start, end) {\r\n        let array = MultiVector3.new(end - start);\r\n        let j = 0;\r\n        for (let i = start; i < end; i++) {\r\n            array.set(j, this.get(i));\r\n            j++;\r\n        }\r\n        return array;\r\n    }\r\n    map(callbackfn) {\r\n        let clone = this.clone();\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            let result = callbackfn(vec, i);\r\n            clone.set(i, result);\r\n        }\r\n        return clone;\r\n    }\r\n    mapWith(other, callback) {\r\n        let result = this._matrix.mapWith(other._matrix, callback);\r\n        return new MultiVector3(result);\r\n    }\r\n    toList() {\r\n        let vecs = [];\r\n        for (let i = 0; i < this.height; i++) {\r\n            vecs.push(this.get(i));\r\n        }\r\n        return vecs;\r\n    }\r\n    to2D() {\r\n        let vec2 = _MultiVector2__WEBPACK_IMPORTED_MODULE_4__.MultiVector2.new(this.count);\r\n        this.forEach((v, i) => {\r\n            vec2.setXY(i, v.x, v.y);\r\n        });\r\n        return vec2;\r\n    }\r\n    mean() {\r\n        // the mean vector of a series of vectors\r\n        let sum = _math_Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3.zero();\r\n        let count = this.count;\r\n        for (let i = 0; i < count; i++) {\r\n            sum.x += this._matrix.data[i * 3];\r\n            sum.y += this._matrix.data[i * 3 + 1];\r\n            sum.z += this._matrix.data[i * 3 + 2];\r\n        }\r\n        return sum.scale(1 / count);\r\n    }\r\n    average() {\r\n        return this.mean();\r\n    }\r\n    closestId(point) {\r\n        let lowScore = Infinity;\r\n        let id = -1;\r\n        this.forEach((v, i) => {\r\n            let disSquared = point.disToSquared(v);\r\n            if (disSquared < lowScore) {\r\n                lowScore = disSquared;\r\n                id = i;\r\n            }\r\n        });\r\n        return id;\r\n    }\r\n    closestIds(point, n) {\r\n        // O(m*n)... TODO implement quicksort\r\n        let ids = [];\r\n        for (let i = 0; i < n; i++) {\r\n            let lowScore = Infinity;\r\n            let id = -1;\r\n            this.forEach((v, i) => {\r\n                if (ids.includes(id))\r\n                    return;\r\n                let disSquared = point.disToSquared(v);\r\n                if (disSquared < lowScore) {\r\n                    lowScore = disSquared;\r\n                    id = i;\r\n                }\r\n            });\r\n            ids.push(id);\r\n        }\r\n        return ids;\r\n    }\r\n    clone() {\r\n        return new MultiVector3(this._matrix.clone());\r\n    }\r\n    transform(m) {\r\n        // THIS CAN BE SPEED UP: BOTH MATRIX 4 & VECTOR3ARRAY ARE JUST FLOAT-MATRICES\r\n        // this.matrix = calc(this.matrix, m);\r\n        // I DONT KNOW WHY, BUT THIS IS QUICKER THAN MATRIX MULTIPLICATION\r\n        for (let i = 0; i < this.height; i++) {\r\n            let vec = this.get(i);\r\n            vec = m.multiplyVector(vec);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n        // // this.data = m.MultiplyM(this).data;\r\n    }\r\n    move(v) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            let vec = this.get(i);\r\n            vec.add(v);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    scale(s) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            let vec = this.get(i);\r\n            vec.mul(s);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        return new MultiVector3(calc(this._matrix, m));\r\n    }\r\n    moved(m) {\r\n        let mover = _math_Matrix4__WEBPACK_IMPORTED_MODULE_1__.Matrix4.newTranslate(m);\r\n        return this.transformed(mover);\r\n    }\r\n    scaled(s) {\r\n        let scaler = _math_Matrix4__WEBPACK_IMPORTED_MODULE_1__.Matrix4.newScaler(s.x, s.y, s.z);\r\n        return this.transformed(scaler);\r\n    }\r\n}\r\nfunction calc(a, b) {\r\n    // we need to do something ugly here, because of the 4th column...\r\n    // and while im at it, I specified the rest of the values as well, for speed's sake\r\n    let product = new _FloatMatrix__WEBPACK_IMPORTED_MODULE_3__.FloatMatrix(b.width, a.height);\r\n    for (var i = 0; i < a.height; i++) {\r\n        for (var j = 0; j < 4; j++) {\r\n            for (var k = 0; k < 3; k++) {\r\n                product.set(i, j, product.get(i, j) + a.get(i, k) * b.get(k, j));\r\n            }\r\n            product.set(i, j, product.get(i, j) + 1 * b.get(3, j));\r\n        }\r\n    }\r\n    return product;\r\n}\r\n// function benchmark2() {\r\n//     let sw = Stopwatch.new();\r\n//     let count = 1000000;\r\n//     let mv = MultiVector3.new(count);\r\n//     let rng = Random.fromSeed(1337);\r\n//     for (let i = 0; i < count; i++) {\r\n//         mv.set(i, Vector3.fromRandomUnit(rng));\r\n//     }\r\n//     sw.log(\"v1: init\");\r\n//     let vecs = Array<Vector3>(count);\r\n//     for (let i = 0; i < count; i++) {\r\n//         vecs[i] = Vector3.fromRandomUnit(rng);\r\n//     }\r\n//     sw.log(\"v2: init\");\r\n//     let vecs3 = Array<Vector3>();\r\n//     for (let i = 0; i < count; i++) {\r\n//         vecs3.push(Vector3.fromRandomUnit(rng));\r\n//     }\r\n//     sw.log(\"v3: init\");\r\n//     // v1: init took: 123 ms\r\n//     // v2: init took: 184 ms\r\n//     // v3: init took: 469 ms\r\n//     // conclusion: MultiVector3 works as intended!\r\n// }\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/MultiVector3.ts?");

/***/ }),

/***/ "../engine/src/data/Pool.ts":
/*!**********************************!*\
  !*** ../engine/src/data/Pool.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pool\": () => (/* binding */ Pool)\n/* harmony export */ });\n// purpose: an object pool data structure. When indices need to stay consistent, but you still want to iterate through a list, you need a data structure like this.\r\nclass Pool {\r\n    constructor(_array, // set length buffer / array. This way, we are not dynamicly allocating anything. speed speed speed!\r\n    _limit = 0) {\r\n        this._array = _array;\r\n        this._limit = _limit;\r\n    }\r\n    static new(size) {\r\n        return new Pool(new Array(size));\r\n    }\r\n    add(item) {\r\n        // add at the first empty spot\r\n        for (let i = 0; i < this._array.length; i++) {\r\n            if (!this._array[i]) {\r\n                this._array[i] = item;\r\n                if (i > this._limit) {\r\n                    this._limit = i + 1;\r\n                }\r\n                return i;\r\n            }\r\n        }\r\n        // its full\r\n        return -1;\r\n    }\r\n    delete(item) {\r\n        // turn item into empty spot\r\n        for (let i = 0; i < this._limit; i++) {\r\n            let r = this._array[i];\r\n            if (r === item) {\r\n                this.deleteAt(i);\r\n                return true;\r\n            }\r\n        }\r\n        // couldnt be found\r\n        return false;\r\n    }\r\n    isValid(i) {\r\n        return i < 0 || i > this._array.length - 1;\r\n    }\r\n    deleteAt(i) {\r\n        // directly turn spot into empty spot\r\n        if (this.isValid(i)) {\r\n            this._array[i] = undefined;\r\n            return true;\r\n        }\r\n        // out of range\r\n        return false;\r\n    }\r\n    clean(callback) {\r\n        // remove all empty spots in between\r\n        let offset = 0;\r\n        for (let i = 0; i < this._limit; i++) {\r\n            if (!this._array[i]) {\r\n                offset -= 1;\r\n            }\r\n            else {\r\n                this._array[i + offset] = this._array[i];\r\n                callback(i + offset, i); // this can be used to clean something else alongside this one.\r\n            }\r\n        }\r\n    }\r\n    reset() {\r\n        // set everything to default\r\n        this._array = new Array(this._array.length);\r\n        this._limit = 0;\r\n    }\r\n    iter(callback) {\r\n        for (let i = 0; i < this._limit; i++) {\r\n            if (this._array[i]) {\r\n                callback(i, this._array[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/data/Pool.ts?");

/***/ }),

/***/ "../engine/src/dom/IO.ts":
/*!*******************************!*\
  !*** ../engine/src/dom/IO.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IO\": () => (/* binding */ IO),\n/* harmony export */   \"addDropFileEventListeners\": () => (/* binding */ addDropFileEventListeners),\n/* harmony export */   \"loadTextFromFile\": () => (/* binding */ loadTextFromFile),\n/* harmony export */   \"loadJSONFromFile\": () => (/* binding */ loadJSONFromFile),\n/* harmony export */   \"loadImageFromFile\": () => (/* binding */ loadImageFromFile),\n/* harmony export */   \"loadImageFromBlob\": () => (/* binding */ loadImageFromBlob),\n/* harmony export */   \"loadImageFromSrc\": () => (/* binding */ loadImageFromSrc)\n/* harmony export */ });\n/* harmony import */ var _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/mesh/ShaderMesh */ \"../engine/src/geometry/mesh/ShaderMesh.ts\");\n/* harmony import */ var _image_Bitmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../image/Bitmap */ \"../engine/src/image/Bitmap.ts\");\n/* harmony import */ var _WebIO__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebIO */ \"../engine/src/dom/WebIO.ts\");\n// domwrappers.ts\r\n// author : Jos Feenstra\r\n// purpuse : wrap certain DOM functionalities\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nclass IO {\r\n    /**\r\n     * TODO catch\r\n     * @deprecated\r\n     */\r\n    static fetchJson(query) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return _WebIO__WEBPACK_IMPORTED_MODULE_2__.WebIO.getJson(query);\r\n        });\r\n    }\r\n    /**\r\n     * TODO catch\r\n     * @deprecated\r\n     */\r\n    static fetchText(query) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return _WebIO__WEBPACK_IMPORTED_MODULE_2__.WebIO.getText(query);\r\n        });\r\n    }\r\n    /**\r\n     * TODO catch\r\n     * @deprecated\r\n     */\r\n    static fetchBlob(query) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return _WebIO__WEBPACK_IMPORTED_MODULE_2__.WebIO.getBlob(query);\r\n        });\r\n    }\r\n    static findFile(files, fileName) {\r\n        for (let i = 0; i < files.length; i++) {\r\n            let file = files.item(i);\r\n            let name = file.name;\r\n            if (name == fileName) {\r\n                return file;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    static find(arr, predicate) {\r\n        for (let i = 0; i < arr.length; i++) {\r\n            if (predicate(arr[i], i, arr)) {\r\n                return arr[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * A dumb hack to trigger a file download\r\n     */\r\n    static promptDownload(file, text) {\r\n        var element = document.createElement(\"a\");\r\n        element.setAttribute(\"href\", \"data:text/plain;charset=utf-8, \" + encodeURIComponent(text));\r\n        element.setAttribute(\"download\", file);\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n    /**\r\n     * A dumb hack to trigger a file download\r\n     */\r\n    static promptDownloadImage(file, imageData) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let element = document.createElement(\"a\");\r\n            let image = yield imageDataToImage(imageData);\r\n            element.setAttribute(\"href\", image.src);\r\n            element.setAttribute(\"download\", file);\r\n            document.body.appendChild(element);\r\n            element.click();\r\n            document.body.removeChild(element);\r\n        });\r\n    }\r\n    /**\r\n     * A procedure specific to scans\r\n     * TODO : fix this\r\n     * @deprecated\r\n     */\r\n    static meshFromWeb(obj, textureBlob) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            console.log(\"reading json...\");\r\n            let texture = yield loadImageFromBlob(textureBlob);\r\n            let mesh = (0,_geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_0__.meshFromObj)(obj);\r\n            // flip texture horizontally -> this is needed for some inexplicable reason\r\n            // and put the flipped version in the mesh\r\n            let gi = _image_Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap.fromImageData(texture);\r\n            gi = gi.flipVer();\r\n            mesh.setTexture(gi.toImageData());\r\n            return mesh;\r\n        });\r\n    }\r\n    static addDropFileEventListeners(canvas, filesCallback) {\r\n        return addDropFileEventListeners(canvas, filesCallback);\r\n    }\r\n    static loadImageFromSrc(src) {\r\n        return new Promise(function (resolve, reject) {\r\n            let img = document.createElement(\"img\");\r\n            img.src = src;\r\n            img.onload = () => resolve(imageToImageData(img));\r\n            img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n        });\r\n    }\r\n}\r\n//@depricated\r\nfunction addDropFileEventListeners(canvas, filesCallback) {\r\n    console.log(\"setting up drag events...\");\r\n    canvas.addEventListener(\"dragenter\", function (ev) {\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"entering entering...\");\r\n        return true;\r\n    }, true);\r\n    // setup file upload\r\n    canvas.addEventListener(\"dragover\", function (ev) {\r\n        //add hover class when drag over\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"over drag....\");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener(\"dragleave\", function (ev) {\r\n        //remove hover class when drag out\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"leaving drag....\");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener(\"drop\", function (ev) {\r\n        //prevent browser from open the file when drop off\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n        //retrieve uploaded files data\r\n        var files = ev.dataTransfer.files;\r\n        filesCallback(files);\r\n        return true;\r\n    }, true);\r\n}\r\n//@depricated\r\nfunction loadTextFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(reader.result);\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\n//@depricated\r\nfunction loadJSONFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(JSON.parse(reader.result));\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\n//@depricated\r\nfunction loadImageFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(file);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\n//@depricated\r\nfunction loadImageFromBlob(blob) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(blob);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\n//@depricated\r\nfunction loadImageFromSrc(src) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement(\"img\");\r\n        img.crossOrigin = \"Anonymous\";\r\n        img.src = src;\r\n        img.onload = () => resolve(imageToImageData(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction loadImageHelper1(fileReader) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement(\"img\");\r\n        img.src = fileReader.result;\r\n        img.crossOrigin = \"Anonymous\";\r\n        img.onload = () => resolve(imageToImageData(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction imageToImageData(image) {\r\n    var _a;\r\n    // turn it into image data by building a complete canvas and sampling it\r\n    let canvas = document.createElement(\"canvas\");\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    let ctx = canvas.getContext(\"2d\");\r\n    ctx.drawImage(image, 0, 0);\r\n    let data = ctx.getImageData(0, 0, image.width, image.height);\r\n    (_a = canvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(canvas);\r\n    return data;\r\n}\r\nfunction imageDataToImage(imagedata) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        var canvas = document.createElement('canvas');\r\n        var ctx = canvas.getContext('2d');\r\n        canvas.width = imagedata.width;\r\n        canvas.height = imagedata.height;\r\n        ctx.putImageData(imagedata, 0, 0);\r\n        var image = new Image();\r\n        image.src = canvas.toDataURL(\"image/png\");\r\n        return new Promise(function (resolve, reject) {\r\n            image.onload = () => resolve(image);\r\n            image.onerror = () => reject(new Error(`could not convert image data to image`));\r\n        });\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/dom/IO.ts?");

/***/ }),

/***/ "../engine/src/dom/UI.ts":
/*!*******************************!*\
  !*** ../engine/src/dom/UI.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UI\": () => (/* binding */ UI)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parametric/EnumParameter */ \"../engine/src/parametric/EnumParameter.ts\");\n/* harmony import */ var _parametric_Parameter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parametric/Parameter */ \"../engine/src/parametric/Parameter.ts\");\n// name:    ui.js\r\n// author:  Jos Feenstra\r\n// purpose: lets create the UI using html & dom api, because why the hell not\r\n\r\n\r\n\r\nclass UI {\r\n    constructor(frame) {\r\n        this.globalContext = frame;\r\n        this.currentContext = frame;\r\n    }\r\n    static new(frame) {\r\n        return new UI(frame);\r\n    }\r\n    // the context system makes sure that ui additions appear under the currently active,\r\n    // selected app, and that these ui elements are removed when switching to another app.\r\n    toggleVisibility() {\r\n        // simple toggle\r\n        if (this.globalContext.hidden) {\r\n            this.show();\r\n        }\r\n        else {\r\n            this.hide();\r\n        }\r\n    }\r\n    clear() {\r\n        let context = this.currentContext;\r\n        while (context.hasChildNodes()) {\r\n            context.removeChild(context.lastChild);\r\n        }\r\n    }\r\n    hide() {\r\n        this.globalContext.hidden = true;\r\n    }\r\n    show() {\r\n        this.globalContext.hidden = false;\r\n    }\r\n    addContext(appName) {\r\n        this.currentContext = this.globalContext;\r\n        let appDiv = this.addDiv(appName + \" app-interface\");\r\n        this.currentContext = appDiv;\r\n    }\r\n    setContext(appName) {\r\n        let appDiv = this.globalContext.querySelector(\".\" + appName);\r\n        this.currentContext = appDiv;\r\n    }\r\n    removeContext(appName) {\r\n        this.setContext(appName);\r\n        let count = this.currentContext.childElementCount;\r\n        for (let i = count - 1; i >= 0; i -= 1) {\r\n            this.currentContext.removeChild(this.currentContext.children.item(i));\r\n        }\r\n        let temp = this.currentContext;\r\n        this.currentContext = this.globalContext;\r\n        this.currentContext.removeChild(temp);\r\n    }\r\n    addElement(element, className = \"\") {\r\n        let el = document.createElement(element);\r\n        el.className = className;\r\n        this.currentContext.appendChild(el);\r\n        return el;\r\n    }\r\n    addDiv(classname, items = []) {\r\n        let div = this.addElement(\"div\", classname);\r\n        items.forEach((item) => {\r\n            div.appendChild(item);\r\n        });\r\n        return div;\r\n    }\r\n    addBooleanParameter(param, onInput = () => { }) {\r\n        // create hacky button\r\n        // <label class=\"check-container\">\r\n        //   <input type=\"checkbox\" checked=\"checked\">\r\n        //   <span class=\"checkmark\"></span>\r\n        // </label>\r\n        let checkbox = this.addElement(\"input\", \"checkbox\");\r\n        checkbox.type = \"checkbox\";\r\n        checkbox.addEventListener(\"change\", () => {\r\n            let state = checkbox.checked;\r\n            param.set(state ? 1 : 0);\r\n            onInput(checkbox.valueAsNumber);\r\n            text1.innerText = param.name;\r\n        });\r\n        checkbox.checked = param.get() == 1;\r\n        // this needs to be done to make css happy\r\n        let checkcontainer = this.addElement(\"label\", \"check-container\");\r\n        let checkmark = this.addElement(\"span\", \"checkmark\");\r\n        checkcontainer.appendChild(checkbox);\r\n        checkcontainer.appendChild(checkmark);\r\n        // text\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        text1.innerText = param.name;\r\n        // TODO update beyond our control\r\n        // param.onset = () => {\r\n        //     // console.log(\"TODO\");\r\n        // };\r\n        this.addDiv(\"control\", [text1, checkcontainer]);\r\n        return checkbox;\r\n    }\r\n    add3DParameter(name, bounds, step, vec, onChange) {\r\n        let v = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        this.addParameter(new _parametric_Parameter__WEBPACK_IMPORTED_MODULE_2__.Parameter(name + \"-x\", vec.x, bounds.x.t0, bounds.x.t1, step), (x) => {\r\n            vec.x = x;\r\n            if (onChange) {\r\n                onChange();\r\n            }\r\n        });\r\n        this.addParameter(new _parametric_Parameter__WEBPACK_IMPORTED_MODULE_2__.Parameter(name + \"-y\", vec.y, bounds.y.t0, bounds.y.t1, step), (y) => {\r\n            vec.y = y;\r\n            if (onChange) {\r\n                onChange();\r\n            }\r\n        });\r\n        this.addParameter(new _parametric_Parameter__WEBPACK_IMPORTED_MODULE_2__.Parameter(name + \"-z\", vec.z, bounds.z.t0, bounds.z.t1, step), (z) => {\r\n            vec.z = z;\r\n            if (onChange) {\r\n                onChange();\r\n            }\r\n        });\r\n    }\r\n    addParameter(param, onInput = () => { }) {\r\n        let p;\r\n        if (param instanceof _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_1__.EnumParameter) {\r\n            p = param.p;\r\n        }\r\n        else {\r\n            p = param;\r\n        }\r\n        // create slider itself\r\n        let slider = this.addRangeInput(p, onInput);\r\n        // create slider title\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        text1.innerText = p.name;\r\n        // create slider value indicator\r\n        let text2 = this.addElement(\"p\", \"control-value\");\r\n        if (param instanceof _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_1__.EnumParameter) {\r\n            text2.innerText = param.getName();\r\n        }\r\n        else {\r\n            text2.innerText = slider.value;\r\n        }\r\n        // put them all together\r\n        this.addDiv(\"control\", [text1, slider, text2]);\r\n        // on reverse update\r\n        param.setSliderAndText(slider, text2);\r\n        // on update by user\r\n        slider.oninput = () => {\r\n            p.set(slider.valueAsNumber, false);\r\n            onInput(slider.valueAsNumber);\r\n            if (param instanceof _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_1__.EnumParameter) {\r\n                text2.innerText = param.getName();\r\n            }\r\n            else {\r\n                text2.innerText = slider.value;\r\n            }\r\n        };\r\n        return slider;\r\n    }\r\n    addColorParameter(name, startState, onInput = () => { }) {\r\n        // create hacky button\r\n        // <label class=\"check-container\">\r\n        //   <input type=\"checkbox\" checked=\"checked\">\r\n        //   <span class=\"checkmark\"></span>\r\n        // </label>\r\n        console.log(\"default\", startState);\r\n        let picker = this.addElement(\"input\", \"colorpicker\");\r\n        picker.type = \"color\";\r\n        picker.value = startState;\r\n        picker.addEventListener(\"change\", () => {\r\n            let state = picker.checked;\r\n            onInput(picker.value);\r\n        });\r\n        // text\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        text1.innerText = name;\r\n        // TODO update beyond our control\r\n        // param.onset = () => {\r\n        //     // console.log(\"TODO\");\r\n        // };\r\n        this.addDiv(\"control\", [text1, picker]);\r\n        return picker;\r\n    }\r\n    addRangeInput(param, onInput = () => { }) {\r\n        // a slider looks like this : <input type=\"range\" min=\"1\" max=\"100\" step=\"1\" value=\"50\">\r\n        let slider = this.addElement(\"input\", \"control-slider\");\r\n        slider.type = \"range\";\r\n        slider.min = param.min.toString();\r\n        slider.max = param.max.toString();\r\n        slider.valueAsNumber = param.state;\r\n        slider.step = param.step.toString();\r\n        return slider;\r\n    }\r\n    addText(text) {\r\n        let p = this.addElement(\"p\", \"ui-text\");\r\n        p.innerText = text;\r\n    }\r\n    addButton(name, callback) {\r\n        let button = this.addElement(\"button\", \"control-button\");\r\n        button.innerText = name;\r\n        button.addEventListener(\"click\", callback);\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        let control = this.addDiv(\"control\", [text1, button]);\r\n        return control;\r\n    }\r\n    addDropdown(enumParam, onchange) {\r\n        // <select>\r\n        //  <option>Cappuccino</option>\r\n        //  <option>Mocha</option>\r\n        // </select>\r\n        let count = enumParam.values.length;\r\n        let dropdownSelector = this.addElement(\"select\", \"enum-selector dropdown-select\");\r\n        for (let i = 0; i < count; i++) {\r\n            let o = this.addElement(\"option\", \"enum-item\");\r\n            o.innerText = enumParam.values[i];\r\n            dropdownSelector.appendChild(o);\r\n        }\r\n        // console.log(e);\r\n        dropdownSelector.addEventListener(\"change\", (e) => {\r\n            let target = e.target;\r\n            let i = target.selectedIndex;\r\n            enumParam.set(i);\r\n            onchange(i);\r\n        });\r\n        this.addDiv(\"dropdown-dark\", [dropdownSelector]);\r\n        return dropdownSelector;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/dom/UI.ts?");

/***/ }),

/***/ "../engine/src/dom/WebIO.ts":
/*!**********************************!*\
  !*** ../engine/src/dom/WebIO.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebIO\": () => (/* binding */ WebIO)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar WebIO;\r\n(function (WebIO) {\r\n    function postJson(url, json) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let res = yield fetch(url, { method: \"POST\", headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(json) });\r\n            return res;\r\n        });\r\n    }\r\n    WebIO.postJson = postJson;\r\n    /**\r\n     * Shorthand\r\n     * Fetch a url, and parse the response as json. will return empty object on encountering negative network responses\r\n     */\r\n    function getJson(url, headers = {}) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let res = yield fetch(url, { headers });\r\n            if (!res.ok) {\r\n                return {};\r\n            }\r\n            let data = yield res.json();\r\n            return data;\r\n        });\r\n    }\r\n    WebIO.getJson = getJson;\r\n    /**\r\n     * Shorthand\r\n     * Fetch a url, and parse the response as text. will return empty string on encountering negative network responses\r\n     */\r\n    function getText(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let res = yield fetch(url);\r\n            if (!res.ok) {\r\n                return \"\";\r\n            }\r\n            let data = yield res.text();\r\n            return data;\r\n        });\r\n    }\r\n    WebIO.getText = getText;\r\n    /**\r\n     * Shorthand\r\n     * Fetch a url, and parse the response as blobl. will return empty blob on encountering negative network responses\r\n     */\r\n    function getBlob(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let res = yield fetch(url);\r\n            if (!res.ok) {\r\n                return new Blob();\r\n            }\r\n            let data = yield res.blob();\r\n            return data;\r\n        });\r\n    }\r\n    WebIO.getBlob = getBlob;\r\n    /**\r\n     * Fetch a url as a blob, then process it to ImageData\r\n     * DOES NOT HANDLE ERRORS\r\n     *\r\n     * @param url\r\n     * @returns\r\n     */\r\n    function getImage(url) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let blob = yield getBlob(url);\r\n            let res = loadImageFromBlob(blob).catch((e) => {\r\n                return new ImageData(0, 0);\r\n            });\r\n            return res;\r\n        });\r\n    }\r\n    WebIO.getImage = getImage;\r\n    /////////////////////////////////////////////////////////////////////////// Private\r\n    function loadImageFromBlob(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            let reader = new FileReader();\r\n            reader.readAsDataURL(blob);\r\n            reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n        });\r\n    }\r\n    function loadImageHelper1(fileReader) {\r\n        return new Promise(function (resolve, reject) {\r\n            let img = document.createElement(\"img\");\r\n            img.src = fileReader.result;\r\n            img.crossOrigin = \"Anonymous\";\r\n            img.onload = () => resolve(loadImageHelper2(img));\r\n            img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n        });\r\n    }\r\n    function loadImageHelper2(image) {\r\n        var _a;\r\n        // turn it into image data by building a complete canvas and sampling it\r\n        let canvas = document.createElement(\"canvas\");\r\n        canvas.width = image.width;\r\n        canvas.height = image.height;\r\n        let ctx = canvas.getContext(\"2d\");\r\n        ctx.drawImage(image, 0, 0);\r\n        let data = ctx.getImageData(0, 0, image.width, image.height);\r\n        (_a = canvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(canvas);\r\n        return data;\r\n    }\r\n})(WebIO || (WebIO = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/dom/WebIO.ts?");

/***/ }),

/***/ "../engine/src/geometry/Geometry.ts":
/*!******************************************!*\
  !*** ../engine/src/geometry/Geometry.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Geometry\": () => (/* binding */ Geometry)\n/* harmony export */ });\n/* harmony import */ var _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix4 */ \"../engine/src/math/Matrix4.ts\");\n// name:    geo.ts\r\n// author:  Jos Feenstra\r\n// purpose: base class of all 3d geometry\r\n// note:    TODO\r\n\r\n// i want traits....\r\nclass Geometry {\r\n    rotateX(radians) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newXRotation(radians);\r\n        return this.transform(rotater);\r\n    }\r\n    rotateY(radians) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newYRotation(radians);\r\n        return this.transform(rotater);\r\n    }\r\n    rotateZ(radians) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newZRotation(radians);\r\n        return this.transform(rotater);\r\n    }\r\n    rotate(radians, axis) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newAxisRotation(axis, radians);\r\n        return this.transform(rotater);\r\n    }\r\n    move(m) {\r\n        let mover = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslate(m);\r\n        return this.transform(mover);\r\n    }\r\n    scale(s) {\r\n        let scaler = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newScaler(s.x, s.y, s.z);\r\n        return this.transform(scaler);\r\n    }\r\n    // all past-tense functions return a copied object, just like the vectors\r\n    rotatedX(radians) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newXRotation(radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    rotatedY(radians) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newYRotation(radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    rotatedZ(radians) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newZRotation(radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    rotated(radians, axis) {\r\n        let rotater = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newAxisRotation(axis, radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    moved(m) {\r\n        let mover = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslate(m);\r\n        return this.transformed(mover);\r\n    }\r\n    scaled(s) {\r\n        let scaler = _math_Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newScaler(s.x, s.y, s.z);\r\n        return this.transformed(scaler);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/Geometry.ts?");

/***/ }),

/***/ "../engine/src/geometry/Intersect.ts":
/*!*******************************************!*\
  !*** ../engine/src/geometry/Intersect.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    intersect.ts\r\n// author:  Jos Feenstra\r\n// purpose: intersection utility functions\r\n\r\n/**\r\n * @returns -1 if no intersection, 0 of parallel or touching, 1 if intersection;\r\n */\r\nfunction lineXplane(l1, l2, p1, p2, p3) {\r\n    let test1 = signed_volume(p1, p2, p3, l1);\r\n    let test2 = signed_volume(p1, p2, p3, l2);\r\n    if (Math.abs(test1) < _lib__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE || Math.abs(test2) < _lib__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n        return 0; // triangle touches plane with an edge\r\n    }\r\n    else if ((test1 < 0 && test2 > 0) || (test1 > 0 && test2 < 0)) {\r\n        return 1; // if 1 test pos and other negative -> line intersects plane!\r\n    }\r\n    else {\r\n        return -1; // no intersection\r\n    }\r\n}\r\n/**\r\n * Calculate if line and triangle intersect\r\n *\r\n * NOTE we could expand on the 'return 0' and explore if its touching a\r\n    vertex, line, or surface of triange\r\n * @returns 0  if line touches triangle\r\n            -1 if line misses  triangle\r\n             1  if line crosses triangle\r\n */\r\nfunction lineXtriangle(l1, l2, p1, p2, p3) {\r\n    // line points must be on opposite sides of the triangle\r\n    // return immidiately if -1: it means no intersection always\r\n    let test0 = lineXplane(l1, l2, p1, p2, p3);\r\n    if (test0 == -1)\r\n        return -1;\r\n    // plane tests\r\n    let test1 = lineXplane(p1, p2, l1, l2, p3);\r\n    if (test1 == -1)\r\n        return -1;\r\n    let test2 = lineXplane(p2, p3, l1, l2, p1);\r\n    if (test2 == -1)\r\n        return -1;\r\n    let test3 = lineXplane(p3, p1, l1, l2, p2);\r\n    if (test3 == -1)\r\n        return -1;\r\n    // debug\r\n    // print(\"points: \", l1, l2, p1, p2, p3)\r\n    // print('tests:', test0, test1, test2, test3)\r\n    // figure out if the line touches the triangle, or if it intersects\r\n    if (test0 == 1 && test1 == 1 && test2 == 1 && test3 == 1) {\r\n        return 1;\r\n    }\r\n    else {\r\n        // TODO based upon the different tests, we could determine what is hit\r\n        return 0;\r\n    }\r\n}\r\nfunction signed_volume(a, b, c, d) {\r\n    // with vertices a,b,c,d: get signed volume\r\n    // remember: vectors always remain state. We dont want to alter the abcd vectors.\r\n    a = a.clone();\r\n    b = b.clone();\r\n    c = c.clone();\r\n    return ((1 / 6) *\r\n        a\r\n            .clone()\r\n            .sub(d)\r\n            .dot(c.sub(d).cross(b.sub(d))));\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/Intersect.ts?");

/***/ }),

/***/ "../engine/src/geometry/curve/Bezier.ts":
/*!**********************************************!*\
  !*** ../engine/src/geometry/curve/Bezier.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bezier\": () => (/* binding */ Bezier),\n/* harmony export */   \"Cubez\": () => (/* binding */ Cubez)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Polynomial */ \"../engine/src/math/Polynomial.ts\");\n/* harmony import */ var _math_Random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Random */ \"../engine/src/math/Random.ts\");\n/* harmony import */ var _math_Util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Util */ \"../engine/src/math/Util.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _util_Stopwatch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../util/Stopwatch */ \"../engine/src/util/Stopwatch.ts\");\n/* harmony import */ var _Curve__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Curve */ \"../engine/src/geometry/curve/Curve.ts\");\n/* harmony import */ var _primitives_Plane__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../primitives/Plane */ \"../engine/src/geometry/primitives/Plane.ts\");\n// name:    bezier.ts\r\n// author:  Jos Feenstra\r\n// purpose: mathematical representation of a simple parametric curve\r\n// notes:   based upon the excellent explainations from Prof. C.-K. Shene: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Bezier extends _Curve__WEBPACK_IMPORTED_MODULE_9__.Curve {\r\n    constructor(verts, degree) {\r\n        super(verts, degree);\r\n    }\r\n    static fromList(verts) {\r\n        return this.new(_data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts));\r\n    }\r\n    static new(verts) {\r\n        return new Bezier(verts, verts.count - 1);\r\n    }\r\n    static equalizeDegrees(curves) {\r\n        // get highest degree\r\n        let maxDegree = 0;\r\n        for (let curve of curves) {\r\n            if (curve.degree > maxDegree) {\r\n                maxDegree = curve.degree;\r\n            }\r\n        }\r\n        // elevate each curve to that degree\r\n        for (let i = 0; i < curves.length; i++) {\r\n            let failsave = 0;\r\n            while (curves[i].degree < maxDegree && failsave < 100) {\r\n                curves[i] = curves[i].increaseDegree();\r\n                failsave++;\r\n            }\r\n        }\r\n        return curves;\r\n    }\r\n    /**\r\n     * Calculate the so-called hodograph of this curve, which is a curve representing all its tangents\r\n     */\r\n    hodograph() {\r\n        let hodoVerts = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.verts.count - 1);\r\n        for (let i = 0; i < this.verts.count - 1; i++) {\r\n            hodoVerts.set(i, this.verts.get(i + 1).subbed(this.verts.get(i)));\r\n        }\r\n        return Bezier.new(hodoVerts);\r\n    }\r\n    /**\r\n     * Return a new curve which is a copy of this curve, but with one added control point\r\n     * Do this recursively, and you have something like decastejau's\r\n     * However, this process cannot be rewritten as a polynomial, since the i / (n + 1) ratio changes every iteration\r\n     */\r\n    increaseDegree() {\r\n        // if (degree <= this.degree) {\r\n        //     console.warn(\"same or lower degree than my current degree...\");\r\n        //     return this.clone();\r\n        // }\r\n        // increase degree by one.\r\n        let n = this.degree;\r\n        let verts = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(n + 2);\r\n        // copy first and last\r\n        verts.set(0, this.verts.get(0));\r\n        verts.set(verts.count - 1, this.verts.get(this.verts.count - 1));\r\n        // interpolate in-betweens\r\n        for (let i = 1; i < n + 1; i++) {\r\n            let pa = this.verts.get(i - 1);\r\n            let pb = this.verts.get(i);\r\n            let sa = i / (n + 1);\r\n            let sb = 1 - sa;\r\n            let q = pa.scale(sa).add(pb.scale(sb));\r\n            verts.set(i, q);\r\n        }\r\n        // create a new curve from it\r\n        return Bezier.new(verts);\r\n    }\r\n    /**\r\n     * subdivide into to new bezier curves,\r\n     * with the same number of control points\r\n     */\r\n    splitAt(t) {\r\n        // get triangle\r\n        let size = this.degree + 1;\r\n        let tri = _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejau(this.verts, t);\r\n        // prepare\r\n        let left = _math_Util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleLeft(tri, size);\r\n        let right = _math_Util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleRight(tri, size);\r\n        return [Bezier.new(left), Bezier.new(right)];\r\n    }\r\n    /**\r\n     * Extends the curve\r\n     *\r\n     * ```js\r\n     * (part1, part2) = whole.split(0.5)\r\n     * assert_eq!(part1.extend(1) == whole)\r\n     * ```\r\n     */\r\n    extend(extra) {\r\n        // get the decastejau piramid based on extrapolation instead of interpolation\r\n        let piramid = _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejauExtrapolateEnd(this.verts, extra);\r\n        // the base of the piramid is the whole\r\n        let size = this.verts.count;\r\n        let base = _math_Util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleBase(piramid, size);\r\n        this.verts = base;\r\n    }\r\n    getExtention(extra) {\r\n        // get the decastejau piramid based on extrapolation instead of interpolation\r\n        let piramid = _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejauExtrapolateEnd(this.verts, extra);\r\n        // the base of the piramid is the whole\r\n        let size = this.verts.count;\r\n        let right = _math_Util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleRight(piramid, size);\r\n        return Bezier.new(right);\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    pointAt(t) {\r\n        let p = _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.zero();\r\n        for (let i = 0; i < this.degree + 1; i++) {\r\n            p.add(this.verts.get(i).scaled(_math_Polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.bernstein(t, i, this.degree)));\r\n        }\r\n        return p;\r\n    }\r\n    /**\r\n     * Calculate the tangent at parameter t.\r\n     * Tangent is calculated using a method described here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-der.html\r\n     * Note that is is not the fasted thing ever. Use the hodograph to eval a huge range of tangents if you desire that\r\n     */\r\n    tangentAt(t) {\r\n        // evaluate the so-called 'hodograph' of this curve\r\n        return this.hodograph().pointAt(t).normalize();\r\n    }\r\n    /**\r\n     * Calculate the normal at parameter t\r\n     */\r\n    normalAt(t, up = _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.unitZ()) {\r\n        return this.tangentAt(t).cross(up);\r\n    }\r\n    frameAt(t, up = _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.unitZ()) {\r\n        let p = this.pointAt(t);\r\n        let tan = this.tangentAt(t);\r\n        return _primitives_Plane__WEBPACK_IMPORTED_MODULE_10__.Plane.fromPVV(p, tan.cross(up), up);\r\n    }\r\n    /**\r\n     * Approximate the closest point with a wacky method\r\n     * partially taken from: https://stackoverflow.com/questions/2742610/closest-point-on-a-cubic-bezier-curve\r\n     *\r\n     * @param p\r\n     * @param precision 2 is very low res, 10 is maybe overkill\r\n     * @param tolerance\r\n     * @returns\r\n     */\r\n    ApproxClosestPoint(p, precision = 5, tolerance = _math_Const__WEBPACK_IMPORTED_MODULE_2__.Const.TOLERANCE) {\r\n        let disToParam = (t) => p.disToSquared(this.pointAt(t));\r\n        // NOTE:\r\n        // we can get away with this, because bezier curves are guaranteed\r\n        // to not 'spike' like any higher order polynomial might\r\n        let scans = precision * this.verts.count;\r\n        let lowest_value = Infinity;\r\n        let best_t = -1;\r\n        for (let i = 1; i < scans + 1; i++) {\r\n            let t = i / scans;\r\n            let value = disToParam(t);\r\n            if (value < lowest_value) {\r\n                lowest_value = value;\r\n                best_t = i;\r\n            }\r\n        }\r\n        // now, binary-search the smallest value\r\n        let t0 = Math.max((best_t - 1) / scans, 0);\r\n        let t1 = Math.min((best_t + 1) / scans, 1);\r\n        let domain = _lib__WEBPACK_IMPORTED_MODULE_1__.Domain.new(t0, t1);\r\n        let t = _math_Util__WEBPACK_IMPORTED_MODULE_5__.Util.lowestScore(domain, disToParam, tolerance);\r\n        return t;\r\n    }\r\n    /**\r\n     * NOTE: work in progress, I am trying a different method\r\n     */\r\n    uglyClosestPoint(p, precision = 4) {\r\n        // STEP 1 : get a number of suspect closest points.\r\n        let suspects = [];\r\n        let ts = [];\r\n        let addSuspect = (t) => {\r\n            suspects.push(this.pointAt(t));\r\n            ts.push(t);\r\n        };\r\n        // start and end are always suspect\r\n        addSuspect(this.domain.t0);\r\n        addSuspect(this.domain.t1);\r\n        // suspects are point 'v' whose tangents are 90 degrees towards the vector 'pv'\r\n        // in other words\r\n        // STEP 2 : get the actual closest suspect using pythagoras\r\n        let distance = Infinity;\r\n        let bestIdx = -1;\r\n        for (let i = 0; i < suspects.length; i++) {\r\n            let dis = p.disToSquared(suspects[i]);\r\n            if (dis < distance) {\r\n                distance = dis;\r\n                bestIdx = i;\r\n            }\r\n        }\r\n        return [suspects[bestIdx], ts[bestIdx]];\r\n    }\r\n    /**\r\n     * Note: All methods dealing with length are approximate\r\n     */\r\n    pointAtApproxLength(length) {\r\n        this.toPolyline(100).tAtLength(length);\r\n    }\r\n    getLazyApprox() {\r\n        if (!this._approx) {\r\n            this.bufferApprox();\r\n        }\r\n        return this._approx;\r\n    }\r\n    bufferApprox() {\r\n        this._approx = this.toPolyline(100);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    clone() {\r\n        return Bezier.new(this.verts.clone());\r\n    }\r\n    transform(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        return Bezier.new(this.verts.transformed(m));\r\n    }\r\n}\r\n// Shorthand for Cubic Bezier\r\nclass Cubez extends Bezier {\r\n    constructor(verts) {\r\n        super(verts, 3);\r\n    }\r\n    static new(verts) {\r\n        return new Cubez(verts);\r\n    }\r\n}\r\nfunction test(times = 1000) {\r\n    let sw = _util_Stopwatch__WEBPACK_IMPORTED_MODULE_8__.Stopwatch.new();\r\n    let bezier = Bezier.fromList([\r\n        _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.new(-2, -2, 0),\r\n        _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.new(-2, 2, 0),\r\n        _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.new(2, 2, 0),\r\n        _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.new(2, -2, 0),\r\n    ]);\r\n    let rng = _math_Random__WEBPACK_IMPORTED_MODULE_4__.Random.fromRandom();\r\n    let domain = _lib__WEBPACK_IMPORTED_MODULE_1__.Domain2.fromRadii(2, 2);\r\n    for (let i = 0; i < times; i++) {\r\n        let randomVec = _math_Vector3__WEBPACK_IMPORTED_MODULE_7__.Vector3.from2d(domain.elevate(_math_Vector2__WEBPACK_IMPORTED_MODULE_6__.Vector2.fromRandom(rng)));\r\n        bezier.ApproxClosestPoint(randomVec);\r\n    }\r\n    sw.log(`${times}x closest point`);\r\n    // 10000x closest point took: 144ms\r\n    // closest point takes approx. 0.0144ms on my machine\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/curve/Bezier.ts?");

/***/ }),

/***/ "../engine/src/geometry/curve/Curve.ts":
/*!*********************************************!*\
  !*** ../engine/src/geometry/curve/Curve.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Curve\": () => (/* binding */ Curve)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Domain */ \"../engine/src/math/Domain.ts\");\n/* harmony import */ var _math_Const__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _mesh_MultiLine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mesh/MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Geometry */ \"../engine/src/geometry/Geometry.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: base class for all parametric curves:\r\n// - Bezier\r\n// - Spline\r\n// - Polyline (not terminologically correct but in terms of logic it makes sense)\r\n\r\n\r\n\r\n\r\n\r\n\r\n// domain is always normalzed, from 0 to 1\r\nclass Curve extends _Geometry__WEBPACK_IMPORTED_MODULE_5__.Geometry {\r\n    constructor(verts, degree, domain = _math_Domain__WEBPACK_IMPORTED_MODULE_2__.Domain.new(0, 1)) {\r\n        super();\r\n        this.verts = verts;\r\n        this.degree = degree;\r\n        this.domain = domain;\r\n    }\r\n    toPolyline(segments) {\r\n        let count = segments + 1;\r\n        let verts = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let t = i / segments; // fraction\r\n            verts.set(i, this.pointAt(this.domain.elevate(t)));\r\n        }\r\n        return _lib__WEBPACK_IMPORTED_MODULE_1__.Polyline.new(verts);\r\n    }\r\n    buffer(segments = _math_Const__WEBPACK_IMPORTED_MODULE_3__.Const.BEZIER_SEGMENTS) {\r\n        return _mesh_MultiLine__WEBPACK_IMPORTED_MODULE_4__.MultiLine.fromPolyline(this.toPolyline(segments));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/curve/Curve.ts?");

/***/ }),

/***/ "../engine/src/geometry/curve/Polyline.ts":
/*!************************************************!*\
  !*** ../engine/src/geometry/curve/Polyline.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polyline\": () => (/* binding */ Polyline)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Curve */ \"../engine/src/geometry/curve/Curve.ts\");\n// name:    polyline.ts\r\n// author:  Jos Feenstra\r\n// purpose: Representation of a polyline.\r\n// Note: ive complicated this quite a bit, since we have to deal with the length of the polyline quite often.\r\n// I want to keep side effects to a minimum, so bufferLengths() needs to be called everytime the curve is changed in some way\r\n\r\n\r\nclass Polyline extends _Curve__WEBPACK_IMPORTED_MODULE_1__.Curve {\r\n    constructor(verts) {\r\n        super(verts, 1);\r\n        this.bufferLengths();\r\n    }\r\n    static fromList(verts) {\r\n        return this.new(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts));\r\n    }\r\n    static new(verts) {\r\n        return new Polyline(verts);\r\n    }\r\n    // ----- Special\r\n    /**\r\n     * create a new, filleted polyline\r\n     */\r\n    fillet(radius) {\r\n        let count = this.verts.count + (this.verts.count - 2);\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let j = Math.ceil(i / 2); // index in original\r\n            verts.set(i, this.verts.get(j));\r\n        }\r\n        return Polyline.new(verts);\r\n    }\r\n    // -----\r\n    pointAt(t) {\r\n        let count = this.verts.count - 1;\r\n        let p = t * count;\r\n        let idxA = Math.floor(p);\r\n        let idxB = Math.ceil(p);\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromLerp(this.verts.get(idxA), this.verts.get(idxB), p - idxA);\r\n    }\r\n    lengthAt(t) {\r\n        let lengths = this.getLazyLengths();\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.sample(lengths, t);\r\n    }\r\n    tAtLength(length) {\r\n        let lengths = this.getLazyLengths();\r\n        let [idxA, idxB] = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.between(lengths, length);\r\n        let [min, max] = [lengths[idxA], lengths[idxB]];\r\n        let f = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.fraction(length, min, max);\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(lengths[idxA], lengths[idxB], f);\r\n    }\r\n    length() {\r\n        return this.getLazyLengths()[this.verts.count - 1];\r\n    }\r\n    getLazyLengths() {\r\n        if (!this._lengths) {\r\n            this.bufferLengths();\r\n        }\r\n        return this._lengths;\r\n    }\r\n    bufferLengths() {\r\n        let count = this.verts.count;\r\n        let lengths = Array(count);\r\n        let acc = 0.0;\r\n        lengths[0] = acc;\r\n        for (let i = 0; i < count - 1; i++) {\r\n            acc += this.verts.get(i).disTo(this.verts.get(i + 1));\r\n            lengths[i + 1] = acc;\r\n        }\r\n        this._lengths = lengths;\r\n    }\r\n    buffer() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromPolyline(this);\r\n    }\r\n    // geo trait\r\n    clone() {\r\n        let b = Polyline.new(this.verts.clone());\r\n        return b;\r\n    }\r\n    transform(m) {\r\n        this._lengths = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._lengths = undefined; // invalidate buffered data\r\n        return Polyline.new(this.verts.transformed(m));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/curve/Polyline.ts?");

/***/ }),

/***/ "../engine/src/geometry/curve/Spline.ts":
/*!**********************************************!*\
  !*** ../engine/src/geometry/curve/Spline.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Spline\": () => (/* binding */ Spline)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _math_Domain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Domain */ \"../engine/src/math/Domain.ts\");\n/* harmony import */ var _math_Polynomial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Polynomial */ \"../engine/src/math/Polynomial.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _Bezier__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bezier */ \"../engine/src/geometry/curve/Bezier.ts\");\n/* harmony import */ var _Curve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Curve */ \"../engine/src/geometry/curve/Curve.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: B-Spline\r\n// NOTE:    [JF]: my spline implementation is not perfect.\r\n//                Due to behaviour of the coxdeboor algorithm which I dont fully understand,\r\n//                I am forced to create knots with very slight tolerances.\r\n//                This could create trouble down the road...\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * B-Spline\r\n */\r\nclass Spline extends _Curve__WEBPACK_IMPORTED_MODULE_5__.Curve {\r\n    constructor(verts, degree, knots, domain) {\r\n        super(verts, degree, domain);\r\n        this.knots = knots;\r\n    }\r\n    static fromList(verts, degree) {\r\n        return this.new(_data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts), degree);\r\n    }\r\n    static calcKnots(n, degree) {\r\n        // TODO incorporate domain parameters in here\r\n        let m = n + degree + 1; // m = n + p + 1\r\n        let knots = new Float32Array(m);\r\n        for (let i = 0; i < degree + 1; i++) {\r\n            knots[i] = 0 - (degree - i) * 0.0001;\r\n        }\r\n        let count = knots.length - degree - degree - 1;\r\n        let j = 1;\r\n        for (let i = degree + 1; i < knots.length - degree - 1; i++) {\r\n            knots[i] = j / count;\r\n            j++;\r\n        }\r\n        j = 0;\r\n        for (let i = knots.length - degree - 1; i < knots.length; i++) {\r\n            knots[i] = 1 + j * 0.0001;\r\n            j++;\r\n        }\r\n        return knots;\r\n    }\r\n    static new(verts, degree) {\r\n        let domain = _math_Domain__WEBPACK_IMPORTED_MODULE_1__.Domain.new(0, 1);\r\n        let n = verts.count;\r\n        if (n < degree + 1) {\r\n            return undefined;\r\n        }\r\n        let knots = this.calcKnots(n, degree);\r\n        return new Spline(verts, degree, knots, domain);\r\n    }\r\n    extend(extra) {\r\n        // create the last bit of this curve as a bezier curve\r\n        let count = this.degree + 1;\r\n        let points = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let j = this.verts.count - count + i;\r\n            points[i] = this.verts.get(j);\r\n        }\r\n        let bz = _Bezier__WEBPACK_IMPORTED_MODULE_4__.Bezier.fromList(points);\r\n        // extend it\r\n        bz.extend(extra);\r\n        // assign the vertices\r\n        for (let i = 0; i < count; i++) {\r\n            let j = this.verts.count - count + i;\r\n            this.verts.set(j, bz.verts.get(i));\r\n        }\r\n        return this;\r\n    }\r\n    // calculate a piece of bezier which extends this curve\r\n    getExtention(extra) {\r\n        // create the last bit of this curve as a bezier curve\r\n        let count = this.degree + 1;\r\n        let points = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            points[i] = this.verts.get(this.verts.count - count + i);\r\n        }\r\n        let bz = _Bezier__WEBPACK_IMPORTED_MODULE_4__.Bezier.fromList(points);\r\n        // get an extension from that\r\n        return bz.getExtention(extra);\r\n    }\r\n    pointAt(t) {\r\n        // console.clear();\r\n        // console.log(\"pointat\");\r\n        // console.log(\"knots:\", this.knots);\r\n        // console.log(\"degree: \", this.degree);\r\n        let p = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n        for (let i = 0; i < this.verts.count; i++) {\r\n            let factor = _math_Polynomial__WEBPACK_IMPORTED_MODULE_2__.Polynomial.coxdeboor(t, i, this.degree, this.knots);\r\n            // console.log(\"factor: \", factor);\r\n            p.add(this.verts.get(i).scaled(factor));\r\n        }\r\n        return p;\r\n    }\r\n    clone() {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    transform(m) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    transformed(m) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/curve/Spline.ts?");

/***/ }),

/***/ "../engine/src/geometry/mesh/Graph.ts":
/*!********************************************!*\
  !*** ../engine/src/geometry/mesh/Graph.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graph\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _data_HashTable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/HashTable */ \"../engine/src/data/HashTable.ts\");\n/* harmony import */ var _primitives_Plane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/Plane */ \"../engine/src/geometry/primitives/Plane.ts\");\n/* harmony import */ var _math_Const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Mesh */ \"../engine/src/geometry/mesh/Mesh.ts\");\n/* harmony import */ var _ShaderMesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShaderMesh */ \"../engine/src/geometry/mesh/ShaderMesh.ts\");\n// name: graph.ts\r\n// author:  Jos Feenstra\r\n// purpose: HalfEdge Mesh in 3D.\r\n// This does mean that the order around a vertex is not staight forward, and must be handled using normals.\r\n// TODO\r\n// - graph clean\r\n// - graph delete vert\r\n// - to line renderable\r\n// - keep track of faces, for quick meshification\r\n//   - THIS WILL SPEED UP 'GET ALL FACES THREMENDOUSLY, WHICH WILL SPEED UP SUBDIVISONS'\r\n// - remove ambiguity of halfedges & edges\r\n//   - fix the fact that we 'dont' realllly use halfedges, we consistently use pairs of two.\r\n//   - aka, twins are implicit: 0 -> 1 & 1 -> 0 OR 21 -> 20 & 20 -> 21\r\n\r\n\r\n\r\n\r\n\r\n\r\n// FACES MUST BE CONVEX, OR BUGS MIGHT OCCUR!!!!\r\n// interface Face {\r\n//    edge: EdgeIndex,\r\n// }\r\n// NOTE: create an interface which hides the Edge, Vert & Face interfaces.\r\n// NOTE: half edge is implied\r\nclass Graph {\r\n    constructor() {\r\n        this.verts = [];\r\n        this.edges = [];\r\n    }\r\n    static new() {\r\n        return new Graph();\r\n    }\r\n    static fromMesh(mesh) {\r\n        let graph = Graph.new();\r\n        let normals = mesh.OLDcalculateVertexNormals();\r\n        mesh.verts.forEach((v, i) => {\r\n            graph.addVert(v, normals[i]);\r\n        });\r\n        let type = mesh.getType();\r\n        if (type == _Mesh__WEBPACK_IMPORTED_MODULE_4__.MeshType.Invalid || type == _Mesh__WEBPACK_IMPORTED_MODULE_4__.MeshType.Points) {\r\n            return graph;\r\n        }\r\n        let map = new _data_HashTable__WEBPACK_IMPORTED_MODULE_0__.HashTable();\r\n        let width = mesh.links._width;\r\n        mesh.links.forEachRow((row, i) => {\r\n            // go through pairs\r\n            // NOTE: this can be done way easier by creating 1 half edge per pair\r\n            for (let i = 0; i < width; i++) {\r\n                let iNext = (i + 1) % width;\r\n                let a = row[i];\r\n                let b = row[iNext];\r\n                // console.log(a, b);\r\n                if (a == -1 || b == -1)\r\n                    continue;\r\n                graph.addEdgeIfNew(a, b);\r\n                // let normal = normals[a].add(normals[b]).normalize();\r\n                // if (map.has([a, b])) {\r\n                //     console.log(\"GOT IT ALREADY\")\r\n                //     continue;\r\n                // }\r\n                // graph.addEdgeWithCustomNormal(a, b, normal);\r\n                // map.set([b, a], true);\r\n                // graph.addEdge(a, b);\r\n            }\r\n        });\r\n        return graph;\r\n    }\r\n    // geometry trait\r\n    clone() {\r\n        throw new Error(\"not yet implemented...\");\r\n    }\r\n    transform(matrix) {\r\n        for (let i = 0; i < this.verts.length; i++) {\r\n            let v = this.verts[i];\r\n            v.pos = matrix.multiplyVector(v.pos);\r\n        }\r\n    }\r\n    // UTILITY\r\n    print() {\r\n        console.log(\"graph\");\r\n        console.log(\"--------\");\r\n        console.log(`${this.verts.length} verts: `);\r\n        for (let i = 0; i < this.verts.length; i++) {\r\n            let v = this.verts[i];\r\n            console.log(`v(${i}) | edge: ${v.edge}, data: ${v.pos.toString()} normal: ${v.normal.toString()}`);\r\n        }\r\n        console.log(\"--------\");\r\n        console.log(`${this.edges.length} edges:  `);\r\n        for (let i = 0; i < this.edges.length; i++) {\r\n            let e = this.edges[i];\r\n            console.log(`e(${i}) | vert: ${e.vert}, twin: ${e.twin}, next: ${e.next}, dead ${e.dead}`);\r\n        }\r\n        console.log(\"--------\");\r\n    }\r\n    // CONVERTERS\r\n    toMesh() {\r\n        return _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromGraph(this);\r\n    }\r\n    toLines() {\r\n        return _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.newLines(this.allVertPositions(), this.allUniqueEdgeVerts());\r\n    }\r\n    toShaderMesh() {\r\n        return _ShaderMesh__WEBPACK_IMPORTED_MODULE_5__.ShaderMesh.fromGraph(this);\r\n    }\r\n    // public getters\r\n    allNorms() {\r\n        let data = [];\r\n        this.verts.forEach((v) => {\r\n            data.push(v.normal);\r\n        });\r\n        return data;\r\n    }\r\n    allVertPositions() {\r\n        let data = [];\r\n        this.verts.forEach((v) => {\r\n            data.push(v.pos);\r\n        });\r\n        return data;\r\n    }\r\n    allUniqueEdges() {\r\n        let edges = [];\r\n        let count = this.edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let i1 = i * 2;\r\n            let i2 = i * 2 + 1;\r\n            let a = this.getEdge(i1);\r\n            let b = this.getEdge(i2);\r\n            if (a.dead || b.dead) {\r\n                continue;\r\n            }\r\n            edges.push(i1);\r\n        }\r\n        return edges;\r\n    }\r\n    allUniqueEdgeVerts() {\r\n        let edges = [];\r\n        let count = this.edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let i1 = i * 2;\r\n            let i2 = i * 2 + 1;\r\n            let a = this.getEdge(i1);\r\n            let b = this.getEdge(i2);\r\n            if (a.dead || b.dead) {\r\n                continue;\r\n            }\r\n            edges.push(a.vert, b.vert);\r\n        }\r\n        return edges;\r\n    }\r\n    allEdgeVerts() {\r\n        let data = [];\r\n        // let edges = new Map<number, number>()\r\n        this.edges.forEach((e, i) => {\r\n            if (e.dead)\r\n                return;\r\n            let a = e.vert;\r\n            let b = this.getEdge(e.twin).vert;\r\n            if (a < b) {\r\n                data.push(a);\r\n                data.push(b);\r\n            }\r\n        });\r\n        return data;\r\n    }\r\n    // allVertLoops(): IntMatrix {\r\n    //     throw \"TODO\";\r\n    // }\r\n    allVertLoopsAsInts() {\r\n        // TODO speed this up\r\n        let loops = [];\r\n        let unvisited = new Set();\r\n        this.edges.forEach((e, i) => {\r\n            if (e.dead) {\r\n                return;\r\n            }\r\n            unvisited.add(i);\r\n        });\r\n        let i = 0;\r\n        const limit = this.edges.length; // we will never visit an edge twice if all is according to plan\r\n        while (unvisited.size > 0) {\r\n            let loop = [];\r\n            let ei = unvisited.entries().next().value[0];\r\n            let start = ei;\r\n            do {\r\n                if (i > limit) {\r\n                    // this.print();\r\n                    throw \"topology is corrupt!\";\r\n                }\r\n                i += 1;\r\n                let e = this.getEdge(ei);\r\n                unvisited.delete(ei);\r\n                loop.push(e.vert);\r\n                ei = e.next;\r\n            } while (ei != start);\r\n            loops.push(loop);\r\n        }\r\n        return loops;\r\n    }\r\n    getLoop(ei) {\r\n        let loop = [];\r\n        let i = 0;\r\n        const limit = this.edges.length;\r\n        let start = ei;\r\n        do {\r\n            if (i > limit) {\r\n                // this.print();\r\n                throw \"topology is corrupt!\";\r\n            }\r\n            i += 1;\r\n            let e = this.getEdge(ei);\r\n            loop.push(ei);\r\n            ei = e.next;\r\n        } while (ei != start);\r\n        return loop;\r\n    }\r\n    getVertexPos(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw \"out of range\";\r\n        }\r\n        return this.verts[vi].pos;\r\n    }\r\n    getVertexNormal(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw \"out of range\";\r\n        }\r\n        return this.verts[vi].normal;\r\n    }\r\n    getVertexCount() {\r\n        return this.verts.length;\r\n    }\r\n    getHalfEdgeCount() {\r\n        return this.edges.length;\r\n    }\r\n    changeVertex(vi, pos, norm) {\r\n        let v = this.verts[vi];\r\n        v.pos = pos;\r\n        v.normal = norm;\r\n    }\r\n    getVert(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw \"out of range\";\r\n        }\r\n        return this.verts[vi];\r\n    }\r\n    getEdge(ei) {\r\n        if (ei < 0 || ei >= this.edges.length) {\r\n            console.error(\"out of range\");\r\n        }\r\n        return this.edges[ei];\r\n    }\r\n    getEdgeIndexBetween(ai, bi) {\r\n        let res = this.getEdgeBetween(ai, bi);\r\n        if (res)\r\n            return this.getEdgeIndex(res);\r\n        return undefined;\r\n    }\r\n    getEdgeBetween(ai, bi) {\r\n        let edges = this.getVertEdgeFan(ai);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            if (this.getEdge(edges[i].twin).vert == bi) {\r\n                return edges[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    getVertEdgeFan(vi) {\r\n        // get all edges connected to this vertex.\r\n        // NOTE: all are outgoing (e.vert == vi)\r\n        // console.log(\"getting fan\");\r\n        let fan = [];\r\n        let v = this.verts[vi];\r\n        let ei = v.edge;\r\n        let start = ei;\r\n        if (ei == -1) {\r\n            return fan;\r\n        }\r\n        let count = 0;\r\n        while (true) {\r\n            if (count > this.verts.length) {\r\n                this.print();\r\n                console.log(\"fan: \", fan);\r\n                throw \"nope\";\r\n            }\r\n            count += 1;\r\n            // console.log(\"step\", count, \"ei\", ei);\r\n            let e = this.getEdge(ei);\r\n            let e_twin = this.getEdgeTwin(ei);\r\n            fan.push(e);\r\n            ei = e_twin.next;\r\n            if (ei == start) {\r\n                break;\r\n            }\r\n        }\r\n        // console.log(\"returning fan: \", fan);\r\n        return fan;\r\n    }\r\n    getLoopsAdjacentToEdge(ei) {\r\n        let loops = [];\r\n        loops.push(this.getLoop(ei));\r\n        loops.push(this.getLoop(this.getEdge(ei).twin));\r\n        return loops;\r\n    }\r\n    getVertNeighbors(vi) {\r\n        let ids = [];\r\n        this.getVertEdgeFan(vi).forEach((e) => {\r\n            ids.push(this.getEdge(e.twin).vert);\r\n        });\r\n        return ids;\r\n    }\r\n    getEdgeIndex(e) {\r\n        return this.getEdge(e.twin).twin;\r\n    }\r\n    getEdgeTwin(ei) {\r\n        return this.edges[this.edges[ei].twin];\r\n    }\r\n    hasEdge(a, b) {\r\n        let nbs = this.getVertNeighbors(a);\r\n        return nbs.includes(b);\r\n    }\r\n    addVert(vector, normal) {\r\n        this.verts.push({ pos: vector, edge: -1, normal: normal, dead: false });\r\n        return this.verts.length - 1;\r\n    }\r\n    removeVert(a) {\r\n        throw \"TODO FIGURE OUT NULL & REMOVAL\";\r\n    }\r\n    addEdgeIfNew(a, b) {\r\n        if (!this.hasEdge(a, b)) {\r\n            // console.log(\"not there!\");\r\n            this.addEdge(a, b);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    addEdge(vi_1, vi_2) {\r\n        //             ei1\r\n        // / vi1 \\  ---------> / vi2 \\\r\n        // \\     / <---------  \\     /\r\n        //             ei2\r\n        let ei_1 = this.edges.length;\r\n        let ei_2 = ei_1 + 1;\r\n        this.edges.push({\r\n            next: -1,\r\n            twin: ei_2,\r\n            vert: vi_1,\r\n            dead: false,\r\n        });\r\n        this.edges.push({\r\n            next: -1,\r\n            twin: ei_1,\r\n            vert: vi_2,\r\n            dead: false,\r\n        });\r\n        // make sure the 'next' things are fixed, and more\r\n        this.addEdgeToDisk(vi_1, ei_1);\r\n        this.addEdgeToDisk(vi_2, ei_2);\r\n    }\r\n    deleteEdgeByIndex(id) {\r\n        // flag it as 'to be removed'\r\n        this.deleteEdge(this.getEdge(id));\r\n    }\r\n    deleteEdge(edge) {\r\n        // flag it as 'to be removed'\r\n        let twin = this.getEdge(edge.twin);\r\n        edge.dead = true;\r\n        twin.dead = true;\r\n        // remove all pointers\r\n        this.deleteEdgeFromDisk(edge);\r\n        this.deleteEdgeFromDisk(twin);\r\n    }\r\n    // SETTERS\r\n    getDiskPositions(ei) {\r\n        // returns edgeIndex before, edgeIndex after\r\n        let e = this.getEdge(ei);\r\n        let v = this.getVert(e.vert);\r\n        let twin = this.getEdgeTwin(ei);\r\n        let v_twin = this.verts[twin.vert];\r\n        let myVector = v.pos.subbed(v_twin.pos);\r\n        // get all vectors\r\n        let vectors = [];\r\n        vectors.push(myVector);\r\n        // get more vectors by getting all edges currently connected to vertex v\r\n        // if this Edge is already within the fan, filter it out, so this assessment can be correctly made\r\n        let edgesPotentiallyWithExistingEdge = this.getVertEdgeFan(e.vert);\r\n        let edges = [];\r\n        for (let i = 0; i < edgesPotentiallyWithExistingEdge.length; i++) {\r\n            let edge = edgesPotentiallyWithExistingEdge[i];\r\n            if (this.getEdgeIndex(edge) == ei) {\r\n                // console.log(\"edge is in the fan!\");\r\n            }\r\n            else {\r\n                edges.push(edge);\r\n            }\r\n        }\r\n        if (edges.length == 0) {\r\n            return [ei, ei];\r\n        }\r\n        if (edges.length == 1) {\r\n            let e = edges[0];\r\n            return [this.getEdgeIndex(e), this.getEdgeIndex(e)];\r\n        }\r\n        // console.log(\"edges\", edges);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            let edge = edges[i];\r\n            let twin = this.getEdge(edge.twin);\r\n            let neighbor = this.verts[twin.vert];\r\n            let neighborVector = v.pos.subbed(neighbor.pos);\r\n            vectors.push(neighborVector);\r\n        }\r\n        // console.log(\"all vectors: \", vectors);\r\n        // order them by 'wheel'\r\n        let plane = _primitives_Plane__WEBPACK_IMPORTED_MODULE_1__.Plane.fromPN(v.pos, v.normal);\r\n        let ihat = plane.ihat;\r\n        let jhat = plane.jhat;\r\n        let order = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.calculateWheelOrder(vectors, ihat, jhat);\r\n        // console.log(\"order\", order);\r\n        // find index 0 in the ordering. that is the position of this new edge. get the edges before and after this edge\r\n        let i_before = -1;\r\n        let i_after = -1;\r\n        for (let a = 0; a < order.length; a++) {\r\n            let b = (a + 1) % order.length;\r\n            let c = (a + 2) % order.length;\r\n            if (order[b] == 0) {\r\n                i_before = order[a];\r\n                i_after = order[c];\r\n                break;\r\n            }\r\n        }\r\n        // pick. NOTE: IF CCW / CC OF GRAPH NEEDS TO BE CHANGED, CHANGE THIS ORDER, BUT USE WITH CAUTION\r\n        // minus one, since we have 1 vector more than the edge list\r\n        let e_before = edges[i_after - 1];\r\n        let e_after = edges[i_before - 1];\r\n        return [this.getEdgeIndex(e_before), this.getEdgeIndex(e_after)];\r\n    }\r\n    addEdgeToDisk(vi, ei) {\r\n        let v = this.getVert(vi);\r\n        let twin = this.getEdgeTwin(ei);\r\n        if (v.edge == -1) {\r\n            // set two pointers:\r\n            v.edge = ei; // I am the vertex's first edge\r\n            twin.next = ei; // that means my twin points back to me\r\n        }\r\n        else {\r\n            let [ei_before, ei_after] = this.getDiskPositions(ei);\r\n            let [e_before, e_after] = [this.getEdge(ei_before), this.getEdge(ei_after)];\r\n            // set two pointers:\r\n            this.getEdge(e_before.twin).next = ei;\r\n            twin.next = this.getEdgeIndex(e_after);\r\n        }\r\n    }\r\n    deleteEdgeFromDisk(edge) {\r\n        let ei = this.getEdgeIndex(edge);\r\n        // console.log(\"deleting...\", ei);\r\n        let vert = this.getVert(edge.vert);\r\n        // console.log(\"deleting from disk...\");\r\n        let [ei_before, ei_after] = this.getDiskPositions(ei);\r\n        if (ei_before == ei) {\r\n            vert.edge = -1;\r\n            return;\r\n        }\r\n        // let flower = this.getVertEdgeFan(edge.vert);\r\n        // flower.forEach((e) => {console.log(this.getEdgeIndex(e))});\r\n        let [e_before, e_after] = [this.getEdge(ei_before), this.getEdge(ei_after)];\r\n        // set one pointer\r\n        // console.log(\"this is edge\", ei);\r\n        // // console.log(\"before is\", ei_before);\r\n        // console.log(\"after is\", ei_after);\r\n        // console.log(\"before.twin.next is\", this.getEdge(e_before.twin).next);\r\n        // console.log(\"after.twin.next is\", this.getEdge(e_after.twin).next);\r\n        this.getEdge(e_before.twin).next = ei_after;\r\n        if (vert.edge == ei) {\r\n            vert.edge = ei_after;\r\n        }\r\n    }\r\n    // MISC\r\n    splitEdge(ai, bi, alpha) {\r\n        // get the edge\r\n        let edge = this.getEdgeBetween(ai, bi);\r\n        if (!edge)\r\n            throw new Error(`No Edge found between ${ai} and ${bi}`);\r\n        let twin = this.getEdge(edge.twin);\r\n        let a = this.getVert(ai);\r\n        let b = this.getVert(bi);\r\n        let v = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromLerp(a.pos, b.pos, alpha);\r\n        let n = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromLerp(a.normal, b.normal, alpha);\r\n        let ci = this.addVert(v, n);\r\n        let c = this.getVert(ci);\r\n        // change the edges\r\n        // if (ai == 0) {\r\n        // }\r\n        this.deleteEdge(edge);\r\n        this.addEdge(ai, ci);\r\n        this.addEdge(ci, bi);\r\n        return ci;\r\n    }\r\n    subdivide() {\r\n        // 1. get all edges\r\n        let edges = this.allEdgeVerts();\r\n        let faces = this.allVertLoopsAsInts();\r\n        // this maps old edges to new vertices\r\n        let deadEdgeMap = new _data_HashTable__WEBPACK_IMPORTED_MODULE_0__.HashTable(); // this\r\n        // 2. split all edges, map\r\n        let count = edges.length / 2;\r\n        let middlePoints = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let vai = edges[i * 2];\r\n            let vbi = edges[i * 2 + 1];\r\n            // let edgeI = this.getEdgeIndexBetween(vai, vbi)!;\r\n            // let edgeII = this.getEdgeIndexBetween(vbi, vai)!;\r\n            let vci = this.splitEdge(vai, vbi, 0.5);\r\n            middlePoints[i] = vci;\r\n            deadEdgeMap.set([vai, vbi], vci);\r\n            deadEdgeMap.set([vbi, vai], vci);\r\n        }\r\n        // 3. per old face: connect the dots\r\n        for (let i = 0; i < faces.length; i++) {\r\n            let face = faces[i];\r\n            // get all middle points\r\n            let middlePoints = new Array(face.length);\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                let via = face[j];\r\n                let vib = face[jNext];\r\n                // console.log(via, vib);\r\n                middlePoints[j] = deadEdgeMap.get([via, vib]);\r\n            }\r\n            // console.log(middlePoints);\r\n            // connect the dots\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                this.addEdge(middlePoints[j], middlePoints[jNext]);\r\n            }\r\n        }\r\n    }\r\n    subdivideQuad() {\r\n        // 1. get all edges\r\n        let edges = this.allEdgeVerts();\r\n        let faces = this.allVertLoopsAsInts();\r\n        // this maps old edges to new vertices\r\n        let deadEdgeMap = new _data_HashTable__WEBPACK_IMPORTED_MODULE_0__.HashTable(); // this\r\n        // 2. split all edges, map\r\n        let count = edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let vai = edges[i * 2];\r\n            let vbi = edges[i * 2 + 1];\r\n            // let edgeI = this.getEdgeIndexBetween(vai, vbi)!;\r\n            // let edgeII = this.getEdgeIndexBetween(vbi, vai)!;\r\n            let vci = this.splitEdge(vai, vbi, 0.5);\r\n            deadEdgeMap.set([vai, vbi], vci);\r\n            deadEdgeMap.set([vbi, vai], vci);\r\n        }\r\n        // 3. per old face: connect the dots\r\n        for (let i = 0; i < faces.length; i++) {\r\n            let face = faces[i];\r\n            // get center point\r\n            let pos = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n            for (let j = 0; j < face.length; j++) {\r\n                pos.add(this.getVertexPos(face[j]));\r\n            }\r\n            pos.scale(1 / face.length);\r\n            let norm = calcPlanarFaceNormal(face.map((v) => this.getVertexPos(v)));\r\n            let si = this.addVert(pos, norm);\r\n            // per middle point, connect the dots\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                let via = face[j];\r\n                let vib = face[jNext];\r\n                // console.log(via, vib);\r\n                let c = deadEdgeMap.get([via, vib]);\r\n                this.addEdge(si, c);\r\n            }\r\n        }\r\n    }\r\n    forEveryEdgeVerts(callback) {\r\n        let edges = this.allUniqueEdgeVerts();\r\n        let edgeCount = edges.length / 2;\r\n        for (let i = 0; i < edgeCount; i++) {\r\n            let a = this.getVert(edges[i * 2]);\r\n            let b = this.getVert(edges[i * 2 + 1]);\r\n            callback(a.pos, b.pos);\r\n        }\r\n    }\r\n    meshify() {\r\n        // init result\r\n        let meshes = [];\r\n        // per quad\r\n        let loops = this.allVertLoopsAsInts();\r\n        for (let i = 0; i < loops.length; i++) {\r\n            const loop = loops[i];\r\n            if (loop.length < 3) {\r\n                console.log(\"invalids\");\r\n                continue;\r\n            }\r\n            let m;\r\n            if (loop.length == 3) {\r\n                let vecs = loop.map((j) => this.getVertexPos(j));\r\n                m = _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.newTriangle([vecs[0], vecs[1], vecs[2]]);\r\n            }\r\n            else {\r\n                let vecs = loop.map((j) => this.getVertexPos(j));\r\n                m = _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.newQuad([vecs[0], vecs[3], vecs[1], vecs[2]]);\r\n            }\r\n            meshes.push(m);\r\n        }\r\n        let rend = _Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromJoin(meshes);\r\n        return rend;\r\n    }\r\n}\r\nfunction calcPlanarFaceNormal(face) {\r\n    // ASSUMES : FACE = PLANAR & FACE = NOT SLIVER POLYGON (AREA > 0)\r\n    let count = face.length;\r\n    if (count < 3) {\r\n        throw \"cannot get face planar with 2 or less edges\";\r\n    }\r\n    // get the normal of a planar face\r\n    let normal = _math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n    // two edges could be parallel, but there will be two edges in the face that are different.\r\n    let ihat = face[1].subbed(face[0]);\r\n    let jhat = face[2].subbed(face[1]);\r\n    for (let i = 1; i < count; i++) {\r\n        if (Math.abs(ihat.dot(jhat)) > _math_Const__WEBPACK_IMPORTED_MODULE_2__.Const.TOLERANCE) {\r\n            return ihat.cross(jhat);\r\n        }\r\n        else {\r\n            // try again with next pair of\r\n            let i2 = (i + 1) % count;\r\n            let i3 = (i + 2) % count;\r\n            jhat = face[i3].subbed(face[i2]);\r\n        }\r\n    }\r\n    throw \"get planar face failed...\";\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/mesh/Graph.ts?");

/***/ }),

/***/ "../engine/src/geometry/mesh/Mesh.ts":
/*!*******************************************!*\
  !*** ../engine/src/geometry/mesh/Mesh.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshType\": () => (/* binding */ MeshType),\n/* harmony export */   \"NormalKind\": () => (/* binding */ NormalKind),\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh),\n/* harmony export */   \"quadToTri\": () => (/* binding */ quadToTri)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Math */ \"../engine/src/math/Math.ts\");\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Geometry */ \"../engine/src/geometry/Geometry.ts\");\n/* harmony import */ var _MultiLine__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n// mesh.ts\r\n// Author: Jos Feenstra\r\n// Purpose:\r\n// NOTE TO SELF: I would rather build a fat Mesh, than to distinquish between pure mesh, a shader mesh, Model, etc. etc.\r\n\r\n\r\n\r\n\r\nvar MeshType;\r\n(function (MeshType) {\r\n    MeshType[MeshType[\"Invalid\"] = 0] = \"Invalid\";\r\n    MeshType[MeshType[\"Points\"] = 1] = \"Points\";\r\n    MeshType[MeshType[\"Lines\"] = 2] = \"Lines\";\r\n    MeshType[MeshType[\"Triangles\"] = 3] = \"Triangles\";\r\n    MeshType[MeshType[\"Quads\"] = 4] = \"Quads\";\r\n})(MeshType || (MeshType = {}));\r\nvar NormalKind;\r\n(function (NormalKind) {\r\n    NormalKind[NormalKind[\"None\"] = 0] = \"None\";\r\n    NormalKind[NormalKind[\"Vertex\"] = 1] = \"Vertex\";\r\n    NormalKind[NormalKind[\"Face\"] = 2] = \"Face\";\r\n    NormalKind[NormalKind[\"MultiVertex\"] = 3] = \"MultiVertex\";\r\n})(NormalKind || (NormalKind = {}));\r\nclass Mesh extends _Geometry__WEBPACK_IMPORTED_MODULE_2__.Geometry {\r\n    constructor(verts, links, // relationships, can be 3 (triangles) | 4 (quads)\r\n    _uvs, _normals, _normalKind = NormalKind.None) {\r\n        super();\r\n        this.verts = verts;\r\n        this.links = links;\r\n        this._uvs = _uvs;\r\n        this._normals = _normals;\r\n        this._normalKind = _normalKind;\r\n    }\r\n    get maxSize() {\r\n        if (this.links) {\r\n            return this.links.data.length;\r\n        }\r\n        else {\r\n            return this.verts.count;\r\n        }\r\n    }\r\n    get uvs() {\r\n        return this._uvs;\r\n    }\r\n    get normals() {\r\n        return this._normals;\r\n    }\r\n    get normalKind() {\r\n        return this._normalKind;\r\n    }\r\n    setUvs(v, kind) {\r\n        this._uvs = v;\r\n        this._normalKind = kind;\r\n    }\r\n    setNormals(v) {\r\n        this._normals = v;\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////// Geometry Trait\r\n    clone() {\r\n        var _a, _b;\r\n        return new Mesh(this.verts.clone(), this.links.clone(), (_a = this._uvs) === null || _a === void 0 ? void 0 : _a.clone(), (_b = this._normals) === null || _b === void 0 ? void 0 : _b.clone(), this._normalKind);\r\n    }\r\n    transform(m) {\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        return this.clone().transform(m);\r\n    }\r\n    static new(verts, links, uvs, normals) {\r\n        return new Mesh(verts, links, uvs, normals);\r\n    }\r\n    static fromLists(verts, faces, uvs = [], normals = [], normalKind = NormalKind.None) {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts), _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList(faces, 3), _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList(uvs), _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(normals), normalKind);\r\n    }\r\n    static fromRawLists(verts, faces, uvs, normals, normalKind = NormalKind.None) {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromData(verts), _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList(faces, 3), _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData(uvs), _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromData(normals), normalKind);\r\n    }\r\n    static newEmpty(vertCount, linkCount, perLinkCount) {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount), new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(linkCount, perLinkCount));\r\n    }\r\n    static newLines(positions, edges) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(positions);\r\n        let links = _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList(edges, 2);\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromBiSurface(srf, uSegments = 10, vSegments = 10) {\r\n        // returns vertices & indices of a flat grid\r\n        let uPoints = uSegments + 1;\r\n        let vPoints = vSegments + 1;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(uPoints * vPoints);\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(uSegments * vSegments * 2, 3);\r\n        // create all positions\r\n        for (let u = 0; u < uPoints; u++) {\r\n            for (let v = 0; v < vPoints; v++) {\r\n                let i = u * vPoints + v;\r\n                verts.set(i, srf.pointAt(u / uSegments, v / vSegments));\r\n            }\r\n        }\r\n        // create all indices\r\n        // a---c\r\n        // | \\ |\r\n        // b---d\r\n        for (let u = 0; u < uSegments; u++) {\r\n            for (let v = 0; v < vSegments; v++) {\r\n                let start_index = 2 * (u * vSegments + v);\r\n                let a = u * uPoints + v;\r\n                let b = a + vPoints;\r\n                let c = a + 1;\r\n                let d = b + 1;\r\n                links.setRow(start_index, [a, b, d]);\r\n                links.setRow(start_index + 1, [c, a, d]);\r\n            }\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromTriSurface(srf, segments = 10) {\r\n        // returns vertices & indices of a flat grid\r\n        let uPoints = segments + 1;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_math_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(uPoints));\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(_math_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(uPoints), 3);\r\n        // // create all positions\r\n        // for (let u = 0; u < uPoints; u++) {\r\n        //     for (let v = 0; v < vPoints; v++) {\r\n        //         let i = u * vPoints + v;\r\n        //         verts.set(i, srf.pointAt(u / uSegments, v / vSegments));\r\n        //     }\r\n        // }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static zero() {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(0), new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(0, 0));\r\n    }\r\n    static fromJoin(meshes) {\r\n        // join meshes, dont try to look for duplicate vertices\r\n        // TODO : make this the trouble of Matrices and Arrays\r\n        let vertCount = 0;\r\n        let faceCount = 0;\r\n        for (let mesh of meshes) {\r\n            vertCount += mesh.verts.count;\r\n            faceCount += mesh.links.count();\r\n        }\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount);\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(faceCount, 3);\r\n        let accVerts = 0;\r\n        let accFaces = 0;\r\n        for (let mesh of meshes) {\r\n            for (let i = 0; i < mesh.verts.count; i++) {\r\n                verts.set(accVerts + i, mesh.verts.get(i));\r\n            }\r\n            for (let i = 0; i < mesh.links.count(); i++) {\r\n                let face = mesh.links.getRow(i);\r\n                for (let j = 0; j < face.length; j++) {\r\n                    face[j] = face[j] + accVerts;\r\n                }\r\n                links.setRow(accFaces + i, face);\r\n            }\r\n            accVerts += mesh.verts.count;\r\n            accFaces += mesh.links.count();\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromRectangle(rect) {\r\n        let verts = rect.getCorners();\r\n        // we cant handle quads yet\r\n        let faces = [];\r\n        faces.push(...quadToTri(cubeFaces[0]));\r\n        return this.fromLists(verts, faces);\r\n    }\r\n    static fromRectDoubleSided(rect, texture) {\r\n        let verts = rect.getCorners();\r\n        let uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData(new Float32Array([\r\n            0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        ]));\r\n        let faces = _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList([0, 1, 3, 0, 3, 2, 0, 3, 1, 0, 2, 3], 3);\r\n        let mesh = Mesh.new(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts), faces, uvs);\r\n        return mesh;\r\n    }\r\n    static newTriangle(corners) {\r\n        return this.fromLists(corners, [0, 1, 2]);\r\n    }\r\n    static newQuad(corners) {\r\n        let faces = [...quadToTri(cubeFaces[0])];\r\n        return this.fromLists(corners, faces);\r\n    }\r\n    static newOct(corners) {\r\n        let faces = [];\r\n        for (let face of cubeFaces) {\r\n            faces.push(...quadToTri(face));\r\n        }\r\n        return this.fromLists(corners, faces);\r\n    }\r\n    static fromCube(cube) {\r\n        let verts = cube.getCorners();\r\n        return Mesh.newOct(verts);\r\n    }\r\n    static newDefaultCube() {\r\n        let cube = new _lib__WEBPACK_IMPORTED_MODULE_0__.Cube(_lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY(), _lib__WEBPACK_IMPORTED_MODULE_0__.Domain3.fromRadius(0.5));\r\n        let verts = cube.getCorners();\r\n        return Mesh.newOct(verts);\r\n    }\r\n    static newIcosahedron(scale = 1) {\r\n        let graph = new _lib__WEBPACK_IMPORTED_MODULE_0__.Graph();\r\n        let a = scale;\r\n        let phi = (1 + Math.pow(5, 0.5)) / 2;\r\n        let b = a * phi;\r\n        let addVert = (v) => {\r\n            graph.addVert(v, v);\r\n        };\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-a, -b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(a, -b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-a, b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(a, b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -a, -b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, a, -b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -a, b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, a, b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b, 0, -a));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b, 0, a));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(b, 0, -a));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(b, 0, a));\r\n        // build edges\r\n        let addEdge = (a, b) => {\r\n            graph.addEdge(a, b);\r\n        };\r\n        for (let i = 0; i < 12; i += 4) {\r\n            addEdge(i + 0, i + 1);\r\n            addEdge(i + 2, i + 3);\r\n            let inext = (i + 4) % 12;\r\n            addEdge(i + 0, inext + 2);\r\n            addEdge(i + 0, inext + 0);\r\n            addEdge(i + 1, inext + 2);\r\n            addEdge(i + 1, inext + 0);\r\n            addEdge(i + 2, inext + 3);\r\n            addEdge(i + 2, inext + 1);\r\n            addEdge(i + 3, inext + 3);\r\n            addEdge(i + 3, inext + 1);\r\n        }\r\n        return this.fromGraph(graph);\r\n    }\r\n    // TODO remove center. Just move afterwards\r\n    static newSphere(center, radius, numRings, resolution) {\r\n        // verts\r\n        let vertCount = numRings * resolution + 2;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount);\r\n        let setVert = function (i, vector) {\r\n            verts.set(i, vector.scale(radius).add(center));\r\n        };\r\n        setVert(0, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1));\r\n        for (let ring = 0; ring < numRings; ring++) {\r\n            for (let perRing = 0; perRing < resolution; perRing++) {\r\n                let alpha = (Math.PI * (ring + 1)) / (numRings + 1);\r\n                let beta = (2 * Math.PI * perRing) / resolution;\r\n                let x = Math.sin(alpha) * Math.cos(beta);\r\n                let y = Math.sin(alpha) * Math.sin(beta);\r\n                let z = Math.cos(alpha);\r\n                let index = 1 + ring * resolution + perRing;\r\n                setVert(index, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z));\r\n            }\r\n        }\r\n        setVert(vertCount - 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1));\r\n        // faces\r\n        let faceCount = resolution * numRings * 2;\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(faceCount, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // faces top\r\n        for (let i = 0; i < resolution; i++) {\r\n            setFace(i, [0, i + 1, ((i + 1) % resolution) + 1]);\r\n        }\r\n        // faces middle\r\n        // we are at this cursor\r\n        // console.log(\"faces\", faceCount);\r\n        for (let ring = 0; ring < numRings - 1; ring++) {\r\n            let vertCursor = resolution * ring + 1;\r\n            let vertCursorBelow = vertCursor + resolution;\r\n            for (let perRing = 0; perRing < resolution; perRing++) {\r\n                let a = vertCursor + perRing;\r\n                let b = vertCursor + ((perRing + 1) % resolution);\r\n                let c = vertCursorBelow + perRing;\r\n                let d = vertCursorBelow + ((perRing + 1) % resolution);\r\n                let iFace = resolution + resolution * ring * 2 + perRing * 2;\r\n                // console.log(iFace);\r\n                setFace(iFace, [a, c, b]);\r\n                setFace(iFace + 1, [c, d, b]);\r\n            }\r\n        }\r\n        // faces bottom\r\n        for (let i = 0; i < resolution; i++) {\r\n            let iNext = (i + 1) % resolution;\r\n            let last = vertCount - 1;\r\n            let iFace = faceCount - resolution + i;\r\n            let zero = vertCount - resolution - 1;\r\n            let vertI = zero + i;\r\n            let vertINext = zero + iNext;\r\n            // console.log(iFace);\r\n            // console.log(\"face\", last, vertINext, vertI);\r\n            setFace(iFace, [last, vertINext, vertI]);\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    // TODO remove from & to, Just move the mesh afterwards\r\n    static newCylinder(from, to, radius, resolution) {\r\n        let normal = to.subbed(from);\r\n        let numVerts = resolution * 2 + 2;\r\n        let numFaces = (numVerts - 2) * 2;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(numVerts);\r\n        // some dumb stuff\r\n        let setVert = function (i, vector) {\r\n            verts.set(i, vector);\r\n        };\r\n        // planes to represent top & bottom\r\n        let planeFrom = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.fromPN(from, normal);\r\n        // console.log(planeFrom);\r\n        let planeTo = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.fromPN(to, normal);\r\n        // console.log(planeFrom);\r\n        // verts 'from ring\r\n        setVert(0, from);\r\n        for (let i = 0; i < resolution; i++) {\r\n            let v = new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos((Math.PI * 2 * i) / resolution), Math.sin((Math.PI * 2 * i) / resolution), 0).scale(radius);\r\n            v = planeFrom.matrix.multiplyVector(v);\r\n            setVert(i + 1, v);\r\n        }\r\n        // verts 'to' ring\r\n        let numVertsHalf = numVerts / 2;\r\n        for (let i = 0; i < resolution; i++) {\r\n            let v = new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos((Math.PI * 2 * i) / resolution), Math.sin((Math.PI * 2 * i) / resolution), 0).scale(radius);\r\n            v = planeTo.matrix.multiplyVector(v);\r\n            setVert(numVertsHalf + i, v);\r\n        }\r\n        setVert(numVerts - 1, to);\r\n        // start making links\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(numFaces, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // set faces\r\n        for (let i = 0; i < resolution; i++) {\r\n            let a = 0;\r\n            let b = 1 + i;\r\n            let c = 1 + ((i + 1) % resolution);\r\n            let d = numVerts - 1;\r\n            let e = numVertsHalf + i;\r\n            let f = numVertsHalf + ((i + 1) % resolution);\r\n            setFace(i * 4, [a, c, b]);\r\n            setFace(i * 4 + 1, [b, c, e]);\r\n            setFace(i * 4 + 2, [c, f, e]);\r\n            setFace(i * 4 + 3, [d, e, f]);\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    // TODO remove center, just move afterwards\r\n    static newCone(center, radius, height, resolution) {\r\n        let numVerts = resolution + 2;\r\n        let numFaces = resolution * 2;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(numVerts);\r\n        let setVert = function (i, vector) {\r\n            verts.set(i, vector.add(center));\r\n        };\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(numFaces, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // set verts\r\n        setVert(0, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\r\n        for (let i = 0; i < resolution; i++) {\r\n            setVert(i + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos((Math.PI * 2 * i) / resolution), Math.sin((Math.PI * 2 * i) / resolution), 0).scale(radius));\r\n        }\r\n        setVert(numVerts - 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, height));\r\n        // set faces\r\n        for (let i = 0; i < resolution; i++) {\r\n            let a = 0;\r\n            let b = numVerts - 1;\r\n            let c = 1 + i;\r\n            let d = 1 + ((i + 1) % resolution);\r\n            setFace(i * 2, [a, d, c]);\r\n            setFace(i * 2 + 1, [c, d, b]);\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static newTorus(r1, r2, ringCount, vertCount) {\r\n        // verts * normals\r\n        let count = ringCount * vertCount;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        let normals = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        // create `resolution` number of section rings\r\n        for (let i = 0; i < ringCount; i++) {\r\n            let alpha = (Math.PI * 2 * i) / ringCount;\r\n            let ringCenter = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(Math.cos(alpha) * r1, Math.sin(alpha) * r1, 0);\r\n            // per section, create `sectionResolution` number of\r\n            for (let j = 0; j < vertCount; j++) {\r\n                let beta = (Math.PI * 2 * j) / vertCount;\r\n                let normal = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(Math.cos(beta) * Math.cos(alpha), Math.cos(beta) * Math.sin(alpha), Math.sin(beta)).normalize();\r\n                normals.set(i * vertCount + j, normal);\r\n                verts.set(i * vertCount + j, normal.scale(r2).add(ringCenter));\r\n            }\r\n        }\r\n        // links & uvs\r\n        let links = _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.new(count * 2, 3);\r\n        let uvs = undefined;\r\n        let getIndex = (i, j) => {\r\n            return (i % ringCount) * vertCount + (j % vertCount);\r\n        };\r\n        for (let i = 0; i < ringCount; i++) {\r\n            for (let j = 0; j < vertCount; j++) {\r\n                let a = getIndex(i, j);\r\n                let b = getIndex(i, j + 1);\r\n                let c = getIndex(i + 1, j);\r\n                let d = getIndex(i + 1, j + 1);\r\n                let iRow = a * 2;\r\n                links.setRow(iRow, [a, c, b]);\r\n                links.setRow(iRow + 1, [b, c, d]);\r\n            }\r\n        }\r\n        let mesh = Mesh.new(verts, links, uvs, normals);\r\n        return mesh;\r\n    }\r\n    static fromGraph(graph) {\r\n        // NOTE : doesnt really work if the loops are not of size 3.\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(graph.allVertPositions());\r\n        let loops = graph.allVertLoopsAsInts();\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(loops.length, 3);\r\n        loops.forEach((loop, i) => {\r\n            if (loop.length == 3) {\r\n                links.setRow(i, loop);\r\n            }\r\n            else {\r\n                console.log(\"cant convert loop\");\r\n            }\r\n        });\r\n        return Mesh.new(verts, links);\r\n    }\r\n    // ------- CONVERTERS\r\n    getLineIds() {\r\n        let width = this.links._width;\r\n        let count = this.links.data.length;\r\n        let lines = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(count, 2);\r\n        for (let i = 0; i < this.links.count(); i++) {\r\n            for (let j = 0; j < width; j++) {\r\n                let jnext = (j + 1) % width;\r\n                let iLines = i * width + j;\r\n                lines.set(iLines, 0, this.links.get(i, j));\r\n                lines.set(iLines, 1, this.links.get(i, jnext));\r\n            }\r\n        }\r\n        return lines;\r\n    }\r\n    toLines() {\r\n        // i think we can replace this with this.getLineIds(), I just cant be bothered to test side effects for now...\r\n        const getLines = (num) => {\r\n            let count = this.links.count() * num;\r\n            let lines = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(count, 2);\r\n            for (let i = 0; i < this.links.count(); i++) {\r\n                for (let j = 0; j < num; j++) {\r\n                    let jnext = (j + 1) % num;\r\n                    let iLines = i * num + j;\r\n                    lines.set(iLines, 0, this.links.get(i, j));\r\n                    lines.set(iLines, 1, this.links.get(i, jnext));\r\n                }\r\n            }\r\n            return lines;\r\n        };\r\n        let type = this.getType();\r\n        if (type == MeshType.Lines) {\r\n            return this.clone();\r\n        }\r\n        else if (type == MeshType.Triangles) {\r\n            let lines = getLines(3);\r\n            return Mesh.new(this.verts.clone(), lines);\r\n        }\r\n        else if (type == MeshType.Quads) {\r\n            let lines = getLines(4);\r\n            return Mesh.new(this.verts.clone(), lines);\r\n        }\r\n        else {\r\n            console.warn(\"cannot convert to lines\");\r\n            return Mesh.newEmpty(0, 0, 0);\r\n        }\r\n    }\r\n    ToShaderMesh() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh.fromMesh(this);\r\n    }\r\n    toGraph() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Graph.fromMesh(this);\r\n    }\r\n    toLinearMesh() {\r\n        // convert to non-indexed verts & norms\r\n        this.ensureFaceNormals();\r\n        let count = this.links.data.length;\r\n        let faceCount = this.links.count();\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        let norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let norm = this.normals.get(i);\r\n            this.links.getRow(i).forEach((v, j) => {\r\n                let id = i * 3 + j;\r\n                verts.set(id, this.verts.get(v));\r\n                norms.set(id, norm);\r\n            });\r\n        }\r\n        let links = _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList([], 3);\r\n        links._width = 3;\r\n        links._height = count / 3;\r\n        links.data = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getDefaultIndices)(count);\r\n        let mesh = new Mesh(verts, links, undefined, norms);\r\n        return mesh;\r\n    }\r\n    // ------ GETTERS\r\n    getVerticesOfFace(f) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.links._width);\r\n        this.links.getRow(f).forEach((v, i) => {\r\n            verts.set(i, this.verts.get(v));\r\n        });\r\n        return verts;\r\n    }\r\n    get type() {\r\n        return this.getType();\r\n    }\r\n    getType() {\r\n        if (this.links._width == MeshType.Points) {\r\n            return MeshType.Points;\r\n        }\r\n        else if (this.links._width == MeshType.Lines) {\r\n            return MeshType.Lines;\r\n        }\r\n        else if (this.links._width == MeshType.Triangles) {\r\n            return MeshType.Triangles;\r\n        }\r\n        else if (this.links._width == MeshType.Quads) {\r\n            return MeshType.Quads;\r\n        }\r\n        else {\r\n            return MeshType.Invalid;\r\n        }\r\n    }\r\n    // ----- Normals -----\r\n    calcAndSetFaceNormals() {\r\n        this._normalKind = NormalKind.Face;\r\n        this._normals = this.calculateFaceNormals();\r\n    }\r\n    calcAndSetVertexNormals() {\r\n        this._normalKind = NormalKind.Vertex;\r\n        this._normals = this.calculateVertexNormals();\r\n    }\r\n    ensureVertexNormals() {\r\n        if (this._normals && this._normals.count == this.verts.count) {\r\n            this._normalKind = NormalKind.Vertex;\r\n            return;\r\n        }\r\n        else {\r\n            // console.warn(\"no or incorrect vertex normals! recalculating...\");\r\n            this.calcAndSetVertexNormals();\r\n            return;\r\n        }\r\n    }\r\n    ensureFaceNormals() {\r\n        if (this._normals && this._normals.count == this.links.count()) {\r\n            this._normalKind = NormalKind.Face;\r\n            return true;\r\n        }\r\n        else {\r\n            // console.warn(\"no or incorrect face normals! recalculating...\");\r\n            this.calcAndSetFaceNormals();\r\n            return false;\r\n        }\r\n    }\r\n    ensureMultiFaceNormals() {\r\n        if (this._normals && this.normals.count == this.maxSize) {\r\n            this._normalKind = NormalKind.MultiVertex;\r\n            return true;\r\n        }\r\n        else {\r\n            // console.warn(\"no or incorrect face normals! recalculating...\");\r\n            return false;\r\n        }\r\n    }\r\n    calculateFaceNormals() {\r\n        if (this.getType() != MeshType.Triangles) {\r\n            console.error(\"can only calculate normals from triangular meshes\");\r\n            return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(0);\r\n        }\r\n        let faceCount = this.links.count();\r\n        let norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(faceCount);\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let verts = this.getVerticesOfFace(i);\r\n            let normal = verts\r\n                .get(1)\r\n                .subbed(verts.get(0))\r\n                .cross(verts.get(2).subbed(verts.get(0)))\r\n                .normalize();\r\n            norms.set(i, normal);\r\n        }\r\n        return norms;\r\n    }\r\n    calculateVertexNormals() {\r\n        // note: this is not completely accurate\r\n        // set the vertex normal to the average of all adjacent face normals\r\n        let faceCount = this.links.count();\r\n        let faceNormals = this.OLDcalculateFaceNormals();\r\n        // stack all face normals per vertex\r\n        let normals = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.verts.count);\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let normal = faceNormals[i];\r\n            this.links.getRow(i).forEach((vertexIndex) => {\r\n                let v = normals.get(vertexIndex);\r\n                normals.set(vertexIndex, v.add(normal));\r\n            });\r\n        }\r\n        // normalize all\r\n        for (let i = 0; i < normals.count; i++) {\r\n            normals.set(i, normals.get(i).normalize());\r\n        }\r\n        return normals;\r\n    }\r\n    // -------- MISC ----------\r\n    OLDcalculateFaceNormals() {\r\n        let norms = [];\r\n        if (this.getType() != MeshType.Triangles) {\r\n            console.error(\"can only calculate normals from triangular meshes\");\r\n            return norms;\r\n        }\r\n        let faceCount = this.links.count();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let verts = this.getVerticesOfFace(i).toList();\r\n            let normal = verts[1].subbed(verts[0]).cross(verts[2].subbed(verts[0])).normalize();\r\n            norms.push(normal);\r\n        }\r\n        return norms;\r\n    }\r\n    OLDcalculateVertexNormals() {\r\n        let faceCount = this.links.count();\r\n        let faceNormals = this.OLDcalculateFaceNormals();\r\n        // stack all face normals per vertex\r\n        let array = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.verts.count);\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let normal = faceNormals[i];\r\n            this.links.getRow(i).forEach((vertexIndex) => {\r\n                let v = array.get(vertexIndex);\r\n                array.set(vertexIndex, v.add(normal));\r\n            });\r\n        }\r\n        // normalize all\r\n        let normals = array.toList();\r\n        for (let i = 0; i < normals.length; i++) {\r\n            normals[i].normalize();\r\n        }\r\n        return normals;\r\n    }\r\n    // ------ UVS\r\n    ensureUVs() {\r\n        if (this._uvs && this._uvs.count == this.maxSize) {\r\n            return true;\r\n        }\r\n        else {\r\n            // console.warn(\"no uvs yet! filling with dummy data\");\r\n            this._uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(this.maxSize);\r\n            return false;\r\n        }\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////// True Operators\r\n    /**\r\n     * 1. For every edge, intersect with plane. if hit: store\r\n     * 2. Use triangle IDS to stitch the points together to form lines.\r\n     * (2. for now, just figure out continuous line segments some other way)\r\n     * @returns\r\n     */\r\n    xPlane(plane) {\r\n        if (this.links._width != 3) {\r\n            _lib__WEBPACK_IMPORTED_MODULE_0__.Debug.error(\"intersection on quad based mesh not implemented...\");\r\n            return _MultiLine__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromLines([]);\r\n        }\r\n        let width = 3;\r\n        let height = this.links.count();\r\n        // we can never have more than 2 vertices per face. We will make this array shorter at the end \r\n        let linePoints = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(height * 2);\r\n        let points = [];\r\n        let nCuts = 0;\r\n        // sorry for this mess, but I want this as fast as possible\r\n        let a = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        let b = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        let c = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        // in between products \r\n        let ba = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        let ac = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        let intersectionsPerTriangle;\r\n        let pNormal = plane.khat;\r\n        let pCenter = plane.center;\r\n        let stored;\r\n        let twice = false;\r\n        // per triangle\r\n        for (let i = 0; i < height; i++) {\r\n            // I do a little trick to 'store' the previous intersection of a triangle, in order to create lines\r\n            stored = undefined;\r\n            twice = false;\r\n            // per edge of the triangle\r\n            for (let j = 0; j < width; j++) {\r\n                if (twice)\r\n                    continue;\r\n                let jnext = (j + 1) % width;\r\n                let ia = this.links.get(i, j);\r\n                let ib = this.links.get(i, jnext);\r\n                // get the verts of the edge\r\n                this.verts.getCopy(a, ia);\r\n                this.verts.getCopy(b, ib);\r\n                // intersection\r\n                ba.copy(a).sub(b);\r\n                ac.copy(a).sub(pCenter);\r\n                let bot = ba.dot(pNormal);\r\n                if (bot == 0) {\r\n                    continue;\r\n                }\r\n                let top = pNormal.dot(ac);\r\n                let t = top / bot;\r\n                if (t < 0 || t > 1) {\r\n                    continue;\r\n                }\r\n                // if we arrive here: valid intersection!               \r\n                if (stored) {\r\n                    linePoints.set(nCuts, stored);\r\n                    linePoints.set(nCuts + 1, c.copy(a).lerp(b, t));\r\n                    nCuts += 2;\r\n                    twice = true;\r\n                }\r\n                else {\r\n                    c.copy(a).lerp(b, t);\r\n                    stored = c;\r\n                }\r\n            }\r\n        }\r\n        linePoints = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromData(linePoints.matrix.data.slice(0, nCuts * 3));\r\n        return _MultiLine__WEBPACK_IMPORTED_MODULE_3__.MultiLine.fromLines(linePoints);\r\n    }\r\n}\r\n// ================ Help ==================\r\n// 0 ------- 1\r\n// | \\     / |\r\n// |  4---5  |\r\n// |  |   |  |\r\n// |  6---7  |\r\n// | /     \\ |\r\n// 2 ------- 3\r\nconst cubeFaces = [\r\n    [0, 1, 3, 2],\r\n    [4, 0, 2, 6],\r\n    [1, 0, 4, 5],\r\n    [1, 5, 7, 3],\r\n    [2, 3, 7, 6],\r\n    [5, 4, 6, 7], // back\r\n];\r\nconst cubeUVS = [\r\n    [0.0, 0.0],\r\n    [1.0, 0.0],\r\n    [0.0, 1.0],\r\n    [1.0, 1.0],\r\n    [0.0, 0.0],\r\n    [1.0, 0.0],\r\n    [0.0, 1.0],\r\n    [1.0, 1.0],\r\n    [0.0, 0.0],\r\n    [1.0, 0.0],\r\n    [0.0, 1.0],\r\n    [1.0, 1.0],\r\n    [0.0, 0.0],\r\n    [1.0, 0.0],\r\n    [0.0, 1.0],\r\n    [1.0, 1.0],\r\n    [0.0, 0.0],\r\n    [1.0, 0.0],\r\n    [0.0, 1.0],\r\n    [1.0, 1.0],\r\n    [0.0, 0.0],\r\n    [1.0, 0.0],\r\n    [0.0, 1.0],\r\n    [1.0, 1.0],\r\n];\r\nfunction quadToTri(abcd) {\r\n    return [abcd[0], abcd[2], abcd[1], abcd[0], abcd[3], abcd[2]];\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/mesh/Mesh.ts?");

/***/ }),

/***/ "../engine/src/geometry/mesh/MultiLine.ts":
/*!************************************************!*\
  !*** ../engine/src/geometry/mesh/MultiLine.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiLine\": () => (/* binding */ MultiLine),\n/* harmony export */   \"getDefaultIndices\": () => (/* binding */ getDefaultIndices),\n/* harmony export */   \"getLongDefaultIndices\": () => (/* binding */ getLongDefaultIndices)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n// name:    line-render-data.ts\r\n// author:  Jos Feenstra\r\n// purpose: represents an object which can be fed directly to a linerenderer.\r\n//          use it to not continuously have to calculate these aspects if the underlying object is unchanged.\r\n\r\n// represents a collection of multiple lines. These could form 1 polyline, but this is not a requirement\r\nclass MultiLine {\r\n    constructor(verts, ids) {\r\n        this.verts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(verts);\r\n        if (ids == undefined) {\r\n            this.links = getDefaultIndices(this.verts.height);\r\n        }\r\n        else {\r\n            this.links = ids;\r\n        }\r\n    }\r\n    // this assumes even vectices are 'from' points, and odd vertices are 'to' points\r\n    static fromLines(verts) {\r\n        let data = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(verts);\r\n        return new MultiLine(data);\r\n    }\r\n    // get all lines from a mesh\r\n    static fromMesh(rend, uv = false) {\r\n        // 3 edges per face, 2 indices per edge\r\n        let mesh = rend.mesh;\r\n        let count = mesh.links.count() * 6;\r\n        let data = new Uint16Array(count);\r\n        for (let i = 0; i < mesh.links.count(); i++) {\r\n            let iData = i * 6;\r\n            data[iData] = mesh.links.get(i, 0);\r\n            data[iData + 1] = mesh.links.get(i, 1);\r\n            data[iData + 2] = mesh.links.get(i, 1);\r\n            data[iData + 3] = mesh.links.get(i, 2);\r\n            data[iData + 4] = mesh.links.get(i, 2);\r\n            data[iData + 5] = mesh.links.get(i, 0);\r\n        }\r\n        if (uv) {\r\n            return new MultiLine(rend.uvs.toMatrixSlice(), data);\r\n        }\r\n        else {\r\n            return new MultiLine(mesh.verts.slice(), data);\r\n        }\r\n    }\r\n    // create lines as a grid centered at a plane\r\n    static fromGrid(plane, count, dis) {\r\n        let halfTotalSize = ((count - 1) * dis) / 2;\r\n        // 2 vectors per line, 2 lines per count\r\n        // plus 5 lines, for ihat and jhat icons\r\n        let lines = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count * 4);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, -halfTotalSize, 0));\r\n            lines.set(i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, halfTotalSize, 0));\r\n        }\r\n        // y lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(2 * count + i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-halfTotalSize, -halfTotalSize + dis * i, 0));\r\n            lines.set(2 * count + i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize, -halfTotalSize + dis * i, 0));\r\n        }\r\n        // finally, transform everything to worldspace, and create the linerenderdata object\r\n        lines.forEach((v) => plane.pushToWorld(v));\r\n        return new MultiLine(lines.slice());\r\n    }\r\n    // get all lines from a plane\r\n    static fromPlane(plane) {\r\n        let count = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.PLANE_RENDER_LINECOUNT;\r\n        let dis = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.PLANE_RENDER_LINEDISTANCE;\r\n        let disSmall = dis / 10;\r\n        let halfTotalSize = ((count - 1) * dis) / 2;\r\n        // 2 vectors per line, 2 lines per count\r\n        // plus 5 lines, for ihat and jhat icons\r\n        let lines = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count * 4 + 5 * 2);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, -halfTotalSize, 0));\r\n            lines.set(i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, halfTotalSize, 0));\r\n        }\r\n        // y lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(2 * count + i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-halfTotalSize, -halfTotalSize + dis * i, 0));\r\n            lines.set(2 * count + i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize, -halfTotalSize + dis * i, 0));\r\n        }\r\n        // icon I  to show ihat\r\n        let iconLine1 = lines.count - 10;\r\n        lines.set(iconLine1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall, -disSmall, 0));\r\n        lines.set(iconLine1 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall * 4, disSmall, 0));\r\n        let iconLine2 = lines.count - 8;\r\n        lines.set(iconLine2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall, disSmall, 0));\r\n        lines.set(iconLine2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall * 4, -disSmall, 0));\r\n        // icon II to show jhat\r\n        let iconLine3 = lines.count - 6;\r\n        lines.set(iconLine3, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, halfTotalSize + disSmall * 2.5, 0));\r\n        lines.set(iconLine3 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(disSmall, halfTotalSize + disSmall * 4, 0));\r\n        let iconLine4 = lines.count - 4;\r\n        lines.set(iconLine4, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(disSmall, halfTotalSize + disSmall, 0));\r\n        lines.set(iconLine4 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-disSmall, halfTotalSize + disSmall * 4, 0));\r\n        // icon III to show khat / normal direction\r\n        let iconLine5 = lines.count - 2;\r\n        lines.set(iconLine5, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\r\n        lines.set(iconLine5 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, dis));\r\n        // finally, transform everything to worldspace, and create the linerenderdata object\r\n        lines.forEach((v) => plane.pushToWorld(v));\r\n        return new MultiLine(lines.slice());\r\n    }\r\n    static fromCircle(c, numSegments = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.CIRCLE_SEGMENTS, domain) {\r\n        let count = numSegments;\r\n        let PI2 = Math.PI * 2;\r\n        if (!domain)\r\n            domain = _lib__WEBPACK_IMPORTED_MODULE_0__.Domain.new(0, PI2);\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            // radial fraction of a circle\r\n            let t = domain.elevate(i / count);\r\n            verts.set(i, c.at(t));\r\n        }\r\n        return new MultiLine(verts.slice(), getPairIndices(count, true));\r\n    }\r\n    static fromPolyline(p, closed = false) {\r\n        return new MultiLine(p.verts, getPairIndices(p.verts.count, closed));\r\n    }\r\n    static fromBezier(b, numSegments = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.BEZIER_SEGMENTS) {\r\n        let count = numSegments + 1;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            // fraction\r\n            let t = i / numSegments;\r\n            verts.set(i, b.pointAt(t));\r\n        }\r\n        return new MultiLine(verts.slice(), getPairIndices(count, false));\r\n    }\r\n    static fromCube(cube) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(cube.getCorners());\r\n        return new MultiLine(verts);\r\n    }\r\n    static fromRect(rect) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(rect.getCorners());\r\n        // swap 2 and 3\r\n        let tempVert = verts.get(3);\r\n        verts.set(3, verts.get(2));\r\n        verts.set(2, tempVert);\r\n        return new MultiLine(verts, getPairIndices(verts.count, true));\r\n    }\r\n    static fromJoin(lines) {\r\n        // join meshes, dont try to look for duplicate vertices\r\n        // TODO : make this the trouble of Matrices and Arrays\r\n        let idsCount = 0;\r\n        let vertCount = 0;\r\n        for (let line of lines) {\r\n            idsCount += line.links.length;\r\n            vertCount += line.verts.count();\r\n        }\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount);\r\n        let ids = new Uint16Array(idsCount);\r\n        let accVerts = 0;\r\n        let accFaces = 0;\r\n        for (let lineset of lines) {\r\n            for (let i = 0; i < lineset.verts.count(); i++) {\r\n                verts.slice().setRow(accVerts + i, lineset.verts.getRow(i));\r\n            }\r\n            for (let i = 0; i < lineset.links.length; i++) {\r\n                ids[accFaces + i] = lineset.links[i] + accVerts;\r\n            }\r\n            accVerts += lineset.verts.count();\r\n            accFaces += lineset.links.length;\r\n        }\r\n        return new MultiLine(verts, ids);\r\n    }\r\n}\r\n// just get an int sequence from 0 to length.\r\nfunction getDefaultIndices(count) {\r\n    let data = new Uint16Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i] = i;\r\n    }\r\n    return data;\r\n}\r\n// just get an int sequence from 0 to length.\r\nfunction getLongDefaultIndices(count) {\r\n    let data = new Uint32Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i] = i;\r\n    }\r\n    return data;\r\n}\r\nfunction getPairIndices(count, cyclic) {\r\n    // given count of 3 => return 0,1 | 1,2 | 2,0\r\n    let length = count * 2;\r\n    if (!cyclic) {\r\n        length -= 2;\r\n    }\r\n    let data = new Uint16Array(length);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i * 2] = i;\r\n        data[i * 2 + 1] = (i + 1) % count;\r\n    }\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/mesh/MultiLine.ts?");

/***/ }),

/***/ "../engine/src/geometry/mesh/ObjProcessing.ts":
/*!****************************************************!*\
  !*** ../engine/src/geometry/mesh/ObjProcessing.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ObjProcessing\": () => (/* binding */ ObjProcessing)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Mesh */ \"../engine/src/geometry/mesh/Mesh.ts\");\n\r\n\r\nvar ObjProcessing;\r\n(function (ObjProcessing) {\r\n    /**\r\n     * Useful for when you just want one mesh from an OBJ.\r\n     * Not useful if you want explicit material info\r\n     * This makes many assumptions, and many of those assumptions are incorrect in many cases...\r\n     */\r\n    function dirty(text) {\r\n        // This is not a full .obj parser.\r\n        // see http://paulbourke.net/dataformats/obj/\r\n        // INDEXES ORIGINALLY REFER TO LINES, so -1 is needed\r\n        // run through all lines, and temporarely store\r\n        // all data in raw number lists, since we dont know how\r\n        // many vertices or faces well get.\r\n        let verts = []; // 3 long float\r\n        let norms = []; // 3 long float\r\n        let uvs = []; // 2 long float\r\n        let faces = []; // 9 long ints, u16's should suffice.\r\n        // note : this is very inefficient, but it'll have to do for now...\r\n        const keywordRE = /(\\w*)(?: )*(.*)/;\r\n        const lines = text.split(\"\\n\");\r\n        for (let i = 0; i < lines.length; ++i) {\r\n            const line = lines[i].trim();\r\n            // filter out comments\r\n            if (line === \"\" || line.startsWith(\"#\")) {\r\n                continue;\r\n            }\r\n            const m = keywordRE.exec(line);\r\n            if (!m) {\r\n                continue;\r\n            }\r\n            const [, keyword, unparsedArgs] = m;\r\n            const parts = line.split(/\\s+/).slice(1);\r\n            switch (keyword) {\r\n                case \"v\":\r\n                    for (const part of parts) {\r\n                        verts.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"vn\":\r\n                    for (const part of parts) {\r\n                        norms.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"vt\":\r\n                    for (const part of parts) {\r\n                        uvs.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"f\":\r\n                    for (const value of ProcessObjFace(parts)) {\r\n                        faces.push(value);\r\n                    }\r\n                    break;\r\n                default:\r\n                    console.warn(\"unhandled keyword:\", keyword); // eslint-disable-line no-console\r\n                    continue;\r\n            }\r\n        }\r\n        // console.log(\"number of vertices: \" + verts.length / 3);\r\n        // console.log(\"number of faces: \" + faces.length / 3);\r\n        // console.log(\"number of uvs: \" + uvs.length / 2);\r\n        // console.log(\"number of norms: \" + norms.length / 3);\r\n        let mesh = _Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh.fromRawLists(verts, faces, uvs, norms);\r\n        return mesh;\r\n    }\r\n    ObjProcessing.dirty = dirty;\r\n    function processObj(text) {\r\n        // This is not a full .obj parser.\r\n        // see http://paulbourke.net/dataformats/obj/\r\n        // INDEXES ORIGINALLY REFER TO LINES, so -1 is needed\r\n        let data = [];\r\n        let addMesh = (mesh, mtlref) => {\r\n            data.push({ mesh, mtlref });\r\n        };\r\n        // run through all lines, and temporarely store\r\n        // all data in raw number lists, since we dont know how\r\n        // many vertices or faces well get.\r\n        let verts = []; // 3 long float\r\n        let norms = []; // 3 long float\r\n        let uvs = []; // 2 long float\r\n        let faces = []; // 9 long ints, u16's should suffice.\r\n        // note : this is very inefficient, but it'll have to do for now...\r\n        const keywordRE = /(\\w*)(?: )*(.*)/;\r\n        const lines = text.split(\"\\n\");\r\n        for (let i = 0; i < lines.length; ++i) {\r\n            const line = lines[i].trim();\r\n            // filter out comments\r\n            if (line === \"\" || line.startsWith(\"#\")) {\r\n                continue;\r\n            }\r\n            const m = keywordRE.exec(line);\r\n            if (!m) {\r\n                continue;\r\n            }\r\n            const [, keyword, unparsedArgs] = m;\r\n            const parts = line.split(/\\s+/).slice(1);\r\n            switch (keyword) {\r\n                case \"mtllib\":\r\n                    console.log(\"mtllib: \", parts[0]);\r\n                    break;\r\n                case \"v\":\r\n                    for (const part of parts) {\r\n                        verts.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"v\":\r\n                    for (const part of parts) {\r\n                        verts.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"v\":\r\n                    for (const part of parts) {\r\n                        verts.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"vn\":\r\n                    for (const part of parts) {\r\n                        norms.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"vt\":\r\n                    for (const part of parts) {\r\n                        uvs.push(parseFloat(part));\r\n                    }\r\n                    break;\r\n                case \"f\":\r\n                    for (const value of ProcessObjFace(parts)) {\r\n                        faces.push(value);\r\n                    }\r\n                    break;\r\n                default:\r\n                    console.warn(\"unhandled keyword:\", keyword); // eslint-disable-line no-console\r\n                    continue;\r\n            }\r\n        }\r\n        // console.log(\"number of vertices: \" + verts.length / 3);\r\n        // console.log(\"number of faces: \" + faces.length / 3);\r\n        // console.log(\"number of uvs: \" + uvs.length / 2);\r\n        // console.log(\"number of norms: \" + norms.length / 3);\r\n        let mesh = _Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh.fromRawLists(verts, norms, uvs, faces);\r\n        return mesh;\r\n    }\r\n    ObjProcessing.processObj = processObj;\r\n    function materialFromMtl(mtl) {\r\n        return [_lib__WEBPACK_IMPORTED_MODULE_0__.Material.default()];\r\n    }\r\n    // NOTE: for now, uv and normals are completely ignored!!!\r\n    // we assume the indices are the same als the vertices!!!\r\n    // verbose way of processing one single vertex/normal/uv combination in a face.\r\n    function ProcessObjFaceVertex(part) {\r\n        // make sure data always has length: 3\r\n        let data = [];\r\n        // cut string apart and process it\r\n        let subparts = part.split(\"/\");\r\n        if (subparts.length == 1) {\r\n            data.push(parseInt(subparts[0]) - 1);\r\n            // data.push(0);\r\n            // data.push(0);\r\n        }\r\n        else if (subparts.length == 3) {\r\n            data.push(parseInt(subparts[0]) - 1);\r\n            // data.push(parseInt(subparts[1])-1);\r\n            // data.push(parseInt(subparts[2])-1);\r\n        }\r\n        else {\r\n            throw \"invalid face found when processing\";\r\n        }\r\n        return data;\r\n    }\r\n    // process a face entry in an obj file\r\n    function ProcessObjFace(parts) {\r\n        let data = [];\r\n        if (parts.length == 4) {\r\n            // i dont want to deal with quads for now, create 2 faces from a quad\r\n            let a = ProcessObjFaceVertex(parts[0]);\r\n            let b = ProcessObjFaceVertex(parts[1]);\r\n            let c = ProcessObjFaceVertex(parts[2]);\r\n            let d = ProcessObjFaceVertex(parts[3]);\r\n            data.push(...a, ...b, ...c, ...a, ...c, ...d);\r\n        }\r\n        else if (parts.length == 3) {\r\n            // as normal\r\n            let a = ProcessObjFaceVertex(parts[0]);\r\n            let b = ProcessObjFaceVertex(parts[1]);\r\n            let c = ProcessObjFaceVertex(parts[2]);\r\n            data.push(...a, ...b, ...c);\r\n        }\r\n        // data always has length 9 or 18\r\n        return data;\r\n    }\r\n})(ObjProcessing || (ObjProcessing = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/mesh/ObjProcessing.ts?");

/***/ }),

/***/ "../engine/src/geometry/mesh/ShaderMesh.ts":
/*!*************************************************!*\
  !*** ../engine/src/geometry/mesh/ShaderMesh.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderMesh\": () => (/* binding */ ShaderMesh),\n/* harmony export */   \"meshFromObj\": () => (/* binding */ meshFromObj)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n// Name: render-mesh.ts\r\n// Author: Jos Feenstra\r\n// Purpose:\r\n// a mesh representation which can be feed to a shader.\r\n// - fixed length attributes\r\n// - can represent:\r\n//   - pointcloud (links = null)\r\n//   - graph (links.width = 2)\r\n//   - triangles (links.width = 3)\r\n//   - quads (links.width = 4. will need to be converted to triangles for now...)\r\n// NOTE : THIS WHOLE CLASS CAN BE DELETED. ALL FUNCTIONALITY HAS BEEN TRANSFERED TO MESH + MODEL + ENTITY ABSTRACTIONS\r\n\r\nclass ShaderMesh {\r\n    constructor(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        this._normKind = _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.None;\r\n        // render speed\r\n        // shader\r\n        this.color = [1, 1, 1, 1];\r\n        this.linecolor = [1, 1, 1, 1];\r\n        let perFaceCount = 3;\r\n        this.mesh = _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.newEmpty(vertCount, faceCount, perFaceCount);\r\n        this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(normCount);\r\n        this.uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(uvCount);\r\n        this.ambi = new Float32Array(vertCount);\r\n        this.texture = texture;\r\n        this.position = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity();\r\n    }\r\n    set norms(v) {\r\n        this.mesh.setNormals(v);\r\n    }\r\n    set uvs(v) {\r\n        this.mesh.setUvs(v, this._normKind);\r\n    }\r\n    get norms() {\r\n        return this.mesh.normals;\r\n    }\r\n    get uvs() {\r\n        return this.mesh.uvs;\r\n    }\r\n    static new(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        return new ShaderMesh(vertCount, normCount, uvCount, faceCount, texture);\r\n    }\r\n    static fromRectDoubleSided(rect, texture) {\r\n        let verts = rect.getCorners();\r\n        let faces = [];\r\n        faces.push(...[0, 1, 3, 0, 3, 2, 0, 3, 1, 0, 2, 3]);\r\n        let rend = new ShaderMesh(4, 0, 0, 4, texture);\r\n        rend.setUvs(new Float32Array([\r\n            0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0,\r\n        ]));\r\n        rend.mesh.verts.fillFromList(verts);\r\n        rend.mesh.links.setData(faces);\r\n        return rend;\r\n    }\r\n    static fromRect(rect, texture) {\r\n        let verts = rect.getCorners();\r\n        let faces = [];\r\n        faces.push(...(0,_lib__WEBPACK_IMPORTED_MODULE_0__.quadToTri)([0, 1, 3, 2]));\r\n        let rend = new ShaderMesh(4, 0, 0, 2);\r\n        rend.setUvs(new Float32Array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]));\r\n        rend.mesh.verts.fillFromList(verts);\r\n        rend.mesh.links.setData(faces);\r\n        return rend;\r\n    }\r\n    static fromImage(image, plane, centered = true, scale = 1, fixWebglLimitation = true, bothSides = true) {\r\n        let domain;\r\n        if (centered) {\r\n            domain = _lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH((-image.width / 2) * scale, (-image.height / 2) * scale, image.width * scale, image.height * scale);\r\n        }\r\n        else {\r\n            domain = _lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH(0, 0, image.width * scale, image.height * scale);\r\n        }\r\n        let rectangle = new _lib__WEBPACK_IMPORTED_MODULE_0__.Rectangle3(plane, domain);\r\n        let mesh;\r\n        if (bothSides) {\r\n            mesh = ShaderMesh.fromRectDoubleSided(rectangle);\r\n        }\r\n        else {\r\n            mesh = ShaderMesh.fromRect(rectangle);\r\n        }\r\n        // note: webgl can only work with 2^x images\r\n        if (fixWebglLimitation) {\r\n            let goodWidth = _lib__WEBPACK_IMPORTED_MODULE_0__.HelpGl.getNearestCorrectTextureSize(image.width);\r\n            let goodHeight = _lib__WEBPACK_IMPORTED_MODULE_0__.HelpGl.getNearestCorrectTextureSize(image.height);\r\n            if (goodWidth !== image.width || goodHeight !== image.height) {\r\n                // we need to perform resizing!\r\n                // console.log(\"resizing to \", goodWidth, goodHeight);\r\n                let u = image.width / goodWidth;\r\n                let v = image.height / goodHeight;\r\n                image = image.buffer(goodWidth, goodHeight);\r\n                if (bothSides) {\r\n                    // mesh.setUvs(new Float32Array([\r\n                    //     0.0, 0.0,\r\n                    //     0.0, v,\r\n                    //     u, 0.0,\r\n                    //     u, v,\r\n                    //     0.0, 0.0,\r\n                    //     u, 0.0,\r\n                    //     0.0, v,\r\n                    //     u, v\r\n                    // ]));\r\n                }\r\n                else {\r\n                    // mesh.setUvs(new Float32Array([\r\n                    //     0.0, 0.0,\r\n                    //     0.0, v,\r\n                    //     u, 0.0,\r\n                    //     u, v\r\n                    // ]));\r\n                }\r\n            }\r\n        }\r\n        mesh.setTexture(image.toImageData());\r\n        return mesh;\r\n    }\r\n    static fromMesh(mesh) {\r\n        let r = new ShaderMesh(mesh.verts.count, 0, 0, mesh.maxSize);\r\n        r.mesh = mesh;\r\n        return r;\r\n    }\r\n    static fromData(verts, norms, uvs, faces) {\r\n        // NOTE : this type of parsing makes my life easy, but is dangerous. This is why i created the\r\n        // Array class.\r\n        let r = new ShaderMesh(verts.length / 3, norms.length / 3, uvs.length / 2, faces.length / 3);\r\n        r.mesh.verts.slice().fillWith(verts);\r\n        r.mesh.links.fillWith(faces);\r\n        r.norms.slice().fillWith(norms);\r\n        r.uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData(uvs);\r\n        return r;\r\n    }\r\n    static fromGraph(graph) {\r\n        let mesh = graph.toMesh();\r\n        let r = ShaderMesh.fromMesh(mesh);\r\n        r.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(graph.allNorms());\r\n        r._normKind = _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Vertex; // fix this!!\r\n        return r;\r\n    }\r\n    // geometry trait\r\n    transform(matrix) {\r\n        for (let i = 0; i < this.mesh.verts.count; i++) {\r\n            let v = this.mesh.verts.get(i);\r\n            let n = this.norms.get(i);\r\n            this.mesh.verts.set(i, matrix.multiplyVector(v));\r\n            this.norms.set(i, matrix.multiplyVector(n)); // TODO, EXTRACT ONLY ROTATION PART FROM THE MATRIX\r\n        }\r\n    }\r\n    // getters & selectors\r\n    // VERY POORLY OPTIMIZED\r\n    getAdjacentFaces(v) {\r\n        let faces = [];\r\n        let count = this.mesh.links.count();\r\n        for (let i = 0; i < count; i++) {\r\n            if (this.mesh.links.getRow(i).find((j) => j == v)) {\r\n                faces.push(i);\r\n            }\r\n        }\r\n        return faces;\r\n    }\r\n    getFaceVertices(f) {\r\n        return this.mesh.getVerticesOfFace(f);\r\n    }\r\n    getType() {\r\n        return this.mesh.getType();\r\n    }\r\n    getNormalType() {\r\n        return this._normKind;\r\n    }\r\n    // setters\r\n    setTexture(texture) {\r\n        this.texture = texture;\r\n        // recalculate things if needed\r\n    }\r\n    setUvs(uvs) {\r\n        if (uvs instanceof Float32Array) {\r\n            this.uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData(uvs);\r\n        }\r\n        else {\r\n            this.uvs = uvs;\r\n        }\r\n        // recalculate if needed\r\n    }\r\n    // convert\r\n    exportToObj(path) {\r\n        throw \"todo\";\r\n    }\r\n    // ------ normals ------\r\n    // set 1 normal per face\r\n    calculateFaceNormals() {\r\n        if (this.getType() != _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Triangles) {\r\n            console.error(\"can only calculate normals from triangular meshes\");\r\n            this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(0);\r\n            return;\r\n        }\r\n        let norms = this.mesh.OLDcalculateFaceNormals();\r\n        this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(norms);\r\n        this._normKind = _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Face;\r\n    }\r\n    calculateVertexNormals() {\r\n        let norms = this.mesh.OLDcalculateVertexNormals();\r\n        this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(norms);\r\n        this._normKind = _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Vertex;\r\n    }\r\n    calculateMultiVertexNormals() {\r\n        // set type\r\n        this._normKind = _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.MultiVertex;\r\n        // calculate\r\n        this.calculateFaceNormals();\r\n        let vertNormals = this.mesh.verts.map((v, i) => {\r\n            let adjFaces = this.getAdjacentFaces(i);\r\n            return this.norms.take(adjFaces).average();\r\n        });\r\n        this.norms = vertNormals;\r\n    }\r\n}\r\n// ================ Obj ===================\r\nfunction meshFromObj(text) {\r\n    // This is not a full .obj parser.\r\n    // see http://paulbourke.net/dataformats/obj/\r\n    // INDEXES ORIGINALLY REFER TO LINES, so -1 is needed\r\n    // run through all lines, and temporarely store\r\n    // all data in raw number lists, since we dont know how\r\n    // many vertices or faces well get.\r\n    let verts = []; // 3 long float\r\n    let norms = []; // 3 long float\r\n    let uvs = []; // 2 long float\r\n    let faces = []; // 9 long ints, u16's should suffice.\r\n    // note : this is very inefficient, but it'll have to do for now...\r\n    const keywordRE = /(\\w*)(?: )*(.*)/;\r\n    const lines = text.split(\"\\n\");\r\n    for (let i = 0; i < lines.length; ++i) {\r\n        const line = lines[i].trim();\r\n        // filter out comments\r\n        if (line === \"\" || line.startsWith(\"#\")) {\r\n            continue;\r\n        }\r\n        const m = keywordRE.exec(line);\r\n        if (!m) {\r\n            continue;\r\n        }\r\n        const [, keyword, unparsedArgs] = m;\r\n        const parts = line.split(/\\s+/).slice(1);\r\n        switch (keyword) {\r\n            case \"v\":\r\n                for (const part of parts) {\r\n                    verts.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case \"vn\":\r\n                for (const part of parts) {\r\n                    norms.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case \"vt\":\r\n                for (const part of parts) {\r\n                    uvs.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case \"f\":\r\n                for (const value of ProcessObjFace(parts)) {\r\n                    faces.push(value);\r\n                }\r\n                break;\r\n            default:\r\n                console.warn(\"unhandled keyword:\", keyword); // eslint-disable-line no-console\r\n                continue;\r\n        }\r\n    }\r\n    // console.log(\"number of vertices: \" + verts.length / 3);\r\n    // console.log(\"number of faces: \" + faces.length / 3);\r\n    // console.log(\"number of uvs: \" + uvs.length / 2);\r\n    // console.log(\"number of norms: \" + norms.length / 3);\r\n    let mesh = ShaderMesh.fromData(verts, norms, uvs, faces);\r\n    return mesh;\r\n}\r\n// NOTE: for now, uv and normals are completely ignored!!!\r\n// we assume the indices are the same als the vertices!!!\r\n// verbose way of processing one single vertex/normal/uv combination in a face.\r\nfunction ProcessObjFaceVertex(part) {\r\n    // make sure data always has length: 3\r\n    let data = [];\r\n    // cut string apart and process it\r\n    let subparts = part.split(\"/\");\r\n    if (subparts.length == 1) {\r\n        data.push(parseInt(subparts[0]) - 1);\r\n        // data.push(0);\r\n        // data.push(0);\r\n    }\r\n    else if (subparts.length == 3) {\r\n        data.push(parseInt(subparts[0]) - 1);\r\n        // data.push(parseInt(subparts[1])-1);\r\n        // data.push(parseInt(subparts[2])-1);\r\n    }\r\n    else {\r\n        throw \"invalid face found when processing\";\r\n    }\r\n    return data;\r\n}\r\n// process a face entry in an obj file\r\nfunction ProcessObjFace(parts) {\r\n    let data = [];\r\n    if (parts.length == 4) {\r\n        // i dont want to deal with quads for now, create 2 faces from a quad\r\n        let a = ProcessObjFaceVertex(parts[0]);\r\n        let b = ProcessObjFaceVertex(parts[1]);\r\n        let c = ProcessObjFaceVertex(parts[2]);\r\n        let d = ProcessObjFaceVertex(parts[3]);\r\n        data.push(...a, ...b, ...c, ...a, ...c, ...d);\r\n    }\r\n    else if (parts.length == 3) {\r\n        // as normal\r\n        let a = ProcessObjFaceVertex(parts[0]);\r\n        let b = ProcessObjFaceVertex(parts[1]);\r\n        let c = ProcessObjFaceVertex(parts[2]);\r\n        data.push(...a, ...b, ...c);\r\n    }\r\n    // data always has length 9 or 18\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/mesh/ShaderMesh.ts?");

/***/ }),

/***/ "../engine/src/geometry/mesh/TopoMesh.ts":
/*!***********************************************!*\
  !*** ../engine/src/geometry/mesh/TopoMesh.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TopoMesh\": () => (/* binding */ TopoMesh)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _primitives_Triangle2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/Triangle2 */ \"../engine/src/geometry/primitives/Triangle2.ts\");\n\r\n\r\n// a mesh with topological information\r\nclass TopoMesh extends _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh {\r\n    // private -> should only be used with factory methods\r\n    constructor(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        super(vertCount, normCount, uvCount, faceCount, texture);\r\n        this.lastTouched = 0; // needed for triangle walk\r\n        this.neighborMap = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(this.mesh.links.count(), 3);\r\n    }\r\n    static copyFromShaderMesh(rend) {\r\n        let topoMesh = new TopoMesh(rend.mesh.verts.count, rend.norms.count, rend.uvs.count, rend.mesh.links.count());\r\n        topoMesh.mesh.verts = rend.mesh.verts.clone();\r\n        topoMesh.norms = rend.norms.clone();\r\n        topoMesh.uvs = rend.uvs.clone();\r\n        topoMesh.mesh.links = rend.mesh.links.clone();\r\n        topoMesh.setNeighborMap();\r\n        return topoMesh;\r\n    }\r\n    setNeighborMap() {\r\n        // this method fills this.neighborMap after data is loaded\r\n        //\r\n        let edges = new _lib__WEBPACK_IMPORTED_MODULE_0__.HashTable();\r\n        let pairs = new _lib__WEBPACK_IMPORTED_MODULE_0__.HashTable();\r\n        // 1 | per triangle\r\n        this.mesh.links.forEachRow((f, faceIndex) => {\r\n            let faceEdges = [\r\n                [f[0], f[1]],\r\n                [f[1], f[2]],\r\n                [f[2], f[0]],\r\n            ];\r\n            faceEdges.forEach((e) => {\r\n                // if (4, 1), orientation is True | if (1, 4), orientation is False\r\n                let orientation = e[0] > e[1];\r\n                // use this min max construction to only store one edge per triangle pair\r\n                // let edge: [number, number] = e.sort();\r\n                let edge = new Int32Array([Math.min(...e), Math.max(...e)]);\r\n                // console.log(edge);\r\n                if (!edges.has(edge)) {\r\n                    // orientation, first tr ID, second tr ID\r\n                    edges.set(edge, [orientation, faceIndex, -1]);\r\n                }\r\n                else {\r\n                    // an edge match is made!\r\n                    // console.log(\"matched!\");\r\n                    let other = edges.get(edge);\r\n                    let nbOrientation = other[0];\r\n                    let nbIndex = other[1];\r\n                    other[2] = faceIndex;\r\n                    edges.set(edge, other); // edge is put away again, if an edge map is ever needed.\r\n                    // assign neighbours\r\n                    this.setNb(faceIndex, edge, nbIndex);\r\n                    this.setNb(nbIndex, edge, faceIndex);\r\n                    // use this info to fill self.pairs\r\n                    // if orientation != other orientation, edge is 'good' -> False\r\n                    // else -> True, one of the neighbour triangles needs to be flipped\r\n                    let pair = [nbIndex, faceIndex];\r\n                    pair.sort();\r\n                    // pair = (Math.min(...pair), Math.max(...pair))\r\n                    if (orientation != nbOrientation)\r\n                        pairs.set(pair, false);\r\n                    else\r\n                        pairs.set(pair, true);\r\n                }\r\n            });\r\n        });\r\n        // Done. Give feedback\r\n        let count = 0;\r\n        // for pair in pairs.items():\r\n        //     if not pair: count +=1;\r\n        console.log(\"number of 'wrong' face neighbours: \", count);\r\n        return;\r\n    }\r\n    /**\r\n     * Get the triangle based on a UV point somewhere on the mesh.\r\n     * Returns -1 if the point is not on the mesh TODO OR IF THE PATH HAS HOLES IN IT TODO FIX THIS!\r\n     * @param  {Vector2} point\r\n     * @returns triangleIndex, or -1 if failure\r\n     */\r\n    walkUV(point) {\r\n        // start where we last stopped\r\n        let faceIndex = this.lastTouched;\r\n        // make sure we never take more steps than triangles in the triangulation.\r\n        // this would mean something went wrong\r\n        let count = this.mesh.links.count();\r\n        for (let _ = 0; _ < count; _++) {\r\n            // i dont know how, but if we accidentally landed outside of the mesh\r\n            if (faceIndex == -1) {\r\n                return -1;\r\n            }\r\n            for (let i = 0; i < 3; i++) {\r\n                let j = (i + 1) % 3;\r\n                let face = this.mesh.links.getRow(faceIndex);\r\n                let edge = [face[i], face[j]];\r\n                let b = this.uvs.get(edge[0]);\r\n                let c = this.uvs.get(edge[1]);\r\n                let sign = point.sign(b, c);\r\n                if (sign < 0) {\r\n                    faceIndex = this.getNb(faceIndex, edge);\r\n                    // if its ouside, return -1\r\n                    if (faceIndex == -1)\r\n                        return -1;\r\n                    // else: go there immidiately\r\n                    this.lastTouched = faceIndex;\r\n                    break;\r\n                }\r\n                // if this ran 3 times, the point must be within the triangle\r\n                if (i == 2)\r\n                    return faceIndex;\r\n            }\r\n        }\r\n        // something went wrong\r\n        return -1;\r\n    }\r\n    // find the faces closest to the point\r\n    // -1 if the mesh does not contain triangles\r\n    closestFaces(point) {\r\n        let closestVertexId = this.mesh.verts.closestId(point);\r\n        // get all face ids containing closestVertex, along with their centers\r\n        let closestFaces = [];\r\n        //let centers: Vector3[] = []\r\n        this.mesh.links.forEachRow((tr, i) => {\r\n            if (tr.includes(closestVertexId)) {\r\n                closestFaces.push(i);\r\n                //let center = Vector3Array.fromList(this.getFacePoints(i, false)).average();\r\n                //centers.push(center);\r\n            }\r\n        });\r\n        // select the triangle with the closest baricenter\r\n        return closestFaces;\r\n    }\r\n    elevate(p) {\r\n        // 'elevate' a point in UV space to vertex space using a barycentric remap\r\n        // figure out where this point is located on the mesh\r\n        let face = this.walkUV(p);\r\n        if (face == -1) {\r\n            console.warn(\"got a point not on triangle...\");\r\n            return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\r\n        }\r\n        let tr3 = this.getTriangle3(face);\r\n        let tr2 = this.getTriangle2(face);\r\n        let bari = tr2.toBarycentric(p);\r\n        return tr3.fromBarycentric(bari);\r\n    }\r\n    closestFace(p) {\r\n        // NOTE this doesnt really work all that well...\r\n        let faceIds = this.closestFaces(p);\r\n        let closestPoints = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(faceIds.length);\r\n        faceIds.forEach((id, i) => {\r\n            let tr = this.getTriangle3(id);\r\n            let cp = tr.closestPoint(p);\r\n            closestPoints.set(i, cp);\r\n        });\r\n        // find the closest closest point\r\n        let id = closestPoints.closestId(p);\r\n        return faceIds[id];\r\n    }\r\n    // 'flatten' a point in vertex space to uv space using a barycentric remap\r\n    // NOTE : this is not exactly a 'project to closest triangle', something like that wouldnt always work\r\n    flatten(p, face) {\r\n        let tr3 = this.getTriangle3(face);\r\n        let tr2 = this.getTriangle2(face);\r\n        let bari = tr3.toBarycentric(p);\r\n        return tr2.fromBarycentric(bari);\r\n    }\r\n    // combo\r\n    flattenClosestPoint(p) {\r\n        let face = this.closestFace(p);\r\n        return this.flatten(p, face);\r\n    }\r\n    closestPoint(p) {\r\n        let face = this.closestFace(p);\r\n        let triangle = this.getTriangle3(face);\r\n        let bari = triangle.toBarycentric(p);\r\n        return triangle.fromBarycentric(bari);\r\n    }\r\n    getTriangle2(id) {\r\n        let p = this.getFacePoints(id, true);\r\n        return new _primitives_Triangle2__WEBPACK_IMPORTED_MODULE_1__.Triangle2(p[0], p[1], p[2]);\r\n    }\r\n    getTriangle3(id) {\r\n        let p = this.getFacePoints(id, false);\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Triangle3(p[0], p[1], p[2]);\r\n    }\r\n    setNb(faceIndex, commonEdge, nbIndex) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (!commonEdge.includes(this.mesh.links.get(faceIndex, j))) {\r\n                this.neighborMap.set(faceIndex, j, nbIndex);\r\n                return;\r\n            }\r\n        }\r\n        console.log(this.mesh.links.getRow(faceIndex));\r\n        console.log(commonEdge);\r\n        throw \"these are not actually neighbors!\";\r\n    }\r\n    getNb(faceIndex, commonEdge) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (!commonEdge.includes(this.mesh.links.get(faceIndex, j))) {\r\n                return this.neighborMap.get(faceIndex, j);\r\n            }\r\n        }\r\n        console.log(this.mesh.links.getRow(faceIndex));\r\n        console.log(commonEdge);\r\n        throw \"common edge does not match triangle index!\";\r\n    }\r\n    getFacePoints(tr, uv) {\r\n        let pointIds = this.mesh.links.getRow(tr);\r\n        if (uv) {\r\n            return [\r\n                this.uvs.get(pointIds[0]),\r\n                this.uvs.get(pointIds[1]),\r\n                this.uvs.get(pointIds[2]),\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                this.mesh.verts.get(pointIds[0]),\r\n                this.mesh.verts.get(pointIds[1]),\r\n                this.mesh.verts.get(pointIds[2]),\r\n            ];\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/mesh/TopoMesh.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Circle2.ts":
/*!****************************************************!*\
  !*** ../engine/src/geometry/primitives/Circle2.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle2\": () => (/* binding */ Circle2)\n/* harmony export */ });\n/* harmony import */ var _math_Const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _math_LSA__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/LSA */ \"../engine/src/math/LSA.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n\r\n\r\n\r\nclass Circle2 {\r\n    constructor(center, radius) {\r\n        this.center = center;\r\n        this.radius = radius;\r\n    }\r\n    static new(center = _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2.new(), radius = 1) {\r\n        return new Circle2(center, radius);\r\n    }\r\n    static fromLSA(points) {\r\n        let [x, y, r] = _math_LSA__WEBPACK_IMPORTED_MODULE_1__.LSA.circle2(points);\r\n        return Circle2.new(_math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2.new(x, y), r);\r\n    }\r\n    // thank you mr Mitteldorf for making me remember how basic math works\r\n    // http://mathforum.org/library/drmath/view/53027.html\r\n    // calculate the centers of two circles, defined by two points and a radius\r\n    static centersFromPPR(a, b, radius) {\r\n        // throw new Error(\"Method not implemented.\");\r\n        // get in between length and halfway point\r\n        let normal = b.clone().sub(a);\r\n        let dis = normal.length();\r\n        let middle = a\r\n            .clone()\r\n            .add(b)\r\n            .scale(1 / 2);\r\n        // scalar length on mirror line (pythagoras)\r\n        let value = Math.pow(radius, 2) - Math.pow((dis / 2), 2);\r\n        if (value < -_math_Const__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n            // no sollution\r\n            return [];\r\n        }\r\n        else if (value < _math_Const__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n            // center roughly in the middle, so just return the middle\r\n            return [middle];\r\n        }\r\n        else {\r\n            // two circles possible:\r\n            let disToCenter = Math.pow(value, 0.5);\r\n            let normY = new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2(normal.y, -normal.x).normalize();\r\n            // move the middle point up and down\r\n            return [\r\n                middle.clone().add(normY.clone().scale(disToCenter)),\r\n                middle.clone().add(normY.clone().scale(-disToCenter)),\r\n            ];\r\n        }\r\n    }\r\n    /**\r\n     * Caclulate how far this point is removed from the circle\r\n     */\r\n    distance(point) {\r\n        let distance = this.center.disTo(point);\r\n        return distance - this.radius;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Circle2.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Circle3.ts":
/*!****************************************************!*\
  !*** ../engine/src/geometry/primitives/Circle3.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle3\": () => (/* binding */ Circle3)\n/* harmony export */ });\n/* harmony import */ var _math_Const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _mesh_MultiLine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../mesh/MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n/* harmony import */ var _Plane__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Plane */ \"../engine/src/geometry/primitives/Plane.ts\");\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Geometry */ \"../engine/src/geometry/Geometry.ts\");\n// purpose: represents a 3d circle\r\n\r\n\r\n\r\n\r\n\r\nclass Circle3 extends _Geometry__WEBPACK_IMPORTED_MODULE_4__.Geometry {\r\n    constructor(plane, radius) {\r\n        super();\r\n        this.plane = plane;\r\n        this.radius = radius;\r\n    }\r\n    static new(plane, radius) {\r\n        return new Circle3(plane, radius);\r\n    }\r\n    static newPlanar(point, radius) {\r\n        return new Circle3(_Plane__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY().moveTo(point), radius);\r\n    }\r\n    static fromCircle2(circle2, plane = _Plane__WEBPACK_IMPORTED_MODULE_3__.Plane.WorldXY()) {\r\n        // elevate center of circle, make it the center of a plane\r\n        let center3d = plane.pushToWorld(_math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3.from2d(circle2.center));\r\n        plane = plane.clone();\r\n        plane.center = center3d;\r\n        return new Circle3(plane, circle2.radius);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    at(t) {\r\n        return this.plane.pushToWorld(new _math_Vector3__WEBPACK_IMPORTED_MODULE_1__.Vector3(Math.cos(t) * this.radius, Math.sin(t) * this.radius, 0));\r\n    }\r\n    frameAt(t) {\r\n        let p = this.at(t);\r\n        let ihat = this.plane.center.subbed(p).normalize();\r\n        let jhat = this.plane.khat.normalize();\r\n        return _Plane__WEBPACK_IMPORTED_MODULE_3__.Plane.fromPVV(p, ihat, jhat);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    buffer() {\r\n        return _mesh_MultiLine__WEBPACK_IMPORTED_MODULE_2__.MultiLine.fromCircle(this);\r\n    }\r\n    includes(p) {\r\n        // test if the point falls in range of the circle, by regarding\r\n        // the circle as a torus\r\n        // CHANGE NOTE: i set this to zero, for testing\r\n        // vertical error\r\n        let [projPoint, yError] = this.plane.closestPoint(p);\r\n        yError = yError / 3;\r\n        // horizontal error: get the difference between point\r\n        let xError = this.plane.center.clone().disTo(projPoint) - this.radius;\r\n        // length of total error vector needs to be smaller than the given\r\n        // tolerance\r\n        return Math.pow(yError, 2) + Math.pow(xError, 2) < _math_Const__WEBPACK_IMPORTED_MODULE_0__.Const.TOL_SQUARED;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    clone() {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    transform(m) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    transformed(m) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Circle3.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Cube.ts":
/*!*************************************************!*\
  !*** ../engine/src/geometry/primitives/Cube.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cube\": () => (/* binding */ Cube)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n// name:    cube.ts\r\n// author:  Jos Feenstra\r\n// purpose: Represents a cube in 3d space, in a certain pose.\r\n\r\nclass Cube {\r\n    constructor(plane, domain) {\r\n        this.plane = plane;\r\n        this.domain = domain;\r\n    }\r\n    static new(plane, domain) {\r\n        return new Cube(plane, domain);\r\n    }\r\n    static fromRadius(point, radius) {\r\n        return new Cube(_lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(point), _lib__WEBPACK_IMPORTED_MODULE_0__.Domain3.fromRadius(radius));\r\n    }\r\n    getCorners() {\r\n        return this.domain.corners(this.plane.matrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Cube.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Line2.ts":
/*!**************************************************!*\
  !*** ../engine/src/geometry/primitives/Line2.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Line2\": () => (/* binding */ Line2)\n/* harmony export */ });\n/* harmony import */ var _math_Domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Domain */ \"../engine/src/math/Domain.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n\r\n\r\n// heavy weight Line class\r\nclass Line2 {\r\n    constructor(from, to) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.vector = to.subbed(this.from);\r\n        this.normal = this.vector.normalized();\r\n        this.bounds = new _math_Domain__WEBPACK_IMPORTED_MODULE_0__.Domain(0, this.vector.length());\r\n        this.length = this.vector.length();\r\n    }\r\n    at(t, bounded = true) {\r\n        if (bounded)\r\n            t = this.bounds.comform(t);\r\n        return _math_Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2.fromLerp(this.from, this.to, t / this.length);\r\n    }\r\n    atNormal(t, bounded = true) {\r\n        if (bounded)\r\n            t = new _math_Domain__WEBPACK_IMPORTED_MODULE_0__.Domain(0, 1).comform(t);\r\n        return _math_Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2.fromLerp(this.from, this.to, t);\r\n    }\r\n    closestPoint(point, bounded = true) {\r\n        const d = this.vector.length();\r\n        if (d === 0)\r\n            return;\r\n        let lineToPoint = point.subbed(this.from);\r\n        let dot = lineToPoint.dot(this.vector);\r\n        return this.at(dot, bounded);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Line2.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Plane.ts":
/*!**************************************************!*\
  !*** ../engine/src/geometry/primitives/Plane.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Plane\": () => (/* binding */ Plane)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Geometry */ \"../engine/src/geometry/Geometry.ts\");\n// name:    plane.ts\r\n// author:  Jos Feenstra\r\n// purpose: definition of a 3d plane.\r\n// todo:    turn Center, Ihat, Jhat, Khat construction to an actual matrix\r\n// todo:    differentiate between a Space (a matrix in essense, ihat, jhat, khat, center, etc...) and a Plane (a, b, c, d);\r\n//          Space = a matrix which is parallel-preserving, i.e. any combination of rotation, scaling and translation, but not a perspective distortion. \r\n\r\n\r\nclass Plane extends _Geometry__WEBPACK_IMPORTED_MODULE_1__.Geometry {\r\n    // _inverse!: Matrix4; // NOTE: currently im not caching this. Might be needed.\r\n    // NOTE : d is not really needed anymore...\r\n    constructor(m) {\r\n        super();\r\n        this._matrix = m;\r\n    }\r\n    static fromPN(center, normal) {\r\n        let cross = normal.cross(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX());\r\n        if (cross.length() < _lib__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n            cross = normal.cross(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY());\r\n        }\r\n        let ihat = cross.normalize();\r\n        let jhat = normal.cross(ihat).normalize();\r\n        let mat = Plane.planeMatrixFromVecs(center, ihat, jhat, normal);\r\n        return new Plane(mat);\r\n    }\r\n    static fromPVV(a, v1, v2) {\r\n        // TODO check if we still need this -1 thing\r\n        let khat = v1.clone().cross(v2).normalize(); //.scale(-1);\r\n        let center = a.clone();\r\n        let ihat = v1.normalized();\r\n        let jhat = v1.clone().cross(khat);\r\n        let mat = Plane.planeMatrixFromVecs(center, ihat, jhat, khat);\r\n        return new Plane(mat);\r\n    }\r\n    static from3pt(a, b, c) {\r\n        let v1 = b.clone().sub(a);\r\n        let v2 = c.clone().sub(a);\r\n        return this.fromPVV(a, v1, v2);\r\n    }\r\n    static WorldXY() {\r\n        return Plane.from3pt(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY());\r\n    }\r\n    static WorldYZ() {\r\n        return Plane.from3pt(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ());\r\n    }\r\n    static WorldXZ() {\r\n        return Plane.from3pt(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ());\r\n    }\r\n    static fromLeastSquares(pts) {\r\n        let mean = pts.mean();\r\n        let cov = _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.cov(pts.slice());\r\n        let [eigValues, eigVectors] = _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.eig(cov);\r\n        console.log(eigValues);\r\n        let biggestEigenVector = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(eigVectors.getColumn(0));\r\n        let secondBiggestEigenVector = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(eigVectors.getColumn(1));\r\n        return Plane.fromPVV(mean, biggestEigenVector, secondBiggestEigenVector);\r\n    }\r\n    static fromXYLeastSquares(pts) {\r\n        // quite specific, but this was needed.\r\n        let mean = pts.mean();\r\n        return Plane.WorldXY().transform(_lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslation(mean.x, mean.y, mean.z));\r\n    }\r\n    static planeMatrixFromVecs(c, i, j, k) {\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4([\r\n            i.x,\r\n            i.y,\r\n            i.z,\r\n            0,\r\n            j.x,\r\n            j.y,\r\n            j.z,\r\n            0,\r\n            k.x,\r\n            k.y,\r\n            k.z,\r\n            0,\r\n            c.x,\r\n            c.y,\r\n            c.z,\r\n            1,\r\n        ]);\r\n    }\r\n    get ihat() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(0));\r\n    }\r\n    get jhat() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(1));\r\n    }\r\n    get khat() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(2));\r\n    }\r\n    get center() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(3));\r\n    }\r\n    get matrix() {\r\n        return this._matrix.clone();\r\n    }\r\n    get normal() {\r\n        return this.khat;\r\n    }\r\n    get d() {\r\n        return this.closestPoint(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero())[1];\r\n    }\r\n    set ihat(v) {\r\n        this._matrix.setRow(0, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set jhat(v) {\r\n        this._matrix.setRow(1, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set khat(v) {\r\n        this._matrix.setRow(2, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set center(v) {\r\n        this._matrix.setRow(3, [v.x, v.y, v.z, 1]);\r\n    }\r\n    set matrix(m) {\r\n        this._matrix = m;\r\n    }\r\n    get inverse() {\r\n        // TODO CACHE INVERSE MATRIX\r\n        return this._matrix.inverse();\r\n    }\r\n    distanceTo(v) {\r\n        return this.khat.dot(v) + this.d;\r\n    }\r\n    setPosition(vec) {\r\n        this.center = vec;\r\n    }\r\n    setNormal(vec) {\r\n        this.khat = vec;\r\n    }\r\n    clone() {\r\n        return new Plane(this._matrix.clone());\r\n    }\r\n    transform(m) {\r\n        this._matrix = this._matrix.multiply(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        return this.clone().transform(m);\r\n    }\r\n    moveTo(origin) {\r\n        this.center = origin;\r\n        return this;\r\n    }\r\n    // NOTE: pulling is inefficient since we do not cache the inverse.\r\n    pullToPlane(p) {\r\n        return this.inverse.multiplyVector(p);\r\n    }\r\n    pushToWorld(p) {\r\n        return this.matrix.multiplyVector(p);\r\n    }\r\n    closestPoint(p) {\r\n        let pulled = this.pullToPlane(p);\r\n        let distance = pulled.z;\r\n        pulled.z = 0;\r\n        let vec = this.pushToWorld(pulled);\r\n        return [vec, distance];\r\n    }\r\n    rotateVector(v, radians) {\r\n        let pulled = this.pullToPlane(v);\r\n        let rotation = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newAxisRotation(this.normal, radians);\r\n        pulled = rotation.multiplyVector(pulled);\r\n        return this.pushToWorld(pulled);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Plane.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Rectangle.ts":
/*!******************************************************!*\
  !*** ../engine/src/geometry/primitives/Rectangle.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rectangle2\": () => (/* binding */ Rectangle2),\n/* harmony export */   \"Rectangle3\": () => (/* binding */ Rectangle3)\n/* harmony export */ });\n/* harmony import */ var _math_Domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Domain */ \"../engine/src/math/Domain.ts\");\n/* harmony import */ var _math_Matrix3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Matrix3 */ \"../engine/src/math/Matrix3.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _mesh_MultiLine__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mesh/MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n/* harmony import */ var _Plane__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Plane */ \"../engine/src/geometry/primitives/Plane.ts\");\n\r\n\r\n\r\n// basic 2d rectangle\r\n// a Matrix3 and Domain2 is used.\r\n// this way, a rectangle can be rotated around an arbirtary point it regards as its center.\r\n// name:    cube.ts\r\n// author:  Jos Feenstra\r\n// purpose: Represents a cube in 3d space, in a certain pose.\r\n\r\n\r\n\r\nclass Rectangle2 {\r\n    constructor(pose, domain) {\r\n        this.pose = pose;\r\n        this.domain = domain;\r\n    }\r\n    static new(startX, startY, width, height) {\r\n        let pose = _math_Matrix3__WEBPACK_IMPORTED_MODULE_1__.Matrix3.newTranslation(startX, startY);\r\n        let domain = _math_Domain__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromBounds(0, 0, width, height);\r\n    }\r\n    center() {\r\n        return this.pose.transformVector(new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2(0, 0));\r\n    }\r\n    getVertices() {\r\n        let verts = [\r\n            new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t0, this.domain.y.t0),\r\n            new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t1, this.domain.y.t0),\r\n            new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t0, this.domain.y.t1),\r\n            new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t1, this.domain.y.t1),\r\n        ];\r\n        verts.forEach((v) => this.pose.transformVector(v));\r\n        return verts;\r\n    }\r\n    to3D() {\r\n        let mat4 = this.pose.toMat4();\r\n        return new Rectangle3(new _Plane__WEBPACK_IMPORTED_MODULE_5__.Plane(mat4), this.domain);\r\n    }\r\n}\r\nclass Rectangle3 {\r\n    constructor(plane, domain) {\r\n        this.plane = plane;\r\n        this.domain = domain;\r\n    }\r\n    static new(plane, domain) {\r\n        return new Rectangle3(plane, domain);\r\n    }\r\n    getCorners() {\r\n        let corners = this.domain.corners();\r\n        let corners3 = corners.map((c) => this.plane.pushToWorld(_math_Vector3__WEBPACK_IMPORTED_MODULE_3__.Vector3.from2d(c)));\r\n        return corners3;\r\n    }\r\n    buffer() {\r\n        return _mesh_MultiLine__WEBPACK_IMPORTED_MODULE_4__.MultiLine.fromRect(this);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Rectangle.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Triangle2.ts":
/*!******************************************************!*\
  !*** ../engine/src/geometry/primitives/Triangle2.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Triangle2\": () => (/* binding */ Triangle2)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n\r\nclass Triangle2 {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    points() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList([this.a, this.b, this.c]);\r\n    }\r\n    toBarycentric(point) {\r\n        let v0 = this.b.subbed(this.a);\r\n        let v1 = this.c.subbed(this.a);\r\n        let v2 = point.subbed(this.a);\r\n        let d00 = v0.dot(v0);\r\n        let d01 = v0.dot(v1);\r\n        let d11 = v1.dot(v1);\r\n        let d20 = v2.dot(v0);\r\n        let d21 = v2.dot(v1);\r\n        let denom = d00 * d11 - d01 * d01;\r\n        let v = (d11 * d20 - d01 * d21) / denom;\r\n        let w = (d00 * d21 - d01 * d20) / denom;\r\n        let u = 1.0 - v - w;\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(u, v, w);\r\n    }\r\n    fromBarycentric(bari) {\r\n        let a = this.a.scaled(bari.x);\r\n        let b = this.b.scaled(bari.y);\r\n        let c = this.c.scaled(bari.z);\r\n        return a.add(b).add(c);\r\n    }\r\n    closestPoint(point) {\r\n        // figure out roughly where the point is.\r\n        // note:\r\n        let ab = point.sign(this.a, this.b);\r\n        let bc = point.sign(this.b, this.c);\r\n        let ca = point.sign(this.c, this.a);\r\n        // if its fully within, return it!\r\n        if ((ab < 0 && bc < 0 && ca < 0) || (ab > 0 && bc > 0 && ca > 0)) {\r\n            console.log(\"fully inside!\");\r\n            return point;\r\n        }\r\n        else {\r\n            let abs = Math.abs(ab);\r\n            let bcs = Math.abs(bc);\r\n            let cas = Math.abs(ca);\r\n            if (abs < bcs && abs < cas) {\r\n                // ab\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.Line2(this.a, this.b).closestPoint(point);\r\n            }\r\n            else if (bcs < cas) {\r\n                // bc\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.Line2(this.b, this.c).closestPoint(point);\r\n            }\r\n            else {\r\n                // ca\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.Line2(this.c, this.a).closestPoint(point);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Triangle2.ts?");

/***/ }),

/***/ "../engine/src/geometry/primitives/Triangle3.ts":
/*!******************************************************!*\
  !*** ../engine/src/geometry/primitives/Triangle3.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Triangle3\": () => (/* binding */ Triangle3)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Plane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Plane */ \"../engine/src/geometry/primitives/Plane.ts\");\n/* harmony import */ var _Triangle2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Triangle2 */ \"../engine/src/geometry/primitives/Triangle2.ts\");\n\r\n\r\n\r\nclass Triangle3 {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    points() {\r\n        return [this.a, this.b, this.c];\r\n    }\r\n    getPlane() {\r\n        return _Plane__WEBPACK_IMPORTED_MODULE_1__.Plane.from3pt(this.a, this.b, this.c);\r\n    }\r\n    to2D(plane = _Plane__WEBPACK_IMPORTED_MODULE_1__.Plane.WorldXY()) {\r\n        return new _Triangle2__WEBPACK_IMPORTED_MODULE_2__.Triangle2(plane.pullToPlane(this.a).to2D(), plane.pullToPlane(this.b).to2D(), plane.pullToPlane(this.c).to2D());\r\n    }\r\n    closestPoint(point) {\r\n        let plane = this.getPlane();\r\n        let [cp, _] = plane.closestPoint(point);\r\n        let planeCP = plane.pullToPlane(cp);\r\n        let planeTriangle = this.to2D(plane);\r\n        return point;\r\n    }\r\n    // Transcribed from Christer Ericson's Real-Time Collision Detection:\r\n    // http://realtimecollisiondetection.net/\r\n    toBarycentric(point) {\r\n        let v0 = this.b.subbed(this.a);\r\n        let v1 = this.c.subbed(this.a);\r\n        let v2 = point.subbed(this.a);\r\n        let d00 = v0.dot(v0);\r\n        let d01 = v0.dot(v1);\r\n        let d11 = v1.dot(v1);\r\n        let d20 = v2.dot(v0);\r\n        let d21 = v2.dot(v1);\r\n        let denom = d00 * d11 - d01 * d01;\r\n        let v = (d11 * d20 - d01 * d21) / denom;\r\n        let w = (d00 * d21 - d01 * d20) / denom;\r\n        let u = 1.0 - v - w;\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(u, v, w);\r\n    }\r\n    fromBarycentric(bari) {\r\n        let a = this.a.clone().scale(bari.x);\r\n        let b = this.b.clone().scale(bari.y);\r\n        let c = this.c.clone().scale(bari.z);\r\n        return a.added(b).add(c);\r\n    }\r\n    /**\r\n     * Calculate the intersection between this triangle and a plane.\r\n     *\r\n     * This will be a line, or undefined.\r\n     */\r\n    xPlane(plane) {\r\n        return undefined;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/primitives/Triangle3.ts?");

/***/ }),

/***/ "../engine/src/geometry/surface/BezierSquare.ts":
/*!******************************************************!*\
  !*** ../engine/src/geometry/surface/BezierSquare.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BezierSquare\": () => (/* binding */ BezierSquare)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Domain */ \"../engine/src/math/Domain.ts\");\n/* harmony import */ var _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Polynomial */ \"../engine/src/math/Polynomial.ts\");\n/* harmony import */ var _math_Random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Random */ \"../engine/src/math/Random.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _util_Stopwatch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../util/Stopwatch */ \"../engine/src/util/Stopwatch.ts\");\n/* harmony import */ var _curve_Bezier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../curve/Bezier */ \"../engine/src/geometry/curve/Bezier.ts\");\n/* harmony import */ var _Surface__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Surface */ \"../engine/src/geometry/surface/Surface.ts\");\n// todo : research tensor: https://en.wikipedia.org/wiki/Tensor_product\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Four sided Bezier Surface\r\n */\r\nclass BezierSquare extends _Surface__WEBPACK_IMPORTED_MODULE_9__.BiSurface {\r\n    constructor(verts, degreeU, degreeV) {\r\n        super();\r\n        this.verts = verts;\r\n        this.degreeU = degreeU;\r\n        this.degreeV = degreeV;\r\n    }\r\n    static new(verts, degreeU, degreeV) {\r\n        // let degree = Math.sqrt(verts.count);\r\n        if (verts.count != (degreeU + 1) * (degreeV + 1)) {\r\n            console.warn(`BiSurface Not Created. ${verts.count} vertices \r\n                does not match ${degreeU} degreeU times ${degreeV} degreeV surface...`);\r\n            return undefined;\r\n        }\r\n        return new BezierSquare(verts, degreeU, degreeV);\r\n    }\r\n    /**\r\n     * ```\r\n     * 0----1-----2----3\r\n     * |    |  A  |    |\r\n     * 4----5?----6?---7\r\n     * | B  |     |    | D\r\n     * 8----9?---10?---11\r\n     * |    |     |    |\r\n     * 12---13----14---15\r\n     *         C\r\n     *```\r\n     * @param a\r\n     * @param b\r\n     * @param c\r\n     * @param d\r\n     * @returns\r\n     */\r\n    static fromFourEdge(a, b, c, d) {\r\n        // TODO do magic to discover the inner control points...\r\n        // NOTE: the magic is just a tensor product of control points : https://en.wikipedia.org/wiki/Tensor_product\r\n        // TODO bezier curves must be of the same degree\r\n        return undefined;\r\n    }\r\n    static fromLoft(curves) {\r\n        curves = _curve_Bezier__WEBPACK_IMPORTED_MODULE_8__.Bezier.equalizeDegrees(curves);\r\n        let degreeV = curves[0].degree;\r\n        let degreeU = curves.length - 1;\r\n        let count = degreeV + 1 * curves.length;\r\n        let verts = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        let idx = 0;\r\n        for (let i = 0; i < curves.length; i++) {\r\n            for (let j = 0; j < curves[i].verts.count; j++) {\r\n                verts.set(idx, curves[i].verts.get(j));\r\n                idx++;\r\n            }\r\n        }\r\n        return BezierSquare.new(verts, degreeU, degreeV);\r\n    }\r\n    /////////// properties ///////////\r\n    pointAt(u, v) {\r\n        let p = _math_Vector3__WEBPACK_IMPORTED_MODULE_6__.Vector3.zero();\r\n        for (let i = 0; i < this.degreeU + 1; i++) {\r\n            for (let j = 0; j < this.degreeV + 1; j++) {\r\n                let scalar = _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.bernstein(u, i, this.degreeU) *\r\n                    _math_Polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.bernstein(v, j, this.degreeV);\r\n                let index = i * (this.degreeV + 1) + j;\r\n                // console.log(i * count + j, s1, s2, scalar);\r\n                p.add(this.verts.get(index).scaled(scalar));\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n    pointAtUV(uv) {\r\n        return this.pointAt(uv.x, uv.y);\r\n    }\r\n    //////////////// projection /////////////////\r\n    /**\r\n     * NOTE: this is tested hastely, use with care\r\n     * @param p\r\n     * @param precision 2 is low-res, 10 is high-res, but more expensive.\r\n     * @param tolerance\r\n     * @returns\r\n     */\r\n    approxClosestPoint(p, precision = 2, tolerance = _lib__WEBPACK_IMPORTED_MODULE_1__.Const.TOLERANCE) {\r\n        let disToParams = (u, v) => p.disToSquared(this.pointAt(u, v));\r\n        let scansU = precision * (this.degreeU + 1);\r\n        let scansV = precision * (this.degreeV + 1);\r\n        let lowest_value = Infinity;\r\n        let best_i = -1;\r\n        let best_j = -1;\r\n        for (let i = 1; i < scansU + 1; i++) {\r\n            let u = i / scansU;\r\n            for (let j = 1; j < scansU + 1; j++) {\r\n                let v = j / scansV;\r\n                let value = disToParams(u, v);\r\n                if (value < lowest_value) {\r\n                    lowest_value = value;\r\n                    best_i = i;\r\n                    best_j = j;\r\n                }\r\n            }\r\n        }\r\n        // now, binary-search the smallest value in a patch around the best guess\r\n        let domain = _math_Domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromBounds(Math.max((best_i - 1) / scansU, 0), Math.min((best_i + 1) / scansU, 1), Math.max((best_j - 1) / scansV, 0), Math.min((best_j + 1) / scansV, 1));\r\n        let uv = _lib__WEBPACK_IMPORTED_MODULE_1__.Util.lowestScoreSquared(domain, disToParams, tolerance);\r\n        return uv;\r\n    }\r\n    /////////////////////////// geo //////////////////////////\r\n    clone() {\r\n        return BezierSquare.new(this.verts.clone(), this.degreeU, this.degreeV);\r\n    }\r\n    transform(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        return BezierSquare.new(this.verts.transformed(m), this.degreeU, this.degreeV);\r\n    }\r\n}\r\nfunction test(times = 1000) {\r\n    // get some points\r\n    let sw = _util_Stopwatch__WEBPACK_IMPORTED_MODULE_7__.Stopwatch.new();\r\n    let rng = _math_Random__WEBPACK_IMPORTED_MODULE_4__.Random.fromSeed(1234);\r\n    let degree = 2;\r\n    let displace = 5;\r\n    let vecs = _math_Domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromRadius(-11) // span a (-size to size)**2 domain\r\n        .offset([-22, 22, 0, 0]) // flip it\r\n        .spawn(degree + 1, degree + 1) // spawn a bunch of points, the exact amound needed for the surface\r\n        .to3D()\r\n        .forEach((v) => {\r\n        return v.add(_math_Vector3__WEBPACK_IMPORTED_MODULE_6__.Vector3.fromRandomUnit(rng).scale(displace)).add(_math_Vector3__WEBPACK_IMPORTED_MODULE_6__.Vector3.unitZ().scale(5)); // and displace them slightly\r\n    });\r\n    // create a surface from it\r\n    let s = BezierSquare.new(vecs, degree, degree);\r\n    let domain = _math_Domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromRadii(11, 11);\r\n    sw.log(\"creation\");\r\n    for (let i = 0; i < times; i++) {\r\n        let randomVec = _math_Vector3__WEBPACK_IMPORTED_MODULE_6__.Vector3.from2d(domain.elevate(_math_Vector2__WEBPACK_IMPORTED_MODULE_5__.Vector2.fromRandom(rng)));\r\n        s.approxClosestPoint(randomVec);\r\n    }\r\n    sw.log(`created ${times} closest points`); // 326 ms\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/surface/BezierSquare.ts?");

/***/ }),

/***/ "../engine/src/geometry/surface/BezierTriangle.ts":
/*!********************************************************!*\
  !*** ../engine/src/geometry/surface/BezierTriangle.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BezierTriangle\": () => (/* binding */ BezierTriangle)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_Polynomial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Polynomial */ \"../engine/src/math/Polynomial.ts\");\n/* harmony import */ var _Surface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Surface */ \"../engine/src/geometry/surface/Surface.ts\");\n\r\n\r\n\r\n/**\r\n * Three sided Bezier Surface\r\n */\r\nclass BezierTriangle extends _Surface__WEBPACK_IMPORTED_MODULE_2__.TriSurface {\r\n    constructor(verts, degree) {\r\n        super();\r\n        this.verts = verts;\r\n        this.degree = degree;\r\n    }\r\n    static new(verts, degree) {\r\n        return new BezierTriangle(verts, degree);\r\n    }\r\n    /**\r\n     * ```\r\n     * 0----1-----2----3\r\n     * |    |  A  |    |\r\n     * 4----5?----6?---7\r\n     * | B  |     |    | D\r\n     * 8----9?---10?---11\r\n     * |    |     |    |\r\n     * 12---13----14---15\r\n     *         C\r\n     *```\r\n     * @param a\r\n     * @param b\r\n     * @param c\r\n     * @param d\r\n     * @returns\r\n     */\r\n    static fromThreeEdge(a, b, c) {\r\n        // TODO do magic to discover the inner control points...\r\n        // TODO bezier curves must be of the same degree\r\n        return undefined;\r\n    }\r\n    pointAt(u, v, w) {\r\n        let p = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero();\r\n        let count = this.degree + 1;\r\n        for (let i = 0; i < count; i++) {\r\n            for (let j = 0; j < count; j++) {\r\n                let scalar = _math_Polynomial__WEBPACK_IMPORTED_MODULE_1__.Polynomial.bernstein(u, i, this.degree) *\r\n                    _math_Polynomial__WEBPACK_IMPORTED_MODULE_1__.Polynomial.bernstein(v, j, this.degree);\r\n                let index = i * count + j;\r\n                // console.log(i * count + j, s1, s2, scalar);\r\n                p.add(this.verts.get(index).scaled(scalar));\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n    // geo\r\n    clone() {\r\n        return BezierTriangle.new(this.verts.clone(), this.degree);\r\n    }\r\n    transform(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        return BezierTriangle.new(this.verts.transformed(m), this.degree);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/surface/BezierTriangle.ts?");

/***/ }),

/***/ "../engine/src/geometry/surface/Loft.ts":
/*!**********************************************!*\
  !*** ../engine/src/geometry/surface/Loft.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loft\": () => (/* binding */ Loft)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _mesh_Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh/Mesh */ \"../engine/src/geometry/mesh/Mesh.ts\");\n/* harmony import */ var _curve_Bezier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../curve/Bezier */ \"../engine/src/geometry/curve/Bezier.ts\");\n/* harmony import */ var _curve_Polyline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curve/Polyline */ \"../engine/src/geometry/curve/Polyline.ts\");\n/* harmony import */ var _Surface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Surface */ \"../engine/src/geometry/surface/Surface.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: mathematical representation of a parametric loft surface\r\n\r\n\r\n\r\n\r\n\r\nclass Loft extends _Surface__WEBPACK_IMPORTED_MODULE_4__.BiSurface {\r\n    constructor(curves) {\r\n        super();\r\n        this.curves = curves;\r\n    }\r\n    static new(curves) {\r\n        // make sure all curves are of the same degree, so we can easely interpolate\r\n        return new Loft(_curve_Bezier__WEBPACK_IMPORTED_MODULE_2__.Bezier.equalizeDegrees(curves));\r\n    }\r\n    getTransposedCurves() {\r\n        // this can only happen if the curves are all of the same degree,\r\n        // and at the very least, have the same number of controlpoints\r\n        let curves = [];\r\n        let isize = this.curves[0].verts.count;\r\n        let jsize = this.curves.length;\r\n        for (let i = 0; i < isize; i++) {\r\n            let verts = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.curves.length);\r\n            for (let j = 0; j < jsize; j++) {\r\n                verts.set(j, this.curves[j].verts.get(i));\r\n            }\r\n            curves.push(_curve_Bezier__WEBPACK_IMPORTED_MODULE_2__.Bezier.new(verts));\r\n        }\r\n        return curves;\r\n    }\r\n    pointAt(u, v) {\r\n        return this.isoCurveV(u).pointAt(v);\r\n    }\r\n    isoCurveV(u) {\r\n        return Loft.isoCurve(this.curves, u);\r\n    }\r\n    isoCurveU(v) {\r\n        let trans = this.getTransposedCurves();\r\n        return Loft.isoCurve(trans, v);\r\n    }\r\n    static isoCurve(curves, t) {\r\n        let pts = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(curves.length);\r\n        for (let i = 0; i < curves.length; i++) {\r\n            pts.set(i, curves[i].pointAt(t));\r\n        }\r\n        return _curve_Bezier__WEBPACK_IMPORTED_MODULE_2__.Bezier.new(pts);\r\n    }\r\n    /**\r\n     * same as buffer, but the udetail is semi-automated\r\n     */\r\n    bufferExact() {\r\n        // NOTE : to make this always watertight: take note of the precision when using polylines:\r\n        let vals = [];\r\n        for (let c of this.curves) {\r\n            if (c instanceof _curve_Polyline__WEBPACK_IMPORTED_MODULE_3__.Polyline) {\r\n                vals.push(c.verts.count - 1);\r\n            }\r\n        }\r\n        let perfectuSegments = vals.reduce((a, b) => {\r\n            return a * b;\r\n        });\r\n        return _mesh_Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh.fromBiSurface(this, perfectuSegments, perfectuSegments);\r\n    }\r\n    clone() {\r\n        let curves = new Array();\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            curves[i] = this.curves[i].clone();\r\n        }\r\n        return Loft.new(curves);\r\n    }\r\n    transform(m) {\r\n        for (let c of this.curves) {\r\n            c.transform(m);\r\n        }\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        let curves = new Array();\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            curves[i] = this.curves[i].transformed(m);\r\n        }\r\n        return Loft.new(curves);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/surface/Loft.ts?");

/***/ }),

/***/ "../engine/src/geometry/surface/Surface.ts":
/*!*************************************************!*\
  !*** ../engine/src/geometry/surface/Surface.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Surface\": () => (/* binding */ Surface),\n/* harmony export */   \"BiSurface\": () => (/* binding */ BiSurface),\n/* harmony export */   \"TriSurface\": () => (/* binding */ TriSurface)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: base interface / abstract classes for surfaces\r\n// todo : research this : https://graphics.pixar.com/library/HarmonicCoordinates/\r\n// todo : and this : https://doc.cgal.org/latest/Barycentric_coordinates_2/index.html\r\n\r\n/**\r\n * Any Surface. Maybe this will be expanded upon sometime in the future?\r\n */\r\nclass Surface extends _lib__WEBPACK_IMPORTED_MODULE_0__.Geometry {\r\n}\r\n/**\r\n * Bidirectional surface\r\n */\r\nclass BiSurface extends Surface {\r\n    buffer(uSegments = 100, vSegments = 100) {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromBiSurface(this, uSegments, vSegments);\r\n    }\r\n}\r\n/**\r\n * Tridirectional surface\r\n */\r\nclass TriSurface extends Surface {\r\n    buffer(segments) {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromTriSurface(this, segments);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/geometry/surface/Surface.ts?");

/***/ }),

/***/ "../engine/src/image/Bitmap.ts":
/*!*************************************!*\
  !*** ../engine/src/image/Bitmap.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bitmap\": () => (/* binding */ Bitmap)\n/* harmony export */ });\n/* harmony import */ var _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageProcessing */ \"../engine/src/image/ImageProcessing.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// image.ts\r\n// author: Jos Feenstra\r\n// purpose: wrapper around the ImageData class,\r\n// - in order to get more functionality out of it\r\n//\r\n// note: named Texture to not collide with Image classes.\r\n\r\n\r\n// TODO : x and y are not the same as i and j, and used inconsistently. fix this.\r\n// TODO : now that GEON is a package, we can use G.Image. the Geon suffix is not needed anymore is not needed anymore!\r\n/**\r\n * A class representing an image, meant to actually edit the image.\r\n */\r\nclass Bitmap {\r\n    constructor(width, height, depth = 4, data) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.depth = depth;\r\n        this.pixelCount = width * height;\r\n        if (data) {\r\n            this.data = data;\r\n        }\r\n        else {\r\n            this.data = new Uint8ClampedArray(this.width * this.height * this.depth);\r\n        }\r\n    }\r\n    get pixelSize() {\r\n        return this.depth;\r\n    }\r\n    get fullSize() {\r\n        return this.data.length;\r\n    }\r\n    static new(width, height, depth = 4) {\r\n        return new Bitmap(width, height, depth);\r\n    }\r\n    static fromImageData(id) {\r\n        let image = new Bitmap(id.width, id.height);\r\n        image.setData(id.data);\r\n        return image;\r\n    }\r\n    toImageData() {\r\n        // imagedata requires pixelsize of 4.\r\n        if (this.pixelSize == 1) {\r\n            console.log(\"conferting to rgba...\");\r\n            return _ImageProcessing__WEBPACK_IMPORTED_MODULE_0__.ImageProcessing.imagedataFromTrueGreyscale(this);\r\n        }\r\n        else if (this.pixelSize != 4) {\r\n            throw \"pixelsize must be 4 for toImageData to work\";\r\n        }\r\n        return new ImageData(this.data, this.width, this.height);\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.height * this.width * this.pixelSize)\r\n            throw \"data.length does not match width * height \";\r\n        this.data = data;\r\n    }\r\n    clone() {\r\n        let image = new Bitmap(this.width, this.height, this.pixelSize);\r\n        image.setData(this.data);\r\n        return image;\r\n    }\r\n    fillWithColors(colors) {\r\n        for (let i = 0; i < this.pixelCount; i++) {\r\n            this.setWithIndex(i, colors[i]);\r\n        }\r\n    }\r\n    fill(pixel) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                this.set(j, i, pixel);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    fillEvery(filler) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                this.set(j, i, filler());\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    forEach(filler) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                this.set(j, i, filler(j, i));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Perform an operation to every pixel of an image\r\n     */\r\n    forEachPixel(operation) {\r\n        let result = new Bitmap(this.width, this.height, this.pixelSize);\r\n        for (let i = 0; i < this.width; i++) {\r\n            for (let j = 0; j < this.height; j++) {\r\n                let pixel = this.get(i, j);\r\n                pixel = operation(pixel, i, j);\r\n                result.set(i, j, pixel);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Perform an operation to every pixel of a 'greyscale' image\r\n     */\r\n    forEachGreyscalePixel(operation) {\r\n        let result = new Bitmap(this.width, this.height, this.pixelSize);\r\n        for (let i = 0; i < this.width; i++) {\r\n            for (let j = 0; j < this.height; j++) {\r\n                let val = this.get(i, j)[0];\r\n                val = operation(val, i, j);\r\n                result.set(i, j, [val, val, val, 255]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    includes(x, y) {\r\n        return x < this.width && x >= 0 && y < this.height && y >= 0;\r\n    }\r\n    set(i, j, pixel) {\r\n        this.data[4 * (j * this.width + i)] = pixel[0];\r\n        this.data[4 * (j * this.width + i) + 1] = pixel[1];\r\n        this.data[4 * (j * this.width + i) + 2] = pixel[2];\r\n        this.data[4 * (j * this.width + i) + 3] = pixel[3];\r\n    }\r\n    get(i, j) {\r\n        return [\r\n            this.data[4 * (j * this.width + i)],\r\n            this.data[4 * (j * this.width + i) + 1],\r\n            this.data[4 * (j * this.width + i) + 2],\r\n            this.data[4 * (j * this.width + i) + 3],\r\n        ];\r\n    }\r\n    getWithIndex(index) {\r\n        return [\r\n            this.data[4 * index],\r\n            this.data[4 * index + 1],\r\n            this.data[4 * index + 2],\r\n            this.data[4 * index + 3],\r\n        ];\r\n    }\r\n    setWithIndex(index, value) {\r\n        this.data[4 * index] = value[0];\r\n        this.data[4 * index + 1] = value[1];\r\n        this.data[4 * index + 2] = value[2];\r\n        this.data[4 * index + 3] = value[3];\r\n    }\r\n    // NOTE: this should be fixed on the level of an nD array\r\n    vecToIndex(x, y) {\r\n        return y * this.width + x;\r\n    }\r\n    indexToVec(index) {\r\n        let base = Math.floor(index / this.width);\r\n        let left = index - base * this.width;\r\n        return _lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(left, base);\r\n    }\r\n    getNbIndices(index) {\r\n        let nbs = new Array();\r\n        if (index >= this.width * this.height)\r\n            return nbs;\r\n        // make sure we dont add out of bound dudes\r\n        if (index % this.width != 0)\r\n            nbs.push(index - 1);\r\n        if ((index + 1) % this.width != 0)\r\n            nbs.push(index + 1);\r\n        if (index - this.width > 0)\r\n            nbs.push(index - this.width);\r\n        if (index + this.width < this.width * this.height)\r\n            nbs.push(index + this.width);\r\n        return nbs;\r\n    }\r\n    getNbIndices8(index) {\r\n        let nbs = new Array();\r\n        let size = this.width * this.height;\r\n        if (index >= size)\r\n            return nbs;\r\n        let hasLeft = index % this.width != 0;\r\n        let hasRight = (index + 1) % this.width != 0;\r\n        let hasTop = index - this.width > 0;\r\n        let hasBot = index + this.width < size;\r\n        if (hasLeft)\r\n            nbs.push(index - 1);\r\n        if (hasRight)\r\n            nbs.push(index + 1);\r\n        if (hasTop)\r\n            nbs.push(index - this.width);\r\n        if (hasBot)\r\n            nbs.push(index + this.width);\r\n        if (hasTop && hasLeft)\r\n            nbs.push(index - this.width - 1);\r\n        if (hasTop && hasRight)\r\n            nbs.push(index - this.width + 1);\r\n        if (hasBot && hasLeft)\r\n            nbs.push(index + this.width - 1);\r\n        if (hasBot && hasRight)\r\n            nbs.push(index + this.width + 1);\r\n        return nbs;\r\n    }\r\n    flipHor() {\r\n        let image = new Bitmap(this.width, this.height, this.pixelSize);\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                let jMirror = this.width - 1 - j;\r\n                image.set(j, i, this.get(jMirror, i));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    flipVer() {\r\n        let image = new Bitmap(this.width, this.height, this.pixelSize);\r\n        for (let i = 0; i < this.height; i++) {\r\n            let iMirror = this.height - 1 - i;\r\n            for (let j = 0; j < this.width; j++) {\r\n                image.set(j, i, this.get(j, iMirror));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    rot90() {\r\n        let image = new Bitmap(this.height, this.width, this.pixelSize);\r\n        for (let oldy = 0; oldy < this.height; oldy++) {\r\n            for (let oldx = 0; oldx < this.width; oldx++) {\r\n                let x = this.width - 1 - oldy;\r\n                let y = oldx;\r\n                image.set(x, y, this.get(oldx, oldy));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    rot180() {\r\n        let image = new Bitmap(this.width, this.height, this.pixelSize);\r\n        for (let oldy = 0; oldy < this.height; oldy++) {\r\n            for (let oldx = 0; oldx < this.width; oldx++) {\r\n                let x = this.width - 1 - oldx;\r\n                let y = this.height - 1 - oldy;\r\n                image.set(x, y, this.get(oldx, oldy));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    rot270() {\r\n        let image = new Bitmap(this.height, this.width, this.pixelSize);\r\n        for (let oldy = 0; oldy < this.height; oldy++) {\r\n            for (let oldx = 0; oldx < this.width; oldx++) {\r\n                let x = oldy;\r\n                let y = this.width - 1 - oldx;\r\n                image.set(x, y, this.get(oldx, oldy));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    applyKernel(kernel) {\r\n        // determine kernel size\r\n        let size = kernel.count();\r\n        let radius = size / 2 - 0.5;\r\n        let image = new Bitmap(this.width - radius * 2, this.height - radius * 2, this.pixelSize);\r\n        // old image space\r\n        for (let i = radius; i < this.width - radius; i++) {\r\n            for (let j = radius; j < this.height - radius; j++) {\r\n                let pixel = this.getWithKernel(i, j, kernel, radius);\r\n                image.set(i - radius, j - radius, pixel);\r\n            }\r\n        }\r\n        return image; // succes\r\n    }\r\n    getMinMax() {\r\n        // get the minimum and maximum pixel value\r\n        // assumes pixelsize = 1\r\n        let min = Infinity;\r\n        let max = 0;\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (this.data[i] < min) {\r\n                min = this.data[i];\r\n            }\r\n            else if (this.data[i] > max) {\r\n                max = this.data[i];\r\n            }\r\n        }\r\n        return [min, max];\r\n    }\r\n    applyThreshold(lower, upper) {\r\n        return this.apply((x, y) => {\r\n            let pixel = this.get(x, y);\r\n            if (pixel[0] < lower) {\r\n                return [0, 0, 0, 0];\r\n            }\r\n            else if (pixel[0] > upper) {\r\n                return [255, 255, 255, 255];\r\n            }\r\n            else {\r\n                return pixel;\r\n            }\r\n        });\r\n    }\r\n    apply(filler) {\r\n        let copy = new Bitmap(this.width, this.height, this.pixelSize);\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                copy.set(x, y, filler(x, y));\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n    getWithKernel(i, j, kernel, radius) {\r\n        // kernel space\r\n        let sum = [0, 0, 0, 255];\r\n        let [dimx, dimy] = kernel.getDimensions();\r\n        for (let ki = 0; ki < dimx; ki++) {\r\n            for (let kj = 0; kj < dimy; kj++) {\r\n                let weight = kernel.get(ki, kj);\r\n                let pixel = this.get(i + ki - radius, j + kj - radius);\r\n                for (let i = 0; i < 3; i++) {\r\n                    sum[i] += pixel[i] * weight;\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n    setAplha(a) {\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                let pixel = this.get(x, y);\r\n                this.set(x, y, [pixel[0], pixel[1], pixel[2], a]);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    scale(scaleX, scaleY) {\r\n        // scale the image to a new width and height, using nearest neighbour\r\n        return this.resize(Math.round(this.width * scaleX), Math.round(this.height * scaleY));\r\n    }\r\n    resize(width, height) {\r\n        // resize the image to a new width and height, using nearest neighbour\r\n        const image = new Bitmap(width, height, this.pixelSize);\r\n        const old = this;\r\n        const x_factor = (1 / image.width) * old.width;\r\n        const y_factor = (1 / image.height) * old.height;\r\n        for (let y = 0; y < image.height; y++) {\r\n            for (let x = 0; x < image.width; x++) {\r\n                let pixel = old.get(Math.round(x * x_factor), Math.round(y * y_factor));\r\n                image.set(x, y, pixel);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    // add borders till this size is achieved\r\n    buffer(width, height) {\r\n        const image = new Bitmap(width, height, this.pixelSize);\r\n        const old = this;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                // console.log(x, y);\r\n                if (old.includes(x, y)) {\r\n                    image.set(x, y, old.get(x, y));\r\n                }\r\n            }\r\n        }\r\n        // for (let y = 0; y < height; y++) {\r\n        //     for (let x = 0; x < width; x++) {\r\n        //         image.set(x, y, [x,0,0,255]);\r\n        //     }\r\n        // }\r\n        // build some simple image instead to test\r\n        // for (let i = 0; i < image.data.length / 4; i++) {\r\n        //     image.data[i*4 + 0] = i % 255;\r\n        //     image.data[i*4 + 1] = 0;\r\n        //     image.data[i*4 + 2] = 0;\r\n        //     image.data[i*4 + 3] = 255;\r\n        // }\r\n        return image;\r\n    }\r\n    trimWithDomain(dom) {\r\n        const x1 = Math.round(dom.x.t0);\r\n        const x2 = Math.round(dom.x.t1);\r\n        const y1 = Math.round(dom.y.t0);\r\n        const y2 = Math.round(dom.y.t1);\r\n        return this.trim(x1, y1, x2, y2);\r\n    }\r\n    trim(x1, y1, x2, y2) {\r\n        // return a hardcopy of this particular window\r\n        const imageWidth = x2 - x1;\r\n        const imageHeight = y2 - y1;\r\n        const image = new Bitmap(imageWidth, imageHeight, this.pixelSize);\r\n        for (let y = 0; y < imageHeight; y++) {\r\n            for (let x = 0; x < imageWidth; x++) {\r\n                let pixel = this.get(x + x1, y + y1);\r\n                image.set(x, y, pixel);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    periodicTrim(x1, y1, x2, y2) {\r\n        // return a hardcopy of this particular window\r\n        const imageWidth = x2 - x1;\r\n        const imageHeight = y2 - y1;\r\n        const image = new Bitmap(imageWidth, imageHeight, this.pixelSize);\r\n        for (let y = 0; y < imageHeight; y++) {\r\n            for (let x = 0; x < imageWidth; x++) {\r\n                let pixel = this.get((x + x1) % this.width, (y + y1) % this.height);\r\n                image.set(x, y, pixel);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    toGreyscale() {\r\n        if (this.pixelSize != 4)\r\n            throw \"please, only use this when pixelsize is 4\";\r\n        let image = new Bitmap(this.width, this.height, 4);\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                let pixel = this.get(x, y);\r\n                let avg = (pixel[0] + pixel[1] + pixel[2]) / 3;\r\n                image.set(x, y, [avg, avg, avg, 255]);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    toRGBA() {\r\n        // if (this.pixelSize != 1) throw \"please, only use this when pixelsize is 1\"\r\n        return this;\r\n        // let image = new Texture(this.width, this.height, 4);\r\n        // for (let y = 0; y < this.height; y++) {\r\n        //     for (let x = 0; x < this.width; x++) {\r\n        //         let pixel = this.get(x,y);\r\n        //         let val = pixel[0];\r\n        //         image.set(x, y, [val, val, val, 255]);\r\n        //     }\r\n        // }\r\n        // return image;\r\n    }\r\n    /**\r\n     * Do a bucketfill (like the ms-paint tool)\r\n     */\r\n    bucketFill(start, color, diagonals = false) {\r\n        let startColor = this.get(start.x, start.y);\r\n        let fillColor = color.toInt();\r\n        let visitCondition = (val) => {\r\n            let color = this.getWithIndex(val);\r\n            return color[0] == startColor[0] && color[1] == startColor[1] && color[2] == startColor[2] && color[3] == startColor[3];\r\n        };\r\n        let visitAction = (val) => {\r\n            this.setWithIndex(val, fillColor);\r\n        };\r\n        let getNeighbors;\r\n        if (diagonals) {\r\n            getNeighbors = this.getNbIndices8.bind(this);\r\n        }\r\n        else {\r\n            getNeighbors = this.getNbIndices.bind(this);\r\n        }\r\n        this.bucketFillCustom(start, visitCondition, visitAction, getNeighbors);\r\n    }\r\n    /**\r\n     * Do a custom bucketfill (like the ms-paint tool)\r\n     * @param image\r\n     * @param start\r\n     * @param visitCondition if this returns true, we should visit the pixel with this index\r\n     * @param visitAction what to do at a visit\r\n     * @param getNeighbors how to get the neighoring indices\r\n     */\r\n    bucketFillCustom(start, visitCondition, visitAction, getNeighbors) {\r\n        let checked = new Set();\r\n        let toVisit = new Array();\r\n        let startIndex = this.vecToIndex(start.x, start.y);\r\n        toVisit.push(startIndex);\r\n        checked.add(startIndex);\r\n        while (toVisit.length > 0) {\r\n            let cursor = toVisit.pop();\r\n            visitAction(cursor);\r\n            for (let nb of getNeighbors(cursor)) {\r\n                if (checked.has(nb))\r\n                    continue;\r\n                checked.add(nb);\r\n                if (!visitCondition(nb))\r\n                    continue;\r\n                toVisit.push(nb);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/image/Bitmap.ts?");

/***/ }),

/***/ "../engine/src/image/Color.ts":
/*!************************************!*\
  !*** ../engine/src/image/Color.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Color\": () => (/* binding */ Color)\n/* harmony export */ });\n/**\r\n * A [0 - 1] float based RGBA representation of color, so it can be loaded directly into webgl\r\n *\r\n * Contains a variety of conversion functions\r\n */\r\nclass Color {\r\n    constructor(data) {\r\n        this.data = data;\r\n    }\r\n    get r() { return this.data[0]; }\r\n    get g() { return this.data[1]; }\r\n    get b() { return this.data[2]; }\r\n    get a() { return this.data[3]; }\r\n    set r(value) { this.data[0] = value; }\r\n    set g(value) { this.data[1] = value; }\r\n    set b(value) { this.data[2] = value; }\r\n    set a(value) { this.data[3] = value; }\r\n    static new() {\r\n        return new Color([1, 1, 1, 1]);\r\n    }\r\n    static fromHex(str) {\r\n        str = str.replace('#', '');\r\n        let parts = str.match(/.{1,2}/g);\r\n        if (!parts) {\r\n            console.warn(`couldnt convert hex ${str} to color`);\r\n            return undefined;\r\n        }\r\n        let values = [];\r\n        for (let p of parts) {\r\n            let integer = parseInt(p, 16);\r\n            if (integer === undefined) {\r\n                console.warn(`couldnt convert hex ${p} to color`);\r\n                return undefined;\r\n            }\r\n            values.push(integer / 255);\r\n        }\r\n        return Color.fromRGB(...values);\r\n    }\r\n    static fromRGB(r = 1, g = 1, b = 1, a = 1) {\r\n        return new Color([r, g, b, a]);\r\n    }\r\n    static fromList(list) {\r\n        if (list.length != 3) {\r\n            return undefined;\r\n        }\r\n        return new Color(list);\r\n    }\r\n    static fromHSL(h, s = 1, l = 0.5, a = 1) {\r\n        let r, g, b;\r\n        if (s == 0) {\r\n            r = g = b = l; // achromatic\r\n        }\r\n        else {\r\n            let hue2rgb = (p, q, t) => {\r\n                if (t < 0)\r\n                    t += 1;\r\n                if (t > 1)\r\n                    t -= 1;\r\n                if (t < 1 / 6)\r\n                    return p + (q - p) * 6 * t;\r\n                if (t < 1 / 2)\r\n                    return q;\r\n                if (t < 2 / 3)\r\n                    return p + (q - p) * (2 / 3 - t) * 6;\r\n                return p;\r\n            };\r\n            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n            let p = 2 * l - q;\r\n            r = hue2rgb(p, q, h + 1 / 3);\r\n            g = hue2rgb(p, q, h);\r\n            b = hue2rgb(p, q, h - 1 / 3);\r\n        }\r\n        return Color.fromRGB(r, g, b, a);\r\n    }\r\n    static fromInt(list) {\r\n        return new Color(list.map(v => v / 255));\r\n    }\r\n    /**\r\n     * This is very dirty\r\n     */\r\n    static isTheSame(a, b) {\r\n        return a[0] == b[0] && a[1] == b[1] && a[2] == b[2];\r\n    }\r\n    toInt() {\r\n        let process = (n) => {\r\n            return Math.round(n * 255);\r\n        };\r\n        return [process(this.r), process(this.g), process(this.b), process(this.a)];\r\n    }\r\n    toHex8() {\r\n        let process = (n) => {\r\n            let str = Math.round(n * 255).toString(16);\r\n            str = (str.length == 1) ? \"0\" + str : str;\r\n            return str;\r\n        };\r\n        return `#${process(this.r)}${process(this.g)}${process(this.b)}${process(this.a)}`;\r\n    }\r\n    toHex6() {\r\n        let process = (n) => {\r\n            let str = Math.round(n * 255).toString(16);\r\n            str = (str.length == 1) ? \"0\" + str : str;\r\n            return str;\r\n        };\r\n        return `#${process(this.r)}${process(this.g)}${process(this.b)}`;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/image/Color.ts?");

/***/ }),

/***/ "../engine/src/image/Colors.ts":
/*!*************************************!*\
  !*** ../engine/src/image/Colors.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hslToRgb\": () => (/* binding */ hslToRgb),\n/* harmony export */   \"rgbToHsl\": () => (/* binding */ rgbToHsl),\n/* harmony export */   \"COLOR\": () => (/* binding */ COLOR)\n/* harmony export */ });\n/* harmony import */ var _Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Color */ \"../engine/src/image/Color.ts\");\n// found this here:\r\n// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion\r\n\r\n/**\r\n * Converts an HSL color value to RGB. Conversion formula\r\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes h, s, and l are contained in the set [0, 1] and\r\n * returns r, g, and b in the set [0, 255].\r\n *\r\n * @param   {number}  h       The hue\r\n * @param   {number}  s       The saturation\r\n * @param   {number}  l       The lightness\r\n * @return  {Array}           The RGB representation\r\n */\r\nfunction hslToRgb(h, s, l) {\r\n    let r, g, b;\r\n    if (s == 0) {\r\n        r = g = b = l; // achromatic\r\n    }\r\n    else {\r\n        let hue2rgb = (p, q, t) => {\r\n            if (t < 0)\r\n                t += 1;\r\n            if (t > 1)\r\n                t -= 1;\r\n            if (t < 1 / 6)\r\n                return p + (q - p) * 6 * t;\r\n            if (t < 1 / 2)\r\n                return q;\r\n            if (t < 2 / 3)\r\n                return p + (q - p) * (2 / 3 - t) * 6;\r\n            return p;\r\n        };\r\n        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        let p = 2 * l - q;\r\n        r = hue2rgb(p, q, h + 1 / 3);\r\n        g = hue2rgb(p, q, h);\r\n        b = hue2rgb(p, q, h - 1 / 3);\r\n    }\r\n    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\r\n}\r\n/**\r\n * Converts an RGB color value to HSL. Conversion formula\r\n * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\r\n * Assumes r, g, and b are contained in the set [0, 255] and\r\n * returns h, s, and l in the set [0, 1].\r\n *\r\n * @param   {number}  r       The red color value\r\n * @param   {number}  g       The green color value\r\n * @param   {number}  b       The blue color value\r\n * @return  {Array}           The HSL representation\r\n */\r\nfunction rgbToHsl(r, g, b) {\r\n    (r /= 255), (g /= 255), (b /= 255);\r\n    let max = Math.max(r, g, b), min = Math.min(r, g, b);\r\n    let h, s, l = (max + min) / 2;\r\n    if (max == min) {\r\n        h = s = 0; // achromatic\r\n    }\r\n    else {\r\n        let d = max - min;\r\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n        switch (max) {\r\n            case r:\r\n                h = (g - b) / d + (g < b ? 6 : 0);\r\n                break;\r\n            case g:\r\n                h = (b - r) / d + 2;\r\n                break;\r\n            case b:\r\n                h = (r - g) / d + 4;\r\n                break;\r\n            default:\r\n                throw \"nope\";\r\n        }\r\n        h /= 6;\r\n    }\r\n    return [h, s, l];\r\n}\r\nconst COLOR = {\r\n    \"aliceblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f0f8ff\"),\r\n    \"antiquewhite\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#faebd7\"),\r\n    \"aqua\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00ffff\"),\r\n    \"aquamarine\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#7fffd4\"),\r\n    \"azure\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f0ffff\"),\r\n    \"beige\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f5f5dc\"),\r\n    \"bisque\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffe4c4\"),\r\n    \"black\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#000000\"),\r\n    \"blanchedalmond\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffebcd\"),\r\n    \"blue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#0000ff\"),\r\n    \"blueviolet\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#8a2be2\"),\r\n    \"brown\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#a52a2a\"),\r\n    \"burlywood\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#deb887\"),\r\n    \"cadetblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#5f9ea0\"),\r\n    \"chartreuse\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#7fff00\"),\r\n    \"chocolate\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#d2691e\"),\r\n    \"coral\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff7f50\"),\r\n    \"cornflowerblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#6495ed\"),\r\n    \"cornsilk\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff8dc\"),\r\n    \"crimson\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#dc143c\"),\r\n    \"cyan\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00ffff\"),\r\n    \"darkblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00008b\"),\r\n    \"darkcyan\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#008b8b\"),\r\n    \"darkgoldenrod\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#b8860b\"),\r\n    \"darkgray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#a9a9a9\"),\r\n    \"darkgreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#006400\"),\r\n    \"darkgrey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#a9a9a9\"),\r\n    \"darkkhaki\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#bdb76b\"),\r\n    \"darkmagenta\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#8b008b\"),\r\n    \"darkolivegreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#556b2f\"),\r\n    \"darkorange\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff8c00\"),\r\n    \"darkorchid\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#9932cc\"),\r\n    \"darkred\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#8b0000\"),\r\n    \"darksalmon\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#e9967a\"),\r\n    \"darkseagreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#8fbc8f\"),\r\n    \"darkslateblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#483d8b\"),\r\n    \"darkslategray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#2f4f4f\"),\r\n    \"darkslategrey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#2f4f4f\"),\r\n    \"darkturquoise\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00ced1\"),\r\n    \"darkviolet\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#9400d3\"),\r\n    \"deeppink\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff1493\"),\r\n    \"deepskyblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00bfff\"),\r\n    \"dimgray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#696969\"),\r\n    \"dimgrey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#696969\"),\r\n    \"dodgerblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#1e90ff\"),\r\n    \"firebrick\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#b22222\"),\r\n    \"floralwhite\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fffaf0\"),\r\n    \"forestgreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#228b22\"),\r\n    \"fuchsia\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff00ff\"),\r\n    \"gainsboro\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#dcdcdc\"),\r\n    \"ghostwhite\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f8f8ff\"),\r\n    \"goldenrod\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#daa520\"),\r\n    \"gold\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffd700\"),\r\n    \"gray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#808080\"),\r\n    \"green\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#008000\"),\r\n    \"greenyellow\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#adff2f\"),\r\n    \"grey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#808080\"),\r\n    \"honeydew\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f0fff0\"),\r\n    \"hotpink\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff69b4\"),\r\n    \"indianred\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#cd5c5c\"),\r\n    \"indigo\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#4b0082\"),\r\n    \"ivory\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fffff0\"),\r\n    \"khaki\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f0e68c\"),\r\n    \"lavenderblush\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff0f5\"),\r\n    \"lavender\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#e6e6fa\"),\r\n    \"lawngreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#7cfc00\"),\r\n    \"lemonchiffon\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fffacd\"),\r\n    \"lightblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#add8e6\"),\r\n    \"lightcoral\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f08080\"),\r\n    \"lightcyan\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#e0ffff\"),\r\n    \"lightgoldenrodyellow\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fafad2\"),\r\n    \"lightgray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#d3d3d3\"),\r\n    \"lightgreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#90ee90\"),\r\n    \"lightgrey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#d3d3d3\"),\r\n    \"lightpink\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffb6c1\"),\r\n    \"lightsalmon\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffa07a\"),\r\n    \"lightseagreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#20b2aa\"),\r\n    \"lightskyblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#87cefa\"),\r\n    \"lightslategray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#778899\"),\r\n    \"lightslategrey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#778899\"),\r\n    \"lightsteelblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#b0c4de\"),\r\n    \"lightyellow\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffffe0\"),\r\n    \"lime\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00ff00\"),\r\n    \"limegreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#32cd32\"),\r\n    \"linen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#faf0e6\"),\r\n    \"magenta\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff00ff\"),\r\n    \"maroon\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#800000\"),\r\n    \"mediumaquamarine\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#66cdaa\"),\r\n    \"mediumblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#0000cd\"),\r\n    \"mediumorchid\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ba55d3\"),\r\n    \"mediumpurple\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#9370db\"),\r\n    \"mediumseagreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#3cb371\"),\r\n    \"mediumslateblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#7b68ee\"),\r\n    \"mediumspringgreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00fa9a\"),\r\n    \"mediumturquoise\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#48d1cc\"),\r\n    \"mediumvioletred\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#c71585\"),\r\n    \"midnightblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#191970\"),\r\n    \"mintcream\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f5fffa\"),\r\n    \"mistyrose\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffe4e1\"),\r\n    \"moccasin\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffe4b5\"),\r\n    \"navajowhite\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffdead\"),\r\n    \"navy\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#000080\"),\r\n    \"oldlace\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fdf5e6\"),\r\n    \"olive\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#808000\"),\r\n    \"olivedrab\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#6b8e23\"),\r\n    \"orange\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffa500\"),\r\n    \"orangered\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff4500\"),\r\n    \"orchid\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#da70d6\"),\r\n    \"palegoldenrod\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#eee8aa\"),\r\n    \"palegreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#98fb98\"),\r\n    \"paleturquoise\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#afeeee\"),\r\n    \"palevioletred\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#db7093\"),\r\n    \"papayawhip\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffefd5\"),\r\n    \"peachpuff\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffdab9\"),\r\n    \"peru\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#cd853f\"),\r\n    \"pink\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffc0cb\"),\r\n    \"plum\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#dda0dd\"),\r\n    \"powderblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#b0e0e6\"),\r\n    \"purple\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#800080\"),\r\n    \"rebeccapurple\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#663399\"),\r\n    \"red\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff0000\"),\r\n    \"rosybrown\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#bc8f8f\"),\r\n    \"royalblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#4169e1\"),\r\n    \"saddlebrown\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#8b4513\"),\r\n    \"salmon\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fa8072\"),\r\n    \"sandybrown\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f4a460\"),\r\n    \"seagreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#2e8b57\"),\r\n    \"seashell\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff5ee\"),\r\n    \"sienna\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#a0522d\"),\r\n    \"silver\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#c0c0c0\"),\r\n    \"skyblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#87ceeb\"),\r\n    \"slateblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#6a5acd\"),\r\n    \"slategray\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#708090\"),\r\n    \"slategrey\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#708090\"),\r\n    \"snow\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fffafa\"),\r\n    \"springgreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#00ff7f\"),\r\n    \"steelblue\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#4682b4\"),\r\n    \"tan\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#d2b48c\"),\r\n    \"teal\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#008080\"),\r\n    \"thistle\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#d8bfd8\"),\r\n    \"tomato\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff6347\"),\r\n    \"turquoise\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#40e0d0\"),\r\n    \"violet\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ee82ee\"),\r\n    \"wheat\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f5deb3\"),\r\n    \"white\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffffff\"),\r\n    \"whitesmoke\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f5f5f5\"),\r\n    \"yellow\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffff00\"),\r\n    \"yellowgreen\": _Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#9acd32\")\r\n};\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/image/Colors.ts?");

/***/ }),

/***/ "../engine/src/image/ImageProcessing.ts":
/*!**********************************************!*\
  !*** ../engine/src/image/ImageProcessing.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageProcessing\": () => (/* binding */ ImageProcessing)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Bitmap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bitmap */ \"../engine/src/image/Bitmap.ts\");\n/* harmony import */ var _Kernels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Kernels */ \"../engine/src/image/Kernels.ts\");\n\r\n\r\n\r\nvar ImageProcessing;\r\n(function (ImageProcessing) {\r\n    const GREY_LVLS = 256;\r\n    function imagedataFromTrueGreyscale(grey) {\r\n        let rgba = new Uint8ClampedArray(grey.width * grey.height * 4);\r\n        for (let i = 0; i < grey.width; i++) {\r\n            for (let j = 0; j < grey.height; j++) {\r\n                let val = grey.get(j, i)[0];\r\n                if (i == 0 && j == 0) {\r\n                    console.log(grey.get(100, 100));\r\n                }\r\n                rgba[4 * (i * grey.width + j)] = val;\r\n                rgba[4 * (i * grey.width + j) + 1] = val;\r\n                rgba[4 * (i * grey.width + j) + 2] = val;\r\n                rgba[4 * (i * grey.width + j) + 3] = 255;\r\n            }\r\n        }\r\n        // let rgba = new Texture(grey.width, grey.height, 4);\r\n        // rgba.fillEvery((x: number, y: number) => {\r\n        //     let pixel = grey.get(x, y);\r\n        //     return [pixel[0], pixel[0], pixel[0], 255];\r\n        // });\r\n        return new ImageData(rgba, grey.width, grey.height);\r\n    }\r\n    ImageProcessing.imagedataFromTrueGreyscale = imagedataFromTrueGreyscale;\r\n    /**\r\n     * Returns a greyscale image which still contains\r\n     */\r\n    function fakeGreyscale(rgba) {\r\n        if (rgba.pixelSize != 4)\r\n            throw \"please, only use this when pixelsize is 4\";\r\n        let image = new _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap(rgba.width, rgba.height, 4);\r\n        for (let y = 0; y < rgba.height; y++) {\r\n            for (let x = 0; x < rgba.width; x++) {\r\n                let pixel = rgba.get(x, y);\r\n                let avg = (pixel[0] + pixel[1] + pixel[2]) / 3;\r\n                image.set(x, y, [avg, avg, avg, 255]);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    ImageProcessing.fakeGreyscale = fakeGreyscale;\r\n    function trueGreyscale(rgba) {\r\n        let grey = new _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap(rgba.width, rgba.height, 1);\r\n        for (let i = 0; i < grey.height; i++) {\r\n            for (let j = 0; j < grey.width; j++) {\r\n                grey.data[1 * (i * grey.width + j)] = 0;\r\n            }\r\n        }\r\n        // grey.forEach((x: number, y: number) => {\r\n        //     let pixel = rgba.get(y, x);\r\n        //     pixel = [126, 126, 126, 255];\r\n        //     return [Math.round(pixel[0] + pixel[1] + pixel[2] / 3)];\r\n        // });\r\n        return grey;\r\n    }\r\n    ImageProcessing.trueGreyscale = trueGreyscale;\r\n    // ------ [ CANNY EDGE DETECTION ] --------\r\n    /**\r\n     * This performs a pythagorean sum of a vertical & horizontal sobel kernel.\r\n     * @returns [gradient: Texture, direction: Texture]\r\n     */\r\n    function sobelMD(image) {\r\n        let kernelLeft = _Kernels__WEBPACK_IMPORTED_MODULE_2__.Kernels.SobelLeft;\r\n        let kernelUp = _Kernels__WEBPACK_IMPORTED_MODULE_2__.Kernels.SobelUp;\r\n        let size = kernelLeft.count();\r\n        let radius = size / 2 - 0.5;\r\n        let newWidth = image.width - radius * 2;\r\n        let newHeight = image.height - radius * 2;\r\n        let magnitudeImage = new _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap(newWidth, newHeight, image.pixelSize);\r\n        let directionImage = new _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap(newWidth, newHeight, image.pixelSize);\r\n        for (let i = radius; i < image.width - radius; i++) {\r\n            for (let j = radius; j < image.height - radius; j++) {\r\n                let pixelX = image.getWithKernel(i, j, kernelLeft, radius);\r\n                let pixelY = image.getWithKernel(i, j, kernelUp, radius);\r\n                let deltaX = pixelX[0];\r\n                let deltaY = pixelY[0];\r\n                // note: this was an idea do use all color differences, instead of just greyscale colors. Results are unpredictable however...\r\n                // take the maximum color difference;\r\n                // let deltaX = Math.sqrt(pixelX[0] * pixelX[0] + pixelX[1] * pixelX[1] + pixelX[2] * pixelX[2]) / 2;\r\n                // let deltaY = Math.sqrt(pixelY[0] * pixelY[0] + pixelY[1] * pixelY[1] + pixelY[2] * pixelY[2]) / 2;\r\n                let gradient = Math.pow(deltaX * deltaX + deltaY * deltaY, 0.5);\r\n                let desI = i - radius;\r\n                let desJ = j - radius;\r\n                directionImage.set(desI, desJ, [(deltaX + 255) / 2, (deltaY + 255) / 2, 255, 255]);\r\n                magnitudeImage.set(desI, desJ, [gradient, gradient, gradient, 255]);\r\n            }\r\n        }\r\n        return [magnitudeImage, directionImage];\r\n    }\r\n    ImageProcessing.sobelMD = sobelMD;\r\n    /**\r\n     * Take a bump map, or a direction image, and convert it to a `theta-angle-greyscale` image.\r\n     *\r\n     */\r\n    function thetaMap(direction) {\r\n        let result = direction.forEachPixel((pixel, i, j) => {\r\n            // get the angle a (x,y) vector makes with a (1,0) vector. result From -PI to PI.\r\n            let theta = Math.atan2(pixel[1] - 128, pixel[0] - 128);\r\n            // normalize to [0 - 1] space;\r\n            theta = (theta + Math.PI) / (Math.PI * 2);\r\n            // put back into a greyscale image\r\n            theta = theta * 255;\r\n            return [theta, theta, theta, 255];\r\n        });\r\n        return result;\r\n    }\r\n    ImageProcessing.thetaMap = thetaMap;\r\n    /**\r\n     * Clamp a theta-map to `x` number of directions\r\n     */\r\n    function clampGreyscale(image, numberOfValues) {\r\n        let result = image.forEachGreyscalePixel((val) => {\r\n            return Math.round((val / 255) * numberOfValues) % numberOfValues;\r\n        });\r\n        return result;\r\n    }\r\n    ImageProcessing.clampGreyscale = clampGreyscale;\r\n    /**\r\n     * Take the canny process, but render all in-between steps\r\n     * When using Dynamic Threshold, the lower and upper values refer to 'edge intensity percentile' values.\r\n     *\r\n     */\r\n    function canny(original, blurSigma = 1.4, blurSize = 3, lower = 100, upper = 200, equalizeHistogram = true, dynamicThreshold = false, dr) {\r\n        const weak = 128;\r\n        const strong = 255;\r\n        let grey = original.toGreyscale();\r\n        if (equalizeHistogram) {\r\n            grey = ImageProcessing.equalizeHistogram(grey);\r\n        }\r\n        let gauss = _Kernels__WEBPACK_IMPORTED_MODULE_2__.Kernels.generateGaussianKernel(blurSigma, blurSize);\r\n        let blurred = grey.applyKernel(gauss);\r\n        let [magnitude, direction] = ImageProcessing.sobelMD(blurred);\r\n        let thetaDirections = ImageProcessing.thetaMap(direction);\r\n        let supressed = ImageProcessing.cannyNonMaximumSuppression(magnitude, thetaDirections);\r\n        if (dynamicThreshold) {\r\n            [lower, upper] = ImageProcessing.cannyDynamicthreshold(supressed, lower / 255, upper / 255);\r\n        }\r\n        let thressed = ImageProcessing.cannyThreshold(supressed, lower, upper, weak, strong);\r\n        let result = ImageProcessing.cannyHysteresis(thressed, weak, strong);\r\n        // early out if we are not interested in debugging\r\n        if (!dr) {\r\n            return result;\r\n        }\r\n        let offset = 0;\r\n        let addToDR = (img, label) => {\r\n            let plane = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldYZ().moveTo(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(-offset, 0, 0));\r\n            dr === null || dr === void 0 ? void 0 : dr.set(_lib__WEBPACK_IMPORTED_MODULE_0__.ImageMesh.new(img, plane, 1, false, true), label);\r\n            offset += 10;\r\n        };\r\n        if (dynamicThreshold) {\r\n            console.log(\"dynamic threshold used: \", { lower, upper });\r\n        }\r\n        addToDR(original, \"original\");\r\n        addToDR(grey, \"grey\");\r\n        addToDR(blurred, \"blurred\");\r\n        addToDR(magnitude, \"sobel magnitude\");\r\n        addToDR(direction, \"sobel direction\");\r\n        addToDR(supressed, \"supressed\");\r\n        addToDR(thressed, \"threshold\");\r\n        addToDR(result, \"hysteresis\");\r\n        return result;\r\n    }\r\n    ImageProcessing.canny = canny;\r\n    function cannyDynamicthreshold(supressed, lowerPercentile, upperPercentile) {\r\n        let histogram = ImageProcessing.getHistogram(supressed);\r\n        // remove lowest channel\r\n        let count = supressed.width * supressed.height - histogram[0];\r\n        histogram.splice(0, 1);\r\n        let cfg = ImageProcessing.getCFG(histogram, count);\r\n        // console.log(histogram);\r\n        // console.log(cfg);\r\n        // returns the pixel intensity at which `percentile` percent of pixels left in the image are more intense\r\n        // if (p=0.95) return 128, that means that pixels more intense than 128 make up 0.05 of the image.  \r\n        let getValueAtPercentile = (cfg, percentile) => {\r\n            for (let i = 0; i < GREY_LVLS; i++) {\r\n                // NOTE: because i am stupid, there needs to be a plus or minus one somewhere in here\r\n                if (cfg[i] > percentile) {\r\n                    return i;\r\n                }\r\n            }\r\n            return undefined;\r\n        };\r\n        let lower = getValueAtPercentile(cfg, lowerPercentile);\r\n        let upper = getValueAtPercentile(cfg, upperPercentile);\r\n        return [lower, upper];\r\n    }\r\n    ImageProcessing.cannyDynamicthreshold = cannyDynamicthreshold;\r\n    /**\r\n     *\r\n     */\r\n    function cannyNonMaximumSuppression(magnitude, direction) {\r\n        // dir is from 0 to 255\r\n        let magGet = (i, j) => {\r\n            return magnitude.get(i, j)[0];\r\n        };\r\n        let range = 1;\r\n        let result = new _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap(magnitude.width - range * 2, magnitude.height - range * 2, magnitude.pixelSize);\r\n        for (let i = range; i < magnitude.width - range; i++) {\r\n            for (let j = range; j < magnitude.height - range; j++) {\r\n                const mag = magGet(i, j);\r\n                const dir = direction.get(i, j)[0] % 128;\r\n                let val = mag;\r\n                // per direction bucket (dir is angle from 0 to 255)\r\n                if (dir >= 16 && dir < 48) {\r\n                    // diagonal-/\r\n                    if (magGet(i + 1, j + 1) > mag || magGet(i - 1, j - 1) > mag)\r\n                        val = 0;\r\n                }\r\n                else if (dir >= 48 && dir < 80) {\r\n                    // vertical\r\n                    if (magGet(i, j - 1) > mag || magGet(i, j + 1) > mag)\r\n                        val = 0;\r\n                }\r\n                else if (dir >= 80 && dir < 112) {\r\n                    // diagonal-\\\r\n                    if (magGet(i + 1, j - 1) > mag || magGet(i - 1, j + 1) > mag)\r\n                        val = 0;\r\n                }\r\n                else {\r\n                    // horizontal\r\n                    if (magGet(i - 1, j) > mag || magGet(i + 1, j) > mag)\r\n                        val = 0;\r\n                }\r\n                result.set(i, j, [val, val, val, 255]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    ImageProcessing.cannyNonMaximumSuppression = cannyNonMaximumSuppression;\r\n    function cannyThreshold(image, lower, upper, weakValue, strongValue) {\r\n        let result = image.forEachGreyscalePixel((val) => {\r\n            if (val < lower) {\r\n                return 0;\r\n            }\r\n            else if (val >= lower && val < upper) {\r\n                return weakValue;\r\n            }\r\n            else {\r\n                return strongValue;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    ImageProcessing.cannyThreshold = cannyThreshold;\r\n    function cannyHysteresis(image, weakValue, strongValue) {\r\n        let result = _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap.new(image.width, image.height).fill([0, 0, 0, 255]);\r\n        let condition = (index) => {\r\n            let val = image.getWithIndex(index)[0];\r\n            return val == weakValue;\r\n        };\r\n        let action = (index) => {\r\n            result.setWithIndex(index, [strongValue, strongValue, strongValue, 255]);\r\n        };\r\n        let count = image.width * image.height;\r\n        for (let i = 0; i < count; i++) {\r\n            let pixel = image.getWithIndex(i)[0];\r\n            if (pixel != strongValue)\r\n                continue;\r\n            // fill all adjacent weak values recursively\r\n            let vec = image.indexToVec(i);\r\n            image.bucketFillCustom(vec, condition, action, image.getNbIndices8.bind(image));\r\n            // break;\r\n        }\r\n        return result;\r\n    }\r\n    ImageProcessing.cannyHysteresis = cannyHysteresis;\r\n    /**\r\n     * same as image.bucketfill, but functional style\r\n     */\r\n    function bucketFill(image, start, color, diagonal = false) {\r\n        image.clone();\r\n        image.bucketFill(start, color, diagonal);\r\n        return image;\r\n    }\r\n    ImageProcessing.bucketFill = bucketFill;\r\n    /**\r\n     * Put all pixels in a\r\n     */\r\n    function equalizeHistogram(image, channel = 0) {\r\n        let histogram = getHistogram(image);\r\n        let count = image.width * image.height;\r\n        let cfg = getCFG(histogram, count);\r\n        let equalized = new _Bitmap__WEBPACK_IMPORTED_MODULE_1__.Bitmap(image.width, image.height);\r\n        for (let i = 0; i < count; i++) {\r\n            let value = image.getWithIndex(i)[channel];\r\n            let newValue = cfg[value] * 255;\r\n            equalized.setWithIndex(i, [newValue, newValue, newValue, 255]);\r\n        }\r\n        return equalized;\r\n    }\r\n    ImageProcessing.equalizeHistogram = equalizeHistogram;\r\n    function getHistogram(image, channel = 0) {\r\n        let histogram = new Array(GREY_LVLS);\r\n        for (let i = 0; i < GREY_LVLS; i++) {\r\n            histogram[i] = 0;\r\n        }\r\n        // just take the first (red) channel, and pretend it is a greyscale image\r\n        let count = image.width * image.height;\r\n        for (let i = 0; i < count; i++) {\r\n            let value = image.getWithIndex(i)[channel];\r\n            histogram[value] = histogram[value] + 1;\r\n        }\r\n        return histogram;\r\n    }\r\n    ImageProcessing.getHistogram = getHistogram;\r\n    /**\r\n     * Calculate the cumulative distributive function of a histogram\r\n     * @param histogram an array, each item is how many times i occures. ASSUMES `GREY_LVLS` amount of buckets\r\n     * @param totalCount the sum of the histogram\r\n     * @returns\r\n     */\r\n    function getCFG(histogram, totalCount) {\r\n        let cfg = new Array(histogram.length);\r\n        let sum = 0;\r\n        for (let i = 0; i < histogram.length; i++) {\r\n            let count = histogram[i];\r\n            sum += count;\r\n            cfg[i] = sum / totalCount;\r\n        }\r\n        return cfg;\r\n    }\r\n    ImageProcessing.getCFG = getCFG;\r\n})(ImageProcessing || (ImageProcessing = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/image/ImageProcessing.ts?");

/***/ }),

/***/ "../engine/src/image/Kernels.ts":
/*!**************************************!*\
  !*** ../engine/src/image/Kernels.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kernels\": () => (/* binding */ Kernels)\n/* harmony export */ });\n/* harmony import */ var _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/FloatMatrix */ \"../engine/src/data/FloatMatrix.ts\");\n\r\n// kernels\r\nconst acceptedKernels = [3, 5, 7, 9];\r\nclass Kernels {\r\n    // inspired from https://github.com/yuta1984/CannyJS/blob/master/canny.js\r\n    static generateGaussianKernel(sigma, size) {\r\n        // messy, probably auto-generated\r\n        var e, gaussian, i, j, kernel, s, sum, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;\r\n        s = sigma;\r\n        e = 2.718;\r\n        kernel = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(size, size);\r\n        sum = 0;\r\n        for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\r\n            x = -(size - 1) / 2 + i;\r\n            for (j = _j = 0, _ref1 = size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {\r\n                y = -(size - 1) / 2 + j;\r\n                gaussian =\r\n                    (1 / (2 * Math.PI * s * s)) * Math.pow(e, -(x * x + y * y) / (2 * s * s));\r\n                kernel.set(i, j, gaussian);\r\n                sum += gaussian;\r\n            }\r\n        }\r\n        for (i = _k = 0, _ref2 = size - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {\r\n            for (j = _l = 0, _ref3 = size - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {\r\n                kernel.set(i, j, kernel.get(i, j) / sum);\r\n            }\r\n        }\r\n        return kernel;\r\n    }\r\n    static buildSobelKernel(x, y) {\r\n        // TODO\r\n    }\r\n}\r\n//prettier-ignore\r\nKernels.SmoothKernel = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 1, 1,\r\n    1, 1, 1,\r\n    1, 1, 1]).forEachValue((i) => (i * 1) / 9);\r\n//prettier-ignore\r\nKernels.SmoothKernel5 = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(5, 5, [\r\n    1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1,\r\n    1, 1, 1, 1, 1\r\n]).forEachValue((v) => (v * 1) / 25);\r\n//prettier-ignore\r\nKernels.Gauss5 = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(5, 5, [2, 4, 5, 4, 2,\r\n    4, 9, 12, 9, 4,\r\n    5, 12, 15, 12, 5,\r\n    4, 9, 12, 9, 4,\r\n    2, 4, 5, 4, 2]).forEachValue((v) => (v * 1) / 159);\r\n//prettier-ignore\r\nKernels.DiagonalKernel = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 0, -1,\r\n    0, 0, 0,\r\n    -1, 0, 1]);\r\n//prettier-ignore\r\nKernels.SobelLeft = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 2, 1,\r\n    0, 0, 0,\r\n    -1, -2, -1]);\r\n//prettier-ignore\r\nKernels.SobelRight = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [-1, -2, -1,\r\n    0, 0, 0,\r\n    1, 2, 1]);\r\n//prettier-ignore\r\nKernels.SobelUp = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 0, -1,\r\n    2, 0, -2,\r\n    1, 0, -1]);\r\n//prettier-ignore\r\nKernels.SobelDown = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [-1, 0, 1,\r\n    -2, 0, 2,\r\n    -1, 0, 1]);\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/image/Kernels.ts?");

/***/ }),

/***/ "../engine/src/inputOld/InputState.ts":
/*!********************************************!*\
  !*** ../engine/src/inputOld/InputState.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputState\": () => (/* binding */ InputState)\n/* harmony export */ });\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n// CanvasInputHandler.ts\r\n// author : Jos Feenstra\r\n// purpose : handle all input events.\r\n\r\nvar Key;\r\n(function (Key) {\r\n    Key[Key[\"A\"] = 0] = \"A\";\r\n    Key[Key[\"B\"] = 1] = \"B\";\r\n    Key[Key[\"C\"] = 2] = \"C\";\r\n    Key[Key[\"D\"] = 3] = \"D\";\r\n    Key[Key[\"E\"] = 4] = \"E\";\r\n    Key[Key[\"F\"] = 5] = \"F\";\r\n    Key[Key[\"G\"] = 6] = \"G\";\r\n    Key[Key[\"H\"] = 7] = \"H\";\r\n    Key[Key[\"I\"] = 8] = \"I\";\r\n    Key[Key[\"J\"] = 9] = \"J\";\r\n    Key[Key[\"K\"] = 10] = \"K\";\r\n    Key[Key[\"L\"] = 11] = \"L\";\r\n    Key[Key[\"M\"] = 12] = \"M\";\r\n    Key[Key[\"N\"] = 13] = \"N\";\r\n    Key[Key[\"O\"] = 14] = \"O\";\r\n    Key[Key[\"P\"] = 15] = \"P\";\r\n    Key[Key[\"Q\"] = 16] = \"Q\";\r\n    Key[Key[\"R\"] = 17] = \"R\";\r\n    Key[Key[\"S\"] = 18] = \"S\";\r\n    Key[Key[\"T\"] = 19] = \"T\";\r\n    Key[Key[\"U\"] = 20] = \"U\";\r\n    Key[Key[\"V\"] = 21] = \"V\";\r\n    Key[Key[\"W\"] = 22] = \"W\";\r\n    Key[Key[\"X\"] = 23] = \"X\";\r\n    Key[Key[\"Y\"] = 24] = \"Y\";\r\n    Key[Key[\"Z\"] = 25] = \"Z\";\r\n    Key[Key[\"Up\"] = 26] = \"Up\";\r\n    Key[Key[\"Down\"] = 27] = \"Down\";\r\n    Key[Key[\"Left\"] = 28] = \"Left\";\r\n    Key[Key[\"Right\"] = 29] = \"Right\";\r\n    Key[Key[\"Space\"] = 30] = \"Space\";\r\n    Key[Key[\"Control\"] = 31] = \"Control\";\r\n    Key[Key[\"Alt\"] = 32] = \"Alt\";\r\n    Key[Key[\"Shift\"] = 33] = \"Shift\";\r\n    Key[Key[\"Enter\"] = 34] = \"Enter\";\r\n    Key[Key[\"Esc\"] = 35] = \"Esc\";\r\n    Key[Key[\"N1\"] = 36] = \"N1\";\r\n    Key[Key[\"N2\"] = 37] = \"N2\";\r\n    Key[Key[\"N3\"] = 38] = \"N3\";\r\n    Key[Key[\"N4\"] = 39] = \"N4\";\r\n    Key[Key[\"N5\"] = 40] = \"N5\";\r\n    Key[Key[\"N6\"] = 41] = \"N6\";\r\n    Key[Key[\"N7\"] = 42] = \"N7\";\r\n    Key[Key[\"N8\"] = 43] = \"N8\";\r\n    Key[Key[\"N9\"] = 44] = \"N9\";\r\n    Key[Key[\"N0\"] = 45] = \"N0\";\r\n    Key[Key[\"Plus\"] = 46] = \"Plus\";\r\n    Key[Key[\"Minus\"] = 47] = \"Minus\";\r\n    Key[Key[\"Backspace\"] = 48] = \"Backspace\";\r\n})(Key || (Key = {}));\r\nfunction toMapping(key) {\r\n    switch (key) {\r\n        case Key.A:\r\n            return 1;\r\n        case Key.B:\r\n            return 2;\r\n        case Key.C:\r\n            return 3;\r\n        case Key.D:\r\n            return 4;\r\n        case Key.E:\r\n            return 5;\r\n        case Key.F:\r\n            return 6;\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\nclass InputState {\r\n    constructor(canvas) {\r\n        this.mousePos = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mousePosBuffered = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mousePosPrev = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mouseDelta = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mouseLeftDown = false;\r\n        this.mouseLeftPressed = false;\r\n        this.mouseLeftPrev = false;\r\n        this.mouseRightDown = false;\r\n        this.mouseRightPressed = false;\r\n        this.mouseRightPrev = false;\r\n        this.mouseMiddleDown = false;\r\n        this.mouseMiddlePressed = false;\r\n        this.mouseMiddlePrev = false;\r\n        this.keysDown = {};\r\n        this.keysPressed = [];\r\n        this.scrollValue = 0;\r\n        this.scrollValuePrevious = 0;\r\n        this.mouseScrollDelta = 0;\r\n        this.mouseScrollBuffered = 0;\r\n        // link\r\n        this.canvas = canvas;\r\n        // time\r\n        this.tick = 0;\r\n        this.oldTime = Date.now();\r\n        this.newTime = this.oldTime;\r\n        this.startTime = Date.now();\r\n        this.minimumTick = 1000 / 144;\r\n        // mouse\r\n        canvas.addEventListener(\"mousedown\", this.setMouseDown.bind(this));\r\n        canvas.addEventListener(\"mouseup\", this.setMouseUp.bind(this));\r\n        canvas.addEventListener(\"contextmenu\", (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        });\r\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\r\n        canvas.addEventListener(\"wheel\", this.setMouseScroll.bind(this));\r\n        // for (let i = 0; i < 223; i++) this.keysDown[i] = false;\r\n        // keyboard\r\n        canvas.addEventListener(\"keydown\", this.onKeyDown.bind(this));\r\n        // canvas.addEventListener(\"keypressed\", this.onKeyPressed.bind(this));\r\n        canvas.addEventListener(\"keyup\", this.onKeyUp.bind(this));\r\n        // final\r\n        canvas.focus();\r\n    }\r\n    static new(canvas) {\r\n        return new InputState(canvas);\r\n    }\r\n    preUpdate(tick) {\r\n        // this must be called every tick within whatever context this is used\r\n        // update time\r\n        this.newTime = Date.now();\r\n        this.oldTime = this.newTime;\r\n        this.tick = tick;\r\n        // update mouse pos\r\n        if (!this.mousePosBuffered.equals(this.mousePos)) {\r\n            // mouse has moved during previous frame\r\n            this.mousePos.copy(this.mousePosBuffered);\r\n            this.mouseDelta.copy(this.mousePos).sub(this.mousePosPrev);\r\n            this.mousePosPrev.copy(this.mousePos);\r\n        }\r\n        else {\r\n            this.mouseDelta.set(0, 0);\r\n        }\r\n        // update mouse buttons\r\n        this.mouseLeftPressed = this.mouseLeftPrev != this.mouseLeftDown && this.mouseLeftDown;\r\n        this.mouseRightPressed = this.mouseRightPrev != this.mouseRightDown && this.mouseRightDown;\r\n        this.mouseMiddlePressed = this.mouseMiddlePrev != this.mouseMiddleDown && this.mouseMiddleDown;\r\n        // update scrolling\r\n        // normalize all scrolling behaviour\r\n        if (this.mouseScrollBuffered != 0) {\r\n            // we are scrolling\r\n            let value = 0.1;\r\n            if (this.mouseScrollBuffered < 0)\r\n                value = -0.1;\r\n            this.scrollValue = Math.max(0, this.scrollValue + value);\r\n            this.mouseScrollDelta = value;\r\n            this.mouseScrollBuffered = 0;\r\n        }\r\n        else {\r\n            // this.mouseScrollBuffered = 0;\r\n            this.mouseScrollDelta = 0;\r\n        }\r\n    }\r\n    setScrollValue(value) {\r\n        this.scrollValue = Math.max(0, value);\r\n    }\r\n    postUpdate() {\r\n        // this also must be called for keyIsPressed to work\r\n        this.mouseLeftPrev = this.mouseLeftDown;\r\n        this.mouseRightPrev = this.mouseRightDown;\r\n        this.mouseMiddlePrev = this.mouseMiddleDown;\r\n        // refresh keypresses\r\n        this.keysPressed = [];\r\n    }\r\n    IsKeyDown(key) {\r\n        return this.keysDown[key];\r\n    }\r\n    IsKeyPressed(key) {\r\n        for (let k of this.keysPressed) {\r\n            if (k === key) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    setCursorStyle(str) {\r\n        this.canvas.style.cursor = \"str\";\r\n    }\r\n    onKeyDown(e) {\r\n        let key = e.key.toLowerCase();\r\n        if (this.keysDown[key] == true)\r\n            return;\r\n        // console.log(key);\r\n        this.keysDown[key] = true;\r\n        this.keysPressed.push(key);\r\n    }\r\n    onKeyUp(e) {\r\n        let key = e.key.toLowerCase();\r\n        this.keysDown[key] = false;\r\n    }\r\n    onKeyPressed(e) {\r\n        // NOTE: i made a different system to handle this, see onKeyDown\r\n    }\r\n    setMouseScroll(e) {\r\n        this.mouseScrollBuffered = e.deltaY;\r\n    }\r\n    onMouseMove(e) {\r\n        // this is a bit messy, BUT, multiply by camera parameters\r\n        this.setMousePos(e.clientX, e.clientY);\r\n    }\r\n    setMousePos(x, y) {\r\n        this.mousePosBuffered = new _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);\r\n    }\r\n    setMouseUp(e) {\r\n        let code = e.buttons;\r\n        if (code < 4) {\r\n            this.mouseMiddleDown = false;\r\n        }\r\n        if (code < 2) {\r\n            this.mouseRightDown = false;\r\n        }\r\n        if (code < 1) {\r\n            this.mouseLeftDown = false;\r\n            if (this.onMouseLeftUp)\r\n                this.onMouseLeftUp();\r\n        }\r\n    }\r\n    setMouseDown(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        this.canvas.focus();\r\n        let code = e.buttons;\r\n        if (code >= 4) {\r\n            code -= 4;\r\n            this.mouseMiddleDown = true;\r\n        }\r\n        if (code >= 2) {\r\n            code -= 2;\r\n            this.mouseRightDown = true;\r\n        }\r\n        if (code >= 1) {\r\n            code -= 1;\r\n            this.mouseLeftDown = true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/inputOld/InputState.ts?");

/***/ }),

/***/ "../engine/src/input/InputHandler.ts":
/*!*******************************************!*\
  !*** ../engine/src/input/InputHandler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pointertype\": () => (/* binding */ Pointertype),\n/* harmony export */   \"InputHandler\": () => (/* binding */ InputHandler)\n/* harmony export */ });\n/* harmony import */ var _util_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/Util */ \"../engine/src/util/Util.ts\");\n/* harmony import */ var _KeyboardHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyboardHandler */ \"../engine/src/input/KeyboardHandler.ts\");\n/* harmony import */ var _MouseHandler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MouseHandler */ \"../engine/src/input/MouseHandler.ts\");\n/* harmony import */ var _TimeHandler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeHandler */ \"../engine/src/input/TimeHandler.ts\");\n/* harmony import */ var _TouchHandler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TouchHandler */ \"../engine/src/input/TouchHandler.ts\");\n/**\r\n * Composition over inherritance :)\r\n * TODO generalize Mouse & Touch into PointerHandler on a later date. this will not be easy...\r\n *\r\n *\r\n * The problem with events and this game engine, is that events fire whenever they like, which is fine\r\n * BUT, certain behaviours are really hard to model as events, and are much easier modelled at a fixed update moment.\r\n * This is why these classes have been created. to catch event state, and turn it into regular state.\r\n */\r\n\r\n\r\n\r\n\r\n\r\nvar Pointertype;\r\n(function (Pointertype) {\r\n    Pointertype[Pointertype[\"Mouse\"] = 0] = \"Mouse\";\r\n    Pointertype[Pointertype[\"Touch\"] = 1] = \"Touch\";\r\n})(Pointertype || (Pointertype = {}));\r\nclass InputHandler {\r\n    constructor(context, // TODO maybe abstract Context, width , height away into 'WindowHandler', which can also handle the lose and regain of the focus\r\n    width, height, time, keys, mouse, touch, pointer, pointerType) {\r\n        this.context = context;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.time = time;\r\n        this.keys = keys;\r\n        this.mouse = mouse;\r\n        this.touch = touch;\r\n        this.pointer = pointer;\r\n        this.pointerType = pointerType;\r\n    }\r\n    static fromCanvas(canvas) {\r\n        return InputHandler.new(canvas, canvas.clientWidth, canvas.clientHeight);\r\n    }\r\n    static new(context, width, height) {\r\n        let timeHandler = _TimeHandler__WEBPACK_IMPORTED_MODULE_3__.TimeHandler.new();\r\n        let isMobile = _util_Util__WEBPACK_IMPORTED_MODULE_0__.Util.isUserMobile();\r\n        console.log({ isMobile });\r\n        if (isMobile) {\r\n            let touchHandler = _TouchHandler__WEBPACK_IMPORTED_MODULE_4__.TouchHandler.new(context, width, height);\r\n            return new InputHandler(context, width, height, timeHandler, undefined, undefined, touchHandler, touchHandler, Pointertype.Touch);\r\n        }\r\n        let keyboardHandler = _KeyboardHandler__WEBPACK_IMPORTED_MODULE_1__.KeyboardHandler.new(context);\r\n        let mouseHandler = _MouseHandler__WEBPACK_IMPORTED_MODULE_2__.MouseHandler.new(context, width, height);\r\n        return new InputHandler(context, width, height, timeHandler, keyboardHandler, mouseHandler, undefined, mouseHandler, Pointertype.Mouse);\r\n    }\r\n    update() {\r\n        var _a;\r\n        this.time.update();\r\n        (_a = this.keys) === null || _a === void 0 ? void 0 : _a.update();\r\n        this.pointer.update(this.time.tick);\r\n    }\r\n    postUpdate() {\r\n        var _a;\r\n        (_a = this.keys) === null || _a === void 0 ? void 0 : _a.postUpdate();\r\n        this.pointer.postUpdate();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/InputHandler.ts?");

/***/ }),

/***/ "../engine/src/input/KeyboardHandler.ts":
/*!**********************************************!*\
  !*** ../engine/src/input/KeyboardHandler.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KeyboardHandler\": () => (/* binding */ KeyboardHandler)\n/* harmony export */ });\nclass KeyboardHandler {\r\n    constructor(context, keysDownPrev = new Set(), // only keeps track of keys down who have a KeyDown action attached\r\n    keysDown = new Set(), // only keeps track of keys down who have a KeyDown action attached\r\n    keysDownNew = new Array(), \r\n    // private keysPressed: Set<Key> = new Set(), // only keeps track of keys down who have a KeyDown action attached\r\n    keysDownWithAction = new Set(), // only keeps track of keys down who have a KeyDown action attached\r\n    keyPressedActions = new Map(), keyDownActions = new Map(), keyUpActions = new Map()) {\r\n        this.context = context;\r\n        this.keysDownPrev = keysDownPrev;\r\n        this.keysDown = keysDown;\r\n        this.keysDownNew = keysDownNew;\r\n        this.keysDownWithAction = keysDownWithAction;\r\n        this.keyPressedActions = keyPressedActions;\r\n        this.keyDownActions = keyDownActions;\r\n        this.keyUpActions = keyUpActions;\r\n        this.start();\r\n    }\r\n    static new(context) {\r\n        // NOTE: it seems that svg's do not handle button press events. For now, use global window.\r\n        return new KeyboardHandler(window);\r\n    }\r\n    update() {\r\n        // set current keydowns to the previous state\r\n        this.keysDownPrev.clear();\r\n        for (let key of this.keysDown) {\r\n            this.keysDownPrev.add(key);\r\n        }\r\n        // update the downList with changes\r\n        for (let key of this.keysDownNew) {\r\n            this.keysDown.add(key);\r\n        }\r\n        console.log(this.keysDown);\r\n        this.keysDownNew = [];\r\n        // this.keyUpActions()\r\n        for (let key of this.keysDownWithAction) {\r\n            this.keyDownActions.get(key)();\r\n        }\r\n    }\r\n    postUpdate() {\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    isDown(key) {\r\n        return this.keysDown.has(key);\r\n    }\r\n    isPressed(key) {\r\n        return this.keysDown.has(key) && !this.keysDownPrev.has(key);\r\n        // return this.keysPressed.has(key);\r\n    }\r\n    onDown(key, action) {\r\n        this.keyDownActions.set(key, action);\r\n    }\r\n    onPressed(key, action) {\r\n        this.keyPressedActions.set(key, action);\r\n    }\r\n    onUp(key, action) {\r\n        this.keyUpActions.set(key, action);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    removeDown(key) {\r\n        this.keyDownActions.delete(key);\r\n    }\r\n    removePressed(key) {\r\n        this.keyPressedActions.delete(key);\r\n    }\r\n    removeUp(key) {\r\n        this.keyUpActions.delete(key);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    start() {\r\n        let c = this.context;\r\n        c.addEventListener(\"keydown\", (res) => this.onDomEventKeyDown(res));\r\n        c.addEventListener(\"keyup\", (res) => this.onDomEventKeyUp(res));\r\n        c.addEventListener(\"blur\", (res) => this.onDomEventBlur());\r\n        c.addEventListener(\"focus\", (res) => this.onDomEventFocus());\r\n    }\r\n    onDomEventKeyDown(res) {\r\n        let code = res.keyCode;\r\n        this.keysDownNew.push(code);\r\n        // this.keysDown.add(code);\r\n        if (this.keysDownWithAction.has(code))\r\n            return;\r\n        // the key is freshly pressed\r\n        let pressedAction = this.keyPressedActions.get(code);\r\n        if (pressedAction) {\r\n            pressedAction();\r\n        }\r\n        // if we need to keep track of if this key is down, then keep track of it\r\n        if (this.keyDownActions.has(code)) {\r\n            this.keysDownWithAction.add(code);\r\n        }\r\n    }\r\n    onDomEventKeyUp(res) {\r\n        let code = res.keyCode;\r\n        // console.log(code, \"up\");\r\n        this.keysDownWithAction.delete(code);\r\n        this.keysDown.delete(code);\r\n        if (this.keysDownNew.indexOf(code) != -1) {\r\n            this.keysDownNew.splice(this.keysDownNew.indexOf(code), 1);\r\n        }\r\n        ;\r\n        // try to do a key up action\r\n        let upAction = this.keyUpActions.get(code);\r\n        if (upAction) {\r\n            upAction();\r\n        }\r\n    }\r\n    onDomEventBlur() {\r\n        // console.log(\"on blur\");\r\n        this.keysDownWithAction.clear();\r\n        this.keysDown.clear();\r\n        this.keysDownNew = [];\r\n    }\r\n    onDomEventFocus() {\r\n        // console.log(\"on focus\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/KeyboardHandler.ts?");

/***/ }),

/***/ "../engine/src/input/Keys.ts":
/*!***********************************!*\
  !*** ../engine/src/input/Keys.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Key\": () => (/* binding */ Key)\n/* harmony export */ });\nvar Key;\r\n(function (Key) {\r\n    Key[Key[\"Backspace\"] = 8] = \"Backspace\";\r\n    Key[Key[\"Tab\"] = 9] = \"Tab\";\r\n    Key[Key[\"Enter\"] = 13] = \"Enter\";\r\n    Key[Key[\"Shift\"] = 16] = \"Shift\";\r\n    Key[Key[\"Ctrl\"] = 17] = \"Ctrl\";\r\n    Key[Key[\"Alt\"] = 18] = \"Alt\";\r\n    Key[Key[\"PauseBreak\"] = 19] = \"PauseBreak\";\r\n    Key[Key[\"CapsLock\"] = 20] = \"CapsLock\";\r\n    Key[Key[\"Escape\"] = 27] = \"Escape\";\r\n    Key[Key[\"Space\"] = 32] = \"Space\";\r\n    Key[Key[\"PageUp\"] = 33] = \"PageUp\";\r\n    Key[Key[\"PageDown\"] = 34] = \"PageDown\";\r\n    Key[Key[\"End\"] = 35] = \"End\";\r\n    Key[Key[\"Home\"] = 36] = \"Home\";\r\n    Key[Key[\"LeftArrow\"] = 37] = \"LeftArrow\";\r\n    Key[Key[\"UpArrow\"] = 38] = \"UpArrow\";\r\n    Key[Key[\"RightArrow\"] = 39] = \"RightArrow\";\r\n    Key[Key[\"DownArrow\"] = 40] = \"DownArrow\";\r\n    Key[Key[\"Insert\"] = 45] = \"Insert\";\r\n    Key[Key[\"Delete\"] = 46] = \"Delete\";\r\n    Key[Key[\"Zero\"] = 48] = \"Zero\";\r\n    Key[Key[\"One\"] = 49] = \"One\";\r\n    Key[Key[\"Two\"] = 50] = \"Two\";\r\n    Key[Key[\"Three\"] = 51] = \"Three\";\r\n    Key[Key[\"Four\"] = 52] = \"Four\";\r\n    Key[Key[\"Five\"] = 53] = \"Five\";\r\n    Key[Key[\"Six\"] = 54] = \"Six\";\r\n    Key[Key[\"Seven\"] = 55] = \"Seven\";\r\n    Key[Key[\"Eight\"] = 56] = \"Eight\";\r\n    Key[Key[\"Nine\"] = 57] = \"Nine\";\r\n    Key[Key[\"A\"] = 65] = \"A\";\r\n    Key[Key[\"B\"] = 66] = \"B\";\r\n    Key[Key[\"C\"] = 67] = \"C\";\r\n    Key[Key[\"D\"] = 68] = \"D\";\r\n    Key[Key[\"E\"] = 69] = \"E\";\r\n    Key[Key[\"F\"] = 70] = \"F\";\r\n    Key[Key[\"G\"] = 71] = \"G\";\r\n    Key[Key[\"H\"] = 72] = \"H\";\r\n    Key[Key[\"I\"] = 73] = \"I\";\r\n    Key[Key[\"J\"] = 74] = \"J\";\r\n    Key[Key[\"K\"] = 75] = \"K\";\r\n    Key[Key[\"L\"] = 76] = \"L\";\r\n    Key[Key[\"M\"] = 77] = \"M\";\r\n    Key[Key[\"N\"] = 78] = \"N\";\r\n    Key[Key[\"O\"] = 79] = \"O\";\r\n    Key[Key[\"P\"] = 80] = \"P\";\r\n    Key[Key[\"Q\"] = 81] = \"Q\";\r\n    Key[Key[\"R\"] = 82] = \"R\";\r\n    Key[Key[\"S\"] = 83] = \"S\";\r\n    Key[Key[\"T\"] = 84] = \"T\";\r\n    Key[Key[\"U\"] = 85] = \"U\";\r\n    Key[Key[\"V\"] = 86] = \"V\";\r\n    Key[Key[\"W\"] = 87] = \"W\";\r\n    Key[Key[\"X\"] = 88] = \"X\";\r\n    Key[Key[\"Y\"] = 89] = \"Y\";\r\n    Key[Key[\"Z\"] = 90] = \"Z\";\r\n    Key[Key[\"LeftWindowKey\"] = 91] = \"LeftWindowKey\";\r\n    Key[Key[\"RightWindowKey\"] = 92] = \"RightWindowKey\";\r\n    Key[Key[\"SelectKey\"] = 93] = \"SelectKey\";\r\n    Key[Key[\"Numpad0\"] = 96] = \"Numpad0\";\r\n    Key[Key[\"Numpad1\"] = 97] = \"Numpad1\";\r\n    Key[Key[\"Numpad2\"] = 98] = \"Numpad2\";\r\n    Key[Key[\"Numpad3\"] = 99] = \"Numpad3\";\r\n    Key[Key[\"Numpad4\"] = 100] = \"Numpad4\";\r\n    Key[Key[\"Numpad5\"] = 101] = \"Numpad5\";\r\n    Key[Key[\"Numpad6\"] = 102] = \"Numpad6\";\r\n    Key[Key[\"Numpad7\"] = 103] = \"Numpad7\";\r\n    Key[Key[\"Numpad8\"] = 104] = \"Numpad8\";\r\n    Key[Key[\"Numpad9\"] = 105] = \"Numpad9\";\r\n    Key[Key[\"Multiply\"] = 106] = \"Multiply\";\r\n    Key[Key[\"Add\"] = 107] = \"Add\";\r\n    Key[Key[\"Subtract\"] = 109] = \"Subtract\";\r\n    Key[Key[\"DecimalPoint\"] = 110] = \"DecimalPoint\";\r\n    Key[Key[\"Divide\"] = 111] = \"Divide\";\r\n    Key[Key[\"F1\"] = 112] = \"F1\";\r\n    Key[Key[\"F2\"] = 113] = \"F2\";\r\n    Key[Key[\"F3\"] = 114] = \"F3\";\r\n    Key[Key[\"F4\"] = 115] = \"F4\";\r\n    Key[Key[\"F5\"] = 116] = \"F5\";\r\n    Key[Key[\"F6\"] = 117] = \"F6\";\r\n    Key[Key[\"F7\"] = 118] = \"F7\";\r\n    Key[Key[\"F8\"] = 119] = \"F8\";\r\n    Key[Key[\"F9\"] = 120] = \"F9\";\r\n    Key[Key[\"F10\"] = 121] = \"F10\";\r\n    Key[Key[\"F11\"] = 122] = \"F11\";\r\n    Key[Key[\"F12\"] = 123] = \"F12\";\r\n    Key[Key[\"NumLock\"] = 144] = \"NumLock\";\r\n    Key[Key[\"ScrollLock\"] = 145] = \"ScrollLock\";\r\n    Key[Key[\"SemiColon\"] = 186] = \"SemiColon\";\r\n    Key[Key[\"Equals\"] = 187] = \"Equals\";\r\n    Key[Key[\"Comma\"] = 188] = \"Comma\";\r\n    Key[Key[\"Dash\"] = 189] = \"Dash\";\r\n    Key[Key[\"Period\"] = 190] = \"Period\";\r\n    Key[Key[\"UnderScore\"] = 189] = \"UnderScore\";\r\n    Key[Key[\"PlusSign\"] = 187] = \"PlusSign\";\r\n    Key[Key[\"ForwardSlash\"] = 191] = \"ForwardSlash\";\r\n    Key[Key[\"Tilde\"] = 192] = \"Tilde\";\r\n    Key[Key[\"GraveAccent\"] = 192] = \"GraveAccent\";\r\n    Key[Key[\"OpenBracket\"] = 219] = \"OpenBracket\";\r\n    Key[Key[\"ClosedBracket\"] = 221] = \"ClosedBracket\";\r\n    Key[Key[\"Quote\"] = 222] = \"Quote\";\r\n})(Key || (Key = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/Keys.ts?");

/***/ }),

/***/ "../engine/src/input/MouseHandler.ts":
/*!*******************************************!*\
  !*** ../engine/src/input/MouseHandler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MouseHandler\": () => (/* binding */ MouseHandler)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\nclass MouseHandler {\r\n    constructor(context, width, height) {\r\n        this.context = context;\r\n        this.width = width;\r\n        this.height = height;\r\n        this.pos = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.delta = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.posBefore = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.leftDown = false;\r\n        this.middleDown = false;\r\n        this.rightDown = false;\r\n        this.scrollNew = 0;\r\n        this.scrollDelta = 0;\r\n        this.middleDownBefore = false;\r\n        this.rightDownBefore = false;\r\n        this.leftDownBefore = false;\r\n        this.start();\r\n    }\r\n    static new(context, width, height) {\r\n        return new MouseHandler(context, width, height);\r\n    }\r\n    start() {\r\n        let c = this.context;\r\n        document.addEventListener(\"mousedown\", (e) => this.onDomEventMouseDown(e));\r\n        document.addEventListener(\"mouseup\", (e) => this.onDomEventMouseUp(e));\r\n        document.addEventListener(\"mousemove\", (e) => this.onDomEventMouseMove(e));\r\n        document.addEventListener(\"contextmenu\", (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        });\r\n        document.addEventListener(\"wheel\", (e) => this.onDomEventWheel(e));\r\n        c.addEventListener(\"blur\", () => this.onDomEventBlur());\r\n        c.addEventListener(\"focus\", () => this.onDomEventFocus());\r\n    }\r\n    /**\r\n     * Call this before general game update calls\r\n     */\r\n    update() {\r\n        // normalize all scrolling behaviour\r\n        if (this.scrollNew != 0) {\r\n            // we are scrolling\r\n            let value = 0.1;\r\n            if (this.scrollNew < 0)\r\n                value = -0.1;\r\n            this.scrollDelta = value;\r\n            this.scrollNew = 0;\r\n        }\r\n        else {\r\n            this.scrollDelta = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Has to be called after game update\r\n    //  */\r\n    postUpdate() {\r\n        this.leftDownBefore = this.leftDown;\r\n        this.rightDownBefore = this.rightDown;\r\n        this.middleDownBefore = this.middleDown;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    get leftPressed() {\r\n        return this.leftDown && !this.leftDownBefore;\r\n    }\r\n    get rightPressed() {\r\n        return this.rightDown && !this.rightDownBefore;\r\n    }\r\n    get middlePressed() {\r\n        return this.middleDown && !this.middleDownBefore;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    onDomEventMouseDown(e) {\r\n        // e.preventDefault();\r\n        // e.stopPropagation();\r\n        // this.context.focus();\r\n        let code = e.buttons;\r\n        if (code >= 4) {\r\n            code -= 4;\r\n            if (!this.middleDown && this.onMiddlePressed)\r\n                this.onMiddlePressed(e);\r\n            this.middleDown = true;\r\n        }\r\n        if (code >= 2) {\r\n            code -= 2;\r\n            if (!this.rightDown && this.onRightPressed)\r\n                this.onRightPressed(e);\r\n            this.rightDown = true;\r\n        }\r\n        if (code >= 1) {\r\n            code -= 1;\r\n            if (!this.leftDown && this.onLeftPressed)\r\n                this.onLeftPressed(e);\r\n            this.leftDown = true;\r\n        }\r\n    }\r\n    onDomEventMouseUp(e) {\r\n        let code = e.buttons;\r\n        if (code < 4) {\r\n            this.middleDown = false;\r\n            if (this.onMiddleUp)\r\n                this.onMiddleUp(e);\r\n        }\r\n        if (code < 2) {\r\n            this.rightDown = false;\r\n            if (this.onRightUp)\r\n                this.onRightUp(e);\r\n        }\r\n        if (code < 1) {\r\n            this.leftDown = false;\r\n            if (this.onLeftUp)\r\n                this.onLeftUp(e);\r\n        }\r\n    }\r\n    onDomEventMouseMove(e) {\r\n        this.pos.x = e.clientX;\r\n        this.pos.y = e.clientY;\r\n    }\r\n    onDomEventWheel(e) {\r\n        this.scrollNew = e.deltaY;\r\n    }\r\n    onDomEventBlur() {\r\n        _lib__WEBPACK_IMPORTED_MODULE_0__.Debug.log(\"blur!\");\r\n    }\r\n    onDomEventFocus() {\r\n        _lib__WEBPACK_IMPORTED_MODULE_0__.Debug.log(\"focus!\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/MouseHandler.ts?");

/***/ }),

/***/ "../engine/src/input/TimeHandler.ts":
/*!******************************************!*\
  !*** ../engine/src/input/TimeHandler.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TimeHandler\": () => (/* binding */ TimeHandler)\n/* harmony export */ });\nclass TimeHandler {\r\n    constructor() {\r\n        this.start();\r\n    }\r\n    static new() {\r\n        return new TimeHandler();\r\n    }\r\n    start() {\r\n        this.tick = 0;\r\n        this.oldTime = Date.now();\r\n        this.newTime = this.oldTime;\r\n        this.startTime = this.oldTime;\r\n        // this.minimumTick = 1000 / 144;\r\n    }\r\n    update() {\r\n        this.newTime = Date.now();\r\n        this.tick = this.newTime - this.oldTime;\r\n        this.oldTime = this.newTime;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/TimeHandler.ts?");

/***/ }),

/***/ "../engine/src/input/TouchFinger.ts":
/*!******************************************!*\
  !*** ../engine/src/input/TouchFinger.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TouchFinger\": () => (/* binding */ TouchFinger)\n/* harmony export */ });\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n\r\nclass TouchFinger {\r\n    constructor() {\r\n        this.pos = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.delta = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.down = false;\r\n        // remember previous state\r\n        this.posBefore = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.downBefore = false;\r\n        this.lastId = 0;\r\n        // store the most current state based on events, update it to the regular state at update time\r\n        this.downNew = false;\r\n        this.posNew = _math_Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n    }\r\n    static new() {\r\n        return new TouchFinger();\r\n    }\r\n    get pressed() {\r\n        return (this.down && !this.downBefore);\r\n    }\r\n    get released() {\r\n        return (!this.down && this.downBefore);\r\n    }\r\n    update() {\r\n        this.downBefore = this.down;\r\n        this.down = this.downNew;\r\n        this.posBefore.copy(this.pos);\r\n        this.pos.copy(this.posNew);\r\n        this.delta.copy(this.posBefore).sub(this.pos);\r\n    }\r\n    _updatePressed(event) {\r\n        this.event = event;\r\n        this.downNew = true;\r\n    }\r\n    _updateReleased(event) {\r\n        this.event = undefined;\r\n        this.downNew = false;\r\n        this.lastId = event.pointerId;\r\n    }\r\n    _updatePos(event) {\r\n        let resetDelta = false;\r\n        this.posNew.set(event.clientX, event.clientY);\r\n        if (this.lastId != event.pointerId) {\r\n            this.pos.set(event.clientX, event.clientY);\r\n            resetDelta = true;\r\n        }\r\n        this.lastId = event.pointerId;\r\n        return resetDelta;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/TouchFinger.ts?");

/***/ }),

/***/ "../engine/src/input/TouchHandler.ts":
/*!*******************************************!*\
  !*** ../engine/src/input/TouchHandler.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TouchHandler\": () => (/* binding */ TouchHandler)\n/* harmony export */ });\n/* harmony import */ var _TouchFinger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TouchFinger */ \"../engine/src/input/TouchFinger.ts\");\n\r\nclass TouchHandler {\r\n    constructor(context, width, height) {\r\n        this.context = context;\r\n        this.width = width;\r\n        this.height = height;\r\n        // represent the first, second, third, etc... finger to touch the screen, in order of touch \r\n        this.fingers = [\r\n            _TouchFinger__WEBPACK_IMPORTED_MODULE_0__.TouchFinger.new(), _TouchFinger__WEBPACK_IMPORTED_MODULE_0__.TouchFinger.new(), _TouchFinger__WEBPACK_IMPORTED_MODULE_0__.TouchFinger.new(), _TouchFinger__WEBPACK_IMPORTED_MODULE_0__.TouchFinger.new(), _TouchFinger__WEBPACK_IMPORTED_MODULE_0__.TouchFinger.new()\r\n        ];\r\n        this.down = 0; // the number of fingers down\r\n        this.downTime = 0; // how long these fingers are down, count starting at the first finger down \r\n        this.zoomScore = 0;\r\n        this.distance = 0;\r\n        this.zoomDelta = 0;\r\n        this.newDistance = 0;\r\n        this.start();\r\n    }\r\n    static new(context, width, height) {\r\n        return new TouchHandler(context, width, height);\r\n    }\r\n    start() {\r\n        let el = this.context;\r\n        if (el instanceof HTMLElement) {\r\n            el.style.touchAction = 'none';\r\n        }\r\n        el.onpointerdown = this.onAddFinger.bind(this);\r\n        el.onpointermove = this.onUpdateFinger.bind(this);\r\n        el.onpointerup = this.onRemoveFinger.bind(this);\r\n        el.onpointercancel = this.onRemoveFinger.bind(this);\r\n        el.onpointerout = this.onRemoveFinger.bind(this);\r\n        el.onpointerleave = this.onRemoveFinger.bind(this);\r\n    }\r\n    update(dt) {\r\n        this.updateFingers();\r\n        this.updateDown(dt);\r\n        this.updateZoom();\r\n    }\r\n    postUpdate() {\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////// \r\n    get tab() {\r\n        return this.down == 5 && this.fingers[4].pressed;\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////// Updates\r\n    updateFingers() {\r\n        for (let finger of this.fingers) {\r\n            finger.update();\r\n        }\r\n    }\r\n    updateDown(dt) {\r\n        // update down\r\n        this.down = 0;\r\n        for (let finger of this.fingers) {\r\n            if (finger.down) {\r\n                this.down += 1;\r\n            }\r\n        }\r\n        // update downtime\r\n        if (this.down > 0) {\r\n            this.downTime += dt;\r\n        }\r\n        else {\r\n            this.downTime = 0;\r\n        }\r\n    }\r\n    updateZoom() {\r\n        if (this.down < 2)\r\n            return;\r\n        this.zoomDelta = this.distance - this.newDistance;\r\n        this.distance = this.newDistance;\r\n        this.zoomScore += this.zoomDelta;\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////// Finger updates\r\n    onAddFinger(event) {\r\n        // add a binding between pointer-events and finger objects. \r\n        for (let finger of this.fingers) {\r\n            if (!finger.event) {\r\n                finger._updatePressed(event);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    onRemoveFinger(event) {\r\n        var _a;\r\n        // remove the event - finger binding\r\n        for (let finger of this.fingers) {\r\n            if (((_a = finger.event) === null || _a === void 0 ? void 0 : _a.pointerId) == event.pointerId) {\r\n                finger._updateReleased(event);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    onUpdateFinger(event) {\r\n        var _a;\r\n        // update the binding\r\n        let resetDelta = false;\r\n        for (let finger of this.fingers) {\r\n            if (((_a = finger.event) === null || _a === void 0 ? void 0 : _a.pointerId) == event.pointerId) {\r\n                resetDelta = finger._updatePos(event);\r\n                break;\r\n            }\r\n        }\r\n        // update pinch zoom stuff\r\n        this.newDistance = this.fingers[0].pos.disTo(this.fingers[1].pos);\r\n        if (resetDelta) {\r\n            this.distance = this.newDistance;\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/input/TouchHandler.ts?");

/***/ }),

/***/ "../engine/src/lib.ts":
/*!****************************!*\
  !*** ../engine/src/lib.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Const\": () => (/* reexport safe */ _math_Const__WEBPACK_IMPORTED_MODULE_0__.Const),\n/* harmony export */   \"Util\": () => (/* reexport safe */ _math_Util__WEBPACK_IMPORTED_MODULE_1__.Util),\n/* harmony export */   \"Kernels\": () => (/* reexport safe */ _image_Kernels__WEBPACK_IMPORTED_MODULE_2__.Kernels),\n/* harmony export */   \"MultiShader\": () => (/* reexport safe */ _render_OldMultiShader__WEBPACK_IMPORTED_MODULE_3__.MultiShader),\n/* harmony export */   \"marchingCubes\": () => (/* reexport safe */ _algorithms_MarchingCubes__WEBPACK_IMPORTED_MODULE_4__.marchingCubes),\n/* harmony export */   \"Perlin\": () => (/* reexport safe */ _algorithms_Perlin__WEBPACK_IMPORTED_MODULE_5__.Perlin),\n/* harmony export */   \"App\": () => (/* reexport safe */ _app_App__WEBPACK_IMPORTED_MODULE_6__.App),\n/* harmony export */   \"Core\": () => (/* reexport safe */ _app_Core__WEBPACK_IMPORTED_MODULE_7__.Core),\n/* harmony export */   \"SwapApp\": () => (/* reexport safe */ _app_SwapApp__WEBPACK_IMPORTED_MODULE_8__.SwapApp),\n/* harmony export */   \"FloatMatrix\": () => (/* reexport safe */ _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_9__.FloatMatrix),\n/* harmony export */   \"HashTable\": () => (/* reexport safe */ _data_HashTable__WEBPACK_IMPORTED_MODULE_10__.HashTable),\n/* harmony export */   \"IntCube\": () => (/* reexport safe */ _data_IntCube__WEBPACK_IMPORTED_MODULE_11__.IntCube),\n/* harmony export */   \"IntMatrix\": () => (/* reexport safe */ _data_IntMatrix__WEBPACK_IMPORTED_MODULE_12__.IntMatrix),\n/* harmony export */   \"LinkedList\": () => (/* reexport safe */ _data_LinkedList__WEBPACK_IMPORTED_MODULE_13__.LinkedList),\n/* harmony export */   \"ToFloatMatrix\": () => (/* reexport safe */ _data_MultiVector__WEBPACK_IMPORTED_MODULE_14__.ToFloatMatrix),\n/* harmony export */   \"MultiVector3\": () => (/* reexport safe */ _data_MultiVector3__WEBPACK_IMPORTED_MODULE_15__.MultiVector3),\n/* harmony export */   \"MultiVector2\": () => (/* reexport safe */ _data_MultiVector2__WEBPACK_IMPORTED_MODULE_16__.MultiVector2),\n/* harmony export */   \"Pool\": () => (/* reexport safe */ _data_Pool__WEBPACK_IMPORTED_MODULE_17__.Pool),\n/* harmony export */   \"IO\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.IO),\n/* harmony export */   \"addDropFileEventListeners\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.addDropFileEventListeners),\n/* harmony export */   \"loadImageFromBlob\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.loadImageFromBlob),\n/* harmony export */   \"loadImageFromFile\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.loadImageFromFile),\n/* harmony export */   \"loadImageFromSrc\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.loadImageFromSrc),\n/* harmony export */   \"loadJSONFromFile\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.loadJSONFromFile),\n/* harmony export */   \"loadTextFromFile\": () => (/* reexport safe */ _dom_IO__WEBPACK_IMPORTED_MODULE_18__.loadTextFromFile),\n/* harmony export */   \"UI\": () => (/* reexport safe */ _dom_UI__WEBPACK_IMPORTED_MODULE_19__.UI),\n/* harmony export */   \"WebIO\": () => (/* reexport safe */ _dom_WebIO__WEBPACK_IMPORTED_MODULE_20__.WebIO),\n/* harmony export */   \"Geometry\": () => (/* reexport safe */ _geometry_Geometry__WEBPACK_IMPORTED_MODULE_21__.Geometry),\n/* harmony export */   \"Circle2\": () => (/* reexport safe */ _geometry_primitives_Circle2__WEBPACK_IMPORTED_MODULE_23__.Circle2),\n/* harmony export */   \"Circle3\": () => (/* reexport safe */ _geometry_primitives_Circle3__WEBPACK_IMPORTED_MODULE_24__.Circle3),\n/* harmony export */   \"Cube\": () => (/* reexport safe */ _geometry_primitives_Cube__WEBPACK_IMPORTED_MODULE_25__.Cube),\n/* harmony export */   \"Line2\": () => (/* reexport safe */ _geometry_primitives_Line2__WEBPACK_IMPORTED_MODULE_26__.Line2),\n/* harmony export */   \"Plane\": () => (/* reexport safe */ _geometry_primitives_Plane__WEBPACK_IMPORTED_MODULE_27__.Plane),\n/* harmony export */   \"Rectangle2\": () => (/* reexport safe */ _geometry_primitives_Rectangle__WEBPACK_IMPORTED_MODULE_28__.Rectangle2),\n/* harmony export */   \"Rectangle3\": () => (/* reexport safe */ _geometry_primitives_Rectangle__WEBPACK_IMPORTED_MODULE_28__.Rectangle3),\n/* harmony export */   \"Triangle2\": () => (/* reexport safe */ _geometry_primitives_Triangle2__WEBPACK_IMPORTED_MODULE_29__.Triangle2),\n/* harmony export */   \"Triangle3\": () => (/* reexport safe */ _geometry_primitives_Triangle3__WEBPACK_IMPORTED_MODULE_30__.Triangle3),\n/* harmony export */   \"Curve\": () => (/* reexport safe */ _geometry_curve_Curve__WEBPACK_IMPORTED_MODULE_31__.Curve),\n/* harmony export */   \"Bezier\": () => (/* reexport safe */ _geometry_curve_Bezier__WEBPACK_IMPORTED_MODULE_32__.Bezier),\n/* harmony export */   \"Cubez\": () => (/* reexport safe */ _geometry_curve_Bezier__WEBPACK_IMPORTED_MODULE_32__.Cubez),\n/* harmony export */   \"Polyline\": () => (/* reexport safe */ _geometry_curve_Polyline__WEBPACK_IMPORTED_MODULE_33__.Polyline),\n/* harmony export */   \"Spline\": () => (/* reexport safe */ _geometry_curve_Spline__WEBPACK_IMPORTED_MODULE_34__.Spline),\n/* harmony export */   \"BiSurface\": () => (/* reexport safe */ _geometry_surface_Surface__WEBPACK_IMPORTED_MODULE_35__.BiSurface),\n/* harmony export */   \"Surface\": () => (/* reexport safe */ _geometry_surface_Surface__WEBPACK_IMPORTED_MODULE_35__.Surface),\n/* harmony export */   \"TriSurface\": () => (/* reexport safe */ _geometry_surface_Surface__WEBPACK_IMPORTED_MODULE_35__.TriSurface),\n/* harmony export */   \"BezierSquare\": () => (/* reexport safe */ _geometry_surface_BezierSquare__WEBPACK_IMPORTED_MODULE_36__.BezierSquare),\n/* harmony export */   \"BezierTriangle\": () => (/* reexport safe */ _geometry_surface_BezierTriangle__WEBPACK_IMPORTED_MODULE_37__.BezierTriangle),\n/* harmony export */   \"Loft\": () => (/* reexport safe */ _geometry_surface_Loft__WEBPACK_IMPORTED_MODULE_38__.Loft),\n/* harmony export */   \"Graph\": () => (/* reexport safe */ _geometry_mesh_Graph__WEBPACK_IMPORTED_MODULE_39__.Graph),\n/* harmony export */   \"MultiLine\": () => (/* reexport safe */ _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_40__.MultiLine),\n/* harmony export */   \"getDefaultIndices\": () => (/* reexport safe */ _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_40__.getDefaultIndices),\n/* harmony export */   \"getLongDefaultIndices\": () => (/* reexport safe */ _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_40__.getLongDefaultIndices),\n/* harmony export */   \"Mesh\": () => (/* reexport safe */ _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_41__.Mesh),\n/* harmony export */   \"MeshType\": () => (/* reexport safe */ _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_41__.MeshType),\n/* harmony export */   \"NormalKind\": () => (/* reexport safe */ _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_41__.NormalKind),\n/* harmony export */   \"quadToTri\": () => (/* reexport safe */ _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_41__.quadToTri),\n/* harmony export */   \"ShaderMesh\": () => (/* reexport safe */ _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_42__.ShaderMesh),\n/* harmony export */   \"meshFromObj\": () => (/* reexport safe */ _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_42__.meshFromObj),\n/* harmony export */   \"TopoMesh\": () => (/* reexport safe */ _geometry_mesh_TopoMesh__WEBPACK_IMPORTED_MODULE_43__.TopoMesh),\n/* harmony export */   \"ObjProcessing\": () => (/* reexport safe */ _geometry_mesh_ObjProcessing__WEBPACK_IMPORTED_MODULE_44__.ObjProcessing),\n/* harmony export */   \"Color\": () => (/* reexport safe */ _image_Color__WEBPACK_IMPORTED_MODULE_45__.Color),\n/* harmony export */   \"COLOR\": () => (/* reexport safe */ _image_Colors__WEBPACK_IMPORTED_MODULE_46__.COLOR),\n/* harmony export */   \"hslToRgb\": () => (/* reexport safe */ _image_Colors__WEBPACK_IMPORTED_MODULE_46__.hslToRgb),\n/* harmony export */   \"rgbToHsl\": () => (/* reexport safe */ _image_Colors__WEBPACK_IMPORTED_MODULE_46__.rgbToHsl),\n/* harmony export */   \"Bitmap\": () => (/* reexport safe */ _image_Bitmap__WEBPACK_IMPORTED_MODULE_47__.Bitmap),\n/* harmony export */   \"ImageProcessing\": () => (/* reexport safe */ _image_ImageProcessing__WEBPACK_IMPORTED_MODULE_48__.ImageProcessing),\n/* harmony export */   \"InputState\": () => (/* reexport safe */ _inputOld_InputState__WEBPACK_IMPORTED_MODULE_49__.InputState),\n/* harmony export */   \"InputHandler\": () => (/* reexport safe */ _input_InputHandler__WEBPACK_IMPORTED_MODULE_50__.InputHandler),\n/* harmony export */   \"Pointertype\": () => (/* reexport safe */ _input_InputHandler__WEBPACK_IMPORTED_MODULE_50__.Pointertype),\n/* harmony export */   \"KeyboardHandler\": () => (/* reexport safe */ _input_KeyboardHandler__WEBPACK_IMPORTED_MODULE_51__.KeyboardHandler),\n/* harmony export */   \"Key\": () => (/* reexport safe */ _input_Keys__WEBPACK_IMPORTED_MODULE_52__.Key),\n/* harmony export */   \"MouseHandler\": () => (/* reexport safe */ _input_MouseHandler__WEBPACK_IMPORTED_MODULE_53__.MouseHandler),\n/* harmony export */   \"TouchHandler\": () => (/* reexport safe */ _input_TouchHandler__WEBPACK_IMPORTED_MODULE_54__.TouchHandler),\n/* harmony export */   \"TimeHandler\": () => (/* reexport safe */ _input_TimeHandler__WEBPACK_IMPORTED_MODULE_55__.TimeHandler),\n/* harmony export */   \"TouchFinger\": () => (/* reexport safe */ _input_TouchFinger__WEBPACK_IMPORTED_MODULE_56__.TouchFinger),\n/* harmony export */   \"Domain\": () => (/* reexport safe */ _math_Domain__WEBPACK_IMPORTED_MODULE_57__.Domain),\n/* harmony export */   \"Domain2\": () => (/* reexport safe */ _math_Domain__WEBPACK_IMPORTED_MODULE_57__.Domain2),\n/* harmony export */   \"Domain3\": () => (/* reexport safe */ _math_Domain__WEBPACK_IMPORTED_MODULE_57__.Domain3),\n/* harmony export */   \"GeonMath\": () => (/* reexport safe */ _math_Math__WEBPACK_IMPORTED_MODULE_58__.GeonMath),\n/* harmony export */   \"Matrix3\": () => (/* reexport safe */ _math_Matrix3__WEBPACK_IMPORTED_MODULE_59__.Matrix3),\n/* harmony export */   \"Matrix4\": () => (/* reexport safe */ _math_Matrix4__WEBPACK_IMPORTED_MODULE_60__.Matrix4),\n/* harmony export */   \"Polynomial\": () => (/* reexport safe */ _math_Polynomial__WEBPACK_IMPORTED_MODULE_61__.Polynomial),\n/* harmony export */   \"Quaternion\": () => (/* reexport safe */ _math_Quaternion__WEBPACK_IMPORTED_MODULE_62__.Quaternion),\n/* harmony export */   \"Random\": () => (/* reexport safe */ _math_Random__WEBPACK_IMPORTED_MODULE_63__.Random),\n/* harmony export */   \"createGUID\": () => (/* reexport safe */ _math_Random__WEBPACK_IMPORTED_MODULE_63__.createGUID),\n/* harmony export */   \"createRandomGUID\": () => (/* reexport safe */ _math_Random__WEBPACK_IMPORTED_MODULE_63__.createRandomGUID),\n/* harmony export */   \"Ray\": () => (/* reexport safe */ _math_Ray__WEBPACK_IMPORTED_MODULE_64__.Ray),\n/* harmony export */   \"Stat\": () => (/* reexport safe */ _math_Statistics__WEBPACK_IMPORTED_MODULE_65__.Stat),\n/* harmony export */   \"Vector2\": () => (/* reexport safe */ _math_Vector2__WEBPACK_IMPORTED_MODULE_66__.Vector2),\n/* harmony export */   \"Vector3\": () => (/* reexport safe */ _math_Vector3__WEBPACK_IMPORTED_MODULE_67__.Vector3),\n/* harmony export */   \"calcLength\": () => (/* reexport safe */ _math_Vector3__WEBPACK_IMPORTED_MODULE_67__.calcLength),\n/* harmony export */   \"EnumParameter\": () => (/* reexport safe */ _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_68__.EnumParameter),\n/* harmony export */   \"Parameter\": () => (/* reexport safe */ _parametric_Parameter__WEBPACK_IMPORTED_MODULE_69__.Parameter),\n/* harmony export */   \"ParametricModel\": () => (/* reexport safe */ _parametric_ParametricModel__WEBPACK_IMPORTED_MODULE_70__.ParametricModel),\n/* harmony export */   \"ImageMesh\": () => (/* reexport safe */ _render_bufferables_ImageMesh__WEBPACK_IMPORTED_MODULE_71__.ImageMesh),\n/* harmony export */   \"MeshBufferer\": () => (/* reexport safe */ _render_bufferers_MeshBufferer__WEBPACK_IMPORTED_MODULE_72__.MeshBufferer),\n/* harmony export */   \"DebugRenderer\": () => (/* reexport safe */ _render_renderers_DebugRenderer__WEBPACK_IMPORTED_MODULE_73__.DebugRenderer),\n/* harmony export */   \"ImageRenderer\": () => (/* reexport safe */ _render_renderers_ImageRenderer__WEBPACK_IMPORTED_MODULE_74__.ImageRenderer),\n/* harmony export */   \"TextRenderer\": () => (/* reexport safe */ _render_renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_75__.TextRenderer),\n/* harmony export */   \"AmbientMeshShader\": () => (/* reexport safe */ _render_shaders_AmbientMeshShader__WEBPACK_IMPORTED_MODULE_76__.AmbientMeshShader),\n/* harmony export */   \"TexturedMeshShader\": () => (/* reexport safe */ _render_shaders_TexturedMeshShader__WEBPACK_IMPORTED_MODULE_77__.TexturedMeshShader),\n/* harmony export */   \"Billboard\": () => (/* reexport safe */ _render_shaders_BillboardShader__WEBPACK_IMPORTED_MODULE_78__.Billboard),\n/* harmony export */   \"BillboardShader\": () => (/* reexport safe */ _render_shaders_BillboardShader__WEBPACK_IMPORTED_MODULE_78__.BillboardShader),\n/* harmony export */   \"DepthMeshShader\": () => (/* reexport safe */ _render_shaders_DepthMeshShader__WEBPACK_IMPORTED_MODULE_79__.DepthMeshShader),\n/* harmony export */   \"DotShaderWithHeight\": () => (/* reexport safe */ _render_shaders_DotShaderWithHeight__WEBPACK_IMPORTED_MODULE_80__.DotShaderWithHeight),\n/* harmony export */   \"PhongShader\": () => (/* reexport safe */ _render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_81__.PhongShader),\n/* harmony export */   \"TemplateShader\": () => (/* reexport safe */ _render_shaders_TemplateShader__WEBPACK_IMPORTED_MODULE_82__.TemplateShader),\n/* harmony export */   \"ZebraShader\": () => (/* reexport safe */ _render_shaders_ZebraShader__WEBPACK_IMPORTED_MODULE_83__.ZebraShader),\n/* harmony export */   \"SkyBoxShader\": () => (/* reexport safe */ _render_shaders_SkyBoxShader__WEBPACK_IMPORTED_MODULE_84__.SkyBoxShader),\n/* harmony export */   \"DrawTarget\": () => (/* reexport safe */ _render_webgl_DrawTarget__WEBPACK_IMPORTED_MODULE_85__.DrawTarget),\n/* harmony export */   \"Attribute\": () => (/* reexport safe */ _render_webgl_Attribute__WEBPACK_IMPORTED_MODULE_86__.Attribute),\n/* harmony export */   \"Attributes\": () => (/* reexport safe */ _render_webgl_Attributes__WEBPACK_IMPORTED_MODULE_87__.Attributes),\n/* harmony export */   \"ClearBufferBit\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.ClearBufferBit),\n/* harmony export */   \"CubeMapTarget\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.CubeMapTarget),\n/* harmony export */   \"CubeMapTargets\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.CubeMapTargets),\n/* harmony export */   \"DataType\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.DataType),\n/* harmony export */   \"DrawElementsType\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.DrawElementsType),\n/* harmony export */   \"DrawMethod\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.DrawMethod),\n/* harmony export */   \"DrawMode\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.DrawMode),\n/* harmony export */   \"INDEX_BUFFER_NAME\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.INDEX_BUFFER_NAME),\n/* harmony export */   \"PixelFormat\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.PixelFormat),\n/* harmony export */   \"TEXTURE_2D\": () => (/* reexport safe */ _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__.TEXTURE_2D),\n/* harmony export */   \"DrawSpeed\": () => (/* reexport safe */ _render_webgl_HelpGl__WEBPACK_IMPORTED_MODULE_89__.DrawSpeed),\n/* harmony export */   \"HelpGl\": () => (/* reexport safe */ _render_webgl_HelpGl__WEBPACK_IMPORTED_MODULE_89__.HelpGl),\n/* harmony export */   \"IndexAttribute\": () => (/* reexport safe */ _render_webgl_IndexAttribute__WEBPACK_IMPORTED_MODULE_90__.IndexAttribute),\n/* harmony export */   \"Uniform\": () => (/* reexport safe */ _render_webgl_Uniform__WEBPACK_IMPORTED_MODULE_91__.Uniform),\n/* harmony export */   \"UniformType\": () => (/* reexport safe */ _render_webgl_Uniform__WEBPACK_IMPORTED_MODULE_91__.UniformType),\n/* harmony export */   \"Uniforms\": () => (/* reexport safe */ _render_webgl_Uniforms__WEBPACK_IMPORTED_MODULE_92__.Uniforms),\n/* harmony export */   \"DotShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.DotShader),\n/* harmony export */   \"GraphDebugShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.GraphDebugShader),\n/* harmony export */   \"LineShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.LineShader),\n/* harmony export */   \"MeshDebugShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.MeshDebugShader),\n/* harmony export */   \"MeshPickShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.MeshPickShader),\n/* harmony export */   \"NormalShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.NormalShader),\n/* harmony export */   \"RectangleShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.RectangleShader),\n/* harmony export */   \"ShadedMeshShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.ShadedMeshShader),\n/* harmony export */   \"SimpleMeshOverlayRenderer\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.SimpleMeshOverlayRenderer),\n/* harmony export */   \"SimpleMeshShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.SimpleMeshShader),\n/* harmony export */   \"TextureMeshShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.TextureMeshShader),\n/* harmony export */   \"TransformLineShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.TransformLineShader),\n/* harmony export */   \"TransformMeshShader\": () => (/* reexport safe */ _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__.TransformMeshShader),\n/* harmony export */   \"OldShader\": () => (/* reexport safe */ _render_OldShader__WEBPACK_IMPORTED_MODULE_94__.OldShader),\n/* harmony export */   \"Camera\": () => (/* reexport safe */ _render_basics_Camera__WEBPACK_IMPORTED_MODULE_95__.Camera),\n/* harmony export */   \"Entity\": () => (/* reexport safe */ _render_basics_Entity__WEBPACK_IMPORTED_MODULE_96__.Entity),\n/* harmony export */   \"Light\": () => (/* reexport safe */ _render_basics_Light__WEBPACK_IMPORTED_MODULE_97__.Light),\n/* harmony export */   \"Material\": () => (/* reexport safe */ _render_basics_Material__WEBPACK_IMPORTED_MODULE_98__.Material),\n/* harmony export */   \"Model\": () => (/* reexport safe */ _render_basics_Model__WEBPACK_IMPORTED_MODULE_99__.Model),\n/* harmony export */   \"createNewShaderForShadable\": () => (/* reexport safe */ _render_basics_Shadable__WEBPACK_IMPORTED_MODULE_100__.createNewShaderForShadable),\n/* harmony export */   \"Scene\": () => (/* reexport safe */ _render_basics_Scene__WEBPACK_IMPORTED_MODULE_101__.Scene),\n/* harmony export */   \"FpsCounter\": () => (/* reexport safe */ _util_FpsCounter__WEBPACK_IMPORTED_MODULE_102__.FpsCounter),\n/* harmony export */   \"Microphone\": () => (/* reexport safe */ _util_Microphone__WEBPACK_IMPORTED_MODULE_103__.Microphone),\n/* harmony export */   \"Debug\": () => (/* reexport safe */ _util_Debug__WEBPACK_IMPORTED_MODULE_104__.Debug),\n/* harmony export */   \"Time\": () => (/* reexport safe */ _util_Time__WEBPACK_IMPORTED_MODULE_105__.Time)\n/* harmony export */ });\n/* harmony import */ var _math_Const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math/Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _math_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math/Util */ \"../engine/src/math/Util.ts\");\n/* harmony import */ var _image_Kernels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./image/Kernels */ \"../engine/src/image/Kernels.ts\");\n/* harmony import */ var _render_OldMultiShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./render/OldMultiShader */ \"../engine/src/render/OldMultiShader.ts\");\n/* harmony import */ var _algorithms_MarchingCubes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./algorithms/MarchingCubes */ \"../engine/src/algorithms/MarchingCubes.ts\");\n/* harmony import */ var _algorithms_Perlin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./algorithms/Perlin */ \"../engine/src/algorithms/Perlin.ts\");\n/* harmony import */ var _app_App__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./app/App */ \"../engine/src/app/App.ts\");\n/* harmony import */ var _app_Core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./app/Core */ \"../engine/src/app/Core.ts\");\n/* harmony import */ var _app_SwapApp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./app/SwapApp */ \"../engine/src/app/SwapApp.ts\");\n/* harmony import */ var _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./data/FloatMatrix */ \"../engine/src/data/FloatMatrix.ts\");\n/* harmony import */ var _data_HashTable__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./data/HashTable */ \"../engine/src/data/HashTable.ts\");\n/* harmony import */ var _data_IntCube__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./data/IntCube */ \"../engine/src/data/IntCube.ts\");\n/* harmony import */ var _data_IntMatrix__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./data/IntMatrix */ \"../engine/src/data/IntMatrix.ts\");\n/* harmony import */ var _data_LinkedList__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./data/LinkedList */ \"../engine/src/data/LinkedList.ts\");\n/* harmony import */ var _data_MultiVector__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./data/MultiVector */ \"../engine/src/data/MultiVector.ts\");\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _data_MultiVector2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./data/MultiVector2 */ \"../engine/src/data/MultiVector2.ts\");\n/* harmony import */ var _data_Pool__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./data/Pool */ \"../engine/src/data/Pool.ts\");\n/* harmony import */ var _dom_IO__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./dom/IO */ \"../engine/src/dom/IO.ts\");\n/* harmony import */ var _dom_UI__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./dom/UI */ \"../engine/src/dom/UI.ts\");\n/* harmony import */ var _dom_WebIO__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./dom/WebIO */ \"../engine/src/dom/WebIO.ts\");\n/* harmony import */ var _geometry_Geometry__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./geometry/Geometry */ \"../engine/src/geometry/Geometry.ts\");\n/* harmony import */ var _geometry_Intersect__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./geometry/Intersect */ \"../engine/src/geometry/Intersect.ts\");\n/* harmony import */ var _geometry_primitives_Circle2__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./geometry/primitives/Circle2 */ \"../engine/src/geometry/primitives/Circle2.ts\");\n/* harmony import */ var _geometry_primitives_Circle3__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./geometry/primitives/Circle3 */ \"../engine/src/geometry/primitives/Circle3.ts\");\n/* harmony import */ var _geometry_primitives_Cube__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./geometry/primitives/Cube */ \"../engine/src/geometry/primitives/Cube.ts\");\n/* harmony import */ var _geometry_primitives_Line2__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./geometry/primitives/Line2 */ \"../engine/src/geometry/primitives/Line2.ts\");\n/* harmony import */ var _geometry_primitives_Plane__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./geometry/primitives/Plane */ \"../engine/src/geometry/primitives/Plane.ts\");\n/* harmony import */ var _geometry_primitives_Rectangle__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./geometry/primitives/Rectangle */ \"../engine/src/geometry/primitives/Rectangle.ts\");\n/* harmony import */ var _geometry_primitives_Triangle2__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./geometry/primitives/Triangle2 */ \"../engine/src/geometry/primitives/Triangle2.ts\");\n/* harmony import */ var _geometry_primitives_Triangle3__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./geometry/primitives/Triangle3 */ \"../engine/src/geometry/primitives/Triangle3.ts\");\n/* harmony import */ var _geometry_curve_Curve__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./geometry/curve/Curve */ \"../engine/src/geometry/curve/Curve.ts\");\n/* harmony import */ var _geometry_curve_Bezier__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./geometry/curve/Bezier */ \"../engine/src/geometry/curve/Bezier.ts\");\n/* harmony import */ var _geometry_curve_Polyline__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./geometry/curve/Polyline */ \"../engine/src/geometry/curve/Polyline.ts\");\n/* harmony import */ var _geometry_curve_Spline__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./geometry/curve/Spline */ \"../engine/src/geometry/curve/Spline.ts\");\n/* harmony import */ var _geometry_surface_Surface__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./geometry/surface/Surface */ \"../engine/src/geometry/surface/Surface.ts\");\n/* harmony import */ var _geometry_surface_BezierSquare__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./geometry/surface/BezierSquare */ \"../engine/src/geometry/surface/BezierSquare.ts\");\n/* harmony import */ var _geometry_surface_BezierTriangle__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./geometry/surface/BezierTriangle */ \"../engine/src/geometry/surface/BezierTriangle.ts\");\n/* harmony import */ var _geometry_surface_Loft__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./geometry/surface/Loft */ \"../engine/src/geometry/surface/Loft.ts\");\n/* harmony import */ var _geometry_mesh_Graph__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./geometry/mesh/Graph */ \"../engine/src/geometry/mesh/Graph.ts\");\n/* harmony import */ var _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./geometry/mesh/MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n/* harmony import */ var _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./geometry/mesh/Mesh */ \"../engine/src/geometry/mesh/Mesh.ts\");\n/* harmony import */ var _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./geometry/mesh/ShaderMesh */ \"../engine/src/geometry/mesh/ShaderMesh.ts\");\n/* harmony import */ var _geometry_mesh_TopoMesh__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./geometry/mesh/TopoMesh */ \"../engine/src/geometry/mesh/TopoMesh.ts\");\n/* harmony import */ var _geometry_mesh_ObjProcessing__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./geometry/mesh/ObjProcessing */ \"../engine/src/geometry/mesh/ObjProcessing.ts\");\n/* harmony import */ var _image_Color__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./image/Color */ \"../engine/src/image/Color.ts\");\n/* harmony import */ var _image_Colors__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./image/Colors */ \"../engine/src/image/Colors.ts\");\n/* harmony import */ var _image_Bitmap__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./image/Bitmap */ \"../engine/src/image/Bitmap.ts\");\n/* harmony import */ var _image_ImageProcessing__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./image/ImageProcessing */ \"../engine/src/image/ImageProcessing.ts\");\n/* harmony import */ var _inputOld_InputState__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./inputOld/InputState */ \"../engine/src/inputOld/InputState.ts\");\n/* harmony import */ var _input_InputHandler__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./input/InputHandler */ \"../engine/src/input/InputHandler.ts\");\n/* harmony import */ var _input_KeyboardHandler__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./input/KeyboardHandler */ \"../engine/src/input/KeyboardHandler.ts\");\n/* harmony import */ var _input_Keys__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./input/Keys */ \"../engine/src/input/Keys.ts\");\n/* harmony import */ var _input_MouseHandler__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./input/MouseHandler */ \"../engine/src/input/MouseHandler.ts\");\n/* harmony import */ var _input_TouchHandler__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./input/TouchHandler */ \"../engine/src/input/TouchHandler.ts\");\n/* harmony import */ var _input_TimeHandler__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./input/TimeHandler */ \"../engine/src/input/TimeHandler.ts\");\n/* harmony import */ var _input_TouchFinger__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./input/TouchFinger */ \"../engine/src/input/TouchFinger.ts\");\n/* harmony import */ var _math_Domain__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./math/Domain */ \"../engine/src/math/Domain.ts\");\n/* harmony import */ var _math_Math__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./math/Math */ \"../engine/src/math/Math.ts\");\n/* harmony import */ var _math_Matrix3__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./math/Matrix3 */ \"../engine/src/math/Matrix3.ts\");\n/* harmony import */ var _math_Matrix4__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./math/Matrix4 */ \"../engine/src/math/Matrix4.ts\");\n/* harmony import */ var _math_Polynomial__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./math/Polynomial */ \"../engine/src/math/Polynomial.ts\");\n/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./math/Quaternion */ \"../engine/src/math/Quaternion.ts\");\n/* harmony import */ var _math_Random__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./math/Random */ \"../engine/src/math/Random.ts\");\n/* harmony import */ var _math_Ray__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./math/Ray */ \"../engine/src/math/Ray.ts\");\n/* harmony import */ var _math_Statistics__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./math/Statistics */ \"../engine/src/math/Statistics.ts\");\n/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./math/Vector2 */ \"../engine/src/math/Vector2.ts\");\n/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./math/Vector3 */ \"../engine/src/math/Vector3.ts\");\n/* harmony import */ var _parametric_EnumParameter__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./parametric/EnumParameter */ \"../engine/src/parametric/EnumParameter.ts\");\n/* harmony import */ var _parametric_Parameter__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./parametric/Parameter */ \"../engine/src/parametric/Parameter.ts\");\n/* harmony import */ var _parametric_ParametricModel__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./parametric/ParametricModel */ \"../engine/src/parametric/ParametricModel.ts\");\n/* harmony import */ var _render_bufferables_ImageMesh__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./render/bufferables/ImageMesh */ \"../engine/src/render/bufferables/ImageMesh.ts\");\n/* harmony import */ var _render_bufferers_MeshBufferer__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./render/bufferers/MeshBufferer */ \"../engine/src/render/bufferers/MeshBufferer.ts\");\n/* harmony import */ var _render_renderers_DebugRenderer__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./render/renderers/DebugRenderer */ \"../engine/src/render/renderers/DebugRenderer.ts\");\n/* harmony import */ var _render_renderers_ImageRenderer__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./render/renderers/ImageRenderer */ \"../engine/src/render/renderers/ImageRenderer.ts\");\n/* harmony import */ var _render_renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./render/renderers/TextRenderer */ \"../engine/src/render/renderers/TextRenderer.ts\");\n/* harmony import */ var _render_shaders_AmbientMeshShader__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./render/shaders/AmbientMeshShader */ \"../engine/src/render/shaders/AmbientMeshShader.ts\");\n/* harmony import */ var _render_shaders_TexturedMeshShader__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./render/shaders/TexturedMeshShader */ \"../engine/src/render/shaders/TexturedMeshShader.ts\");\n/* harmony import */ var _render_shaders_BillboardShader__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./render/shaders/BillboardShader */ \"../engine/src/render/shaders/BillboardShader.ts\");\n/* harmony import */ var _render_shaders_DepthMeshShader__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./render/shaders/DepthMeshShader */ \"../engine/src/render/shaders/DepthMeshShader.ts\");\n/* harmony import */ var _render_shaders_DotShaderWithHeight__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./render/shaders/DotShaderWithHeight */ \"../engine/src/render/shaders/DotShaderWithHeight.ts\");\n/* harmony import */ var _render_shaders_PhongShader__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./render/shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n/* harmony import */ var _render_shaders_TemplateShader__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./render/shaders/TemplateShader */ \"../engine/src/render/shaders/TemplateShader.ts\");\n/* harmony import */ var _render_shaders_ZebraShader__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./render/shaders/ZebraShader */ \"../engine/src/render/shaders/ZebraShader.ts\");\n/* harmony import */ var _render_shaders_SkyBoxShader__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./render/shaders/SkyBoxShader */ \"../engine/src/render/shaders/SkyBoxShader.ts\");\n/* harmony import */ var _render_webgl_DrawTarget__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./render/webgl/DrawTarget */ \"../engine/src/render/webgl/DrawTarget.ts\");\n/* harmony import */ var _render_webgl_Attribute__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./render/webgl/Attribute */ \"../engine/src/render/webgl/Attribute.ts\");\n/* harmony import */ var _render_webgl_Attributes__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./render/webgl/Attributes */ \"../engine/src/render/webgl/Attributes.ts\");\n/* harmony import */ var _render_webgl_Constants__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./render/webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _render_webgl_HelpGl__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./render/webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _render_webgl_IndexAttribute__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./render/webgl/IndexAttribute */ \"../engine/src/render/webgl/IndexAttribute.ts\");\n/* harmony import */ var _render_webgl_Uniform__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./render/webgl/Uniform */ \"../engine/src/render/webgl/Uniform.ts\");\n/* harmony import */ var _render_webgl_Uniforms__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./render/webgl/Uniforms */ \"../engine/src/render/webgl/Uniforms.ts\");\n/* harmony import */ var _render_shaders_old_lib__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./render/shaders-old/_lib */ \"../engine/src/render/shaders-old/_lib.ts\");\n/* harmony import */ var _render_OldShader__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./render/OldShader */ \"../engine/src/render/OldShader.ts\");\n/* harmony import */ var _render_basics_Camera__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./render/basics/Camera */ \"../engine/src/render/basics/Camera.ts\");\n/* harmony import */ var _render_basics_Entity__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./render/basics/Entity */ \"../engine/src/render/basics/Entity.ts\");\n/* harmony import */ var _render_basics_Light__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./render/basics/Light */ \"../engine/src/render/basics/Light.ts\");\n/* harmony import */ var _render_basics_Material__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./render/basics/Material */ \"../engine/src/render/basics/Material.ts\");\n/* harmony import */ var _render_basics_Model__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./render/basics/Model */ \"../engine/src/render/basics/Model.ts\");\n/* harmony import */ var _render_basics_Shadable__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./render/basics/Shadable */ \"../engine/src/render/basics/Shadable.ts\");\n/* harmony import */ var _render_basics_Scene__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./render/basics/Scene */ \"../engine/src/render/basics/Scene.ts\");\n/* harmony import */ var _util_FpsCounter__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./util/FpsCounter */ \"../engine/src/util/FpsCounter.ts\");\n/* harmony import */ var _util_Microphone__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./util/Microphone */ \"../engine/src/util/Microphone.ts\");\n/* harmony import */ var _util_Debug__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./util/Debug */ \"../engine/src/util/Debug.ts\");\n/* harmony import */ var _util_Time__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./util/Time */ \"../engine/src/util/Time.ts\");\n// purpose: make sure the entire library is callable from one point.\r\n// I dont know why, but I had to move these up, otherwise some weird dependency interlinking bug creeps up in the ts compiler\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// export * from \"./geometry/solid\";\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/lib.ts?");

/***/ }),

/***/ "../engine/src/math/Const.ts":
/*!***********************************!*\
  !*** ../engine/src/math/Const.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Const\": () => (/* binding */ Const)\n/* harmony export */ });\n// name:    const.ts\r\n// author:  Jos Feenstra\r\n// purpose: Certain math constances\r\n// todo:    These are somewhat like the settings of the entire application. This could be expanded upon (json's, in-app functionalitiy)\r\nclass Const {\r\n    static IsRouglyZero(value) {\r\n        return Math.abs(value) < this.TOLERANCE;\r\n    }\r\n}\r\nConst.TOLERANCE = 0.0001; // tolerance used for determining if 1 value is the same as some other value, relatively speaking\r\nConst.TOL_SQUARED = Math.pow(Const.TOLERANCE, 2);\r\nConst.MAX_U16 = 65536;\r\n// ----- Line Render Settings -----\r\nConst.PLANE_RENDER_LINECOUNT = 9;\r\nConst.PLANE_RENDER_LINEDISTANCE = 0.3;\r\nConst.CIRCLE_SEGMENTS = 100;\r\nConst.BEZIER_SEGMENTS = 100;\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Const.ts?");

/***/ }),

/***/ "../engine/src/math/Directions.ts":
/*!****************************************!*\
  !*** ../engine/src/math/Directions.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"D4\": () => (/* binding */ D4),\n/* harmony export */   \"D6\": () => (/* binding */ D6),\n/* harmony export */   \"D8\": () => (/* binding */ D8),\n/* harmony export */   \"Direction\": () => (/* binding */ Direction)\n/* harmony export */ });\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector2 */ \"../engine/src/math/Vector2.ts\");\n\r\nvar D4;\r\n(function (D4) {\r\n    D4[D4[\"Left\"] = 0] = \"Left\";\r\n    D4[D4[\"Up\"] = 1] = \"Up\";\r\n    D4[D4[\"Right\"] = 2] = \"Right\";\r\n    D4[D4[\"Down\"] = 3] = \"Down\";\r\n})(D4 || (D4 = {}));\r\nvar D6;\r\n(function (D6) {\r\n    D6[D6[\"PosX\"] = 0] = \"PosX\";\r\n    D6[D6[\"NegX\"] = 1] = \"NegX\";\r\n    D6[D6[\"PosY\"] = 2] = \"PosY\";\r\n    D6[D6[\"NegY\"] = 3] = \"NegY\";\r\n    D6[D6[\"PosZ\"] = 4] = \"PosZ\";\r\n    D6[D6[\"NegZ\"] = 5] = \"NegZ\";\r\n})(D6 || (D6 = {}));\r\nvar D8;\r\n(function (D8) {\r\n    D8[D8[\"Left\"] = 0] = \"Left\";\r\n    D8[D8[\"UpLeft\"] = 1] = \"UpLeft\";\r\n    D8[D8[\"Up\"] = 2] = \"Up\";\r\n    D8[D8[\"UpRight\"] = 3] = \"UpRight\";\r\n    D8[D8[\"Right\"] = 4] = \"Right\";\r\n    D8[D8[\"DownRight\"] = 5] = \"DownRight\";\r\n    D8[D8[\"Down\"] = 6] = \"Down\";\r\n    D8[D8[\"DownLeft\"] = 7] = \"DownLeft\";\r\n})(D8 || (D8 = {}));\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction.Four = [D8.Left, D8.Up, D8.Right, D8.Down];\r\n    Direction.Eight = [D8.Left, D8.UpLeft, D8.Up, D8.UpRight, D8.Right, D8.DownRight, D8.Down, D8.DownLeft];\r\n    function D8ToVector(dir) {\r\n        switch (dir) {\r\n            case D8.Left:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(-1, 0);\r\n            case D8.UpLeft:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(-1, -1);\r\n            case D8.Up:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(0, -1);\r\n            case D8.UpRight:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(1, -1);\r\n            case D8.Right:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(1, 0);\r\n            case D8.DownRight:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(1, 1);\r\n            case D8.Down:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(0, 1);\r\n            case D8.DownLeft:\r\n                return _Vector2__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(-1, 1);\r\n        }\r\n    }\r\n    Direction.D8ToVector = D8ToVector;\r\n    function opposite(dir) {\r\n        switch (dir) {\r\n            case D8.Left: return D8.Right;\r\n            case D8.UpLeft: return D8.DownRight;\r\n            case D8.Up: return D8.Down;\r\n            case D8.UpRight: return D8.DownLeft;\r\n            case D8.Right: return D8.Left;\r\n            case D8.DownRight: return D8.UpLeft;\r\n            case D8.Down: return D8.Up;\r\n            case D8.DownLeft: return D8.UpRight;\r\n        }\r\n    }\r\n    Direction.opposite = opposite;\r\n})(Direction || (Direction = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Directions.ts?");

/***/ }),

/***/ "../engine/src/math/Domain.ts":
/*!************************************!*\
  !*** ../engine/src/math/Domain.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Domain\": () => (/* binding */ Domain),\n/* harmony export */   \"Domain2\": () => (/* binding */ Domain2),\n/* harmony export */   \"Domain3\": () => (/* binding */ Domain3)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector2 */ \"../engine/src/math/Vector2.ts\");\n/* harmony import */ var _util_Stopwatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/Stopwatch */ \"../engine/src/util/Stopwatch.ts\");\n// domain.ts\r\n//\r\n// author: Jos Feenstra\r\n// purpose: general representation of a domain / range / bound of numbers\r\n// TODO: give domain a stride / step. \r\n//       - redivide \r\n//       - fromDivide()\r\n//       - default: 1 \r\n//       - \r\n\r\n\r\n\r\nclass Domain {\r\n    constructor(t0 = 0.0, t1 = 1.0) {\r\n        this.t0 = t0;\r\n        this.t1 = t1;\r\n        // if (t0 > t1) console.error(\"created a domain with negative size.\");\r\n        // if (t0 == t1) console.warn(\"created a domain with size is 0.0. could cause problems\");\r\n        this.size = this.t1 - this.t0;\r\n    }\r\n    static new(t0 = 0, t1 = 1) {\r\n        return new Domain(t0, t1);\r\n    }\r\n    static fromRadius(r) {\r\n        return new Domain(-r, r);\r\n    }\r\n    static fromInclude(data) {\r\n        // create a new domain which bounds all parsed values\r\n        let min = Number.MAX_VALUE;\r\n        let max = Number.MIN_VALUE;\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i] < min)\r\n                min = data[i];\r\n            if (data[i] > max)\r\n                max = data[i];\r\n        }\r\n        return new Domain(min, max);\r\n    }\r\n    offset(t0Offset, t1Offset) {\r\n        this.t0 += t0Offset;\r\n        this.t1 += t1Offset;\r\n        this.size = this.t1 - this.t0;\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return value >= this.t0 && value <= this.t1;\r\n    }\r\n    includesEx(value) {\r\n        // note: including t0, exccluding t1\r\n        return value >= this.t0 && value < this.t1;\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return (value - this.t0) / this.size;\r\n    }\r\n    /**\r\n     * elevate a normalized parameter onto this domain\r\n     * @param t normalized parameter t in domain 0--1\r\n     * @returns parameter in domains numerical space\r\n     */\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return t * this.size + this.t0;\r\n    }\r\n    /**\r\n     * Exact same thing as elevate\r\n     */\r\n    lerp(t) {\r\n        return this.elevate(t);\r\n    }\r\n    remap(value, other = new Domain()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    /**\r\n     * generate `count` values evenly distributed along the domain.\r\n     */\r\n    spawn(count) {\r\n        // this is almost 100x slower\r\n        // return new Float32Array(this.iter(count));\r\n        let result = new Float32Array(count);\r\n        let step = this.size / (count - 1);\r\n        for (let i = 0; i < count; i++) {\r\n            result[i] = this.t0 + i * step;\r\n        }\r\n        return result;\r\n    }\r\n    *iter(count) {\r\n        // iterate over this Domain 'count' number of times\r\n        let step = this.size / (count - 1);\r\n        for (let i = 0; i < count; i++) {\r\n            let val = this.t0 + i * step;\r\n            yield val;\r\n        }\r\n    }\r\n    *iterStep(step) {\r\n        // iterate over this domain with a stepsize of 'step'\r\n        for (let i = this.t0; i <= this.t1; i += step) {\r\n            yield i;\r\n        }\r\n    }\r\n    // comform a number to the bound\r\n    comform(value) {\r\n        if (value < this.t0) {\r\n            return this.t0;\r\n        }\r\n        else if (value > this.t1) {\r\n            return this.t1;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n}\r\nclass Domain2 {\r\n    constructor(x = new Domain(), y = new Domain()) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    static fromRadii(rx, ry) {\r\n        return new Domain2(Domain.fromRadius(rx), Domain.fromRadius(ry));\r\n    }\r\n    static fromRadius(r) {\r\n        return new Domain2(Domain.fromRadius(r), Domain.fromRadius(r));\r\n    }\r\n    static fromBounds(x0, x1, y0, y1) {\r\n        return new Domain2(new Domain(x0, x1), new Domain(y0, y1));\r\n    }\r\n    static fromWH(x, y, w, h) {\r\n        return new Domain2(new Domain(x, x + w), new Domain(y, y + h));\r\n    }\r\n    static fromInclude(data) {\r\n        // note : could be quicker by going verbose, this now iterates over data 4 times\r\n        let mat = data.toMatrixSlice();\r\n        return new Domain2(Domain.fromInclude(mat.getColumn(0)), Domain.fromInclude(mat.getColumn(1)));\r\n    }\r\n    offset(xXyYoffset) {\r\n        let off = xXyYoffset;\r\n        if (off.length != 4)\r\n            throw \"need 4 values\";\r\n        this.x.offset(off[0], off[1]);\r\n        this.y.offset(off[2], off[3]);\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includes(value.x) && this.y.includes(value.y);\r\n    }\r\n    includesEx(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includesEx(value.x) && this.y.includesEx(value.y);\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return new _Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(this.x.size, this.y.size);\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return new _Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(this.x.normalize(value.x), this.y.normalize(value.y));\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return new _Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(this.x.elevate(t.x), this.y.elevate(t.y));\r\n    }\r\n    remap(value, other = new Domain2()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    corners() {\r\n        // render the extends of this boundary / domain\r\n        let dim = 2;\r\n        let data = [];\r\n        for (let x of [this.x.t0, this.x.t1]) {\r\n            for (let y of [this.y.t0, this.y.t1]) {\r\n                data.push(new _Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2(x, y));\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     * generate `countX * CountY` vector2's evenly distributed along the domain.\r\n     */\r\n    spawn(countX, countY) {\r\n        // iterate over this Domain 'count' number of times\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(countX * countY);\r\n        let i = 0;\r\n        let yRange = this.y.spawn(countY);\r\n        let xRange = this.x.spawn(countX);\r\n        for (const y of yRange) {\r\n            for (const x of xRange) {\r\n                result.setXY(i, x, y);\r\n                i++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Generate a bunch of random points\r\n     */\r\n    populate(count, rng) {\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(count);\r\n        for (let i = 0; i < result.count; i++) {\r\n            result.set(i, this.elevate(_Vector2__WEBPACK_IMPORTED_MODULE_1__.Vector2.fromRandom(rng)));\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass Domain3 {\r\n    constructor(x = new Domain(), y = new Domain(), z = new Domain()) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    static fromVectors(lower = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), upper = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(1, 1, 1)) {\r\n        return new Domain3(new Domain(lower.x, upper.x), new Domain(lower.y, upper.y), new Domain(lower.z, upper.z));\r\n    }\r\n    static fromBounds(x0, x1, y0, y1, z0, z1) {\r\n        return new Domain3(new Domain(x0, x1), new Domain(y0, y1), new Domain(z0, z1));\r\n    }\r\n    static fromRadius(r) {\r\n        return new Domain3(Domain.fromRadius(r), Domain.fromRadius(r), Domain.fromRadius(r));\r\n    }\r\n    static fromRadii(rx, ry, rz) {\r\n        return new Domain3(Domain.fromRadius(rx), Domain.fromRadius(ry), Domain.fromRadius(rz));\r\n    }\r\n    static fromInclude(data) {\r\n        // note : could be quicker by going verbose, this now iterates over data 6 times\r\n        return new Domain3(Domain.fromInclude(data.slice().getColumn(0)), Domain.fromInclude(data.slice().getColumn(1)), Domain.fromInclude(data.slice().getColumn(2)));\r\n    }\r\n    offset(xXyYoffset) {\r\n        let off = xXyYoffset;\r\n        if (off.length != 6)\r\n            throw \"need 6 values\";\r\n        this.x.offset(off[0], off[1]);\r\n        this.y.offset(off[2], off[3]);\r\n        this.z.offset(off[4], off[5]);\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includes(value.x) && this.y.includes(value.y) && this.z.includes(value.z);\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x.size, this.y.size, this.z.size);\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x.normalize(value.x), this.y.normalize(value.y), this.z.normalize(value.z));\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x.elevate(t.x), this.y.elevate(t.y), this.z.elevate(t.z));\r\n    }\r\n    remap(value, other = new Domain3()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    remapAll(values, other = new Domain3()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let newValues = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(values.count);\r\n        for (let i = 0; i < values.count; i++) {\r\n            let norm = this.normalize(values.get(i));\r\n            newValues.set(i, other.elevate(norm));\r\n        }\r\n        return newValues;\r\n    }\r\n    corners(matrix) {\r\n        // render the extends of this boundary / domain\r\n        let dim = 3;\r\n        let corners = 2 ^ dim;\r\n        let data = [];\r\n        for (let x of [this.x.t0, this.x.t1]) {\r\n            for (let y of [this.y.t0, this.y.t1]) {\r\n                for (let z of [this.z.t0, this.z.t1]) {\r\n                    data.push(matrix.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z)));\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     * generate `countX * countY * countZ` vector3's evenly distributed along the domain.\r\n     */\r\n    spawn(countX, countY, countZ) {\r\n        // iterate over this Domain 'count' number of times\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(countX * countY);\r\n        let i = 0;\r\n        // this looks dumb, i have tried other methods, this is still the fastest...\r\n        let zRange = this.z.spawn(countZ);\r\n        let yRange = this.y.spawn(countY);\r\n        let xRange = this.x.spawn(countX);\r\n        for (const z of zRange) {\r\n            for (const y of yRange) {\r\n                for (const x of xRange) {\r\n                    result.setXYZ(i, x, y, z);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Generate a bunch of random points\r\n     */\r\n    populate(count, rng) {\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < result.count; i++) {\r\n            result.set(i, this.elevate(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromRandom(rng)));\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction benchmark() {\r\n    // GENERAL BENCHMARKING CONCLUSIONS\r\n    // use typedarrays\r\n    // do not use yield. Its just not how javascript likes to function, often 100x slower\r\n    let sw = _util_Stopwatch__WEBPACK_IMPORTED_MODULE_2__.Stopwatch.new();\r\n    let domain = Domain2.fromRadius(5);\r\n    sw.log(\"init\");\r\n    let count = 1000;\r\n    domain.spawn(count, count);\r\n    sw.log(\"spawn1\");\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Domain.ts?");

/***/ }),

/***/ "../engine/src/math/LSA.ts":
/*!*********************************!*\
  !*** ../engine/src/math/LSA.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LSA\": () => (/* binding */ LSA)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\n/**\r\n * Use this namespace for fitting\r\n */\r\nvar LSA;\r\n(function (LSA) {\r\n    /**\r\n     * Find optimal `W` for `AW = b(*error^2)`.\r\n     */\r\n    function lsa(A, b) {\r\n        let mul = _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.mulBtoA;\r\n        let At = A.tp();\r\n        let inv_ATA = mul(A, At).inv();\r\n        let Atb = mul(b, At);\r\n        let W = mul(Atb, inv_ATA);\r\n        return W.getColumn(0);\r\n    }\r\n    LSA.lsa = lsa;\r\n    // https://mec560sbu.github.io/2016/08/29/Least_SQ_Fitting/\r\n    /**\r\n     * returns center X, center Y, radius\r\n     * @param points\r\n     * @returns\r\n     */\r\n    function circle2(points) {\r\n        // create and fill A & b\r\n        let count = points.count;\r\n        let A = _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.zeros(3, count);\r\n        let b = _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.zeros(1, count);\r\n        for (let i = 0; i < count; i++) {\r\n            let [x, y] = points.matrix.getRow(i);\r\n            A.setRow(i, [-2 * x, -2 * y, 1]);\r\n            b.setRow(i, [-(x * x + y * y)]);\r\n        }\r\n        let w = lsa(A, b);\r\n        // console.log(w);\r\n        let xc = w[0];\r\n        let yc = w[1];\r\n        let r = Math.sqrt(xc * xc + yc * yc - w[2]);\r\n        return [xc, yc, r];\r\n    }\r\n    LSA.circle2 = circle2;\r\n    /**\r\n     * Progressive Least Squares Fitting of a circle.\r\n     * This method's result is comparable to normal Least Squares, but it can detect and remove outliers.\r\n     * This is at the cost of latency, since this will calculate an LSA circle every iterations\r\n     *\r\n     * Returns a complete circle\r\n     */\r\n    function circle2Progressive(included, maxDeviation, maxIterations = 1000) {\r\n        let getIdWithLargestError = (circle, points2d) => {\r\n            let highscore = 0;\r\n            let highscoreId = -1;\r\n            for (let i = 0; i < points2d.count; i++) {\r\n                let p = points2d.get(i);\r\n                let score = Math.abs(circle.distance(p));\r\n                if (score > highscore) {\r\n                    highscore = score;\r\n                    highscoreId = i;\r\n                }\r\n            }\r\n            return [highscore, highscoreId];\r\n        };\r\n        let excluded = [];\r\n        let points2d = included.clone();\r\n        for (let i = 0; i < maxIterations; i++) {\r\n            console.log(i);\r\n            if (points2d.count < 2) {\r\n                console.error(\"PROGRESSIVE-LSA FAILED DUE TO LESS THAN TWO POINTS (REMAIN WITHIN ERROR RANGE).\");\r\n                return undefined;\r\n            }\r\n            // get a circle using all `points`\r\n            let circle = _lib__WEBPACK_IMPORTED_MODULE_0__.Circle2.fromLSA(points2d);\r\n            // remove the point with an error larger than max-deviation\r\n            let [largestError, largestID] = getIdWithLargestError(circle, points2d);\r\n            console.log(largestError, circle.distance(points2d.get(largestID)), maxDeviation);\r\n            if (largestError > maxDeviation) {\r\n                // NOTE: SOMETHING'S STILL WRONG HERE...\r\n                excluded.push(points2d.get(largestID));\r\n                points2d = points2d.remove([largestID]);\r\n                continue;\r\n            }\r\n            // if we arrive here, all errors are smaller than the max-deviation. We are done!\r\n            return {\r\n                circle,\r\n                included: points2d,\r\n                excluded: _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList(excluded)\r\n            };\r\n        }\r\n        console.error(\"PROGRESSIVE-LSA FAILED DUE TO TOO MANY ITERATIONS\");\r\n        return undefined;\r\n    }\r\n    LSA.circle2Progressive = circle2Progressive;\r\n    /**\r\n     *  solve x for Ax = b, where in this case, A = left, b = right.\r\n     */\r\n    function matrix(left, right) {\r\n        if (left.count != right.count) {\r\n            throw \"matrices need to be of equal width & height\";\r\n        }\r\n        // construct linear system of equations\r\n        let n = left.count;\r\n        let left_width = 4;\r\n        let right_width = 3;\r\n        let height = right_width * n;\r\n        let width = 16;\r\n        let M = new _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(width, height);\r\n        // per row in floatmatrix\r\n        for (let f = 0; f < n; f++) {\r\n            let l_vec = [...left.slice().getRow(f), 1];\r\n            let r_vec = [...right.slice().getRow(f), 1];\r\n            // go over x', y', z', 1 on the right side\r\n            for (let part = 0; part < right_width; part++) {\r\n                //\r\n                let i = f * right_width + part;\r\n                let offset = left_width * part;\r\n                // X  Y  Z  1  0  0  0  0 ...\r\n                for (let j = 0; j < l_vec.length; j++) {\r\n                    M.set(i, j + offset, l_vec[j]);\r\n                }\r\n                // ... -v*X  -v*Y  -v*Z   -v*1\r\n                offset = width - left_width;\r\n                for (let j = 0; j < l_vec.length; j++) {\r\n                    let v = M.get(i, j + offset);\r\n                    M.set(i, j + offset, v + -1 * r_vec[part] * l_vec[j]);\r\n                }\r\n            }\r\n        }\r\n        let [U, S, V] = _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.svd(M);\r\n        let col = V.getColumn(V.width - 1);\r\n        let scaler = 1 / col[15];\r\n        for (let i = 0; i < col.length; i++) {\r\n            col[i] = Math.round(col[i] * scaler * 100000) / 100000;\r\n        }\r\n        // create the actual matrix\r\n        let matrix = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new([...col]);\r\n        return matrix.transpose();\r\n    }\r\n    LSA.matrix = matrix;\r\n})(LSA || (LSA = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/LSA.ts?");

/***/ }),

/***/ "../engine/src/math/Math.ts":
/*!**********************************!*\
  !*** ../engine/src/math/Math.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeonMath\": () => (/* binding */ GeonMath)\n/* harmony export */ });\n// purpose: simple operations with only numbers\r\nclass GeonMath {\r\n    static isRougly(value, check, tolerance) {\r\n        return Math.abs(value - check) < tolerance;\r\n    }\r\n    // make sure 'value' is more than 'lower', and less than 'upper'\r\n    static clamp(value, lower, upper) {\r\n        return Math.min(Math.max(value, lower), upper);\r\n    }\r\n    static smooth(t) {\r\n        // Fade function as defined by Ken Perlin.  This eases coordinate values\r\n        // so that they will ease towards integral values.  This ends up smoothing\r\n        // the final output.\r\n        return t * t * t * (t * (t * 6 - 15) + 10); // 6t^5 - 15t^4 + 10t^3\r\n    }\r\n    /**\r\n     *  get `value` as a fraction between `min` and `max`.\r\n     */\r\n    static fraction(value, min, max) {\r\n        return (value - min) / (max - min);\r\n    }\r\n    static lerp(a, b, x) {\r\n        return a + x * (b - a);\r\n    }\r\n    static radToDeg(r) {\r\n        return (r * 180) / Math.PI;\r\n    }\r\n    static degToRad(d) {\r\n        return (d * Math.PI) / 180;\r\n    }\r\n    static factorial(n) {\r\n        let prod = 1;\r\n        for (let i = 1; i < n + 1; i++) {\r\n            prod *= i;\r\n        }\r\n        return prod;\r\n    }\r\n    static stack(n) {\r\n        let prod = 0;\r\n        for (let i = 1; i < n + 1; i++) {\r\n            prod += i;\r\n        }\r\n        return prod;\r\n    }\r\n    // on the edge of math & utility...\r\n    static sample(values, t) {\r\n        let count = values.length - 1;\r\n        let p = t * count;\r\n        let idxA = Math.floor(p);\r\n        let idxB = Math.ceil(p);\r\n        return this.lerp(values[idxA], values[idxB], p - idxA);\r\n    }\r\n    static sampleSmooth(data, t) {\r\n        let count = data.length - 1;\r\n        let p = t * count;\r\n        let idxA = Math.floor(p);\r\n        let idxB = Math.ceil(p);\r\n        return this.lerp(data[idxA], data[idxB], this.smooth(p - idxA));\r\n    }\r\n    /**\r\n     * binary search to figure out between which two values this sample is\r\n     * assumes data is sorted!!\r\n     */\r\n    static between(data, sample) {\r\n        let start = 0;\r\n        let end = data.length - 1;\r\n        for (let _ = 0; _ < data.length; _++) {\r\n            if (start > end) {\r\n                // its between these values\r\n                console.log(\"start\", start, \"end\", end);\r\n                let temp = end;\r\n                end = start;\r\n                start = temp;\r\n                break;\r\n            }\r\n            let mid = Math.round((end - start) / 2);\r\n            if (sample < data[mid]) {\r\n                // lower | on the left\r\n                start = mid;\r\n            }\r\n            else if (sample > data[mid]) {\r\n                // higher | on the right\r\n                end = mid;\r\n            }\r\n            else {\r\n                // same!\r\n                start = mid;\r\n                end = mid;\r\n                break;\r\n            }\r\n        }\r\n        return [start, end];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Math.ts?");

/***/ }),

/***/ "../engine/src/math/Matrix3.ts":
/*!*************************************!*\
  !*** ../engine/src/math/Matrix3.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Matrix3\": () => (/* binding */ Matrix3)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Matrix4 */ \"../engine/src/math/Matrix4.ts\");\n// NOTE: maybe matrix 3 should be removed...\r\n// 3x3 matrix of floats used for 2d math\r\n\r\n\r\n// inspired by Gregg Tavares.\r\nclass Matrix3 extends _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix {\r\n    constructor(data = []) {\r\n        super(3, 3, data);\r\n    }\r\n    static fromMat4(mat4) {\r\n        let d = mat4.data;\r\n        return new Matrix3([\r\n            d[0], d[1], d[2],\r\n            d[4], d[5], d[6],\r\n            d[8], d[9], d[10]\r\n        ]);\r\n    }\r\n    static new(data = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {\r\n        return new Matrix3(data);\r\n    }\r\n    static newIdentity() {\r\n        return new Matrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);\r\n    }\r\n    static newProjection(width, height) {\r\n        // Note: This matrix flips the Y axis so 0 is at the top.\r\n        return new Matrix3([2 / width, 0, 0, 0, -2 / height, 0, -1, 1, 1]);\r\n    }\r\n    static newTranslation(dx, dy) {\r\n        return new Matrix3([1, 0, 0, 0, 1, 0, dx, dy, 1]);\r\n    }\r\n    // angle in radians\r\n    static newRotation(r) {\r\n        var c = Math.cos(r);\r\n        var s = Math.sin(r);\r\n        return new Matrix3([c, -s, 0, s, c, 0, 0, 0, 1]);\r\n    }\r\n    static newScalar(sx, sy) {\r\n        return new Matrix3([sx, 0, 0, 0, sy, 0, 0, 0, 1]);\r\n    }\r\n    toMat4() {\r\n        let d = this.data;\r\n        return new _Matrix4__WEBPACK_IMPORTED_MODULE_1__.Matrix4([\r\n            d[0],\r\n            d[1],\r\n            0,\r\n            d[2],\r\n            d[3],\r\n            d[4],\r\n            0,\r\n            d[5],\r\n            0,\r\n            0,\r\n            1,\r\n            0,\r\n            d[6],\r\n            d[7],\r\n            0,\r\n            d[8],\r\n        ]);\r\n    }\r\n    toMat4Rot() {\r\n        let d = this.data;\r\n        return new _Matrix4__WEBPACK_IMPORTED_MODULE_1__.Matrix4([\r\n            d[0],\r\n            d[1],\r\n            d[2],\r\n            0,\r\n            d[3],\r\n            d[4],\r\n            d[5],\r\n            0,\r\n            d[6],\r\n            d[7],\r\n            d[8],\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            1,\r\n        ]);\r\n    }\r\n    project(width, height) {\r\n        return this.multiply(Matrix3.newProjection(width, height));\r\n    }\r\n    translateN(dx, dy) {\r\n        return this.multiply(Matrix3.newTranslation(dx, dy));\r\n    }\r\n    translate(v) {\r\n        return this.multiply(Matrix3.newTranslation(v.x, v.y));\r\n    }\r\n    rotate(r) {\r\n        return this.multiply(Matrix3.newRotation(r));\r\n    }\r\n    scale(sx, sy) {\r\n        return this.multiply(Matrix3.newScalar(sx, sy));\r\n    }\r\n    // multiply two m3's\r\n    multiply(other) {\r\n        let a = this.data;\r\n        let b = other.data;\r\n        var a00 = a[0 * 3 + 0];\r\n        var a01 = a[0 * 3 + 1];\r\n        var a02 = a[0 * 3 + 2];\r\n        var a10 = a[1 * 3 + 0];\r\n        var a11 = a[1 * 3 + 1];\r\n        var a12 = a[1 * 3 + 2];\r\n        var a20 = a[2 * 3 + 0];\r\n        var a21 = a[2 * 3 + 1];\r\n        var a22 = a[2 * 3 + 2];\r\n        var b00 = b[0 * 3 + 0];\r\n        var b01 = b[0 * 3 + 1];\r\n        var b02 = b[0 * 3 + 2];\r\n        var b10 = b[1 * 3 + 0];\r\n        var b11 = b[1 * 3 + 1];\r\n        var b12 = b[1 * 3 + 2];\r\n        var b20 = b[2 * 3 + 0];\r\n        var b21 = b[2 * 3 + 1];\r\n        var b22 = b[2 * 3 + 2];\r\n        return new Matrix3([\r\n            b00 * a00 + b01 * a10 + b02 * a20,\r\n            b00 * a01 + b01 * a11 + b02 * a21,\r\n            b00 * a02 + b01 * a12 + b02 * a22,\r\n            b10 * a00 + b11 * a10 + b12 * a20,\r\n            b10 * a01 + b11 * a11 + b12 * a21,\r\n            b10 * a02 + b11 * a12 + b12 * a22,\r\n            b20 * a00 + b21 * a10 + b22 * a20,\r\n            b20 * a01 + b21 * a11 + b22 * a21,\r\n            b20 * a02 + b21 * a12 + b22 * a22,\r\n        ]);\r\n    }\r\n    // transform a vector. RECYCLE IT\r\n    transformVector(v) {\r\n        let m = this.data;\r\n        let v0 = v.x;\r\n        let v1 = v.y;\r\n        let d = v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + m[2 * 3 + 2];\r\n        v.x = (v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + m[2 * 3 + 0]) / d;\r\n        v.y = (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + m[2 * 3 + 1]) / d;\r\n        return v;\r\n    }\r\n    // return the inverse of this matrix\r\n    inverse() {\r\n        // ive got no idea what is happening here,\r\n        // but apparantly, this is how you inverse a 3x3 matrix.\r\n        let m = this.data;\r\n        var t00 = m[1 * 3 + 1] * m[2 * 3 + 2] - m[1 * 3 + 2] * m[2 * 3 + 1];\r\n        var t10 = m[0 * 3 + 1] * m[2 * 3 + 2] - m[0 * 3 + 2] * m[2 * 3 + 1];\r\n        var t20 = m[0 * 3 + 1] * m[1 * 3 + 2] - m[0 * 3 + 2] * m[1 * 3 + 1];\r\n        // discriminant\r\n        var d = 1.0 / (m[0 * 3 + 0] * t00 - m[1 * 3 + 0] * t10 + m[2 * 3 + 0] * t20);\r\n        this.setData([\r\n            d * t00,\r\n            -d * t10,\r\n            d * t20,\r\n            -d * (m[1 * 3 + 0] * m[2 * 3 + 2] - m[1 * 3 + 2] * m[2 * 3 + 0]),\r\n            d * (m[0 * 3 + 0] * m[2 * 3 + 2] - m[0 * 3 + 2] * m[2 * 3 + 0]),\r\n            -d * (m[0 * 3 + 0] * m[1 * 3 + 2] - m[0 * 3 + 2] * m[1 * 3 + 0]),\r\n            d * (m[1 * 3 + 0] * m[2 * 3 + 1] - m[1 * 3 + 1] * m[2 * 3 + 0]),\r\n            -d * (m[0 * 3 + 0] * m[2 * 3 + 1] - m[0 * 3 + 1] * m[2 * 3 + 0]),\r\n            d * (m[0 * 3 + 0] * m[1 * 3 + 1] - m[0 * 3 + 1] * m[1 * 3 + 0]),\r\n        ]);\r\n        return this;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Matrix3.ts?");

/***/ }),

/***/ "../engine/src/math/Matrix4.ts":
/*!*************************************!*\
  !*** ../engine/src/math/Matrix4.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Matrix4\": () => (/* binding */ Matrix4)\n/* harmony export */ });\n/* harmony import */ var _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/FloatMatrix */ \"../engine/src/data/FloatMatrix.ts\");\n/* harmony import */ var _Transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Transform */ \"../engine/src/math/Transform.ts\");\n/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector3 */ \"../engine/src/math/Vector3.ts\");\n// matrix\r\n// author: Jos Feenstra\r\n// TODO: FIX MATRIX4 !!!\r\n// NOTE:\r\n\r\n\r\n\r\n// 4x4 matrix of floats used for 3d math\r\n// inspired by Gregg Tavares.\r\nclass Matrix4 extends _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix {\r\n    constructor(data = []) {\r\n        super(4, 4, data);\r\n    }\r\n    static new(data = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]) {\r\n        return new Matrix4(data);\r\n    }\r\n    static newIdentity() {\r\n        return new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newCopy(other) {\r\n        let result = new Matrix4();\r\n        for (let i = 0; i < 16; i++) {\r\n            result.data[i] = other.data[i];\r\n        }\r\n        return result;\r\n    }\r\n    get position() {\r\n        let d = this.data;\r\n        let pos = _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3.new();\r\n        pos.x = d[12];\r\n        pos.y = d[13];\r\n        pos.z = d[14];\r\n        return pos;\r\n    }\r\n    clone() {\r\n        return Matrix4.newCopy(this);\r\n    }\r\n    copy(other) {\r\n        for (let i = 0; i < 16; i++) {\r\n            this.data[i] = other.data[i];\r\n        }\r\n        return this;\r\n    }\r\n    multiplied(other) {\r\n        // NOTE: i swapped a and b, this makes more sense to me, but i could be wrong about it...\r\n        const a = other.data;\r\n        const b = this.data;\r\n        var b00 = b[0 * 4 + 0];\r\n        var b01 = b[0 * 4 + 1];\r\n        var b02 = b[0 * 4 + 2];\r\n        var b03 = b[0 * 4 + 3];\r\n        var b10 = b[1 * 4 + 0];\r\n        var b11 = b[1 * 4 + 1];\r\n        var b12 = b[1 * 4 + 2];\r\n        var b13 = b[1 * 4 + 3];\r\n        var b20 = b[2 * 4 + 0];\r\n        var b21 = b[2 * 4 + 1];\r\n        var b22 = b[2 * 4 + 2];\r\n        var b23 = b[2 * 4 + 3];\r\n        var b30 = b[3 * 4 + 0];\r\n        var b31 = b[3 * 4 + 1];\r\n        var b32 = b[3 * 4 + 2];\r\n        var b33 = b[3 * 4 + 3];\r\n        var a00 = a[0 * 4 + 0];\r\n        var a01 = a[0 * 4 + 1];\r\n        var a02 = a[0 * 4 + 2];\r\n        var a03 = a[0 * 4 + 3];\r\n        var a10 = a[1 * 4 + 0];\r\n        var a11 = a[1 * 4 + 1];\r\n        var a12 = a[1 * 4 + 2];\r\n        var a13 = a[1 * 4 + 3];\r\n        var a20 = a[2 * 4 + 0];\r\n        var a21 = a[2 * 4 + 1];\r\n        var a22 = a[2 * 4 + 2];\r\n        var a23 = a[2 * 4 + 3];\r\n        var a30 = a[3 * 4 + 0];\r\n        var a31 = a[3 * 4 + 1];\r\n        var a32 = a[3 * 4 + 2];\r\n        var a33 = a[3 * 4 + 3];\r\n        return new Matrix4([\r\n            b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\r\n            b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\r\n            b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\r\n            b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\r\n            b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\r\n            b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\r\n            b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\r\n            b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\r\n            b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\r\n            b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\r\n            b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\r\n            b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\r\n            b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\r\n            b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\r\n            b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\r\n            b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\r\n        ]);\r\n    }\r\n    multiply(other) {\r\n        this.data = this.multiplied(other).data;\r\n        return this;\r\n    }\r\n    transpose() {\r\n        let matrix = new Matrix4();\r\n        let res = matrix.data;\r\n        let old = this.data;\r\n        res[0] = old[0];\r\n        res[1] = old[4];\r\n        res[2] = old[8];\r\n        res[3] = old[12];\r\n        res[4] = old[1];\r\n        res[5] = old[5];\r\n        res[6] = old[9];\r\n        res[7] = old[13];\r\n        res[8] = old[2];\r\n        res[9] = old[6];\r\n        res[10] = old[10];\r\n        res[11] = old[14];\r\n        res[12] = old[3];\r\n        res[13] = old[7];\r\n        res[14] = old[11];\r\n        res[15] = old[15];\r\n        return matrix;\r\n    }\r\n    static newLookAt(cameraPosition, target, up) {\r\n        let matrix = new Matrix4();\r\n        let data = matrix.data;\r\n        let zAxis = cameraPosition.clone().sub(target).normalize();\r\n        let xAxis = up.clone().cross(up).normalize();\r\n        let yAxis = zAxis.clone().cross(xAxis).normalize();\r\n        data[0] = xAxis.x;\r\n        data[1] = xAxis.y;\r\n        data[2] = xAxis.z;\r\n        data[3] = 0;\r\n        data[4] = yAxis.x;\r\n        data[5] = yAxis.y;\r\n        data[6] = yAxis.z;\r\n        data[7] = 0;\r\n        data[8] = zAxis.x;\r\n        data[9] = zAxis.y;\r\n        data[10] = zAxis.z;\r\n        data[11] = 0;\r\n        data[12] = cameraPosition.x;\r\n        data[13] = cameraPosition.y;\r\n        data[14] = cameraPosition.z;\r\n        data[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 perspective transformation matrix given the angular height\r\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\r\n     * arguments define a frustum extending in the negative z direction.  The given\r\n     * angle is the vertical angle of the frustum, and the horizontal angle is\r\n     * determined to produce the given aspect ratio.  The arguments near and far are\r\n     * the distances to the near and far clipping planes.  Note that near and far\r\n     * are not z coordinates, but rather they are distances along the negative\r\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\r\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\r\n     * from -1 to 1 in the z dimension.\r\n     * @param {number} fieldOfViewInRadians field of view in y axis.\r\n     * @param {number} aspect aspect of viewport (width / height)\r\n     * @param {number} near near Z clipping plane\r\n     * @param {number} far far Z clipping plane\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newPerspective(fov, aspect, near, far) {\r\n        let matrix = new Matrix4();\r\n        let data = matrix.data;\r\n        var f = Math.tan(Math.PI * 0.5 - 0.5 * fov);\r\n        var rangeInv = 1.0 / (near - far);\r\n        data[0] = f / aspect;\r\n        data[1] = 0;\r\n        data[2] = 0;\r\n        data[3] = 0;\r\n        data[4] = 0;\r\n        data[5] = f;\r\n        data[6] = 0;\r\n        data[7] = 0;\r\n        data[8] = 0;\r\n        data[9] = 0;\r\n        data[10] = (near + far) * rangeInv;\r\n        data[11] = -1;\r\n        data[12] = 0;\r\n        data[13] = 0;\r\n        data[14] = near * far * rangeInv * 2;\r\n        data[15] = 0;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 orthographic projection matrix given the coordinates of the\r\n     * planes defining the axis-aligned, box-shaped viewing volume.  The matrix\r\n     * generated sends that box to the unit box.  Note that although left and right\r\n     * are x coordinates and bottom and top are y coordinates, near and far\r\n     * are not z coordinates, but rather they are distances along the negative\r\n     * z-axis.  We assume a unit box extending from -1 to 1 in the x and y\r\n     * dimensions and from -1 to 1 in the z dimension.\r\n     * @param {number} left The x coordinate of the left plane of the box.\r\n     * @param {number} right The x coordinate of the right plane of the box.\r\n     * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n     * @param {number} top The y coordinate of the right plane of the box.\r\n     * @param {number} near The negative z coordinate of the near plane of the box.\r\n     * @param {number} far The negative z coordinate of the far plane of the box.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newOrthographic(left, right, bottom, top, near, far) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        dst[0] = 2 / (right - left);\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = 2 / (top - bottom);\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = 0;\r\n        dst[9] = 0;\r\n        dst[10] = 2 / (near - far);\r\n        dst[11] = 0;\r\n        dst[12] = (left + right) / (left - right);\r\n        dst[13] = (bottom + top) / (bottom - top);\r\n        dst[14] = (near + far) / (near - far);\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 perspective transformation matrix given the left, right,\r\n     * top, bottom, near and far clipping planes. The arguments define a frustum\r\n     * extending in the negative z direction. The arguments near and far are the\r\n     * distances to the near and far clipping planes. Note that near and far are not\r\n     * z coordinates, but rather they are distances along the negative z-axis. The\r\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\r\n     * box extending from -1 to 1 in the x and y dimensions and from -1 to 1 in the z\r\n     * dimension.\r\n     * @param {number} left The x coordinate of the left plane of the box.\r\n     * @param {number} right The x coordinate of the right plane of the box.\r\n     * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n     * @param {number} top The y coordinate of the right plane of the box.\r\n     * @param {number} near The negative z coordinate of the near plane of the box.\r\n     * @param {number} far The negative z coordinate of the far plane of the box.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newFrustum(left, right, bottom, top, near, far) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        dst[0] = (2 * near) / dx;\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = (2 * near) / dy;\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = (left + right) / dx;\r\n        dst[9] = (top + bottom) / dy;\r\n        dst[10] = -(far + near) / dz;\r\n        dst[11] = -1;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = (-2 * near * far) / dz;\r\n        dst[15] = 0;\r\n        return matrix;\r\n    }\r\n    static newTranslation(tx, ty, tz, matrix = Matrix4.new()) {\r\n        let data = matrix.data;\r\n        data[12] = tx;\r\n        data[13] = ty;\r\n        data[14] = tz;\r\n        return matrix;\r\n    }\r\n    static newTranslate(v, matrix = Matrix4.new()) {\r\n        let data = matrix.data;\r\n        data[12] = v.x;\r\n        data[13] = v.y;\r\n        data[14] = v.z;\r\n        return matrix;\r\n    }\r\n    // static newRotate(euler: Vector3) {\r\n    //     return Matrix4.newRotation(euler.x, euler.y, euler.z);\r\n    // }\r\n    // static newRotation(pitch: number, yaw: number, roll: number) {\r\n    //     let rotation = Matrix4.new();\r\n    //     let rd = rotation.data;\r\n    //     rd[0] *= pitch;\r\n    //     rd[1] *= pitch;\r\n    //     rd[2] *= pitch;\r\n    //     rd[4] *= yaw;\r\n    //     rd[5] *= yaw;\r\n    //     rd[6] *= yaw;\r\n    //     rd[8] *= roll;\r\n    //     rd[9] *= roll;\r\n    //     rd[10] *= roll;\r\n    //     return rotation;\r\n    // }\r\n    static newXRotation(angleInRadians, matrix = Matrix4.newIdentity()) {\r\n        let data = matrix.data;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        // return new Matrix4(\r\n        //     [1, 0, 0, 0, \r\n        //     0, c, -s, 0, \r\n        //     0, s, c, 0,\r\n        //      0, 0, 0, 1]);\r\n        data[5] = c;\r\n        data[6] = -s;\r\n        data[9] = s;\r\n        data[10] = c;\r\n        return matrix;\r\n    }\r\n    static newYRotation(angleInRadians, matrix = Matrix4.newIdentity()) {\r\n        let data = matrix.data;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        // return new Matrix4([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\r\n        data[0] = c;\r\n        data[2] = s;\r\n        data[8] = -s;\r\n        data[10] = c;\r\n        return matrix;\r\n    }\r\n    static newZRotation(angleInRadians, matrix = Matrix4.newIdentity()) {\r\n        let data = matrix.data;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        data[0] = c;\r\n        data[1] = s;\r\n        data[4] = -s;\r\n        data[5] = c;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Makes an rotation matrix around an arbitrary axis\r\n     * @param {Vector3} axis axis to rotate around\r\n     * @param {number} angleInRadians amount to rotate\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newAxisRotation(axis, angleInRadians) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let x = axis.x;\r\n        let y = axis.y;\r\n        let z = axis.z;\r\n        let n = Math.sqrt(x * x + y * y + z * z);\r\n        x /= n;\r\n        y /= n;\r\n        z /= n;\r\n        let xx = x * x;\r\n        let yy = y * y;\r\n        let zz = z * z;\r\n        let c = Math.cos(angleInRadians);\r\n        let s = Math.sin(angleInRadians);\r\n        let oneMinusCosine = 1 - c;\r\n        dst[0] = xx + (1 - xx) * c;\r\n        dst[1] = x * y * oneMinusCosine + z * s;\r\n        dst[2] = x * z * oneMinusCosine - y * s;\r\n        dst[3] = 0;\r\n        dst[4] = x * y * oneMinusCosine - z * s;\r\n        dst[5] = yy + (1 - yy) * c;\r\n        dst[6] = y * z * oneMinusCosine + x * s;\r\n        dst[7] = 0;\r\n        dst[8] = x * z * oneMinusCosine + y * s;\r\n        dst[9] = y * z * oneMinusCosine - x * s;\r\n        dst[10] = zz + (1 - zz) * c;\r\n        dst[11] = 0;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = 0;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Multiply by an axis rotation matrix\r\n     * @param {Matrix4} m matrix to multiply\r\n     * @param {Vector3} axis axis to rotate around\r\n     * @param {number} angleInRadians amount to rotate\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     * @memberOf module:webgl-3d-math\r\n     */\r\n    axisRotate(axis, angleInRadians) {\r\n        // This is the optimized version of\r\n        // return multiply(m, axisRotation(axis, angleInRadians), dst);\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var n = Math.sqrt(x * x + y * y + z * z);\r\n        x /= n;\r\n        y /= n;\r\n        z /= n;\r\n        var xx = x * x;\r\n        var yy = y * y;\r\n        var zz = z * z;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        var oneMinusCosine = 1 - c;\r\n        var r00 = xx + (1 - xx) * c;\r\n        var r01 = x * y * oneMinusCosine + z * s;\r\n        var r02 = x * z * oneMinusCosine - y * s;\r\n        var r10 = x * y * oneMinusCosine - z * s;\r\n        var r11 = yy + (1 - yy) * c;\r\n        var r12 = y * z * oneMinusCosine + x * s;\r\n        var r20 = x * z * oneMinusCosine + y * s;\r\n        var r21 = y * z * oneMinusCosine - x * s;\r\n        var r22 = zz + (1 - zz) * c;\r\n        var m00 = m[0];\r\n        var m01 = m[1];\r\n        var m02 = m[2];\r\n        var m03 = m[3];\r\n        var m10 = m[4];\r\n        var m11 = m[5];\r\n        var m12 = m[6];\r\n        var m13 = m[7];\r\n        var m20 = m[8];\r\n        var m21 = m[9];\r\n        var m22 = m[10];\r\n        var m23 = m[11];\r\n        dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\r\n        dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\r\n        dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\r\n        dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\r\n        dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\r\n        dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\r\n        dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\r\n        dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\r\n        dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\r\n        dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\r\n        dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\r\n        dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return matrix;\r\n    }\r\n    // make a scaling matrix\r\n    static newScaler(sx, sy, sz) {\r\n        return new Matrix4([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);\r\n    }\r\n    /**\r\n     * Multiply by a scaling matrix\r\n     * @param {Matrix4} m matrix to multiply\r\n     * @param {number} sx x scale.\r\n     * @param {number} sy y scale.\r\n     * @param {number} sz z scale.\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     * @memberOf module:webgl-3d-math\r\n     */\r\n    scale(sx, sy, sz) {\r\n        // This is the optimized version of\r\n        // return multiply(m, scaling(sx, sy, sz), dst);\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        dst[0] = sx * m[0 * 4 + 0];\r\n        dst[1] = sx * m[0 * 4 + 1];\r\n        dst[2] = sx * m[0 * 4 + 2];\r\n        dst[3] = sx * m[0 * 4 + 3];\r\n        dst[4] = sy * m[1 * 4 + 0];\r\n        dst[5] = sy * m[1 * 4 + 1];\r\n        dst[6] = sy * m[1 * 4 + 2];\r\n        dst[7] = sy * m[1 * 4 + 3];\r\n        dst[8] = sz * m[2 * 4 + 0];\r\n        dst[9] = sz * m[2 * 4 + 1];\r\n        dst[10] = sz * m[2 * 4 + 2];\r\n        dst[11] = sz * m[2 * 4 + 3];\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return matrix;\r\n    }\r\n    static fromXform(xform, matrix = new Matrix4()) {\r\n        return Matrix4.fromPosRotScale(xform.pos, xform.rot, xform.scale, matrix);\r\n    }\r\n    /**\r\n     * creates a matrix from translation, quaternion, scale\r\n     */\r\n    static fromPosRotScale(pos, rot, scale, matrix = new Matrix4()) {\r\n        const rx = rot.x;\r\n        const ry = rot.y;\r\n        const rz = rot.z;\r\n        const rw = rot.w;\r\n        const sx = scale.x;\r\n        const sy = scale.y;\r\n        const sz = scale.z;\r\n        const x2 = rx + rx;\r\n        const y2 = ry + ry;\r\n        const z2 = rz + rz;\r\n        const xx = rx * x2;\r\n        const xy = rx * y2;\r\n        const xz = rx * z2;\r\n        const yy = ry * y2;\r\n        const yz = ry * z2;\r\n        const zz = rz * z2;\r\n        const wx = rw * x2;\r\n        const wy = rw * y2;\r\n        const wz = rw * z2;\r\n        matrix.data[0] = (1 - (yy + zz)) * sx;\r\n        matrix.data[1] = (xy + wz) * sx;\r\n        matrix.data[2] = (xz - wy) * sx;\r\n        matrix.data[3] = 0;\r\n        matrix.data[4] = (xy - wz) * sy;\r\n        matrix.data[5] = (1 - (xx + zz)) * sy;\r\n        matrix.data[6] = (yz + wx) * sy;\r\n        matrix.data[7] = 0;\r\n        matrix.data[8] = (xz + wy) * sz;\r\n        matrix.data[9] = (yz - wx) * sz;\r\n        matrix.data[10] = (1 - (xx + yy)) * sz;\r\n        matrix.data[11] = 0;\r\n        matrix.data[12] = pos.x;\r\n        matrix.data[13] = pos.y;\r\n        matrix.data[14] = pos.z;\r\n        matrix.data[15] = 1;\r\n        return matrix;\r\n    }\r\n    toTransform(xform = _Transform__WEBPACK_IMPORTED_MODULE_1__.Transform.new()) {\r\n        xform.setWithMatrix(this);\r\n        return xform;\r\n    }\r\n    determinant() {\r\n        const m = this.data;\r\n        const m00 = m[0];\r\n        const m01 = m[1];\r\n        const m02 = m[2];\r\n        const m03 = m[3];\r\n        const m10 = m[4];\r\n        const m11 = m[5];\r\n        const m12 = m[6];\r\n        const m13 = m[7];\r\n        const m20 = m[8];\r\n        const m21 = m[9];\r\n        const m22 = m[10];\r\n        const m23 = m[11];\r\n        const m30 = m[12];\r\n        const m31 = m[13];\r\n        const m32 = m[14];\r\n        const m33 = m[15];\r\n        const tmp_0 = m22 * m33;\r\n        const tmp_1 = m32 * m23;\r\n        const tmp_2 = m12 * m33;\r\n        const tmp_3 = m32 * m13;\r\n        const tmp_4 = m12 * m23;\r\n        const tmp_5 = m22 * m13;\r\n        const tmp_6 = m02 * m33;\r\n        const tmp_7 = m32 * m03;\r\n        const tmp_8 = m02 * m23;\r\n        const tmp_9 = m22 * m03;\r\n        const tmp_10 = m02 * m13;\r\n        const tmp_11 = m12 * m03;\r\n        const t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        const t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        const t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        const t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n        return 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n    }\r\n    inverse(matrix = new Matrix4()) {\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        var m00 = m[0 * 4 + 0];\r\n        var m01 = m[0 * 4 + 1];\r\n        var m02 = m[0 * 4 + 2];\r\n        var m03 = m[0 * 4 + 3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        var tmp_0 = m22 * m33;\r\n        var tmp_1 = m32 * m23;\r\n        var tmp_2 = m12 * m33;\r\n        var tmp_3 = m32 * m13;\r\n        var tmp_4 = m12 * m23;\r\n        var tmp_5 = m22 * m13;\r\n        var tmp_6 = m02 * m33;\r\n        var tmp_7 = m32 * m03;\r\n        var tmp_8 = m02 * m23;\r\n        var tmp_9 = m22 * m03;\r\n        var tmp_10 = m02 * m13;\r\n        var tmp_11 = m12 * m03;\r\n        var tmp_12 = m20 * m31;\r\n        var tmp_13 = m30 * m21;\r\n        var tmp_14 = m10 * m31;\r\n        var tmp_15 = m30 * m11;\r\n        var tmp_16 = m10 * m21;\r\n        var tmp_17 = m20 * m11;\r\n        var tmp_18 = m00 * m31;\r\n        var tmp_19 = m30 * m01;\r\n        var tmp_20 = m00 * m21;\r\n        var tmp_21 = m20 * m01;\r\n        var tmp_22 = m00 * m11;\r\n        var tmp_23 = m10 * m01;\r\n        var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n        var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n        dst[0] = d * t0;\r\n        dst[1] = d * t1;\r\n        dst[2] = d * t2;\r\n        dst[3] = d * t3;\r\n        dst[4] =\r\n            d *\r\n                (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\r\n        dst[5] =\r\n            d *\r\n                (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\r\n        dst[6] =\r\n            d *\r\n                (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\r\n        dst[7] =\r\n            d *\r\n                (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\r\n        dst[8] =\r\n            d *\r\n                (tmp_12 * m13 +\r\n                    tmp_15 * m23 +\r\n                    tmp_16 * m33 -\r\n                    (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\r\n        dst[9] =\r\n            d *\r\n                (tmp_13 * m03 +\r\n                    tmp_18 * m23 +\r\n                    tmp_21 * m33 -\r\n                    (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\r\n        dst[10] =\r\n            d *\r\n                (tmp_14 * m03 +\r\n                    tmp_19 * m13 +\r\n                    tmp_22 * m33 -\r\n                    (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\r\n        dst[11] =\r\n            d *\r\n                (tmp_17 * m03 +\r\n                    tmp_20 * m13 +\r\n                    tmp_23 * m23 -\r\n                    (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\r\n        dst[12] =\r\n            d *\r\n                (tmp_14 * m22 +\r\n                    tmp_17 * m32 +\r\n                    tmp_13 * m12 -\r\n                    (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\r\n        dst[13] =\r\n            d *\r\n                (tmp_20 * m32 +\r\n                    tmp_12 * m02 +\r\n                    tmp_19 * m22 -\r\n                    (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\r\n        dst[14] =\r\n            d *\r\n                (tmp_18 * m12 +\r\n                    tmp_23 * m32 +\r\n                    tmp_15 * m02 -\r\n                    (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\r\n        dst[15] =\r\n            d *\r\n                (tmp_22 * m22 +\r\n                    tmp_16 * m02 +\r\n                    tmp_21 * m12 -\r\n                    (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\r\n        return matrix;\r\n    }\r\n    multiplyVector(v) {\r\n        let data = new Array(3);\r\n        for (var i = 0; i < 3; ++i) {\r\n            data[i] = 0.0;\r\n            for (var j = 0; j < 4; ++j) {\r\n                data[i] += v.item(j) * this.get(j, i);\r\n            }\r\n        }\r\n        return new _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3(data[0], data[1], data[2]);\r\n    }\r\n    multipliedVectorList(vecs) {\r\n        let result = Array(vecs.length);\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            result[i] = this.multiplyVector(vecs[i]);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Matrix4.ts?");

/***/ }),

/***/ "../engine/src/math/Polynomial.ts":
/*!****************************************!*\
  !*** ../engine/src/math/Polynomial.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polynomial\": () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math */ \"../engine/src/math/Math.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Util */ \"../engine/src/math/Util.ts\");\n// author: Jos Feenstra \r\n// purpose: polynomial math needed for curves & surfaces\r\n// note: uses a hardcoded pascal's triangle for performance reasons\r\n// notes:   based upon the excellent explainations from Prof. C.-K. Shene: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/\r\n\r\n\r\n\r\nclass Polynomial {\r\n    /**\r\n     *   calculate weight using the Bernstein Polynomials:\r\n     *   (n over i) t^i * (1-t)^(n - i).\r\n     *   precalculated Pascal's triangle for a bit more efficiency\r\n     * @param t parameter t\r\n     * @param i vert index\r\n     * @param n degree\r\n     * @returns\r\n     */\r\n    static bernstein(t, i, n) {\r\n        return this.getBicoef(n, i) * Math.pow(t, i) * Math.pow(1 - t, n - i);\r\n    }\r\n    /**\r\n     * CoxDeboor's recusion formula.\r\n     * Basicly bernstein, but for b-splines\r\n     * NOTE: inefficient calculation: recursive in the dumb sense\r\n     */\r\n    static coxdeboor(t, i, degree, knots) {\r\n        // console.log(\"t\", t, \"i\", i, \"degree\", degree);\r\n        // let ui = knots[i];\r\n        // let ui1 = knots[i+1];\r\n        // let uip = knots[i+degree];\r\n        // let uip1 = knots[i + degree + 1];\r\n        if (degree == 0) {\r\n            // console.log(\"range\", knots[i], \" to \", knots[i + 1]);\r\n            if (t >= knots[i] && t < knots[i + 1]) {\r\n                // console.log(\"in between!\");\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n        let denom1 = knots[i + degree] - knots[i];\r\n        let denom2 = knots[i + degree + 1] - knots[i + 1];\r\n        // if (denom1 == 0 || denom2 == 0) {\r\n        //     console.log(\"zero\");\r\n        //     return 0;\r\n        // }\r\n        let c1 = (t - knots[i]) / denom1;\r\n        let c2 = (knots[i + degree + 1] - t) / denom2;\r\n        // console.log(c1);\r\n        // console.log(c2);\r\n        return (c1 * this.coxdeboor(t, i, degree - 1, knots) +\r\n            c2 * this.coxdeboor(t, i + 1, degree - 1, knots));\r\n    }\r\n    /**\r\n     * CoxDeboor's recusion formula.\r\n     * Basicly bernstein, but for b-splines\r\n     * NOTE: this is but a sketch, this is not correct yet...\r\n     * NOTE: the result will be\r\n     */\r\n    static coxdeboorTriangle(t, i, p, knots) {\r\n        let size = knots.length;\r\n        // console.log(points.count);\r\n        // create the triangle of resulting points\r\n        let result = new Float32Array(_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let tri = _Util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        // copy paste the base\r\n        let basecolumn = size - 1;\r\n        let j = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = tri(basecolumn, row);\r\n            if (knots[i] <= t || t < knots[i + 1]) {\r\n                result[idx] = 1;\r\n            }\r\n            result[idx] = 0;\r\n            j++;\r\n        }\r\n        // iterate over this triangle, starting at the base + 1\r\n        for (let col = size - 2; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = tri(col, row);\r\n                let left = result[tri(col + 1, row)];\r\n                let right = result[tri(col + 1, row + 1)];\r\n                let c1 = (t - knots[i]) / (knots[i + p] - knots[i]);\r\n                let c2 = (knots[i + p + 1] - t) / (knots[i + p + 1] - knots[i + 1]);\r\n                result[idx] = c1 * left + c2 * right;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Binomial coeficient\r\n     */\r\n    static getBicoef(n, i) {\r\n        return this._pascal[n][i];\r\n    }\r\n    /**\r\n     * Binomial coeficient\r\n     */\r\n    static calcBicoef(n, i) {\r\n        let f = _Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.factorial;\r\n        return f(n) / (f(i) * f(n - i));\r\n    }\r\n    static calcPascal(limit) {\r\n        let pascal = Array(limit);\r\n        for (let n = 0; n < limit; n++) {\r\n            pascal[n] = Array(n + 1);\r\n            for (let i = 0; i < n + 1; i++) {\r\n                pascal[n][i] = this.calcBicoef(n, i);\r\n            }\r\n        }\r\n        return pascal;\r\n    }\r\n    /**\r\n     *  This function returns the entire castejau piramid.\r\n     *  the final point is the first: verts[0].\r\n     *  Hovever, this is slower than the PointAt() method,\r\n     *  which uses bernstein polynomials\r\n     *\r\n     *  useful for:\r\n     *  Subdividing bezier curves, debugging, and splines\r\n     */\r\n    static decastejau(verts, t) {\r\n        let size = verts.count;\r\n        // console.log(points.count);\r\n        // create the triangle of resulting points\r\n        let result = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let tri = _Util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        // copy paste the base\r\n        let basecolumn = size - 1;\r\n        let i = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = tri(basecolumn, row);\r\n            result.set(idx, verts.get(i));\r\n            i++;\r\n        }\r\n        // iterate over this triangle, starting at the base + 1\r\n        for (let col = size - 2; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = tri(col, row);\r\n                let p_a = result.get(tri(col + 1, row));\r\n                let p_b = result.get(tri(col + 1, row + 1));\r\n                let q = p_b.scale(t).add(p_a.scale(1 - t));\r\n                result.set(idx, q);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // calculate the decastejau piramid based on extrapolation\r\n    static decastejauExtrapolateEnd(verts, t) {\r\n        let size = verts.count;\r\n        // create the triangle of resulting points\r\n        let triangle = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let iterTri = _Util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        let i = 0;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            let idx = iterTri(col, 0);\r\n            triangle.set(idx, verts.get(i));\r\n            i++;\r\n        }\r\n        // per triangle of 3 within this triangle (hard to put into words...)\r\n        for (let col = 1; col < size; col++) {\r\n            for (let row = 1; row <= col; row++) {\r\n                let a = iterTri(col - 1, row - 1);\r\n                let b = iterTri(col, row - 1);\r\n                let c = iterTri(col, row);\r\n                // set C based upon extrapolation of B past A\r\n                let C = triangle.get(b).lerp(triangle.get(a), 1 + t);\r\n                triangle.set(c, C);\r\n            }\r\n        }\r\n        // triangle.map(v => console.log(v));\r\n        return triangle;\r\n    }\r\n    static decastejauExtrapolateStart(verts, t) {\r\n        let size = verts.count;\r\n        // console.log(points.count);\r\n        // create the triangle of resulting points\r\n        let result = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let tri = _Util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        // copy paste the base\r\n        let basecolumn = size - 1;\r\n        let i = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = tri(basecolumn, row);\r\n            result.set(idx, verts.get(i));\r\n            i++;\r\n        }\r\n        // iterate over this triangle, starting at the base + 1\r\n        for (let col = size - 2; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = tri(col, row);\r\n                let p_a = result.get(tri(col + 1, row));\r\n                let p_b = result.get(tri(col + 1, row + 1));\r\n                let q = p_b.scale(t).add(p_a.scale(1 - t));\r\n                result.set(idx, q);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n// pascals's triangle. Hardcoded for performance\r\nPolynomial.MAX_DEGREE = 15;\r\nPolynomial._pascal = Polynomial.calcPascal(Polynomial.MAX_DEGREE);\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Polynomial.ts?");

/***/ }),

/***/ "../engine/src/math/Quaternion.ts":
/*!****************************************!*\
  !*** ../engine/src/math/Quaternion.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Quaternion\": () => (/* binding */ Quaternion)\n/* harmony export */ });\n/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3 */ \"../engine/src/math/Vector3.ts\");\n// author: Jos Feenstra\r\n// purpose: Quaternion to be used for rotation\r\n// Inspired by:\r\n// https://api.flutter.dev/flutter/vector_math/Quaternion-class.html\r\n\r\nclass Quaternion {\r\n    constructor(x, y, z, w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n    }\r\n    static new() {\r\n        return new Quaternion(0, 0, 0, 1);\r\n    }\r\n    static fromEuler(yaw, pitch, roll) {\r\n        return new Quaternion(0, 0, 0, 1).setEuler(yaw, pitch, roll);\r\n    }\r\n    setIndex(i, value) {\r\n        switch (i) {\r\n            case 0:\r\n                this.x = value;\r\n                return;\r\n            case 1:\r\n                this.y = value;\r\n                return;\r\n            case 2:\r\n                this.z = value;\r\n                return;\r\n            case 3:\r\n                this.w = value;\r\n                return;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n    lengthSquared() {\r\n        return (this.x * this.x) + (this.y * this.y) + (this.z * this.z) + (this.w * this.w);\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.lengthSquared());\r\n    }\r\n    set(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n        return this;\r\n    }\r\n    copy(q) {\r\n        this.x = q.x;\r\n        this.y = q.y;\r\n        this.z = q.z;\r\n        this.w = q.w;\r\n        return this;\r\n    }\r\n    inverse() {\r\n        const scalar = 1.0 / this.lengthSquared();\r\n        this.w = this.w * scalar;\r\n        this.z = -this.z * scalar;\r\n        this.y = -this.y * scalar;\r\n        this.x = -this.x * scalar;\r\n    }\r\n    add(other) {\r\n        this.x += other.x;\r\n        this.y += other.y;\r\n        this.z += other.z;\r\n        this.w += other.w;\r\n        return this;\r\n    }\r\n    addN(x = 0.0, y = 0.0, z = 0.0, w = 0.0) {\r\n        this.x += x;\r\n        this.y += y;\r\n        this.z += z;\r\n        this.w += w;\r\n        return this;\r\n    }\r\n    setEuler(yaw, pitch, roll) {\r\n        const halfYaw = yaw * 0.5;\r\n        const halfPitch = pitch * 0.5;\r\n        const halfRoll = roll * 0.5;\r\n        const cosYaw = Math.cos(halfYaw);\r\n        const sinYaw = Math.sin(halfYaw);\r\n        const cosPitch = Math.cos(halfPitch);\r\n        const sinPitch = Math.sin(halfPitch);\r\n        const cosRoll = Math.cos(halfRoll);\r\n        const sinRoll = Math.sin(halfRoll);\r\n        this.x = cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw;\r\n        this.y = cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw;\r\n        this.z = sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw;\r\n        this.w = cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw;\r\n        return this;\r\n    }\r\n    setAxisAngle(axis, radians) {\r\n        const length = axis.length();\r\n        if (length == 0.0) {\r\n            return;\r\n        }\r\n        const halfSin = Math.sin(radians * 0.5) / length;\r\n        this.x = axis.x * halfSin;\r\n        this.y = axis.y * halfSin;\r\n        this.z = axis.z * halfSin;\r\n        this.w = Math.cos(radians * 0.5);\r\n        return this;\r\n    }\r\n    /**\r\n     * Same as 'setTwoVectors', but skips out on normalization for efficiencie's sake\r\n     * This makes YOU responsible for giving me two normalized vectors :)\r\n     */\r\n    setTwoNormalizedVectors(a, b) {\r\n        const c = a.dot(b);\r\n        let angle = Math.acos(c);\r\n        let axis = a.cross(b);\r\n        if (Math.abs(1.0 + c) < 0.0005) {\r\n            // c \\approx -1 indicates 180 degree rotation\r\n            angle = Math.PI;\r\n            // [JF]: This is a common problem, \r\n            // a and b are parallel in opposite directions. We need any\r\n            // vector as our rotation axis that is perpendicular.\r\n            // Find one by taking the cross product of v1 with an appropriate unit axis\r\n            if (a.x > a.y && a.x > a.z) {\r\n                // v1 points in a dominantly x direction, so don't cross with that axis\r\n                axis = a.cross(_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY());\r\n            }\r\n            else {\r\n                // Predominantly points in some other direction, so x-axis should be safe\r\n                axis = a.cross(_Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX());\r\n            }\r\n        }\r\n        else if (Math.abs(1.0 - c) < 0.0005) {\r\n            // c \\approx 1 is 0-degree rotation, axis is arbitrary\r\n            angle = 0.0;\r\n            axis = _Vector3__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX();\r\n        }\r\n        return this.setAxisAngle(axis.normalize(), angle);\r\n    }\r\n    /**\r\n     * This is like plane.fromCVV, but just the vv part\r\n     * NOTE: the plane class should probably be deleted eventually, it wont be needed anymore :)\r\n     * TODO: Replace Plane with a Pose class, aka Transform without Scale\r\n     */\r\n    setTwoVectors(a, b) {\r\n        return this.setTwoNormalizedVectors(a.normalized(), b.normalized());\r\n    }\r\n    setPose(a, b) {\r\n        let i = a.normalized();\r\n        let k = a.cross(b).normalized();\r\n        let j = k.cross(a).normalized();\r\n        return this.setFromMatrix(i.x, i.y, i.z, j.x, j.y, j.z, k.x, k.y, k.z);\r\n    }\r\n    /**\r\n     * http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.html\r\n     */\r\n    multiply(q2) {\r\n        const q1 = this;\r\n        const x = q1.x * q2.w + q1.y * q2.z - q1.z * q2.y + q1.w * q2.x;\r\n        const y = -q1.x * q2.z + q1.y * q2.w + q1.z * q2.x + q1.w * q2.y;\r\n        const z = q1.x * q2.y - q1.y * q2.x + q1.z * q2.w + q1.w * q2.z;\r\n        const w = -q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w;\r\n        this.set(x, y, z, w);\r\n    }\r\n    /**\r\n     * I dont know what this means yet ...\r\n     */\r\n    setStrangeNumbers(a, b, c) {\r\n        const x0 = a;\r\n        const r1 = Math.sqrt(1.0 - x0);\r\n        const r2 = Math.sqrt(x0);\r\n        const t1 = Math.PI * 2.0 * b;\r\n        const t2 = Math.PI * 2.0 * c;\r\n        const c1 = Math.cos(t1);\r\n        const s1 = Math.sin(t1);\r\n        const c2 = Math.cos(t2);\r\n        const s2 = Math.sin(t2);\r\n        this.x = s1 * r1;\r\n        this.y = c1 * r1;\r\n        this.z = s2 * r2;\r\n        this.w = c2 * r2;\r\n        return this;\r\n    }\r\n    setRandom(random) {\r\n        // From: \"Uniform Random Rotations\", Ken Shoemake, Graphics Gems III,\r\n        // pg. 124-132.\r\n        return this.setStrangeNumbers(random.get(), random.get(), random.get());\r\n    }\r\n    /**\r\n     * Set from rotation matrix\r\n     * PS: I'm trying to do this without constructing a M3 for efficiencies sake\r\n     */\r\n    setFromMatrix(r0 = 1, r1 = 0, r2 = 0, r3 = 0, r4 = 1, r5 = 0, r6 = 0, r7 = 0, r8 = 1) {\r\n        // NOTE: this is unavoidable... unless we rewrite a whole bunch\r\n        let r = [r0, r1, r2, r3, r4, r5, r6, r7, r8];\r\n        let index = (row = 0, col = 0) => (col * 3) + row;\r\n        // the trace of a matrix is the sum of diagonal entries \r\n        let trace = r0 + r4 + r8;\r\n        if (trace > 0.0) {\r\n            let s = Math.sqrt(trace + 1.0);\r\n            this.w = s * 0.5;\r\n            s = 0.5 / s;\r\n            this.x = (r5 - r7) * s;\r\n            this.y = (r6 - r2) * s;\r\n            this.z = (r1 - r3) * s;\r\n        }\r\n        else {\r\n            // i is largest out of r0, r4, r8\r\n            const i = r0 < r4 ? (r4 < r8 ? 2 : 1) : (r0 < r8 ? 2 : 0);\r\n            // TODO rewrite it verbose-style, it will be quicker, a la:\r\n            // if (i == 0) {\r\n            //     const j = 1;\r\n            //     const k = 2;\r\n            // } else if (i == 1) {\r\n            //     const j = 2;\r\n            //     const k = 0;\r\n            // } else /* (i == 2) */ {\r\n            //     const j = 0;\r\n            //     const k = 1;\r\n            // }\r\n            const j = (i + 1) % 3;\r\n            const k = (i + 2) % 3;\r\n            let s = Math.sqrt(r[index(i, i)] - r[index(j, j)] - r[index(k, k)] + 1.0);\r\n            this.setIndex(i, s * 0.5);\r\n            s = 0.5 / s;\r\n            this.setIndex(j, (r[index(j, i)] + r[index(i, j)]) * s);\r\n            this.setIndex(k, (r[index(k, i)] + r[index(i, k)]) * s);\r\n            this.w = (r[index(k, j)] - r[index(j, k)]) * s;\r\n        }\r\n        return this;\r\n    }\r\n    rotate(v) {\r\n        const x = this.x;\r\n        const y = this.y;\r\n        const z = this.z;\r\n        const w = this.w;\r\n        const tiw = w;\r\n        const tiz = -z;\r\n        const tiy = -y;\r\n        const tix = -x;\r\n        const tx = tiw * v.x + tix * 0.0 + tiy * v.z - tiz * v.y;\r\n        const ty = tiw * v.y + tiy * 0.0 + tiz * v.x - tix * v.z;\r\n        const tz = tiw * v.z + tiz * 0.0 + tix * v.y - tiy * v.x;\r\n        const tw = tiw * 0.0 - tix * v.x - tiy * v.y - tiz * v.z;\r\n        const result_x = tw * x + tx * w + ty * z - tz * y;\r\n        const result_y = tw * y + ty * w + tz * x - tx * z;\r\n        const result_z = tw * z + tz * w + tx * y - ty * x;\r\n        v.x = result_x;\r\n        v.y = result_y;\r\n        v.z = result_z;\r\n        return v;\r\n    }\r\n    rotated(v) {\r\n        return this.rotate(v.clone());\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Quaternion.ts?");

/***/ }),

/***/ "../engine/src/math/Random.ts":
/*!************************************!*\
  !*** ../engine/src/math/Random.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Random\": () => (/* binding */ Random),\n/* harmony export */   \"createGUID\": () => (/* binding */ createGUID),\n/* harmony export */   \"createRandomGUID\": () => (/* binding */ createRandomGUID)\n/* harmony export */ });\n//\r\n// note: thank you, stackoverflow!\r\n// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\r\n/**\r\n * Pseudo random number generator. based on simple fast counter (sfc32)\r\n */\r\nclass Random {\r\n    constructor(a, b, c, d) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n    }\r\n    static new(a, b, c, d) {\r\n        return new Random(a, b, c, d);\r\n    }\r\n    static randomSeed() {\r\n        return Math.random() * 393847477636;\r\n    }\r\n    static fromSeed(n) {\r\n        var seed = n ^ 0xdeadbeef; // 32-bit seed with optional XOR value\r\n        // Pad seed with Phi, Pi and E.\r\n        // https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number\r\n        var rand = Random.new(0x9e3779b9, 0x243f6a88, 0xb7e15162, seed);\r\n        for (var i = 0; i < 15; i++)\r\n            rand.get();\r\n        return rand;\r\n    }\r\n    static fromRandom() {\r\n        // stacking random for maximum randomness i guess...\r\n        return this.fromSeed(Math.random() * 103948857);\r\n    }\r\n    static fromHash(seed) {\r\n        var seeder = xmur3(seed);\r\n        return this.new(seeder(), seeder(), seeder(), seeder());\r\n    }\r\n    /**\r\n     * number in between 0 and 1\r\n     */\r\n    get() {\r\n        // sfc32\r\n        this.a >>>= 0;\r\n        this.b >>>= 0;\r\n        this.c >>>= 0;\r\n        this.d >>>= 0;\r\n        let t = (this.a + this.b) | 0;\r\n        this.a = this.b ^ (this.b >>> 9);\r\n        this.b = (this.c + (this.c << 3)) | 0;\r\n        this.c = (this.c << 21) | (this.c >>> 11);\r\n        this.d = (this.d + 1) | 0;\r\n        t = (t + this.d) | 0;\r\n        this.c = (this.c + t) | 0;\r\n        return (t >>> 0) / 4294967296;\r\n    }\r\n    /**\r\n     * get random integer\r\n     */\r\n    int(max) {\r\n        return Math.floor(this.get() * max);\r\n    }\r\n    /**\r\n     * get random item from array\r\n     */\r\n    choose(array) {\r\n        let choice = this.int(array.length);\r\n        return array[choice];\r\n    }\r\n    chooseWeighted(array, weights) {\r\n        let choice = this.weightedIndex(weights);\r\n        return array[choice];\r\n    }\r\n    /**\r\n     * 2n implementation of ChooseWeighted\r\n     */\r\n    weightedIndex(weights) {\r\n        let sumOfWeights = 0;\r\n        for (let i = 0; i < weights.length; i++) {\r\n            sumOfWeights += weights[i];\r\n        }\r\n        let value = this.get() * sumOfWeights;\r\n        for (let i = 0; i < weights.length; i++) {\r\n            value -= weights[i];\r\n            if (value < 0) {\r\n                return i;\r\n            }\r\n        }\r\n        // will never get here, since this.get() includes 0, and excludes 1. \r\n        // it will always be smaller than the sum of weights\r\n        console.error(\"RANDOM: should never happen...\");\r\n        return 0;\r\n    }\r\n}\r\n// not using this right now, but could be fun\r\nfunction mulberry32(a) {\r\n    return function () {\r\n        var t = (a += 0x6d2b79f5);\r\n        t = Math.imul(t ^ (t >>> 15), t | 1);\r\n        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\nfunction xmur3(str) {\r\n    for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)\r\n        (h = Math.imul(h ^ str.charCodeAt(i), 3432918353)), (h = (h << 13) | (h >>> 19));\r\n    return function () {\r\n        h = Math.imul(h ^ (h >>> 16), 2246822507);\r\n        h = Math.imul(h ^ (h >>> 13), 3266489909);\r\n        return (h ^= h >>> 16) >>> 0;\r\n    };\r\n}\r\n/**\r\n * https://www.tutorialspoint.com/how-to-create-guid-uuid-in-javascript\r\n * @returns guid\r\n */\r\nfunction createGUID(rng) {\r\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\r\n        var r = (rng.get() * 16) | 0, v = c == \"x\" ? r : (r & 0x3) | 0x8;\r\n        return v.toString(16);\r\n    });\r\n}\r\n/**\r\n * https://www.tutorialspoint.com/how-to-create-guid-uuid-in-javascript\r\n * @returns guid\r\n */\r\nfunction createRandomGUID() {\r\n    let rng = Random.fromRandom();\r\n    return createGUID(rng);\r\n}\r\nfunction test() {\r\n    let r = Random.fromRandom();\r\n    let counts = [0, 0, 0];\r\n    let arr = [4, 2, 10];\r\n    console.time(\"1000 weighted index\");\r\n    for (let i = 0; i < 1000; i++) {\r\n        counts[r.weightedIndex(arr)] += 1;\r\n    }\r\n    console.timeEnd(\"1000 weighted index\");\r\n    console.log(counts);\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Random.ts?");

/***/ }),

/***/ "../engine/src/math/Ray.ts":
/*!*********************************!*\
  !*** ../engine/src/math/Ray.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ray\": () => (/* binding */ Ray)\n/* harmony export */ });\n/* harmony import */ var _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/mesh/MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n// author:  Jos Feenstra\r\n// purpose: infinite Ray used for projection and similar actions\r\n// notes:   found some nice examples at https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld004.htm\r\n\r\nclass Ray {\r\n    // i do this to force intent : from points, or from normal. Both vector3, so otherwise confusing\r\n    constructor(origin, normal) {\r\n        this.origin = origin;\r\n        this.normal = normal.normalize();\r\n    }\r\n    static fromNormal(origin, normal) {\r\n        return new Ray(origin, normal);\r\n    }\r\n    static fromPoints(origin, through) {\r\n        return new Ray(origin, through.subbed(origin).normalize());\r\n    }\r\n    at(t) {\r\n        return this.origin.added(this.normal.scaled(t));\r\n    }\r\n    /**\r\n     *  ray : pt = rOrigin + t * rNormal\r\n     *  plane : a, b, c, d -> pNormal(a, b, c) , d\r\n     *  plane : P . N + d = 0;\r\n     *  substitute for p:\r\n     *  t = -(rOrigin . N + d) / (V . N)\r\n     *\r\n     * @param plane\r\n     * @returns t\r\n     */\r\n    xPlane(plane) {\r\n        let ray = this; // to be clear\r\n        return -(ray.origin.dot(plane.normal) + plane.d) / ray.normal.dot(plane.normal);\r\n    }\r\n    toLine(length) {\r\n        let toPoint = this.at(length);\r\n        return _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromLines([this.origin, toPoint]);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Ray.ts?");

/***/ }),

/***/ "../engine/src/math/Statistics.ts":
/*!****************************************!*\
  !*** ../engine/src/math/Statistics.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stat\": () => (/* binding */ Stat)\n/* harmony export */ });\n/* harmony import */ var _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/FloatMatrix */ \"../engine/src/data/FloatMatrix.ts\");\n// name:    statistics.ts\r\n// author:  Jos Feenstra\r\n// purpose: functionality and documentation of variance,\r\n//          covariance, eigen vectors, least squares, and other\r\n//          statistical operations.\r\n// source:  been a while since I did this,\r\n//          https://datascienceplus.com/understanding-the-covariance-matrix/\r\n//          https://wiki.pathmind.com/eigenvector\r\n//          used to make sure the basics are correct :).\r\n// notes:   Whats the difference between a Principal Component and an Eigen vector?\r\n//          \"Because eigenvectors trace the principal lines of force, and the axes of greatest variance and covariance illustrate where the data is most susceptible to change.\"\r\n\r\nvar Stat;\r\n(function (Stat) {\r\n    // calculate sum\r\n    function sum(x) {\r\n        let sum = 0;\r\n        for (let i = 0; i < x.length; i++) {\r\n            sum += x[i];\r\n        }\r\n        return sum;\r\n    }\r\n    Stat.sum = sum;\r\n    // calculate average\r\n    function mean(x) {\r\n        return sum(x) / x.length;\r\n    }\r\n    Stat.mean = mean;\r\n    // calculate weighted mean\r\n    function meanWeighted(values, weights) {\r\n        if (values.length != weights.length) {\r\n            throw new Error(\"values & weights need same length\");\r\n        }\r\n        var sum = 0.0;\r\n        var sumweight = 0.0;\r\n        for (let i = 0; i < values.length; i++) {\r\n            sum += values[i] * weights[i];\r\n            sumweight += weights[i];\r\n        }\r\n        return sum / sumweight;\r\n    }\r\n    Stat.meanWeighted = meanWeighted;\r\n    // calculate variance\r\n    function variance(x) {\r\n        //σ^2x = (1/n−1) * n∑i=1 (x[i] – xAvr)^2\r\n        let n = x.length;\r\n        let avr = mean(x);\r\n        let sum = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sum += Math.pow((x[i] - avr), 2);\r\n        }\r\n        return sum / (n - 1);\r\n    }\r\n    Stat.variance = variance;\r\n    // calculate the standard deviation\r\n    function deviation(x) {\r\n        return Math.pow(variance(x), 0.5);\r\n    }\r\n    Stat.deviation = deviation;\r\n    // calculate covariance\r\n    function covariance(x, y) {\r\n        if (x.length != y.length)\r\n            throw \"this is not how covariance works...\";\r\n        let n = x.length;\r\n        let xAvr = mean(x);\r\n        let yAvr = mean(y);\r\n        let sum = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sum += (x[i] - xAvr) * (y[i] - yAvr);\r\n        }\r\n        return sum / (n - 1); // losing one degree of freedom\r\n    }\r\n    Stat.covariance = covariance;\r\n    // calculate variance / covariance matrix\r\n    function cov(matrix) {\r\n        let size = matrix.width;\r\n        let cov = new _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(size, size);\r\n        let columns = Array(size);\r\n        for (let i = 0; i < size; i++) {\r\n            columns[i] = matrix.getColumn(i);\r\n        }\r\n        // matrix is symmertical, so only run through one half\r\n        for (let i = 0; i < size; i++) {\r\n            for (let j = i; j < size; j++) {\r\n                let value = covariance(columns[i], columns[j]);\r\n                cov.set(i, j, value);\r\n                cov.set(j, i, value);\r\n            }\r\n        }\r\n        return cov;\r\n    }\r\n    Stat.cov = cov;\r\n    function eig(A) {\r\n        let results = svd(A);\r\n        return [results[1], results[2]];\r\n    }\r\n    Stat.eig = eig;\r\n    /**\r\n     * Thin Single Value Decomposition.\r\n     * Can be used for Eigen Value Decomposition\r\n     * from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970).\r\n     * Taken from numeric.js. not yet cleaned & optimized.\r\n     * https://en.wikipedia.org/wiki/Singular_value_decomposition\r\n     * @param  {FloatMatrix} A matrix to decompose, such as a covariance matrix\r\n     * @returns [U, ∑, V]\r\n     * U -> during EVD, these are the eigen vectors of A transposed, if im not mistaken\r\n     * ∑ -> during EVD, these are the eigen values\r\n     * V -> during EVD, the columns are eigen vectors. NOT TRANSPOSED !!!!!\r\n     */\r\n    function svd(A) {\r\n        var prec = Math.pow(2, -52); // assumes double prec\r\n        var tolerance = 1e-64 / prec;\r\n        var itmax = 50;\r\n        var c = 0;\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var l = 0;\r\n        var u = A.clone().toNative();\r\n        var m = u.length;\r\n        var n = u[0].length;\r\n        if (m < n)\r\n            throw \"Need more rows than columns\";\r\n        var e = new Array(n);\r\n        var q = new Array(n);\r\n        for (i = 0; i < n; i++)\r\n            e[i] = q[i] = 0.0;\r\n        var v = rep([n, n], 0);\r\n        function pythag(a, b) {\r\n            a = Math.abs(a);\r\n            b = Math.abs(b);\r\n            if (a > b)\r\n                return a * Math.sqrt(1.0 + (b * b) / a / a);\r\n            else if (b == 0.0)\r\n                return a;\r\n            return b * Math.sqrt(1.0 + (a * a) / b / b);\r\n        }\r\n        //rep function, [JF] : dont know what this does exactly...\r\n        function rep(s, v, k = 0) {\r\n            let n = s[k];\r\n            let ret = Array(n);\r\n            let i;\r\n            if (k === s.length - 1) {\r\n                for (i = n - 2; i >= 0; i -= 2) {\r\n                    ret[i + 1] = v;\r\n                    ret[i] = v;\r\n                }\r\n                if (i === -1) {\r\n                    ret[0] = v;\r\n                }\r\n                return ret;\r\n            }\r\n            for (i = n - 1; i >= 0; i--) {\r\n                ret[i] = rep(s, v, k + 1);\r\n            }\r\n            return ret;\r\n        }\r\n        //Householder's reduction to bidiagonal form\r\n        var f = 0.0;\r\n        var g = 0.0;\r\n        var h = 0.0;\r\n        var x = 0.0;\r\n        var y = 0.0;\r\n        var z = 0.0;\r\n        var s = 0.0;\r\n        for (i = 0; i < n; i++) {\r\n            e[i] = g;\r\n            s = 0.0;\r\n            l = i + 1;\r\n            for (j = i; j < m; j++)\r\n                s += u[j][i] * u[j][i];\r\n            if (s <= tolerance)\r\n                g = 0.0;\r\n            else {\r\n                f = u[i][i];\r\n                g = Math.sqrt(s);\r\n                if (f >= 0.0)\r\n                    g = -g;\r\n                h = f * g - s;\r\n                u[i][i] = f - g;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = i; k < m; k++)\r\n                        s += u[k][i] * u[k][j];\r\n                    f = s / h;\r\n                    for (k = i; k < m; k++)\r\n                        u[k][j] += f * u[k][i];\r\n                }\r\n            }\r\n            q[i] = g;\r\n            s = 0.0;\r\n            for (j = l; j < n; j++)\r\n                s = s + u[i][j] * u[i][j];\r\n            if (s <= tolerance)\r\n                g = 0.0;\r\n            else {\r\n                f = u[i][i + 1];\r\n                g = Math.sqrt(s);\r\n                if (f >= 0.0)\r\n                    g = -g;\r\n                h = f * g - s;\r\n                u[i][i + 1] = f - g;\r\n                for (j = l; j < n; j++)\r\n                    e[j] = u[i][j] / h;\r\n                for (j = l; j < m; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < n; k++)\r\n                        s += u[j][k] * u[i][k];\r\n                    for (k = l; k < n; k++)\r\n                        u[j][k] += s * e[k];\r\n                }\r\n            }\r\n            y = Math.abs(q[i]) + Math.abs(e[i]);\r\n            if (y > x)\r\n                x = y;\r\n        }\r\n        // accumulation of right hand gtransformations\r\n        for (i = n - 1; i != -1; i += -1) {\r\n            if (g != 0.0) {\r\n                h = g * u[i][i + 1];\r\n                for (j = l; j < n; j++)\r\n                    v[j][i] = u[i][j] / h;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < n; k++)\r\n                        s += u[i][k] * v[k][j];\r\n                    for (k = l; k < n; k++)\r\n                        v[k][j] += s * v[k][i];\r\n                }\r\n            }\r\n            for (j = l; j < n; j++) {\r\n                v[i][j] = 0;\r\n                v[j][i] = 0;\r\n            }\r\n            v[i][i] = 1;\r\n            g = e[i];\r\n            l = i;\r\n        }\r\n        // accumulation of left hand transformations\r\n        for (i = n - 1; i != -1; i += -1) {\r\n            l = i + 1;\r\n            g = q[i];\r\n            for (j = l; j < n; j++)\r\n                u[i][j] = 0;\r\n            if (g != 0.0) {\r\n                h = u[i][i] * g;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < m; k++)\r\n                        s += u[k][i] * u[k][j];\r\n                    f = s / h;\r\n                    for (k = i; k < m; k++)\r\n                        u[k][j] += f * u[k][i];\r\n                }\r\n                for (j = i; j < m; j++)\r\n                    u[j][i] = u[j][i] / g;\r\n            }\r\n            else\r\n                for (j = i; j < m; j++)\r\n                    u[j][i] = 0;\r\n            u[i][i] += 1;\r\n        }\r\n        // diagonalization of the bidiagonal form\r\n        prec = prec * x;\r\n        for (k = n - 1; k != -1; k += -1) {\r\n            for (var iteration = 0; iteration < itmax; iteration++) {\r\n                // test f splitting\r\n                var test_convergence = false;\r\n                for (l = k; l != -1; l += -1) {\r\n                    if (Math.abs(e[l]) <= prec) {\r\n                        test_convergence = true;\r\n                        break;\r\n                    }\r\n                    if (Math.abs(q[l - 1]) <= prec)\r\n                        break;\r\n                }\r\n                if (!test_convergence) {\r\n                    // cancellation of e[l] if l>0\r\n                    c = 0.0;\r\n                    s = 1.0;\r\n                    var l1 = l - 1;\r\n                    for (i = l; i < k + 1; i++) {\r\n                        f = s * e[i];\r\n                        e[i] = c * e[i];\r\n                        if (Math.abs(f) <= prec)\r\n                            break;\r\n                        g = q[i];\r\n                        h = pythag(f, g);\r\n                        q[i] = h;\r\n                        c = g / h;\r\n                        s = -f / h;\r\n                        for (j = 0; j < m; j++) {\r\n                            y = u[j][l1];\r\n                            z = u[j][i];\r\n                            u[j][l1] = y * c + z * s;\r\n                            u[j][i] = -y * s + z * c;\r\n                        }\r\n                    }\r\n                }\r\n                // test f convergence\r\n                z = q[k];\r\n                if (l == k) {\r\n                    //convergence\r\n                    if (z < 0.0) {\r\n                        //q[k] is made non-negative\r\n                        q[k] = -z;\r\n                        for (j = 0; j < n; j++)\r\n                            v[j][k] = -v[j][k];\r\n                    }\r\n                    break; //break out of iteration loop and move on to next k value\r\n                }\r\n                if (iteration >= itmax - 1)\r\n                    throw \"Error: no convergence.\";\r\n                // shift from bottom 2x2 minor\r\n                x = q[l];\r\n                y = q[k - 1];\r\n                g = e[k - 1];\r\n                h = e[k];\r\n                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\r\n                g = pythag(f, 1.0);\r\n                if (f < 0.0)\r\n                    f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\r\n                else\r\n                    f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\r\n                // next QR transformation\r\n                c = 1.0;\r\n                s = 1.0;\r\n                for (i = l + 1; i < k + 1; i++) {\r\n                    g = e[i];\r\n                    y = q[i];\r\n                    h = s * g;\r\n                    g = c * g;\r\n                    z = pythag(f, h);\r\n                    e[i - 1] = z;\r\n                    c = f / z;\r\n                    s = h / z;\r\n                    f = x * c + g * s;\r\n                    g = -x * s + g * c;\r\n                    h = y * s;\r\n                    y = y * c;\r\n                    for (j = 0; j < n; j++) {\r\n                        x = v[j][i - 1];\r\n                        z = v[j][i];\r\n                        v[j][i - 1] = x * c + z * s;\r\n                        v[j][i] = -x * s + z * c;\r\n                    }\r\n                    z = pythag(f, h);\r\n                    q[i - 1] = z;\r\n                    c = f / z;\r\n                    s = h / z;\r\n                    f = c * g + s * y;\r\n                    x = -s * g + c * y;\r\n                    for (j = 0; j < m; j++) {\r\n                        y = u[j][i - 1];\r\n                        z = u[j][i];\r\n                        u[j][i - 1] = y * c + z * s;\r\n                        u[j][i] = -y * s + z * c;\r\n                    }\r\n                }\r\n                e[l] = 0.0;\r\n                e[k] = f;\r\n                q[k] = x;\r\n            }\r\n        }\r\n        for (i = 0; i < q.length; i++)\r\n            if (q[i] < prec)\r\n                q[i] = 0;\r\n        //sort eigenvalues\r\n        var temp;\r\n        for (i = 0; i < n; i++) {\r\n            for (j = i - 1; j >= 0; j--) {\r\n                if (q[j] < q[i]) {\r\n                    c = q[j];\r\n                    q[j] = q[i];\r\n                    q[i] = c;\r\n                    for (k = 0; k < u.length; k++) {\r\n                        temp = u[k][i];\r\n                        u[k][i] = u[k][j];\r\n                        u[k][j] = temp;\r\n                    }\r\n                    for (k = 0; k < v.length; k++) {\r\n                        temp = v[k][i];\r\n                        v[k][i] = v[k][j];\r\n                        v[k][j] = temp;\r\n                    }\r\n                    i = j;\r\n                }\r\n            }\r\n        }\r\n        // let transposeS = (s: Float32Array, A: FloatMatrix) => {\r\n        //     let size = Math.min(A.width, A.height);\r\n        //     let St = FloatMatrix.zeros(size, size);\r\n        //     for (let i = 0; i < size; i++) {\r\n        //         St.set(i, i, 1 / s[i]);        \r\n        //     }\r\n        //     return St;\r\n        // }\r\n        // let S = transposeS(sum, A);\r\n        let sum = new Float32Array(q);\r\n        return [_data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.fromNative(u), sum, _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.fromNative(v)];\r\n    }\r\n    Stat.svd = svd;\r\n    function diagonalize(sum, size) {\r\n        let St = _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.zeros(size, size);\r\n        for (let i = 0; i < size; i++) {\r\n            St.set(i, i, sum[i]);\r\n        }\r\n        return St;\r\n    }\r\n    Stat.diagonalize = diagonalize;\r\n    function diagonalizeInverse(sum, size) {\r\n        let St = _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.zeros(size, size);\r\n        for (let i = 0; i < size; i++) {\r\n            St.set(i, i, 1 / sum[i]);\r\n        }\r\n        return St;\r\n    }\r\n    Stat.diagonalizeInverse = diagonalizeInverse;\r\n    /**\r\n     * Calculate the pseudo inverse of a matrix:\r\n     * `M = UΣV†` -> `M† = V Σ† U`\r\n     * https://en.wikipedia.org/wiki/Singular_value_decomposition\r\n     * @param A\r\n     */\r\n    function pinv(A) {\r\n        let [U, s, V] = svd(A);\r\n        let St = diagonalizeInverse(s, Math.min(A.width, A.height));\r\n        let mul = _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.mulBtoA;\r\n        let Mt = mul(U.tp(), mul(St, V));\r\n        return Mt;\r\n    }\r\n    Stat.pinv = pinv;\r\n    function pinv2(A) {\r\n        console.log(\"PSEUDO INVERSE 2\");\r\n        A.print();\r\n        let [U, s, Vt] = svd(A);\r\n        let S = diagonalizeInverse(s, Math.min(A.width, A.height));\r\n        console.log(\"[ PRINTING SVD: ]\");\r\n        let mul = _data_FloatMatrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.mulAtoB;\r\n        U.print();\r\n        S.print();\r\n        Vt.print();\r\n        let something = mul(U, mul(S, Vt));\r\n        something.print();\r\n        // console.log(V.width, V.height);\r\n        // Ut.print();\r\n        // let Mt = S.mul(Ut).mul(V);\r\n        return something;\r\n    }\r\n    Stat.pinv2 = pinv2;\r\n})(Stat || (Stat = {}));\r\nfunction test() {\r\n    // console.log(\"[ CHECK SUM INVERSE ]\")\r\n    // let result = Stat.svd(A);\r\n    // let [U, s, V] = result;\r\n    // let S = Stat.diagonalize(s, Math.min(A.width, A.height));\r\n    // U.print();\r\n    // S.print();\r\n    // V.print();\r\n    // A.print();\r\n    // U.mul(S.mul(V.tp())).print();\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Statistics.ts?");

/***/ }),

/***/ "../engine/src/math/Transform.ts":
/*!***************************************!*\
  !*** ../engine/src/math/Transform.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Transform\": () => (/* binding */ Transform)\n/* harmony export */ });\n/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix4 */ \"../engine/src/math/Matrix4.ts\");\n/* harmony import */ var _Quaternion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion */ \"../engine/src/math/Quaternion.ts\");\n/* harmony import */ var _Vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector3 */ \"../engine/src/math/Vector3.ts\");\n\r\n\r\n\r\n// this xform determines an object's position, rotation and scale in the world, or relative to another xform\r\n// can be turned into a Matrix4, and created from a Matrix4\r\nclass Transform {\r\n    // lazely cached matrix version of this transform.\r\n    // this prevents us from recreating matrix classes every update\r\n    // _m: Matrix4 = undefined; \r\n    constructor(pos, rot, scale, _m) {\r\n        this.pos = pos;\r\n        this.rot = rot;\r\n        this.scale = scale;\r\n        this._m = _m;\r\n    }\r\n    static new(pos = _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3.zero(), rot = _Quaternion__WEBPACK_IMPORTED_MODULE_1__.Quaternion.new(), scale = _Vector3__WEBPACK_IMPORTED_MODULE_2__.Vector3.ones(), matrix) {\r\n        return new Transform(pos, rot, scale, matrix);\r\n    }\r\n    static fromMatrix(mat) {\r\n        return Transform.fromDecompose(mat);\r\n    }\r\n    /**\r\n     * decompose a Matrix4 into its position, rotation and scale components\r\n     */\r\n    static fromDecompose(mat) {\r\n        let tf = Transform.new(undefined, undefined, undefined, mat);\r\n        tf.setWithMatrix(mat);\r\n        return tf;\r\n    }\r\n    buffer() {\r\n    }\r\n    setWithMatrix(mat) {\r\n        this._m = mat;\r\n        const m = this._m;\r\n        const md = this._m.data;\r\n        let d = mat.determinant();\r\n        // deal with scale\r\n        this.scale.x = (0,_Vector3__WEBPACK_IMPORTED_MODULE_2__.calcLength)(md[0], md[1], md[2]);\r\n        this.scale.y = (0,_Vector3__WEBPACK_IMPORTED_MODULE_2__.calcLength)(md[4], md[5], md[6]);\r\n        this.scale.z = (0,_Vector3__WEBPACK_IMPORTED_MODULE_2__.calcLength)(md[8], md[9], md[10]);\r\n        if (d < 0) {\r\n            this.scale.x = -this.scale.x;\r\n        }\r\n        // deal with translation\r\n        this.pos.x = md[12];\r\n        this.pos.y = md[13];\r\n        this.pos.z = md[14];\r\n        // deal with rotation\r\n        // --- get rotation matrix pre-scaling\r\n        const invSX = 1.0 / this.scale.x;\r\n        const invSY = 1.0 / this.scale.y;\r\n        const invSZ = 1.0 / this.scale.z;\r\n        const r0 = md[0] *= invSX;\r\n        const r1 = md[1] *= invSX;\r\n        const r2 = md[2] *= invSX;\r\n        const r3 = md[4] *= invSY;\r\n        const r4 = md[5] *= invSY;\r\n        const r5 = md[6] *= invSY;\r\n        const r6 = md[8] *= invSZ;\r\n        const r7 = md[9] *= invSZ;\r\n        const r8 = md[10] *= invSZ;\r\n        this.rot.setFromMatrix(r0, r1, r2, r3, r4, r5, r6, r7, r8);\r\n    }\r\n    toMatrix() {\r\n        return this.compose();\r\n    }\r\n    compose() {\r\n        return _Matrix4__WEBPACK_IMPORTED_MODULE_0__.Matrix4.fromPosRotScale(this.pos, this.rot, this.scale, this._m);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Transform.ts?");

/***/ }),

/***/ "../engine/src/math/Util.ts":
/*!**********************************!*\
  !*** ../engine/src/math/Util.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Util\": () => (/* binding */ Util)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math */ \"../engine/src/math/Math.ts\");\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Vector2 */ \"../engine/src/math/Vector2.ts\");\n\r\n\r\n\r\nclass Util {\r\n    static range(n) {\r\n        let array = [];\r\n        for (let i = 0; i < n; i++) {\r\n            array.push(i);\r\n        }\r\n        return array;\r\n    }\r\n    static collect(gen) {\r\n        let arr = new Array();\r\n        for (let item of gen) {\r\n            arr.push(item);\r\n        }\r\n        return arr;\r\n    }\r\n    /** binary-seach an equation, to get the smallest x.\r\n     * from   : https://stackoverflow.com/questions/2742610/closest-point-on-a-cubic-bezier-curve/57315396#57315396\r\n     * formatted differently\r\n     * ```\r\n     * minX   : the smallest input value\r\n     * maxX   : the largest input value\r\n     * ƒ      : a function that returns a value `y` given an `x`\r\n     * ε      : how close in `x` the bounds must be before returning\r\n     * returns: the `x` value that produces the smallest `y`\r\n     * ```\r\n     */\r\n    static lowestScore(domain, score, tol = 1e-10) {\r\n        let half = Infinity;\r\n        // binary seach-like procedure:\r\n        while (domain.t1 - domain.t0 > tol) {\r\n            half = (domain.t1 + domain.t0) / 2;\r\n            if (score(half - tol) < score(half + tol)) {\r\n                domain.t1 = half;\r\n            }\r\n            else {\r\n                domain.t0 = half;\r\n            }\r\n        }\r\n        return half;\r\n    }\r\n    static lowestScoreSquared(domain, score, tol = 1e-10) {\r\n        let halfX = Infinity;\r\n        let halfY = Infinity;\r\n        // binary seach-like procedure:\r\n        while (domain.x.t1 - domain.x.t0 > tol || domain.y.t1 - domain.y.t0 > tol) {\r\n            halfX = (domain.x.t1 + domain.x.t0) / 2;\r\n            halfY = (domain.y.t1 + domain.y.t0) / 2;\r\n            // select smallest quadrant\r\n            if (score(halfX - tol, halfY) < score(halfX + tol, halfY)) {\r\n                domain.x.t1 = halfX;\r\n            }\r\n            else {\r\n                domain.x.t0 = halfX;\r\n            }\r\n            if (score(halfX, halfY - tol) < score(halfX, halfY + tol)) {\r\n                domain.y.t1 = halfY;\r\n            }\r\n            else {\r\n                domain.y.t0 = halfY;\r\n            }\r\n        }\r\n        return _Vector2__WEBPACK_IMPORTED_MODULE_2__.Vector2.new(halfX, halfY);\r\n    }\r\n    //      triangle business\r\n    // ============================\r\n    /**\r\n     * ```\r\n     *         column\r\n     *      4  3  2  1  0\r\n     *   0 |>\r\n     * r 1 |>     >\r\n     * o 2 |>     >     >\r\n     * w 3 |>     >\r\n     *   4 |>\r\n     *\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = Util.iterateTriangle(col, row);\r\n            }\r\n        }\r\n     * ```\r\n     */\r\n    static iterateTriangle(column, row) {\r\n        return _Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(column) + row;\r\n    }\r\n    static getTriangleBase(triangle, size) {\r\n        let base = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(size);\r\n        let basecolumn = size - 1;\r\n        let i = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = Util.iterateTriangle(basecolumn, row);\r\n            base.set(i, triangle.get(idx));\r\n            i++;\r\n        }\r\n        return base;\r\n    }\r\n    static getTriangleLeft(triangle, size) {\r\n        // prepare\r\n        let left = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(size);\r\n        // the two edges of the triangle opposite to the base are the vertices we are interested in\r\n        let i = 0;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            left.set(i, triangle.get(Util.iterateTriangle(col, 0)));\r\n            i++;\r\n        }\r\n        return left;\r\n    }\r\n    static getTriangleRight(triangle, size) {\r\n        // prepare\r\n        let right = _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(size);\r\n        // the two edges of the triangle opposite to the base are the vertices we are interested in\r\n        let i = 0;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            right.set(i, triangle.get(Util.iterateTriangle(col, col)));\r\n            i++;\r\n        }\r\n        return right;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Util.ts?");

/***/ }),

/***/ "../engine/src/math/Vector2.ts":
/*!*************************************!*\
  !*** ../engine/src/math/Vector2.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector2\": () => (/* binding */ Vector2)\n/* harmony export */ });\n// author: \tJos Feenstra\r\n// inspiration from Three.js\r\n// note: \trecycle the class as much as possble, building a new class is expensive,\r\n// \t\t\tespecially in javascript\r\n// todo: \tBIJ NADER INZIEN: dont go the copy route. rewrite this in a more functional way creating new classes is expensive, but we really need immutable vectors.\r\n// \t\t\tthese types of consistent vectors are only useful in niche cases, and complitate a lot of common cases.\r\nclass Vector2 {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    get data() {\r\n        return [this.x, this.y];\r\n    }\r\n    static new(x = 0, y = 0) {\r\n        return new Vector2(x, y);\r\n    }\r\n    static fromArray(a) {\r\n        return new Vector2(a[0], a[1]);\r\n    }\r\n    static fromLerp(v1, v2, alpha) {\r\n        return new Vector2(v1.x + (v2.x - v1.x) * alpha, v1.y + (v2.y - v1.y) * alpha);\r\n    }\r\n    static fromRandom(rng) {\r\n        return new Vector2(rng.get(), rng.get());\r\n    }\r\n    static fromRandomAngle() {\r\n        let alpha = Math.random() * Math.PI * 2;\r\n        return new Vector2(Math.cos(alpha), Math.sin(alpha));\r\n    }\r\n    // static from2Pt(from: Vector2, to: Vector2) : Vector2 {\r\n    // \treturn new Vector2(\r\n    // \t\tfrom.x - to.x,\r\n    // \t\tfrom.y - to.y\r\n    // \t)\r\n    // }\r\n    static fromCircle(center, radius, theta) {\r\n        return new Vector2(center.x + radius * Math.sin(theta), center.y + radius * Math.cos(theta));\r\n    }\r\n    static fromCopy(other) {\r\n        return this.zero().copy(other);\r\n    }\r\n    static zero() {\r\n        return new Vector2(0, 0);\r\n    }\r\n    static NaN() {\r\n        return new Vector2(NaN, NaN);\r\n    }\r\n    static fromCircumcenter(a, b, c) {\r\n        const asum = a.squareSum();\r\n        const bsum = b.squareSum();\r\n        const csum = c.squareSum();\r\n        // sort of cross product\r\n        let d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));\r\n        // if this triangle has no circumcenter\r\n        if (d < 0.000001)\r\n            return Vector2.NaN();\r\n        let x = (asum * (b.y - c.y) + bsum * (c.y - a.y) + csum * (a.y - b.y)) / d;\r\n        let y = (asum * (c.x - b.x) + bsum * (a.x - c.x) + csum * (b.x - a.x)) / d;\r\n        return new Vector2(x, y);\r\n    }\r\n    static sign(a, b, c) {\r\n        return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n    }\r\n    // --- basics\r\n    set(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    roughlyEquals(v, tol) {\r\n        return Math.abs(this.x - v.x) < tol && Math.abs(this.y - v.y) < tol;\r\n    }\r\n    equals(v) {\r\n        return v.x === this.x && v.y === this.y;\r\n    }\r\n    toString() {\r\n        return `Vector2(${this.x}, ${this.y})`;\r\n    }\r\n    clone() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        return this;\r\n    }\r\n    // --- math\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        return this;\r\n    }\r\n    added(v) {\r\n        return new Vector2(this.x + v.x, this.y + v.y);\r\n    }\r\n    addn(arg0, arg1) {\r\n        this.x += arg0;\r\n        this.y += arg1;\r\n        return this;\r\n    }\r\n    sub(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        return this;\r\n    }\r\n    subbed(v) {\r\n        return new Vector2(this.x - v.x, this.y - v.y);\r\n    }\r\n    mul(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        return this;\r\n    }\r\n    scale(v) {\r\n        this.x *= v;\r\n        this.y *= v;\r\n        return this;\r\n    }\r\n    scaled(v) {\r\n        return new Vector2(this.x * v, this.y * v);\r\n    }\r\n    divVector(v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        return this;\r\n    }\r\n    div(v) {\r\n        this.x /= v;\r\n        this.y /= v;\r\n        return this;\r\n    }\r\n    dived(v) {\r\n        return new Vector2(this.x / v, this.y / v);\r\n    }\r\n    minimum(other) {\r\n        this.x = Math.min(this.x, other.x);\r\n        this.y = Math.min(this.y, other.y);\r\n        return this;\r\n    }\r\n    maximum(other) {\r\n        this.x = Math.max(this.x, other.x);\r\n        this.y = Math.max(this.y, other.y);\r\n        return this;\r\n    }\r\n    clamp(min, max) {\r\n        // assumes min < max, componentwise\r\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\r\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\r\n        return this;\r\n    }\r\n    clampScalar(minVal, maxVal) {\r\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\r\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\r\n        return this;\r\n    }\r\n    clampLength(min, max) {\r\n        const length = this.length();\r\n        return this.div(length || 1).scale(Math.max(min, Math.min(max, length)));\r\n    }\r\n    floor() {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        return this;\r\n    }\r\n    ceil() {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        return this;\r\n    }\r\n    round() {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        return this;\r\n    }\r\n    rounded() {\r\n        return Vector2.new(Math.round(this.x), Math.round(this.y));\r\n    }\r\n    roundToZero() {\r\n        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\r\n        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\r\n        return this;\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y;\r\n    }\r\n    cross(v) {\r\n        return this.x * v.y - this.y * v.x; // ????\r\n    }\r\n    squareSum() {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.lengthSquared());\r\n    }\r\n    lengthSquared() {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n    manhat() {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n    normalize() {\r\n        return this.div(this.length() || 1);\r\n    }\r\n    normalized() {\r\n        return this.dived(this.length() || 1);\r\n    }\r\n    angle() {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n        const angle = Math.atan2(-this.y, -this.x) + Math.PI;\r\n        return angle;\r\n    }\r\n    disTo(v) {\r\n        return Math.sqrt(this.disToSquared(v));\r\n    }\r\n    disToSquared(v) {\r\n        let dx = this.x - v.x;\r\n        let dy = this.y - v.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n    disToManhat(v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n    }\r\n    setLength(length) {\r\n        return this.normalize().scale(length);\r\n    }\r\n    lerp(other, alpha) {\r\n        return new Vector2(this.x + (other.x - this.x) * alpha, this.y + (other.y - this.y) * alpha);\r\n    }\r\n    // calculate the 'triangle sign' of three points. Can be used to determine clockwise & counter clockwise\r\n    sign(b, c) {\r\n        return Vector2.sign(this, b, c);\r\n    }\r\n    // use dot product to project this vector on the other vector\r\n    projectOnVector(other) {\r\n        const denominator = other.lengthSquared();\r\n        if (denominator === 0)\r\n            return this.set(0, 0);\r\n        const scalar = other.dot(this) / denominator;\r\n        return this.copy(other).scale(scalar);\r\n    }\r\n}\r\n// --- factories & other statics\r\nVector2._zero = Vector2.zero();\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Vector2.ts?");

/***/ }),

/***/ "../engine/src/math/Vector3.ts":
/*!*************************************!*\
  !*** ../engine/src/math/Vector3.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector3\": () => (/* binding */ Vector3),\n/* harmony export */   \"calcLength\": () => (/* binding */ calcLength)\n/* harmony export */ });\n/* harmony import */ var _Const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Const */ \"../engine/src/math/Const.ts\");\n/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Math */ \"../engine/src/math/Math.ts\");\n/* harmony import */ var _Matrix4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Matrix4 */ \"../engine/src/math/Matrix4.ts\");\n/* harmony import */ var _Util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Util */ \"../engine/src/math/Util.ts\");\n/* harmony import */ var _Vector2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Vector2 */ \"../engine/src/math/Vector2.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Vector3 {\r\n    // #region constructors\r\n    constructor(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    static new(x = 0, y = 0, z = 0) {\r\n        return new Vector3(x, y, z);\r\n    }\r\n    static ones() {\r\n        return new Vector3(1, 1, 1);\r\n    }\r\n    get data() {\r\n        return [this.x, this.y, this.z];\r\n    }\r\n    static from2d(v) {\r\n        return new Vector3(v.x, v.y, 0);\r\n    }\r\n    static calculateWheelOrder(vectors, ihat, jhat) {\r\n        // console.log(\"wheel order\");\r\n        // console.log(\"hats\", ihat, jhat)\r\n        let angles = [];\r\n        vectors.forEach((v) => {\r\n            angles.push(new _Vector2__WEBPACK_IMPORTED_MODULE_4__.Vector2(v.dot(ihat), v.dot(jhat)).angle());\r\n        });\r\n        // console.log(\"angles\", angles);\r\n        let ids = _Util__WEBPACK_IMPORTED_MODULE_3__.Util.range(vectors.length);\r\n        ids.sort((a, b) => {\r\n            return angles[a] - angles[b];\r\n        });\r\n        return ids;\r\n    }\r\n    static fromLerp(v1, v2, alpha) {\r\n        return new Vector3(v1.x + (v2.x - v1.x) * alpha, v1.y + (v2.y - v1.y) * alpha, v1.z + (v2.z - v1.z) * alpha);\r\n    }\r\n    static fromArray(a) {\r\n        return new Vector3(a[0], a[1], a[2]);\r\n    }\r\n    static fromRandom(rng) {\r\n        return new Vector3(rng.get(), rng.get(), rng.get());\r\n    }\r\n    static fromRandomUnit(rng) {\r\n        // NOTE : this is not perfectly random, but good enough...\r\n        return this.fromRandom(rng).sub(Vector3.new(0.5, 0.5, 0.5)).normalize();\r\n    }\r\n    static fromSphere(radius, theta, phi) {\r\n        const sinPhiRadius = Math.sin(phi) * radius;\r\n        return this.constructor(sinPhiRadius * Math.sin(theta), Math.cos(phi) * radius, sinPhiRadius * Math.cos(theta));\r\n    }\r\n    static fromCylinder(radius, theta, height) {\r\n        return this.constructor(radius * Math.sin(theta), height, radius * Math.cos(theta));\r\n    }\r\n    static fromLerpWeights(p1, p2, tP1, tP2, t) {\r\n        if (Math.abs(t - tP1) < 0.00001)\r\n            return p1;\r\n        if (Math.abs(t - tP2) < 0.00001)\r\n            return p2;\r\n        if (Math.abs(tP1 - tP2) < 0.00001)\r\n            return p1;\r\n        let mu = (t - tP1) / (tP2 - tP1);\r\n        return new Vector3(p1.x + mu * (p2.x - p1.x), p1.y + mu * (p2.y - p1.y), p1.z + mu * (p2.z - p1.z));\r\n    }\r\n    // #endregion\r\n    // #region defaults\r\n    static zero() {\r\n        return new Vector3(0, 0, 0);\r\n    }\r\n    static unitX() {\r\n        return new Vector3(1, 0, 0);\r\n    }\r\n    static unitY() {\r\n        return new Vector3(0, 1, 0);\r\n    }\r\n    static unitZ() {\r\n        return new Vector3(0, 0, 1);\r\n    }\r\n    // #endregion\r\n    // #region basics\r\n    toArray() {\r\n        return new Float32Array([this.x, this.y, this.z]);\r\n    }\r\n    set(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n    equals(v) {\r\n        return v.x === this.x && v.y === this.y && v.z === this.z;\r\n    }\r\n    toString() {\r\n        return `Vector3(${this.x}, ${this.y}, ${this.z})`;\r\n    }\r\n    toVector2() {\r\n        return new _Vector2__WEBPACK_IMPORTED_MODULE_4__.Vector2(this.x, this.y);\r\n    }\r\n    clone() {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    }\r\n    to2D() {\r\n        return new _Vector2__WEBPACK_IMPORTED_MODULE_4__.Vector2(this.x, this.y);\r\n    }\r\n    // #endregion\r\n    // #region math like vector2\r\n    largestValue() {\r\n        return Math.max(this.x, this.y, this.z);\r\n    }\r\n    addN(n) {\r\n        this.x += n;\r\n        this.y += n;\r\n        this.z += n;\r\n        return this;\r\n    }\r\n    addNs(x, y, z) {\r\n        this.x += x;\r\n        this.y += y;\r\n        this.z += z;\r\n        return this;\r\n    }\r\n    added(v) {\r\n        return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        return this;\r\n    }\r\n    subbed(v) {\r\n        return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);\r\n    }\r\n    sub(v) {\r\n        (this.x -= v.x), (this.y -= v.y), (this.z -= v.z);\r\n        return this;\r\n    }\r\n    item(i) {\r\n        switch (i) {\r\n            case 0:\r\n                return this.x;\r\n            case 1:\r\n                return this.y;\r\n            case 2:\r\n                return this.z;\r\n            case 3:\r\n                return 1;\r\n            default:\r\n                throw \"nope\";\r\n        }\r\n    }\r\n    scaled(v) {\r\n        return new Vector3(this.x * v, this.y * v, this.z * v);\r\n    }\r\n    scale(v) {\r\n        this.x *= v;\r\n        this.y *= v;\r\n        this.z *= v;\r\n        return this;\r\n    }\r\n    mul(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z;\r\n        return this;\r\n    }\r\n    multiplied(v) {\r\n        return new Vector3(this.x * v.x, this.y * v.y, this.z * v.z);\r\n    }\r\n    divVector(v) {\r\n        return new Vector3(this.x / v.x, this.y / v.y, this.z / v.z);\r\n    }\r\n    divided(value) {\r\n        return new Vector3(this.x / value, this.y / value, this.z / value);\r\n    }\r\n    div(value) {\r\n        (this.x /= value), (this.y /= value), (this.z /= value);\r\n        return this;\r\n    }\r\n    minimumed(other) {\r\n        return new Vector3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));\r\n    }\r\n    maximumed(other) {\r\n        return new Vector3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));\r\n    }\r\n    clamped(min, max) {\r\n        return new Vector3(Math.max(min.x, Math.min(max.x, this.x)), Math.max(min.y, Math.min(max.y, this.y)), Math.max(min.z, Math.min(max.z, this.z)));\r\n    }\r\n    clampScalared(min, max) {\r\n        return new Vector3(_Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.x, min, max), _Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.y, min, max), _Math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.z, min, max));\r\n    }\r\n    clampLengthed(min, max) {\r\n        const length = this.length();\r\n        return this.div(length || 1).scale(Math.max(min, Math.min(max, length)));\r\n    }\r\n    floored() {\r\n        return new Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\r\n    }\r\n    ceiled() {\r\n        return new Vector3(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));\r\n    }\r\n    rounded() {\r\n        return new Vector3(Math.round(this.x), Math.round(this.y), Math.round(this.z));\r\n    }\r\n    roundedToZero() {\r\n        return new Vector3(this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z));\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        return this;\r\n    }\r\n    negated() {\r\n        return new Vector3(-this.x, -this.y, -this.z);\r\n    }\r\n    angle(other, normal) {\r\n        let thisProjected = this.subbed(normal.scaled(this.dot(normal)));\r\n        let otherProjected = other.subbed(normal.scaled(other.dot(normal)));\r\n        console.log(thisProjected);\r\n        console.log(otherProjected);\r\n        return 0;\r\n    }\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    }\r\n    cross(other) {\r\n        const ax = this.x, ay = this.y, az = this.z;\r\n        const bx = other.x, by = other.y, bz = other.z;\r\n        return new Vector3(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);\r\n    }\r\n    getLengthSquared() {\r\n        return this.x * this.x + this.y * this.y + this.z * this.z;\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.getLengthSquared());\r\n    }\r\n    manhat() {\r\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n    }\r\n    normalize() {\r\n        return this.div(this.length() || 1);\r\n    }\r\n    normalized() {\r\n        return this.divided(this.length() || 1);\r\n    }\r\n    isNormal() {\r\n        return Math.abs(this.length() - 1) < _Const__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE;\r\n    }\r\n    disTo(v) {\r\n        return Math.sqrt(this.disToSquared(v));\r\n    }\r\n    disToSquared(v) {\r\n        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n        return dx * dx + dy * dy + dz * dz;\r\n    }\r\n    disToManhat(v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n    }\r\n    setLength(length) {\r\n        return this.normalize().scale(length);\r\n    }\r\n    lerp(other, alpha) {\r\n        this.x += (other.x - this.x) * alpha;\r\n        this.y += (other.y - this.y) * alpha;\r\n        this.z += (other.z - this.z) * alpha;\r\n        return this;\r\n    }\r\n    // #endregion\r\n    // #region math specific\r\n    projectOnVector(other) {\r\n        // use dot product to project this vector on the other vector\r\n        const denominator = other.getLengthSquared();\r\n        if (denominator === 0)\r\n            return this.set(0, 0, 0);\r\n        const scalar = other.dot(this) / denominator;\r\n        return this.copy(other).scale(scalar);\r\n    }\r\n    projectedOnPlane(normal) {\r\n        // project a vector\r\n        _vector.copy(this).projectOnVector(normal);\r\n        return this.minimumed(_vector);\r\n    }\r\n    mirrored(normal) {\r\n        // mirror incident vector off plane orthogonal to normal\r\n        // normal is assumed to have unit length\r\n        return this.minimumed(_vector.copy(normal).scale(2 * this.dot(normal)));\r\n    }\r\n    rotated(axis, angle) {\r\n        let mat = _Matrix4__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newAxisRotation(axis, angle);\r\n        return mat.multiplyVector(this);\r\n    }\r\n}\r\nconst _vector = new Vector3(0, 0, 0);\r\nfunction calcLength(x, y, z) {\r\n    return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/math/Vector3.ts?");

/***/ }),

/***/ "../engine/src/parametric/EnumParameter.ts":
/*!*************************************************!*\
  !*** ../engine/src/parametric/EnumParameter.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EnumParameter\": () => (/* binding */ EnumParameter)\n/* harmony export */ });\n/* harmony import */ var _Parameter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Parameter */ \"../engine/src/parametric/Parameter.ts\");\n\r\n// a parameter representing distinct states\r\nclass EnumParameter {\r\n    constructor(p, values) {\r\n        this.p = p;\r\n        this.values = values;\r\n    }\r\n    static new(name, state, descriptions) {\r\n        return new EnumParameter(new _Parameter__WEBPACK_IMPORTED_MODULE_0__.Parameter(name, state, 0, descriptions.length - 1, 1), descriptions);\r\n    }\r\n    getName() {\r\n        return this.values[this.get()];\r\n    }\r\n    // passthroughs\r\n    get() {\r\n        return this.p.get();\r\n    }\r\n    get state() {\r\n        return this.p.state;\r\n    }\r\n    get name() {\r\n        return this.p.name;\r\n    }\r\n    set(state) {\r\n        return this.p.set(state);\r\n    }\r\n    getNPermutations() {\r\n        return this.p.getNPermutations();\r\n    }\r\n    setSlider(slider) {\r\n        this.slider = slider;\r\n    }\r\n    setSliderAndText(slider, text) {\r\n        this.slider = slider;\r\n        this.text = text;\r\n    }\r\n    onset() {\r\n        if (this.slider)\r\n            this.slider.valueAsNumber = this.get();\r\n        if (this.text)\r\n            this.text.innerText = this.getName();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/parametric/EnumParameter.ts?");

/***/ }),

/***/ "../engine/src/parametric/Parameter.ts":
/*!*********************************************!*\
  !*** ../engine/src/parametric/Parameter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Parameter\": () => (/* binding */ Parameter)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\n// a slider parameter\r\nclass Parameter {\r\n    constructor(name, state, min = -Infinity, max = Infinity, step = 0.1) {\r\n        this.name = name;\r\n        this.min = min;\r\n        this.max = max;\r\n        this.step = step;\r\n        this.state = state;\r\n        this.set(this.state);\r\n    }\r\n    static new(name, state, min = -Infinity, max = Infinity, step = 0.1) {\r\n        return new Parameter(name, state, min, max, step);\r\n    }\r\n    static newBoolean(name, state) {\r\n        return new Parameter(name, state ? 1 : 0, 0, 1, 1);\r\n    }\r\n    get() {\r\n        return this.state;\r\n    }\r\n    getDomain() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Domain.new(this.min, this.max);\r\n    }\r\n    set(state, activateOnSet = true) {\r\n        // something is still wrong here...\r\n        let clamped = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.clamp(state, this.min, this.max);\r\n        let rest = state - this.min;\r\n        let times = Math.round(rest / this.step);\r\n        let stepped = this.min + this.step * times;\r\n        this.state = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.clamp(stepped, this.min, this.max);\r\n        if (activateOnSet)\r\n            this.onset();\r\n    }\r\n    getNPermutations() {\r\n        return Math.min((this.max - this.min) / this.step + 1);\r\n    }\r\n    setSlider(slider) {\r\n        this.slider = slider;\r\n    }\r\n    setSliderAndText(slider, text) {\r\n        this.slider = slider;\r\n        this.text = text;\r\n    }\r\n    onset() {\r\n        if (this.slider)\r\n            this.slider.valueAsNumber = this.state;\r\n        if (this.text)\r\n            this.text.innerText = this.state.toString();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/parametric/Parameter.ts?");

/***/ }),

/***/ "../engine/src/parametric/ParametricModel.ts":
/*!***************************************************!*\
  !*** ../engine/src/parametric/ParametricModel.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ParametricModel\": () => (/* binding */ ParametricModel)\n/* harmony export */ });\n// class ParametricFrame extends ParametricModel {\r\n// \tconstructor(parameters, )\r\n// \tcalculate() {\r\n// \t}\r\n// }\r\nclass ParametricModel {\r\n    constructor(cons, dr) {\r\n        this.cons = cons;\r\n        this.dr = dr;\r\n    }\r\n    static new(constants, debugRenderer) {\r\n    }\r\n    calculate(variables) {\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/parametric/ParametricModel.ts?");

/***/ }),

/***/ "../engine/src/render/OldMultiShader.ts":
/*!**********************************************!*\
  !*** ../engine/src/render/OldMultiShader.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiShader\": () => (/* binding */ MultiShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\nclass MultiShader {\r\n    setAndRender(r, context) {\r\n        this.set(r, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/OldMultiShader.ts?");

/***/ }),

/***/ "../engine/src/render/OldShader.ts":
/*!*****************************************!*\
  !*** ../engine/src/render/OldShader.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OldShader\": () => (/* binding */ OldShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_Attributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl/Attributes */ \"../engine/src/render/webgl/Attributes.ts\");\n/* harmony import */ var _webgl_Uniforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/Uniforms */ \"../engine/src/render/webgl/Uniforms.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n// shader.ts\r\n// author: Jos Feenstra\r\n// credits to : https://webglfundamentals.org/\r\n// note: im still figuring out how to organize this\r\n// TODO: incorrect terminology: this is not a Shader, this is a ShaderSet, ShaderDuo, or something like that\r\n// still tho, within a larger context, the whole of a fragment & vertex shader can be named Shader for the time being...\r\n// This is old, not needed anymore\r\n\r\n\r\n\r\n\r\n/**\r\n * An implementation of 'Shader' needs to define 3 methods:\r\n *\r\n * 1. `constructor`\r\n *    - state the vertex & fragment shader\r\n *    - init all uniforms, state which ones should be exposed publicly (TODO could be automated...)\r\n *    - init all attributes (TODO could be automated...)\r\n * 2. `Set`\r\n *    - explain how 'T' set the attributes\r\n *    - give a number to 'this.drawCount'\r\n * 3. `Render`\r\n *    - explain how 'Context' needs to be loaded into this shader\r\n *    - call 'loadAll()' on both attributes & uniforms\r\n *    - render using either 'DrawArrays()' or 'DrawElements()' (TODO could get some more automation)\r\n */\r\n// @param T = data to feed the renderer at 'set'\r\nclass OldShader {\r\n    constructor(gl, vertexScript, fragmentScript) {\r\n        this.active = true;\r\n        // auto set\r\n        this.draw = () => { };\r\n        this.method = _webgl_Constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Arrays;\r\n        this.mode = _webgl_Constants__WEBPACK_IMPORTED_MODULE_3__.DrawMode.Triangles;\r\n        this.drawCount = 0; // number of times the shaders need to render\r\n        this.drawOffset = 0;\r\n        this.gl = gl;\r\n        this.program = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_2__.HelpGl.createProgramFromScripts(gl, vertexScript, fragmentScript);\r\n        this.uniforms = new _webgl_Uniforms__WEBPACK_IMPORTED_MODULE_1__.Uniforms(this.gl, this.program);\r\n        this.attributes = new _webgl_Attributes__WEBPACK_IMPORTED_MODULE_0__.Attributes(this.gl, this.program);\r\n        this.drawCount = 0;\r\n        gl.useProgram(this.program);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n    setDrawCount(drawCount) {\r\n        this.drawCount = drawCount;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/OldShader.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Bufferer.ts":
/*!***********************************************!*\
  !*** ../engine/src/render/basics/Bufferer.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiBufferer\": () => (/* binding */ MultiBufferer),\n/* harmony export */   \"Bufferer\": () => (/* binding */ Bufferer)\n/* harmony export */ });\n// name:    combo.ts\r\n// author:  Jos Feenstra\r\n// purpose:\r\n// - combination of state, bufferedState, and renderer:\r\n//\r\n// 1.      state\r\n//           ||\r\n//        (buffer)\r\n//           \\/\r\n// 2.     buffered\r\n//           ||\r\n//        (render)\r\n//           \\/\r\n// 3. rendered to screen\r\n//\r\n// TODO: maybe find a better name, but 'combo' is quite distinct in a way\r\n// todo: force buffering a bit more. make a way that requiers this.buffered to be filled\r\n// staticcombo\r\n// dynacombo\r\n// multistaic combo\r\n// Vector3 & dotrenderer\r\nclass MultiBufferer {\r\n    constructor(gl, state, renderConstructor) {\r\n        this.buffered = [];\r\n        this.state = [];\r\n        this.buffered;\r\n        this.renderer = renderConstructor(gl);\r\n    }\r\n    buffer() { }\r\n    render(context) {\r\n        for (let i = 0; i < this.buffered.length; i++) {\r\n            const b = this.buffered[i];\r\n            this.renderer.setAndRender(b, context);\r\n        }\r\n    }\r\n}\r\nclass Bufferer {\r\n    constructor(gl, state, renderConstructor) {\r\n        this.state = state;\r\n        this.buffered;\r\n        this.renderer = renderConstructor(gl);\r\n    }\r\n    buffer() { }\r\n    render(context) {\r\n        this.renderer.render(context);\r\n    }\r\n}\r\n// Combi\r\n// // small tie-together of data & renderer.\r\n// // used to interact with the rendering behaviour of a renderableMesh.\r\n// // TODO: typecheck if data & renderer are compatible\r\n// import { Renderer, DrawSpeed } from \"./renderer\";\r\n// import { Scene } from \"./scene\";\r\n// // TODO add this information to the new Renderable\r\n// export class StaticRenderUnit<R extends Renderer, D> {\r\n//     renderer: R;\r\n//     data: D;\r\n//     constructor(renderer: R, data: D) {\r\n//         this.renderer = renderer;\r\n//         this.data = data;\r\n//     }\r\n//     static new<A extends Renderer, B>(renderer: A, data: B): StaticRenderUnit<A, B> {\r\n//         return new StaticRenderUnit(renderer, data);\r\n//     }\r\n//     buffer() {\r\n//         this.renderer.buffer(this.data);\r\n//     }\r\n//     render(context: Scene) {\r\n//         this.renderer.render(context);\r\n//     }\r\n// }\r\n// export class DynamicRenderUnit<R extends Renderer, D> {\r\n//     renderer: R;\r\n//     data: D;\r\n//     constructor(renderer: R, data: D) {\r\n//         this.renderer = renderer;\r\n//         this.data = data;\r\n//     }\r\n//     static new<A extends Renderer, B>(renderer: A, data: B): DynamicRenderUnit<A, B> {\r\n//         return new DynamicRenderUnit(renderer, data);\r\n//     }\r\n//     render(context: Scene) {\r\n//         this.renderer.buffer();\r\n//         this.renderer.render(context);\r\n//     }\r\n// }\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Bufferer.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Camera.ts":
/*!*********************************************!*\
  !*** ../engine/src/render/basics/Camera.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n// author : Jos Feenstra\r\n// purpose : contain all logic regarding\r\n\r\nvar MoveMode;\r\n(function (MoveMode) {\r\n    MoveMode[MoveMode[\"None\"] = 0] = \"None\";\r\n    MoveMode[MoveMode[\"Rotate\"] = 1] = \"Rotate\";\r\n    MoveMode[MoveMode[\"Pan\"] = 2] = \"Pan\";\r\n    MoveMode[MoveMode[\"Zoom\"] = 3] = \"Zoom\";\r\n})(MoveMode || (MoveMode = {}));\r\nclass Camera {\r\n    // scrollPrev = 0;\r\n    constructor(canvas, z_offset = 1, canMove = false, canControl = true) {\r\n        this.angleAlpha = 0; // rotation x\r\n        this.angleBeta = 0; // rotation y\r\n        this.mousePos = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        // camera matrix properties\r\n        this.fov = (20 * Math.PI) / 100;\r\n        this.zFar = 10000;\r\n        this.zNear = 0.01;\r\n        // other consts\r\n        this.speed = 10;\r\n        this.rotateSmoothener = 0.9; // 0: no smooth | 0.99: suuuuper smooth\r\n        this.scrollSmoothener = 0.9; // 0: no smooth | 0.99: suuuuper smooth\r\n        this.worldPlane = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY();\r\n        this.positionM = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new();\r\n        this.rotateXRev = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new();\r\n        this.rotateZRev = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new();\r\n        this.rotateX = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new();\r\n        this.rotateZ = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new();\r\n        this.rotate = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.new();\r\n        this.calculateInverseMatrices = true;\r\n        // stuff for smooth camera\r\n        this.rotateDropoffDelta = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.zoomDelta = 0;\r\n        this.getRelativeUnitZ = () => {\r\n            let m = this.rotateXRev;\r\n            let m2 = this.rotateZRev;\r\n            return m2.multiplyVector(m.multiplyVector(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ()));\r\n        };\r\n        this.getRelativeTrueUnitY = () => {\r\n            let m = this.rotateXRev;\r\n            let m2 = this.rotateZRev;\r\n            return m2.multiplyVector(m.multiplyVector(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY()));\r\n        };\r\n        this.getRelativeUnitY = () => {\r\n            // let m = Matrix4.newXRotation(-this.angleAlpha);\r\n            // let m = Matrix4.newZRotation(-this.angleBeta);\r\n            return this.rotateZRev.multiplyVector(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY());\r\n        };\r\n        this.getRelativeUnitX = () => {\r\n            // let m = Matrix4.newZRotation(-this.angleBeta);\r\n            return this.rotateZRev.multiplyVector(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX());\r\n        };\r\n        this.canMove = canMove;\r\n        this.canControl = canControl;\r\n        this.pos = new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\r\n        this.offset = new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -z_offset);\r\n        this.updateMatrices(canvas.width, canvas.height);\r\n    }\r\n    get zoom() {\r\n        return this.offset.z;\r\n    }\r\n    set zoom(value) {\r\n        this.offset.z = value;\r\n    }\r\n    static new(canvas, zOffset = 1, canMove = false) {\r\n        return new Camera(canvas, zOffset, canMove);\r\n    }\r\n    /**\r\n     * New way of updating. Has touch support\r\n     */\r\n    update(state, forceUpdate = true) {\r\n        var _a;\r\n        let hasChanged = this.updateControlsNew(state);\r\n        if (hasChanged || forceUpdate) {\r\n            this.updateMatrices(state.width, state.height); // TODO only move if we have changed\r\n        }\r\n        (_a = state.keys) === null || _a === void 0 ? void 0 : _a.onPressed(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.P, this.printState.bind(this));\r\n        // this.updateOtherControls(state);\r\n        return hasChanged;\r\n    }\r\n    updateOld(state, forceUpdate = true) {\r\n        let hasChanged = this.updateControlsOld(state);\r\n        if (hasChanged || forceUpdate) {\r\n            this.updateMatrices(state.canvas.width, state.canvas.height); // TODO only move if we have changed\r\n        }\r\n        if (state.IsKeyPressed('p'))\r\n            this.printState();\r\n        return hasChanged;\r\n    }\r\n    printState() {\r\n        // make camera debuggable, and create a way to get camera positions\r\n        _lib__WEBPACK_IMPORTED_MODULE_0__.Debug.log(`camera state: [${this.pos.x.toPrecision(5)}, ${this.pos.y.toPrecision(5)}, ${this.pos.z.toPrecision(5)}, ${this.zoom}, ${this.angleAlpha},${this.angleBeta}]`);\r\n        // console.log(\r\n        //     `printing camera status.\r\n        //     pos: ${this.pos},\r\n        //     offset: ${this.offset},\r\n        //     speed: ${this.speed},\r\n        //     alpha ${this.angleAlpha},\r\n        //     beta: ${this.angleBeta}`,\r\n        // );\r\n        _lib__WEBPACK_IMPORTED_MODULE_0__.Debug.log(\"speed is now: \" + this.speed);\r\n    }\r\n    // just a quick way of getting & setting\r\n    getActualPosition() {\r\n        // TODO MUST BE WAY QUICKER!!!\r\n        return this.inverseWorldMatrix.multiplyVector(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero());\r\n    }\r\n    getState() {\r\n        return [this.pos.x, this.pos.y, this.pos.z, this.zoom, this.angleAlpha, this.angleBeta];\r\n    }\r\n    setState(state) {\r\n        this.pos.x = state[0];\r\n        this.pos.y = state[1];\r\n        this.pos.z = state[2];\r\n        this.zoom = state[3];\r\n        this.angleAlpha = state[4];\r\n        this.angleBeta = state[5];\r\n    }\r\n    set(offset, alpha, beta) {\r\n        this.zoom = offset;\r\n        this.angleAlpha = alpha;\r\n        this.angleBeta = beta;\r\n    }\r\n    updateMatrices(width, height) {\r\n        // 1 : calculate world matrix\r\n        let offset = this.offset;\r\n        // translate so z means 'up'\r\n        // let yzFlip = new Matrix4([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\r\n        // translated to fit screen\r\n        let mOffset = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslation(offset.x, offset.y, offset.z);\r\n        let camMatrix;\r\n        if (!this.xform) {\r\n            let position = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslation(this.pos.x, this.pos.y, this.pos.z);\r\n            // rotated by user\r\n            this.rotateX = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newXRotation(this.angleAlpha, this.rotateX);\r\n            this.rotateXRev = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newXRotation(-this.angleAlpha, this.rotateXRev);\r\n            this.rotateZ = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newZRotation(this.angleBeta, this.rotateZ);\r\n            this.rotateZRev = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newZRotation(-this.angleBeta, this.rotateZRev);\r\n            this.rotate.copy(this.rotateZ).multiply(this.rotateX);\r\n            camMatrix = position.multiply(this.rotate);\r\n        }\r\n        else {\r\n            camMatrix = this.xform.toMatrix().inverse();\r\n        }\r\n        // let transform = mOffset.multiply(rotation).multiply(position);\r\n        let worldMatrix = camMatrix.multiply(mOffset);\r\n        // 2 : project & total\r\n        let projectMatrix = this.getProjectionMatrix(width, height); // THIS IS MORE OR LESS STATIC, CACHE IT!\r\n        let totalMatrix = worldMatrix.multiplied(projectMatrix);\r\n        // translation = 0\r\n        var viewDirectionMatrix = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newCopy(worldMatrix);\r\n        viewDirectionMatrix.data[12] = 0;\r\n        viewDirectionMatrix.data[13] = 0;\r\n        viewDirectionMatrix.data[14] = 0;\r\n        let totalViewMatrix = this.rotate.multiplied(projectMatrix);\r\n        this.worldMatrix = worldMatrix;\r\n        this.projectMatrix = projectMatrix;\r\n        this.totalMatrix = totalMatrix;\r\n        // early out: matrix inverses every frame? dont do it if it is not needed!\r\n        if (this.calculateInverseMatrices) {\r\n            this.inverseWorldMatrix = this.worldMatrix.inverse();\r\n            this.inverseTransposeMatrix = this.inverseWorldMatrix.transpose();\r\n            this.inverseTotalViewMatrix = totalViewMatrix.inverse();\r\n        }\r\n    }\r\n    lookat(position, target) {\r\n        // set matrices to the thing\r\n        let matrix = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newLookAt(position, target, this.worldPlane.khat);\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    updateControlsOld(state) {\r\n        // dont update controls if we are not allowed to\r\n        if (!this.canControl) {\r\n            return false;\r\n        }\r\n        // determine control values using 'state';\r\n        let mode = this.getMoveModeFromKeyboard(state);\r\n        let prevPos = this.mousePos.clone();\r\n        let pos = state.mousePos.clone();\r\n        this.mousePos = pos;\r\n        let delta = prevPos.clone().sub(this.mousePos);\r\n        let scrollDelta = state.mouseScrollDelta;\r\n        // update things\r\n        let hasChanged1 = this.updatePointerControls(mode, delta, scrollDelta);\r\n        let hasChanged2 = this.updateKeyboardControlsOld(state);\r\n        this.updatePointerStyle();\r\n        return hasChanged1 || hasChanged2;\r\n    }\r\n    updateControlsNew(input) {\r\n        if (!this.canControl) {\r\n            return false;\r\n        }\r\n        let mode = MoveMode.None;\r\n        let delta = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        let scrollDelta = 0;\r\n        let hasChanged1 = false;\r\n        let hasChanged2 = false;\r\n        if (input.touch) {\r\n            mode = this.getMoveModeFromTouch(input.touch);\r\n            if (input.touch.down > 0) {\r\n                delta = input.touch.fingers[0].delta;\r\n                this.mousePos.copy(input.touch.fingers[0].pos);\r\n            }\r\n            else {\r\n                delta = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n            }\r\n            if (mode == MoveMode.Zoom) {\r\n                delta.x = 0;\r\n                delta.y = 0; // input.touch.zoomDelta\r\n                scrollDelta = input.touch.zoomDelta * 0.05;\r\n            }\r\n        }\r\n        if (input.mouse) {\r\n            mode = this.getMoveModeFromKeyboardNew(input.keys, input.mouse);\r\n            let prevPos = this.mousePos.clone();\r\n            let pos = input.mouse.pos.clone();\r\n            this.mousePos = pos;\r\n            delta = prevPos.clone().sub(this.mousePos);\r\n            this.scrollSmoothener = 0.90;\r\n            scrollDelta = input.mouse.scrollDelta * 3;\r\n        }\r\n        if (input.keys) {\r\n            hasChanged2 = this.updateKeyboardControls(input.keys);\r\n        }\r\n        hasChanged1 = this.updatePointerControls(mode, delta, scrollDelta);\r\n        this.updatePointerStyle();\r\n        return hasChanged1 || hasChanged2;\r\n    }\r\n    getMoveModeFromTouch(touch) {\r\n        if (touch.down > 3) {\r\n            return MoveMode.Pan;\r\n        }\r\n        else if (touch.down == 2) {\r\n            return MoveMode.Zoom;\r\n        }\r\n        else if (touch.down == 1) {\r\n            return MoveMode.Rotate;\r\n        }\r\n        else {\r\n            return MoveMode.None;\r\n        }\r\n    }\r\n    getMoveModeFromKeyboard(state) {\r\n        let isMouseRightDown = state.mouseRightDown;\r\n        let isControlDown = state.IsKeyDown('control');\r\n        let isShiftDown = state.IsKeyDown('shift');\r\n        if (isMouseRightDown && !isControlDown && !isShiftDown) {\r\n            return MoveMode.Rotate;\r\n        }\r\n        else if (isMouseRightDown && isControlDown && !isShiftDown) {\r\n            return MoveMode.Zoom;\r\n        }\r\n        else if (state.mouseRightDown && !isControlDown && isShiftDown) {\r\n            return MoveMode.Pan;\r\n        }\r\n        else {\r\n            return MoveMode.None;\r\n        }\r\n    }\r\n    getMoveModeFromKeyboardNew(keys, mouse) {\r\n        let isMouseRightDown = mouse.rightDown;\r\n        let isControlDown = keys.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.Ctrl);\r\n        let isShiftDown = keys.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.Shift);\r\n        if (isMouseRightDown && !isControlDown && !isShiftDown) {\r\n            return MoveMode.Rotate;\r\n        }\r\n        else if (isMouseRightDown && isControlDown && !isShiftDown) {\r\n            return MoveMode.Zoom;\r\n        }\r\n        else if (isMouseRightDown && !isControlDown && isShiftDown) {\r\n            return MoveMode.Pan;\r\n        }\r\n        else {\r\n            return MoveMode.None;\r\n        }\r\n    }\r\n    updatePointerControls(mode, delta, scrollDelta) {\r\n        let hasChanged = false;\r\n        if (!this.canControl) {\r\n            return hasChanged;\r\n        }\r\n        // rotate the camera : apply\r\n        if (mode == MoveMode.Rotate) {\r\n            hasChanged = delta.y != 0 || delta.x != 0;\r\n            this.rotateDropoffDelta.copy(delta);\r\n        }\r\n        // rotate the camera : we use a dropoff to make it smooth\r\n        if (!this.rotateDropoffDelta.roughlyEquals(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2._zero, 0.1)) {\r\n            hasChanged = true;\r\n            let rd = 0.003; // rotate dampner\r\n            this.angleAlpha = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.clamp(this.angleAlpha + this.rotateDropoffDelta.y * rd, 0, Math.PI);\r\n            this.angleBeta += this.rotateDropoffDelta.x * -rd;\r\n            this.rotateDropoffDelta.scale(this.rotateSmoothener);\r\n        }\r\n        // zoom the camera : apply scroll\r\n        if (scrollDelta != 0) {\r\n            let sd = 0.03; // scroll dampner\r\n            this.zoomDelta += scrollDelta * sd;\r\n        }\r\n        // zoom the camera : apply mouse move\r\n        if (mode == MoveMode.Zoom) {\r\n            this.zoomDelta -= delta.y * 0.0005;\r\n        }\r\n        // zoom the camera : apply dropoff effect\r\n        if (!_lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.isRougly(this.zoomDelta, 0, 0.001)) {\r\n            hasChanged = true;\r\n            this.zoom = Math.min(-0.001, this.zoom * (1 + this.zoomDelta));\r\n            this.zoomDelta *= this.scrollSmoothener;\r\n        }\r\n        // pan the camera : no dropoff\r\n        if (mode == MoveMode.Pan) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitX().scale(0.0005 * this.zoom * delta.x));\r\n            this.pos.add(this.getRelativeTrueUnitY().scale(0.0005 * this.zoom * -delta.y));\r\n        }\r\n        return hasChanged;\r\n    }\r\n    updatePointerStyle() {\r\n        // if (isShiftDown && !isControlDown) {\r\n        //     state.setCursorStyle('move');\r\n        // } else if (!isShiftDown && isControlDown) {\r\n        //     if (delta.y > 0) {\r\n        //         state.setCursorStyle('zoom-out');\r\n        //     } else {\r\n        //         state.setCursorStyle('zoom-in');\r\n        //     }\r\n        // } else if (state.mouseRightDown) {\r\n        //     state.setCursorStyle('crosshair');\r\n        // } else {\r\n        //     state.setCursorStyle('default');\r\n        // }\r\n    }\r\n    updateKeyboardControlsOld(state) {\r\n        let hasChanged = false;\r\n        if (state.IsKeyPressed(\"r\")) {\r\n            this.speed *= 2;\r\n        }\r\n        if (state.IsKeyPressed(\"f\")) {\r\n            this.speed = Math.max(this.speed * 0.5, 0.1);\r\n        }\r\n        if (!this.canMove) {\r\n            return hasChanged;\r\n        }\r\n        if (state.IsKeyDown(\"s\")) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitY().scale(0.01 * this.speed));\r\n        }\r\n        if (state.IsKeyDown(\"w\")) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitY().scale(-0.01 * this.speed));\r\n        }\r\n        if (state.IsKeyDown(\"a\")) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitX().scale(0.01 * this.speed));\r\n        }\r\n        if (state.IsKeyDown(\"d\")) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitX().scale(-0.01 * this.speed));\r\n        }\r\n        if (state.IsKeyDown(\"q\")) {\r\n            hasChanged = true;\r\n            this.pos.z += 0.01 * this.speed;\r\n        }\r\n        if (state.IsKeyDown(\"e\")) {\r\n            hasChanged = true;\r\n            this.pos.z -= 0.01 * this.speed;\r\n        }\r\n        return hasChanged;\r\n    }\r\n    updateKeyboardControls(state) {\r\n        let hasChanged = false;\r\n        if (state.isPressed(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.R)) {\r\n            this.speed *= 2;\r\n        }\r\n        if (state.isPressed(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.F)) {\r\n            this.speed = Math.max(this.speed * 0.5, 0.1);\r\n        }\r\n        if (!this.canMove) {\r\n            return hasChanged;\r\n        }\r\n        if (state.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.S)) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitY().scale(0.01 * this.speed));\r\n        }\r\n        if (state.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.W)) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitY().scale(-0.01 * this.speed));\r\n        }\r\n        if (state.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.A)) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitX().scale(0.01 * this.speed));\r\n        }\r\n        if (state.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.D)) {\r\n            hasChanged = true;\r\n            this.pos.add(this.getRelativeUnitX().scale(-0.01 * this.speed));\r\n        }\r\n        if (state.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.Q)) {\r\n            hasChanged = true;\r\n            this.pos.z += 0.01 * this.speed;\r\n        }\r\n        if (state.isDown(_lib__WEBPACK_IMPORTED_MODULE_0__.Key.E)) {\r\n            hasChanged = true;\r\n            this.pos.z -= 0.01 * this.speed;\r\n        }\r\n        return hasChanged;\r\n    }\r\n    ///////////////////////////////////////////////////////////////////////////\r\n    getCameraPoint() {\r\n        return this.inverseWorldMatrix.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\r\n    }\r\n    getMouseWorldRay(canvasWidth, canvasHeight, useMouse = true) {\r\n        // get a ray from origin through mousepos\r\n        // mouse unit screen position:\r\n        //       -------------- -0.5\r\n        //       |            |\r\n        //       |      .(0,0)|\r\n        //       |            |\r\n        //       -------------- 0.5\r\n        //     -0.72        0.72\r\n        //    (0.72 = 0.5 * aspect)\r\n        //\r\n        let size = 0.5; // size indicator of the fustrum\r\n        let mp = this.mousePos;\r\n        let aspect = canvasWidth / canvasHeight;\r\n        let mouseUnitX = (-size + mp.x / canvasWidth) * aspect;\r\n        let mouseUnitY = -size + mp.y / canvasHeight;\r\n        let f = size / Math.tan(this.fov / 2); // focal length\r\n        let invWorld = this.inverseWorldMatrix;\r\n        let origin = invWorld.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\r\n        // TODO instead of doing this, just extract the x, y, and z columns of invWorld\r\n        let iDestiny = invWorld.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0));\r\n        let jDestiny = invWorld.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));\r\n        let kDestiny = invWorld.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1));\r\n        let ihat = iDestiny.sub(origin).normalize();\r\n        let jhat = jDestiny.sub(origin).normalize();\r\n        let khat = kDestiny.sub(origin).normalize();\r\n        // pardon this insanely ugly statement\r\n        let screenPoint = useMouse\r\n            ? origin\r\n                .added(khat.scaled(f))\r\n                .add(ihat.scaled(mouseUnitX))\r\n                .add(jhat.scaled(-mouseUnitY))\r\n            : origin.added(khat.scaled(f));\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Ray.fromPoints(origin, screenPoint);\r\n    }\r\n    getProjectionMatrix(width, height) {\r\n        // aspects\r\n        let aspect = width / height; // note: this should be constant\r\n        // let z_plane = -1. / Math.tan(pi / 8.);\r\n        // projection to screen\r\n        // let projection = Matrix4.newOrthographic(-1, 1, -1, 1, 0.1, 0.1);\r\n        let projection = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newPerspective(this.fov, aspect, this.zNear, this.zFar);\r\n        return projection;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Camera.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Entity.ts":
/*!*********************************************!*\
  !*** ../engine/src/render/basics/Entity.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Entity\": () => (/* binding */ Entity)\n/* harmony export */ });\n/* harmony import */ var _math_Transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Transform */ \"../engine/src/math/Transform.ts\");\n/* harmony import */ var _Model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Model */ \"../engine/src/render/basics/Model.ts\");\n// purpose: highest level shadable 'object'.\r\n//     like: a tree, a rock, a spawner, an enemy.\r\n\r\n\r\nclass Entity {\r\n    constructor(xform, model) {\r\n        this.xform = xform;\r\n        this.model = model;\r\n    }\r\n    static new(position = _math_Transform__WEBPACK_IMPORTED_MODULE_0__.Transform.new(), model = _Model__WEBPACK_IMPORTED_MODULE_1__.Model.new()) {\r\n        return new Entity(position, model);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Entity.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Light.ts":
/*!********************************************!*\
  !*** ../engine/src/render/basics/Light.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Light\": () => (/* binding */ Light)\n/* harmony export */ });\n/* harmony import */ var _image_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../image/Color */ \"../engine/src/image/Color.ts\");\n// Name:    scene.ts\r\n// Author:  Jos Feenstra\r\n// NOTE:    not used yet\r\n\r\nclass Light {\r\n    constructor(pos, color) {\r\n        this.pos = pos;\r\n        this.color = color;\r\n    }\r\n    static new(pos, color = _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromRGB()) {\r\n        return new Light(pos, color);\r\n    }\r\n    static newDirectional(pos, color = _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromRGB()) {\r\n        return new Light(pos, color);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Light.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Material.ts":
/*!***********************************************!*\
  !*** ../engine/src/render/basics/Material.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Material\": () => (/* binding */ Material)\n/* harmony export */ });\n/* harmony import */ var _image_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../image/Color */ \"../engine/src/image/Color.ts\");\n\r\nclass Material {\r\n    constructor(ambient, diffuse, specular, occluded, specularDampner, opacity, // 0: transparant, 1: opaque\r\n    texture, bumpmap) {\r\n        this.ambient = ambient;\r\n        this.diffuse = diffuse;\r\n        this.specular = specular;\r\n        this.occluded = occluded;\r\n        this.specularDampner = specularDampner;\r\n        this.opacity = opacity;\r\n        this.texture = texture;\r\n        this.bumpmap = bumpmap;\r\n    }\r\n    static fromObjMtl() {\r\n        throw new Error(\"TODO!!!\");\r\n    }\r\n    static fromTexture(texture) {\r\n        let mat = Material.neutral();\r\n        mat.texture = texture;\r\n        return mat;\r\n    }\r\n    static newPurple() {\r\n        return new Material(_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#35006a\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ff0080\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#513600\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#1b0035\"), 3.195, 1);\r\n    }\r\n    static grey() {\r\n        return new Material(_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#1d1d1d\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#4c4c4c\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#f0f0f0\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#1d1d1d\"), 3.195, 1);\r\n    }\r\n    static neutral() {\r\n        return new Material(_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffffff\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffffff\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffffff\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#ffffff\"), 3.195, 1);\r\n    }\r\n    static yellow() {\r\n        return new Material(_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff25f\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff25f\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff25f\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#fff25f\"), 3.195, 1);\r\n    }\r\n    static default() {\r\n        return new Material(_image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#4f009d\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#06ffff\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#58593e\"), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHex(\"#1b0035\"), 3.195, 1);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Material.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Model.ts":
/*!********************************************!*\
  !*** ../engine/src/render/basics/Model.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Entity */ \"../engine/src/render/basics/Entity.ts\");\n/* harmony import */ var _Material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Material */ \"../engine/src/render/basics/Material.ts\");\n\r\n\r\n\r\n/**\r\n * model instance.\r\n *\r\n * Mind that\r\n * - Multiple models can share the same mesh\r\n * - Multiple models can share the same material\r\n */\r\nclass Model {\r\n    constructor(mesh, material) {\r\n        this.mesh = mesh;\r\n        this.material = material;\r\n    }\r\n    static new(mesh = _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.newIcosahedron(), material = _Material__WEBPACK_IMPORTED_MODULE_2__.Material.default()) {\r\n        return new Model(mesh, material);\r\n    }\r\n    /**\r\n     * Spawns an entity equiped with this model\r\n     */\r\n    spawn() {\r\n        return _Entity__WEBPACK_IMPORTED_MODULE_1__.Entity.new(undefined, this);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Model.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Scene.ts":
/*!********************************************!*\
  !*** ../engine/src/render/basics/Scene.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scene\": () => (/* binding */ Scene)\n/* harmony export */ });\n/* harmony import */ var _image_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../image/Color */ \"../engine/src/image/Color.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _Light__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Light */ \"../engine/src/render/basics/Light.ts\");\n// purpose: wrapper around Camera, Lights, and the Sun\r\n//          This is all the data a typical shader requires at render time\r\n\r\n\r\n\r\nclass Scene {\r\n    constructor(camera, sun = _Light__WEBPACK_IMPORTED_MODULE_2__.Light.new(_lib__WEBPACK_IMPORTED_MODULE_1__.Vector3.new(30, 40, 50), _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHSL(0.1)), lights = []) {\r\n        this.camera = camera;\r\n        this.sun = sun;\r\n        this.lights = lights;\r\n    }\r\n    static new(camera, sun, lights) {\r\n        return new Scene(camera, sun, lights);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Scene.ts?");

/***/ }),

/***/ "../engine/src/render/basics/Shadable.ts":
/*!***********************************************!*\
  !*** ../engine/src/render/basics/Shadable.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createNewShaderForShadable\": () => (/* binding */ createNewShaderForShadable)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var _shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n\r\n\r\n\r\n// type AcceptableShader =\r\n//     | DotShader\r\n//     | ShadedMeshShader\r\n//     | MeshDebugShader\r\n//     | LineShader\r\n//     | TextureMeshShader;\r\nfunction createNewShaderForShadable(s, gl) {\r\n    if (s instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.MultiLine) {\r\n        return new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl);\r\n    }\r\n    else if (s instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.MultiLine) {\r\n        return new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_1__.LineShader(gl);\r\n    }\r\n    else if (s instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\r\n        return new _shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_2__.MeshDebugShader(gl);\r\n    }\r\n    else {\r\n        console.warn(\"No shader can be found for shadable: \", s);\r\n        return undefined;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/basics/Shadable.ts?");

/***/ }),

/***/ "../engine/src/render/bufferables/ImageMesh.ts":
/*!*****************************************************!*\
  !*** ../engine/src/render/bufferables/ImageMesh.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageMesh\": () => (/* binding */ ImageMesh)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n\r\n/**\r\n * This describes an image in 3D space.\r\n * Can be regarded as a 3D sprite, build would be very inefficient to be used like that\r\n * Mostly used for debugging textures\r\n */\r\nclass ImageMesh {\r\n    constructor(image, plane, scale, centered, doubleSided) {\r\n        this.image = image;\r\n        this.plane = plane;\r\n        this.scale = scale;\r\n        this.centered = centered;\r\n        this.doubleSided = doubleSided;\r\n    }\r\n    static new(image, plane = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY(), scale = 1, centered = true, doubleSided = true) {\r\n        return new ImageMesh(image, plane, scale, centered, doubleSided);\r\n    }\r\n    buffer() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh.fromImage(this.image, this.plane, this.centered, this.scale, this.doubleSided);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/bufferables/ImageMesh.ts?");

/***/ }),

/***/ "../engine/src/render/bufferers/MeshBufferer.ts":
/*!******************************************************!*\
  !*** ../engine/src/render/bufferers/MeshBufferer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshBufferer\": () => (/* binding */ MeshBufferer)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry/mesh/Mesh */ \"../engine/src/geometry/mesh/Mesh.ts\");\n/* harmony import */ var _shaders_old_transform_line_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders-old/transform-line-shader */ \"../engine/src/render/shaders-old/transform-line-shader.ts\");\n/* harmony import */ var _shaders_old_transform_mesh_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders-old/transform-mesh-shader */ \"../engine/src/render/shaders-old/transform-mesh-shader.ts\");\n/* harmony import */ var _basics_Bufferer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../basics/Bufferer */ \"../engine/src/render/basics/Bufferer.ts\");\n\r\n\r\n\r\n\r\n\r\nclass MeshBufferer extends _basics_Bufferer__WEBPACK_IMPORTED_MODULE_4__.Bufferer {\r\n    constructor(gl) {\r\n        super(gl, _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh.newEmpty(0, 0, 0), _shaders_old_transform_line_shader__WEBPACK_IMPORTED_MODULE_2__.TransformLineShader.new);\r\n        this.color = [0, 0, 0, 0.8];\r\n        this.linecolor = [0.3, 0.3, 0.3, 1];\r\n        this.renderer2 = new _shaders_old_transform_mesh_shader__WEBPACK_IMPORTED_MODULE_3__.TransformMeshShader(gl);\r\n    }\r\n    static new(gl) {\r\n        return new MeshBufferer(gl);\r\n    }\r\n    set(mesh) {\r\n        this.state = mesh;\r\n        this.buffer();\r\n    }\r\n    // how to convert from state to buffered\r\n    buffer() {\r\n        this.buffered = this.state.ToShaderMesh();\r\n        this.buffered.calculateFaceNormals();\r\n        this.buffered.color = this.color;\r\n        this.buffered.linecolor = this.linecolor;\r\n        this.commit();\r\n    }\r\n    commit() {\r\n        this.buffered.color = this.color;\r\n        this.buffered.linecolor = this.linecolor;\r\n        this.renderer.set(this.buffered, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw);\r\n        this.renderer2.set(this.buffered, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw);\r\n    }\r\n    render(scene) {\r\n        this.renderer2.render(scene);\r\n        this.renderer.render(scene);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/bufferers/MeshBufferer.ts?");

/***/ }),

/***/ "../engine/src/render/renderers/DebugRenderer.ts":
/*!*******************************************************!*\
  !*** ../engine/src/render/renderers/DebugRenderer.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DebugRenderer\": () => (/* binding */ DebugRenderer)\n/* harmony export */ });\n/* harmony import */ var _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/MultiVector3 */ \"../engine/src/data/MultiVector3.ts\");\n/* harmony import */ var _geometry_curve_Curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometry/curve/Curve */ \"../engine/src/geometry/curve/Curve.ts\");\n/* harmony import */ var _geometry_curve_Polyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometry/curve/Polyline */ \"../engine/src/geometry/curve/Polyline.ts\");\n/* harmony import */ var _math_Random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Random */ \"../engine/src/math/Random.ts\");\n/* harmony import */ var _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../geometry/mesh/Mesh */ \"../engine/src/geometry/mesh/Mesh.ts\");\n/* harmony import */ var _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../geometry/mesh/MultiLine */ \"../engine/src/geometry/mesh/MultiLine.ts\");\n/* harmony import */ var _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../geometry/mesh/ShaderMesh */ \"../engine/src/geometry/mesh/ShaderMesh.ts\");\n/* harmony import */ var _shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shaders-old/dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shaders-old/line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var _shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shaders-old/mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var _shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../shaders-old/shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _bufferables_ImageMesh__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../bufferables/ImageMesh */ \"../engine/src/render/bufferables/ImageMesh.ts\");\n/* harmony import */ var _parametric_Parameter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../parametric/Parameter */ \"../engine/src/parametric/Parameter.ts\");\n/* harmony import */ var _shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../shaders-old/texture-mesh-shader */ \"../engine/src/render/shaders-old/texture-mesh-shader.ts\");\n/* harmony import */ var _basics_Shadable__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../basics/Shadable */ \"../engine/src/render/basics/Shadable.ts\");\n/* harmony import */ var _basics_Entity__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../basics/Entity */ \"../engine/src/render/basics/Entity.ts\");\n/* harmony import */ var _shaders_PhongShader__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../shaders/PhongShader */ \"../engine/src/render/shaders/PhongShader.ts\");\n// purpose: something that is willing to create new Shaders on the fly, to render whatever it gets\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Renderer which can instantly visualize a large number of geometries. Very useful for looking at intermediate data.\r\n */\r\nclass DebugRenderer {\r\n    constructor(gl, shaders, activeShaders) {\r\n        this.gl = gl;\r\n        this.shaders = shaders;\r\n        this.activeShaders = activeShaders;\r\n    }\r\n    static new(gl) {\r\n        return new DebugRenderer(gl, new Map(), new Set());\r\n    }\r\n    clear() {\r\n        this.shaders.clear();\r\n        this.activeShaders.clear();\r\n    }\r\n    /**\r\n     * Creates a new shader, or updates existing shader\r\n     */\r\n    set(unit, key, ...options) {\r\n        if (!key) {\r\n            key = (0,_math_Random__WEBPACK_IMPORTED_MODULE_3__.createRandomGUID)().slice(0, 8);\r\n        }\r\n        let shader = this.shaders.get(key);\r\n        if (!shader) {\r\n            return this.add(key, unit, ...options);\r\n        }\r\n        this.multiSet(key, unit, ...options);\r\n        return shader;\r\n    }\r\n    setBufferable(unit, key, ...options) {\r\n        this.setShadable(unit.buffer(), key, options);\r\n    }\r\n    setShadable(shadable, key, ...options) {\r\n        if (!key) {\r\n            key = (0,_math_Random__WEBPACK_IMPORTED_MODULE_3__.createRandomGUID)().slice(0, 8);\r\n        }\r\n        let shader = this.shaders.get(key);\r\n        if (!shader) {\r\n            shader = (0,_basics_Shadable__WEBPACK_IMPORTED_MODULE_16__.createNewShaderForShadable)(shadable, this.gl);\r\n            this.shaders.set(key, shader);\r\n            this.activeShaders.add(key);\r\n            // ADD THE OPTIONS SOMEHOW\r\n            // shader.setOptions(options); \r\n        }\r\n        //@ts-ignore\r\n        shader.set(shadable, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__.DrawSpeed.StaticDraw);\r\n        return shader;\r\n    }\r\n    addUi(ui) {\r\n        ui.clear();\r\n        for (let [key, _] of this.shaders) {\r\n            let p = _parametric_Parameter__WEBPACK_IMPORTED_MODULE_14__.Parameter.newBoolean(key, true);\r\n            ui.addBooleanParameter(p, () => {\r\n                this.onChange(key, p.state !== 0);\r\n            });\r\n        }\r\n    }\r\n    onChange(key, state) {\r\n        if (state) {\r\n            this.activeShaders.add(key);\r\n        }\r\n        else {\r\n            this.activeShaders.delete(key);\r\n        }\r\n    }\r\n    render(c) {\r\n        for (let key of this.activeShaders) {\r\n            this.shaders.get(key).render(c);\r\n        }\r\n    }\r\n    multiSet(key, unit, ...options) {\r\n        // NOTE: If the type definitions above are set correctly\r\n        // and if the 'add' procedure went correctly, this will work\r\n        // thats why i'm liberal with the @ts ignores \r\n        let gl = this.gl;\r\n        let shader = this.shaders.get(key);\r\n        if (unit instanceof _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3) {\r\n            //@ts-ignore\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_6__.ShaderMesh) {\r\n            //@ts-ignore\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh) {\r\n            let smesh = unit.ToShaderMesh();\r\n            //@ts-ignore\r\n            shader.set(smesh);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_11__.BiSurface) {\r\n            let smesh = unit.buffer().ToShaderMesh();\r\n            //@ts-ignore\r\n            shader.set(smesh);\r\n        }\r\n        else if (unit instanceof _geometry_curve_Curve__WEBPACK_IMPORTED_MODULE_1__.Curve) {\r\n            let multiLine = unit.buffer();\r\n            //@ts-ignore\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _geometry_curve_Polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline) {\r\n            let multiLine = _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromPolyline(unit);\r\n            //@ts-ignore\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_11__.Plane) {\r\n            let multiLine = _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromPlane(unit);\r\n            //@ts-ignore\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_11__.Circle3) {\r\n            //@ts-ignore\r\n            shader.set(_geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromCircle(unit));\r\n        }\r\n        else if (unit instanceof _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine) {\r\n            //@ts-ignore\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _bufferables_ImageMesh__WEBPACK_IMPORTED_MODULE_13__.ImageMesh) {\r\n            // FOR DEBUGGING\r\n            // IO.promptDownloadImage(key + \".png\", unit.image.toImageData());\r\n            //@ts-ignore\r\n            shader.set(unit.buffer(), _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__.DrawSpeed.StaticDraw);\r\n        }\r\n        else if (unit instanceof _basics_Entity__WEBPACK_IMPORTED_MODULE_17__.Entity) {\r\n            //@ts-ignore\r\n            shader.load(unit, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__.DrawSpeed.StaticDraw);\r\n        }\r\n        else {\r\n            console.error(\"MultiRenderer cannot render: \", unit);\r\n            return undefined;\r\n        }\r\n    }\r\n    add(key, unit, ...options) {\r\n        let shader;\r\n        let gl = this.gl;\r\n        // determine the RenderableUnit type\r\n        // rely as much on the defaults as possilbe\r\n        if (unit instanceof _data_MultiVector3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3) {\r\n            shader = new _shaders_old_dot_shader__WEBPACK_IMPORTED_MODULE_7__.DotShader(gl, ...options);\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _geometry_mesh_ShaderMesh__WEBPACK_IMPORTED_MODULE_6__.ShaderMesh) {\r\n            shader = new _shaders_old_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_10__.ShadedMeshShader(gl);\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _geometry_mesh_Mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh) {\r\n            shader = new _shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_9__.MeshDebugShader(gl, [0.5, 0, 0, 1], [0.8, 0, 0, 1]);\r\n            let smesh = unit.ToShaderMesh();\r\n            shader.set(smesh);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_11__.BiSurface) {\r\n            shader = new _shaders_old_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_9__.MeshDebugShader(gl, ...options);\r\n            let smesh = unit.buffer().ToShaderMesh();\r\n            shader.set(smesh);\r\n        }\r\n        else if (unit instanceof _geometry_curve_Curve__WEBPACK_IMPORTED_MODULE_1__.Curve) {\r\n            shader = new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_8__.LineShader(gl, ...options);\r\n            let multiLine = unit.buffer();\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _geometry_curve_Polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline) {\r\n            shader = new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_8__.LineShader(gl, ...options);\r\n            let multiLine = _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromPolyline(unit);\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_11__.Plane) {\r\n            shader = new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_8__.LineShader(gl, ...options);\r\n            let multiLine = _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromPlane(unit);\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_11__.Circle3) {\r\n            shader = new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_8__.LineShader(gl, ...options);\r\n            let multiLine = _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine.fromCircle(unit);\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _geometry_mesh_MultiLine__WEBPACK_IMPORTED_MODULE_5__.MultiLine) {\r\n            shader = new _shaders_old_line_shader__WEBPACK_IMPORTED_MODULE_8__.LineShader(gl, ...options);\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _bufferables_ImageMesh__WEBPACK_IMPORTED_MODULE_13__.ImageMesh) {\r\n            shader = new _shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_15__.TextureMeshShader(gl);\r\n            shader.set(unit.buffer(), _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__.DrawSpeed.StaticDraw);\r\n        }\r\n        else if (unit instanceof _basics_Entity__WEBPACK_IMPORTED_MODULE_17__.Entity) {\r\n            if (unit.model.material.texture) {\r\n                // TODO WE NEED A NEW TEXTUREDMESHSHADER!!!!!\r\n                shader = new _shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_15__.TextureMeshShader(gl);\r\n                shader.setWithMesh(unit.model.mesh, unit.model.material.texture, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__.DrawSpeed.StaticDraw);\r\n            }\r\n            else {\r\n                shader = new _shaders_PhongShader__WEBPACK_IMPORTED_MODULE_18__.PhongShader(gl);\r\n                unit.model.mesh.calcAndSetVertexNormals();\r\n                shader.load(unit, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_12__.DrawSpeed.StaticDraw);\r\n            }\r\n        }\r\n        else {\r\n            console.error(\"MultiRenderer cannot render: \", unit);\r\n            return undefined;\r\n        }\r\n        this.shaders.set(key, shader);\r\n        this.activeShaders.add(key);\r\n        return shader;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/renderers/DebugRenderer.ts?");

/***/ }),

/***/ "../engine/src/render/renderers/ImageRenderer.ts":
/*!*******************************************************!*\
  !*** ../engine/src/render/renderers/ImageRenderer.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageRenderer\": () => (/* binding */ ImageRenderer)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shaders-old/texture-mesh-shader */ \"../engine/src/render/shaders-old/texture-mesh-shader.ts\");\n\r\n\r\nclass ImageRenderer {\r\n    constructor(gl, stdSize, gap = 10, scale = 2, images = [], shaders = []) {\r\n        this.gl = gl;\r\n        this.stdSize = stdSize;\r\n        this.gap = gap;\r\n        this.scale = scale;\r\n        this.images = images;\r\n        this.shaders = shaders;\r\n    }\r\n    static new(gl, stdSize) {\r\n        return new ImageRenderer(gl, stdSize);\r\n    }\r\n    add(image) {\r\n        this.images.push(image);\r\n        this.shaders.push(new _shaders_old_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_1__.TextureMeshShader(this.gl));\r\n    }\r\n    buffer() {\r\n        // i was having trouble rendering images... this is a workaround:\r\n        // convert the this.images[] list into the this.imageMeshes[] list\r\n        let accumulatedWidth = 0;\r\n        this.images.forEach((image, i) => {\r\n            let mesh = _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh.fromImage(image, _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.new(accumulatedWidth, 0, 0)), false, 100);\r\n            this.shaders[i].set(mesh, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw);\r\n            accumulatedWidth += image.width + this.gap;\r\n        });\r\n    }\r\n    render(c) {\r\n        this.shaders.forEach((shader) => {\r\n            shader.render(c);\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/renderers/ImageRenderer.ts?");

/***/ }),

/***/ "../engine/src/render/renderers/TextRenderer.ts":
/*!******************************************************!*\
  !*** ../engine/src/render/renderers/TextRenderer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextRenderer\": () => (/* binding */ TextRenderer)\n/* harmony export */ });\n// https://www.angelcode.com/products/bmfont/\r\n// take a bitmap with standardized positions, or some json stating the position\r\n// frank already made this!!\r\nclass TextRenderer {\r\n    // mapping of text characters to data: texturePosition, textureExtend\r\n    constructor() {\r\n        // constuct it\r\n        // use a billboard renderer,\r\n    }\r\n    static new() { }\r\n    setFont() { }\r\n    set(text, position) {\r\n        // calculate the different positions + offsets of the text\r\n        // set it as state to the billboard renderer\r\n    }\r\n    render() { }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/renderers/TextRenderer.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/_lib.ts":
/*!************************************************!*\
  !*** ../engine/src/render/shaders-old/_lib.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotShader\": () => (/* reexport safe */ _dot_shader__WEBPACK_IMPORTED_MODULE_0__.DotShader),\n/* harmony export */   \"GraphDebugShader\": () => (/* reexport safe */ _graph_debug_shader__WEBPACK_IMPORTED_MODULE_1__.GraphDebugShader),\n/* harmony export */   \"LineShader\": () => (/* reexport safe */ _line_shader__WEBPACK_IMPORTED_MODULE_2__.LineShader),\n/* harmony export */   \"MeshDebugShader\": () => (/* reexport safe */ _mesh_debug_shader__WEBPACK_IMPORTED_MODULE_3__.MeshDebugShader),\n/* harmony export */   \"NormalShader\": () => (/* reexport safe */ _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_4__.NormalShader),\n/* harmony export */   \"MeshPickShader\": () => (/* reexport safe */ _pick_shader__WEBPACK_IMPORTED_MODULE_5__.MeshPickShader),\n/* harmony export */   \"RectangleShader\": () => (/* reexport safe */ _rectangle_shader__WEBPACK_IMPORTED_MODULE_6__.RectangleShader),\n/* harmony export */   \"ShadedMeshShader\": () => (/* reexport safe */ _shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_7__.ShadedMeshShader),\n/* harmony export */   \"SimpleMeshOverlayRenderer\": () => (/* reexport safe */ _simple_mesh_overlay_renderer__WEBPACK_IMPORTED_MODULE_8__.SimpleMeshOverlayRenderer),\n/* harmony export */   \"SimpleMeshShader\": () => (/* reexport safe */ _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_9__.SimpleMeshShader),\n/* harmony export */   \"TextureMeshShader\": () => (/* reexport safe */ _texture_mesh_shader__WEBPACK_IMPORTED_MODULE_10__.TextureMeshShader),\n/* harmony export */   \"TransformLineShader\": () => (/* reexport safe */ _transform_line_shader__WEBPACK_IMPORTED_MODULE_11__.TransformLineShader),\n/* harmony export */   \"TransformMeshShader\": () => (/* reexport safe */ _transform_mesh_shader__WEBPACK_IMPORTED_MODULE_12__.TransformMeshShader)\n/* harmony export */ });\n/* harmony import */ var _dot_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var _graph_debug_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graph-debug-shader */ \"../engine/src/render/shaders-old/graph-debug-shader.ts\");\n/* harmony import */ var _line_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var _mesh_debug_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh-debug-shader */ \"../engine/src/render/shaders-old/mesh-debug-shader.ts\");\n/* harmony import */ var _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mesh-normals-shader */ \"../engine/src/render/shaders-old/mesh-normals-shader.ts\");\n/* harmony import */ var _pick_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pick-shader */ \"../engine/src/render/shaders-old/pick-shader.ts\");\n/* harmony import */ var _rectangle_shader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rectangle-shader */ \"../engine/src/render/shaders-old/rectangle-shader.ts\");\n/* harmony import */ var _shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shaded-mesh-shader */ \"../engine/src/render/shaders-old/shaded-mesh-shader.ts\");\n/* harmony import */ var _simple_mesh_overlay_renderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./simple-mesh-overlay-renderer */ \"../engine/src/render/shaders-old/simple-mesh-overlay-renderer.ts\");\n/* harmony import */ var _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./simple-mesh-shader */ \"../engine/src/render/shaders-old/simple-mesh-shader.ts\");\n/* harmony import */ var _texture_mesh_shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./texture-mesh-shader */ \"../engine/src/render/shaders-old/texture-mesh-shader.ts\");\n/* harmony import */ var _transform_line_shader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./transform-line-shader */ \"../engine/src/render/shaders-old/transform-line-shader.ts\");\n/* harmony import */ var _transform_mesh_shader__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./transform-mesh-shader */ \"../engine/src/render/shaders-old/transform-mesh-shader.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/_lib.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/dot-shader.ts":
/*!******************************************************!*\
  !*** ../engine/src/render/shaders-old/dot-shader.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotShader\": () => (/* binding */ DotShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// jos feenstra\r\n\r\n\r\n\r\nclass DotShader extends _OldShader__WEBPACK_IMPORTED_MODULE_2__.OldShader {\r\n    constructor(gl, radius = 5, color = [1, 1, 1, 1], square = true) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n        uniform float u_size;\r\n\r\n        attribute vec3 a_vertex;\r\n\r\n        void main() {\r\n            // Set the size of a rendered point.\r\n            gl_PointSize = u_size;\r\n\r\n            // Transform the location of the vertex.\r\n            gl_Position = u_transform * vec4(a_vertex, 1.0);\r\n        }\r\n\r\n        `;\r\n        let fragmentSourceSquare = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        // vec2 center = vec2(0.5, 0.5);\r\n\r\n        void main() {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        let fragmentSourceRound = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        vec2 center = vec2(0.5, 0.5);\r\n\r\n        void main() {\r\n            if (distance(center, gl_PointCoord) > 0.5) {\r\n               discard;\r\n            }\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        if (square) {\r\n            super(gl, vertexSource, fragmentSourceSquare);\r\n        }\r\n        else {\r\n            super(gl, vertexSource, fragmentSourceRound);\r\n        }\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_size = gl.getUniformLocation(this.program, \"u_size\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.color = color;\r\n        this.size = radius;\r\n        this.count = 0;\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_vertex\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set(points, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        gl.useProgram(this.program);\r\n        // convert all possible entries to a general entry\r\n        let array = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(points);\r\n        // from some other thing\r\n        this.count = array.count();\r\n        // // Bind the position buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, array.width, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, array.data, speed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        // console.log(matrix.data);\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniform1f(this.u_size, this.size);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        // Draw the point.\r\n        gl.drawArrays(gl.POINTS, 0, this.count);\r\n    }\r\n    setAndRender(data, c) {\r\n        this.set(data, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/dot-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/graph-debug-shader.ts":
/*!**************************************************************!*\
  !*** ../engine/src/render/shaders-old/graph-debug-shader.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphDebugShader\": () => (/* binding */ GraphDebugShader)\n/* harmony export */ });\n/* harmony import */ var _OldMultiShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../OldMultiShader */ \"../engine/src/render/OldMultiShader.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _dot_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dot-shader */ \"../engine/src/render/shaders-old/dot-shader.ts\");\n/* harmony import */ var _line_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mesh-normals-shader */ \"../engine/src/render/shaders-old/mesh-normals-shader.ts\");\n/* harmony import */ var _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simple-mesh-shader */ \"../engine/src/render/shaders-old/simple-mesh-shader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GraphDebugShader extends _OldMultiShader__WEBPACK_IMPORTED_MODULE_0__.MultiShader {\r\n    constructor(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        super();\r\n        this.faceRend = new _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_5__.SimpleMeshShader(gl, faceColor);\r\n        this.lineRend = new _line_shader__WEBPACK_IMPORTED_MODULE_3__.LineShader(gl, edgeColor);\r\n        this.pointRend = new _dot_shader__WEBPACK_IMPORTED_MODULE_2__.DotShader(gl, 7, edgeColor, false);\r\n        if (renderNormal)\r\n            this.normRend = new _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_4__.NormalShader(gl);\r\n    }\r\n    set(graph, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        //this.faceRend.setMesh(gl, mesh);\r\n        this.pointRend.set(graph.allVertPositions(), speed);\r\n        this.lineRend.set(graph.toLines(), speed);\r\n        // this.normRend?.setWithLists(graph.allVertPositions(), graph.allNorms(), speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        this.pointRend.render(c);\r\n        // this.faceRend.render(gl, camera.totalMatrix);\r\n        this.lineRend.render(c);\r\n        // this.normRend?.render(gl, camera);\r\n    }\r\n    setAndRender(r, context) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/graph-debug-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/line-shader.ts":
/*!*******************************************************!*\
  !*** ../engine/src/render/shaders-old/line-shader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineShader\": () => (/* binding */ LineShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\n\r\nclass LineShader extends _OldShader__WEBPACK_IMPORTED_MODULE_2__.OldShader {\r\n    constructor(gl, color = [1, 1, 1, 0.5]) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // set uniforms which wont change\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n    }\r\n    set(data, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw, personal = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity()) {\r\n        // save how many faces need to be drawn\r\n        let gl = this.gl;\r\n        let links;\r\n        let verts;\r\n        if (data instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\r\n            verts = data.verts.slice();\r\n            links = data.links.getData();\r\n        }\r\n        else {\r\n            verts = data.verts;\r\n            links = data.links;\r\n        }\r\n        // console.log(links);\r\n        gl.useProgram(this.program);\r\n        this.count = links.length;\r\n        this.vertCount = verts.width;\r\n        let drawspeed = speed;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, verts.data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, links.buffer, drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // index\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(data, c) {\r\n        this.set(data, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/line-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/mesh-debug-shader.ts":
/*!*************************************************************!*\
  !*** ../engine/src/render/shaders-old/mesh-debug-shader.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshDebugShader\": () => (/* binding */ MeshDebugShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _line_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-shader */ \"../engine/src/render/shaders-old/line-shader.ts\");\n/* harmony import */ var _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh-normals-shader */ \"../engine/src/render/shaders-old/mesh-normals-shader.ts\");\n/* harmony import */ var _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./simple-mesh-shader */ \"../engine/src/render/shaders-old/simple-mesh-shader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\n\r\n\r\nclass MeshDebugShader extends _lib__WEBPACK_IMPORTED_MODULE_0__.MultiShader {\r\n    constructor(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        super();\r\n        this.faceRend = new _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_4__.SimpleMeshShader(gl, faceColor);\r\n        this.lineRend = new _line_shader__WEBPACK_IMPORTED_MODULE_2__.LineShader(gl, edgeColor);\r\n        this.personal = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity();\r\n        if (renderNormal)\r\n            this.normRend = new _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_3__.NormalShader(gl);\r\n    }\r\n    static new(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        return new MeshDebugShader(gl, faceColor, edgeColor, renderNormal);\r\n    }\r\n    set(data, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        var _a;\r\n        this.personal = data.position;\r\n        this.faceRend.set(data.mesh);\r\n        this.lineRend.set(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromMesh(data), speed);\r\n        (_a = this.normRend) === null || _a === void 0 ? void 0 : _a.set(data, speed);\r\n    }\r\n    render(c) {\r\n        var _a;\r\n        this.faceRend.render(c);\r\n        this.lineRend.render(c);\r\n        (_a = this.normRend) === null || _a === void 0 ? void 0 : _a.render(c);\r\n    }\r\n    setAndRender(r, c) {\r\n        this.set(r, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/mesh-debug-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/mesh-normals-shader.ts":
/*!***************************************************************!*\
  !*** ../engine/src/render/shaders-old/mesh-normals-shader.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NormalShader\": () => (/* binding */ NormalShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\n\r\nclass NormalShader extends _OldShader__WEBPACK_IMPORTED_MODULE_2__.OldShader {\r\n    constructor(gl) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_vertex;\r\n        attribute vec4 a_vertex_color;\r\n\r\n        uniform mat4 u_transform;\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_vertex;\r\n            v_color = a_vertex_color;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main () {\r\n            gl_FragColor = v_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_vertex\");\r\n        this.a_color = gl.getAttribLocation(this.program, \"a_vertex_color\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.a_color_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n        this.scale = 0.4;\r\n    }\r\n    // take a general render mesh, and extract normals\r\n    set(rend, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        // save how many verts need to be drawn\r\n        let gl = this.gl;\r\n        gl.useProgram(this.program);\r\n        let drawspeed = speed;\r\n        this.vertCount = 3;\r\n        let lineverts;\r\n        let normals;\r\n        // different buffer fills based upon normal kind\r\n        let normalKind = rend.getNormalType();\r\n        if (normalKind == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Face) {\r\n            let faceCount = rend.mesh.links.count();\r\n            this.count = faceCount * 2;\r\n            lineverts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            normals = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            for (let f = 0; f < faceCount; f++) {\r\n                let center = rend.getFaceVertices(f).average();\r\n                let normal = rend.norms.get(f);\r\n                let i1 = f * 2;\r\n                let i2 = f * 2 + 1;\r\n                lineverts.set(i1, center);\r\n                lineverts.set(i2, center.add(normal.scaled(this.scale)));\r\n                let color = normal.add(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1).div(2));\r\n                normals.set(i1, color);\r\n                normals.set(i2, color);\r\n            }\r\n        }\r\n        else if (normalKind == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Vertex) {\r\n            let vertCount = rend.mesh.verts.count;\r\n            this.count = vertCount * 2;\r\n            lineverts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            normals = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            for (let i = 0; i < vertCount; i++) {\r\n                let center = rend.mesh.verts.get(i);\r\n                let normal = rend.norms.get(i);\r\n                let i1 = i * 2;\r\n                let i2 = i * 2 + 1;\r\n                lineverts.set(i1, center);\r\n                lineverts.set(i2, center.add(normal.scaled(this.scale)));\r\n                let color = normal.add(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)).div(2);\r\n                normals.set(i1, color);\r\n                normals.set(i2, color);\r\n            }\r\n            // console.log(normals);\r\n        }\r\n        else {\r\n            // console.warn(\"no normals for type\", normalKind);\r\n            this.count = 0;\r\n            return;\r\n        }\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, lineverts.slice().data, drawspeed);\r\n        // normals\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_color_buffer);\r\n        gl.enableVertexAttribArray(this.a_color);\r\n        gl.vertexAttribPointer(this.a_color, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, normals.slice().data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getDefaultIndices)(this.count), drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        let camera = c.camera;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_color_buffer);\r\n        gl.enableVertexAttribArray(this.a_color);\r\n        gl.vertexAttribPointer(this.a_color, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // index buffer\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/mesh-normals-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/pick-shader.ts":
/*!*******************************************************!*\
  !*** ../engine/src/render/shaders-old/pick-shader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshPickShader\": () => (/* binding */ MeshPickShader)\n/* harmony export */ });\n// TODO: to select triangles (or quads), use this beautiful thing\r\nclass MeshPickShader {\r\n    constructor() { }\r\n    pickMesh(meshes) {\r\n        return 0;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/pick-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/rectangle-shader.ts":
/*!************************************************************!*\
  !*** ../engine/src/render/shaders-old/rectangle-shader.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RectangleShader\": () => (/* binding */ RectangleShader)\n/* harmony export */ });\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// jos feenstra\r\n\r\nclass RectangleShader extends _OldShader__WEBPACK_IMPORTED_MODULE_0__.OldShader {\r\n    constructor(gl) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\r\n        attribute vec2 a_position;\r\n\r\n        uniform vec2 u_resolution;\r\n\r\n        void main() {\r\n            // convert the rectangle from pixels to 0.0 to 1.0\r\n            vec2 zeroToOne = ((a_position / u_resolution) * 2.0) - 1.0;\r\n\r\n            // convert from 0->1 to 0->2\r\n            // vec2 zeroToTwo = zeroToOne * 2.0;\r\n\r\n            // convert from 0->2 to -1->+1 (clipspace)\r\n            // vec2 clipSpace = zeroToTwo - 1.0;\r\n\r\n            gl_Position = vec4(zeroToOne * vec2(1, -1), 0, 1);\r\n        }\r\n        `;\r\n        let fragmentSource = `\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        \r\n        void main() {\r\n           gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vertexSource, fragmentSource);\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.u_resolution = gl.getUniformLocation(this.program, \"u_resolution\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        // Create a buffer to put three 2d clip space points in\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set() {\r\n        throw \"not used\";\r\n    }\r\n    render() {\r\n        throw \"not used!\";\r\n    }\r\n    setAndRender(rs, c) {\r\n        // Clear the canvas\r\n        let gl = this.gl;\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // Turn on the attribute\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.uniform2f(this.u_resolution, gl.canvas.width, gl.canvas.height);\r\n        // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0; // start at the beginning of the buffer\r\n        gl.vertexAttribPointer(this.a_position, size, type, normalize, stride, offset);\r\n        // draw 50 random rectangles in random colors\r\n        for (let r of rs) {\r\n            // Setup a random rectangle\r\n            // This will write to positionBuffer because\r\n            // its the last thing we bound on the ARRAY_BUFFER\r\n            // bind point\r\n            this.setRectangle(gl, r);\r\n            // Set a random color.\r\n            gl.uniform4f(this.u_color, Math.random(), Math.random(), Math.random(), 1);\r\n            // Draw the rectangle.\r\n            var primitiveType = gl.TRIANGLES;\r\n            var offset = 0;\r\n            var count = 6;\r\n            gl.drawArrays(primitiveType, offset, count);\r\n        }\r\n    }\r\n    // Fill the buffer with the values that define a rectangle.\r\n    setRectangle(gl, r) {\r\n        let verts = r.getVertices();\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n            verts[0].x,\r\n            verts[0].y,\r\n            verts[1].x,\r\n            verts[1].y,\r\n            verts[2].x,\r\n            verts[2].y,\r\n            verts[2].x,\r\n            verts[2].y,\r\n            verts[1].x,\r\n            verts[1].y,\r\n            verts[3].x,\r\n            verts[3].y,\r\n        ]), gl.STATIC_DRAW);\r\n    }\r\n    randomInt(range) {\r\n        return Math.floor(Math.random() * range);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/rectangle-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/shaded-mesh-shader.ts":
/*!**************************************************************!*\
  !*** ../engine/src/render/shaders-old/shaded-mesh-shader.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadedMeshShader\": () => (/* binding */ ShadedMeshShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: A shader wrapper for rendering shaded, textured, meshes\r\n\r\n\r\n\r\nclass ShadedMeshShader extends _OldShader__WEBPACK_IMPORTED_MODULE_2__.OldShader {\r\n    constructor(gl) {\r\n        const vs = `\r\n\r\n        attribute vec4 a_vertex_position;\r\n        attribute vec3 a_vertex_normal;\r\n        attribute float a_vertex_ambi;\r\n    \r\n        uniform mat4 u_normal_matrix;\r\n        uniform mat4 u_personal_matrix;\r\n        uniform mat4 u_model_view_matrix;\r\n        uniform mat4 u_projection_matrix;\r\n\r\n        // should be uniforms constances\r\n        uniform vec3 u_ambient_light;\r\n        uniform vec3 u_dir_light_color;\r\n        uniform vec3 u_dir_light_vector;  \r\n\r\n        // varying vec2 v_texture_coord;\r\n        varying vec3 v_lighting;\r\n    \r\n        void main(void) {\r\n\r\n            gl_Position = u_projection_matrix * u_model_view_matrix * u_personal_matrix * a_vertex_position;\r\n            // v_texture_coord = a_texture_coord;\r\n        \r\n            // Apply lighting effect\r\n            // highpr is removed\r\n            vec4 transformedNormal = u_normal_matrix * vec4(a_vertex_normal, 1.0);\r\n            float directional = max(dot(transformedNormal.xyz, u_dir_light_vector), 0.0);\r\n            v_lighting = (u_ambient_light + (u_dir_light_color * directional));\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump float;\r\n\r\n        // Calculates the diffuse factor produced by the light illumination  \r\n        // if done like this, color could look nicer\r\n        // float diffuseFactor(vec3 normal, vec3 light_direction) {\r\n        //     float df = dot(normalize(normal), normalize(light_direction));\r\n        //     if (gl_FrontFacing) {\r\n        //         df = -df;\r\n        //     }\r\n        //     return max(0.0, df);\r\n        // }\r\n\r\n        varying vec3 v_lighting;\r\n\r\n        void main() {\r\n\r\n            // Fragment shader output\r\n            gl_FragColor = vec4(v_lighting, 1.0);\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // init uniforms\r\n        this.u_normal_matrix = gl.getUniformLocation(this.program, \"u_normal_matrix\");\r\n        this.u_model_view_matrix = gl.getUniformLocation(this.program, \"u_model_view_matrix\");\r\n        this.u_projection_matrix = gl.getUniformLocation(this.program, \"u_projection_matrix\");\r\n        this.u_personal_matrix = gl.getUniformLocation(this.program, \"u_personal_matrix\");\r\n        // light uniforms\r\n        this.u_ambient_light = gl.getUniformLocation(this.program, \"u_ambient_light\");\r\n        this.u_dir_light_color = gl.getUniformLocation(this.program, \"u_dir_light_color\");\r\n        this.u_dir_light_vector = gl.getUniformLocation(this.program, \"u_dir_light_vector\");\r\n        // init attributes: verts | normals | ambi\r\n        this.a_vertex_position = gl.getAttribLocation(this.program, \"a_vertex_position\");\r\n        this.a_vertex_postition_buffer = gl.createBuffer();\r\n        this.a_vertex_normal = gl.getAttribLocation(this.program, \"a_vertex_normal\");\r\n        this.a_vertex_normal_buffer = gl.createBuffer();\r\n        this.a_vertex_ambi = gl.getAttribLocation(this.program, \"a_vertex_ambi\");\r\n        this.a_vertex_ambi_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(rend, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        // NOTE: processing time is longer: we use DrawArray instead of DrawElements, to deal with normals & uv data\r\n        let gl = this.gl;\r\n        this.setShallow(gl, rend);\r\n        let normalType = rend.getNormalType();\r\n        if (normalType == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Face) {\r\n            // save how many verts need to be drawn\r\n            gl.useProgram(this.program);\r\n            this.count = rend.mesh.links.data.length;\r\n            // convert to non-indexed verts & norms\r\n            let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            let norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            let ambi = new Float32Array(this.count);\r\n            let faceCount = rend.mesh.links.count();\r\n            for (let i = 0; i < rend.mesh.links.count(); i++) {\r\n                let norm = rend.norms.get(i);\r\n                rend.mesh.links.getRow(i).forEach((v, j) => {\r\n                    let id = i * 3 + j;\r\n                    verts.set(id, rend.mesh.verts.get(v));\r\n                    norms.set(id, norm);\r\n                    ambi[id] = 1;\r\n                });\r\n            }\r\n            // buffer 1\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, verts.slice().data.buffer, speed);\r\n            // buffer 2\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, norms.slice().data.buffer, speed);\r\n            // buffer 3\r\n            // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n            // gl.vertexAttribPointer(this.a_vertex_ambi, 1, gl.FLOAT, false, 0, 0);\r\n            // gl.bufferData(gl.ARRAY_BUFFER, ambi, ds);\r\n            // index\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getDefaultIndices)(this.count), speed);\r\n        }\r\n        else if (normalType == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Vertex) {\r\n            // save how many verts need to be drawn\r\n            gl.useProgram(this.program);\r\n            let ds = speed;\r\n            // convert to non-indexed verts & norms\r\n            let ambi = rend.ambi;\r\n            let faceCount = rend.mesh.links.count();\r\n            this.count = rend.mesh.links.data.length;\r\n            // console.log(rend.mesh.links);\r\n            // buffer 1\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, rend.mesh.verts.slice().data, ds);\r\n            // buffer 2\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, rend.norms.slice().data, ds);\r\n            // buffer 3\r\n            // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n            // gl.vertexAttribPointer(this.a_vertex_ambi, 1, gl.FLOAT, false, 0, 0);\r\n            // gl.bufferData(gl.ARRAY_BUFFER, ambi, ds);\r\n            // index\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, rend.mesh.links.data, ds);\r\n        }\r\n        else {\r\n            console.log(\"cannot render with this normal data\");\r\n        }\r\n        // never render more than possible\r\n        // NOTE : THIS IS INCORRECT. OFTEN WE CAN JUST RENDER IT NO PROBLEM\r\n        // TODO : CREATE SOMETHING LIKE AN AUTOMATIC OVERFLOW SHADER WHICH RENDERS THE REST\r\n        // if (this.count > Const.MAX_U16) {\r\n        //     this.count = Const.MAX_U16;\r\n        //     console.warn(\"mesh max reached.\");\r\n        // }\r\n    }\r\n    // set only the basic elements.\r\n    // use this to dynamicly alter things like position and color,\r\n    // without refilling all buffers with it\r\n    setShallow(gl, rend) {\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // position\r\n        gl.uniformMatrix4fv(this.u_personal_matrix, false, rend.position.data);\r\n        // color\r\n        let color = rend.color;\r\n        // shift shadow to darker, slightly to blue\r\n        let shadowColor = color.map((x) => x * 0.25);\r\n        shadowColor[2] = Math.min(1, shadowColor[2] * 1.05);\r\n        // shift bright color slightly to yellow\r\n        let brightColor = color.map((x) => x);\r\n        brightColor[0] = Math.min(1, brightColor[0] * 1.05);\r\n        brightColor[1] = Math.min(1, brightColor[1] * 1.05);\r\n        brightColor[2] = Math.min(1, brightColor[2] * 1);\r\n        gl.uniform3fv(this.u_ambient_light, shadowColor.slice(0, 3));\r\n        gl.uniform3fv(this.u_dir_light_color, brightColor.slice(0, 3));\r\n    }\r\n    // render the previous set data to the screen\r\n    render(c) {\r\n        // console.log(\"rendering..\");\r\n        let gl = this.gl;\r\n        let camera = c.camera;\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_normal_matrix, false, _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity().data);\r\n        gl.uniformMatrix4fv(this.u_model_view_matrix, false, camera.worldMatrix.data);\r\n        gl.uniformMatrix4fv(this.u_projection_matrix, false, camera.projectMatrix.data);\r\n        // set light direction\r\n        let vec = camera.getMouseWorldRay(gl.canvas.width, gl.canvas.height, false).normal;\r\n        gl.uniform3fv(this.u_dir_light_vector, _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX().add(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY()).add(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ()).normalize().toArray());\r\n        // buffer 1\r\n        gl.enableVertexAttribArray(this.a_vertex_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n        gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.enableVertexAttribArray(this.a_vertex_normal);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n        gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 3\r\n        // gl.enableVertexAttribArray(this.a_vertex_ambi);\r\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n        // gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // draw!\r\n        // NOTE: We can increase the number of triangles we can maximally draw!!!!\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements\r\n        // When using the OES_element_index_uint extension:\r\n        // gl.UNSIGNED_INT;\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/shaded-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/simple-mesh-overlay-renderer.ts":
/*!************************************************************************!*\
  !*** ../engine/src/render/shaders-old/simple-mesh-overlay-renderer.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SimpleMeshOverlayRenderer\": () => (/* binding */ SimpleMeshOverlayRenderer)\n/* harmony export */ });\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n/**\r\n * Draw a mesh on top of all other meshes\r\n */\r\nclass SimpleMeshOverlayRenderer extends _OldShader__WEBPACK_IMPORTED_MODULE_1__.OldShader {\r\n    constructor(gl, color = [1, 0, 0, 0.25], forcedZ = 0.0001) {\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n            gl_Position.z = ${forcedZ};\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // we need 2 buffers\r\n        // -> 1 float buffer for the positions of all vertices.\r\n        // -> 1 int buffer for the index of all triangles\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(rend, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        let mesh = rend.mesh;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // color\r\n        let color = rend.color;\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        this.size = 3;\r\n        var type = gl.FLOAT;\r\n        var normalize = false;\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.slice().data, speed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.links.data, speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/simple-mesh-overlay-renderer.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/simple-mesh-shader.ts":
/*!**************************************************************!*\
  !*** ../engine/src/render/shaders-old/simple-mesh-shader.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SimpleMeshShader\": () => (/* binding */ SimpleMeshShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\nclass SimpleMeshShader extends _OldShader__WEBPACK_IMPORTED_MODULE_1__.OldShader {\r\n    constructor(gl, color = [1, 0, 0, 0.25]) {\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // we need 2 buffers\r\n        // -> 1 float buffer for the positions of all vertices.\r\n        // -> 1 int buffer for the index of all triangles\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(mesh, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        this.size = 3;\r\n        var type = gl.FLOAT;\r\n        var normalize = false;\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.slice().data, speed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.links.data, speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/simple-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/texture-mesh-shader.ts":
/*!***************************************************************!*\
  !*** ../engine/src/render/shaders-old/texture-mesh-shader.ts ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureMeshShader\": () => (/* binding */ TextureMeshShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n/* harmony import */ var _webgl_UniformTexture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/UniformTexture */ \"../engine/src/render/webgl/UniformTexture.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\nclass TextureMeshShader extends _OldShader__WEBPACK_IMPORTED_MODULE_1__.OldShader {\r\n    constructor(gl, pixelPerfect = true) {\r\n        const vs = `\r\n        // precision mediump int;\r\n        // precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        attribute vec2 a_texcoord;\r\n\r\n        uniform mat4 u_transform;\r\n\r\n        varying vec2 v_texcoord;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n            v_texcoord = a_texcoord;\r\n        }\r\n        `;\r\n        let fs;\r\n        if (pixelPerfect) {\r\n            fs = `\r\n            precision mediump float;\r\n    \r\n            varying vec2 v_texcoord;\r\n\r\n            uniform vec2 u_texture_size;\r\n            uniform sampler2D u_texture;\r\n    \r\n            // make pixel-perfect, but round it so it has no artefacts.\r\n            vec2 snapPixel(vec2 uv, vec2 size, vec2 alpha) {\r\n                vec2 pixel_uv = uv * size;\r\n                vec2 x = fract(pixel_uv);\r\n                vec2 x_ = clamp(0.5 / alpha * x, 0.0, 0.5) +\r\n                          clamp(0.5 / alpha * (x - 1.0) + 0.5, 0.0, 0.5);\r\n                return clamp((floor(pixel_uv) + x_) / size, 0.0, 0.9999);\r\n            } \r\n\r\n            void main() {\r\n                vec2 coord = snapPixel(v_texcoord, u_texture_size, vec2(0.02));\r\n                gl_FragColor = texture2D(u_texture, coord);\r\n            }\r\n            `;\r\n        }\r\n        else {\r\n            fs = `\r\n            precision mediump float;\r\n    \r\n            varying vec2 v_texcoord;\r\n    \r\n            uniform vec2 u_texture_size;\r\n            uniform sampler2D u_texture;\r\n    \r\n            void main() {\r\n                gl_FragColor = texture2D(u_texture, v_texcoord);\r\n            }\r\n            `;\r\n        }\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // init uniforms\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_texture_size = gl.getUniformLocation(this.program, \"u_texture_size\");\r\n        this.u_texture = gl.getUniformLocation(this.program, \"u_texture\");\r\n        // init three buffers: verts | uvs | links\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.a_texcoord = gl.getAttribLocation(this.program, \"a_texcoord\");\r\n        this.a_texcoord_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // init texture\r\n        this.texture_id = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__.HelpGl.getNextTextureID();\r\n        this.texture = gl.createTexture();\r\n    }\r\n    static new(gl, pixelPerfect = true) {\r\n        return new TextureMeshShader(gl, pixelPerfect);\r\n    }\r\n    set(r, speed) {\r\n        let gl = this.gl;\r\n        if (!r.texture) {\r\n            console.warn(\"Mesh does not contain a texture!\");\r\n            return;\r\n        }\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = r.mesh.links.data.length;\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, r.mesh.verts.matrix.data, speed);\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, r.uvs.data, speed);\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(r.mesh.links.data), speed);\r\n        // texture\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r.texture);\r\n        gl.uniform2f(this.u_texture_size, r.texture.width, r.texture.height);\r\n        // alternative texture -> Fill the texture with a 1x1 blue pixel.\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 128, 128, 255]));\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, mesh.texture.data);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    setWithMesh(mesh, texture, speed) {\r\n        let gl = this.gl;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.slice().data, speed);\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.uvs.toMatrixSlice().data, speed);\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(mesh.links.data), speed);\r\n        // texture\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, texture.data);\r\n        gl.uniform2f(this.u_texture_size, texture.width, texture.height);\r\n        // alternative texture -> Fill the texture with a 1x1 blue pixel.\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 128, 128, 255]));\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, mesh.texture.data);\r\n        // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n        if ((0,_webgl_UniformTexture__WEBPACK_IMPORTED_MODULE_2__.isPowerOf2)(texture.width) && (0,_webgl_UniformTexture__WEBPACK_IMPORTED_MODULE_2__.isPowerOf2)(texture.height)) {\r\n            // Yes, it's a power of 2. Generate mips.\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            // No, it's not a power of 2. Turn off mips and set\r\n            // wrapping to clamp to edge\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n    }\r\n    render(context) {\r\n        let gl = this.gl;\r\n        let camera = context.camera;\r\n        let matrix = camera.totalMatrix;\r\n        // console.log(\"rendering..\");\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // set texture\r\n        gl.uniform1i(this.u_texture, this.texture_id);\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        // buffer 1\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.enableVertexAttribArray(this.a_texcoord);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // draw!\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/texture-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/transform-line-shader.ts":
/*!*****************************************************************!*\
  !*** ../engine/src/render/shaders-old/transform-line-shader.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TransformLineShader\": () => (/* binding */ TransformLineShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\n\r\nclass TransformLineShader extends _OldShader__WEBPACK_IMPORTED_MODULE_2__.OldShader {\r\n    constructor(gl, color = [1, 0, 0, 0.5]) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform mat4 u_personal;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * u_personal * a_position;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_personal = gl.getUniformLocation(this.program, \"u_personal\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // set uniforms which wont change\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n        this.personal = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity();\r\n        this.color = color;\r\n    }\r\n    static new(gl, color = [1, 0, 0, 0.5]) {\r\n        return new TransformLineShader(gl, color);\r\n    }\r\n    set(data, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        // save how many faces need to be drawn\r\n        let gl = this.gl;\r\n        let links;\r\n        let verts;\r\n        // extract\r\n        verts = data.mesh.verts;\r\n        links = data.mesh.toLines().links.getData();\r\n        this.personal = data.position;\r\n        this.color = data.linecolor;\r\n        // set it\r\n        gl.useProgram(this.program);\r\n        this.count = links.length;\r\n        this.vertCount = verts.slice().width;\r\n        let drawspeed = speed;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, verts.slice().data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, links.buffer, drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        //\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        //\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniformMatrix4fv(this.u_personal, false, this.personal.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/transform-line-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders-old/transform-mesh-shader.ts":
/*!*****************************************************************!*\
  !*** ../engine/src/render/shaders-old/transform-mesh-shader.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TransformMeshShader\": () => (/* binding */ TransformMeshShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _OldShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../OldShader */ \"../engine/src/render/OldShader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\nclass TransformMeshShader extends _OldShader__WEBPACK_IMPORTED_MODULE_2__.OldShader {\r\n    constructor(gl, color = [1, 0, 0, 0.25]) {\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform mat4 u_personal;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * u_personal * a_position;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_personal = gl.getUniformLocation(this.program, \"u_personal\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // we need 2 buffers\r\n        // -> 1 float buffer for the positions of all vertices.\r\n        // -> 1 int buffer for the index of all triangles\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        this.personal = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity();\r\n        this.color = color;\r\n    }\r\n    set(data, speed = _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        let mesh = data.mesh;\r\n        this.color = data.color;\r\n        this.personal = data.position;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        this.size = 3;\r\n        var type = gl.FLOAT;\r\n        var normalize = false;\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.slice().data, speed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.links.data, speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniformMatrix4fv(this.u_personal, false, this.personal.data);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // Draw the point.\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl_HelpGl__WEBPACK_IMPORTED_MODULE_1__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders-old/transform-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/AmbientMeshShader.ts":
/*!*********************************************************!*\
  !*** ../engine/src/render/shaders/AmbientMeshShader.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AmbientMeshShader\": () => (/* binding */ AmbientMeshShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\n\r\nclass AmbientMeshShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_1__.ShaderProgram {\r\n    constructor(gl) {\r\n        const vertexShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 vertexPosition;\r\n        uniform mat4 worldMatrix;\r\n\r\n        void main() {\r\n            gl_Position = worldMatrix * vertexPosition;\r\n        }\r\n        `;\r\n        const fragmentShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 ambientColor;\r\n\r\n        void main () {\r\n            gl_FragColor = ambientColor;\r\n        }\r\n        `;\r\n        super(gl, vertexShader, fragmentShader);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"vertexPosition\", 3);\r\n        this.attributes.addIndex(_webgl_Constants__WEBPACK_IMPORTED_MODULE_0__.DrawElementsType.UnsignedShort);\r\n        this.uniforms.add(\"ambientColor\", 4, [1.0, 1.0, 1.0, 1.0]);\r\n        this.uniforms.add(\"worldMatrix\", 16);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_0__.DrawMode.Triangles;\r\n    }\r\n    onLoad(mesh, speed) {\r\n        this.attributes.load(\"vertexPosition\", mesh.verts.slice().data, speed);\r\n        this.attributes.loadIndex(mesh.links.data, speed);\r\n        return mesh.links.data.length;\r\n    }\r\n    loadColor(color) {\r\n        this.useProgram();\r\n        this.uniforms.loadColor(\"ambientColor\", color);\r\n    }\r\n    onDraw(c) {\r\n        this.uniforms.loadMatrix4(\"worldMatrix\", c.camera.totalMatrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/AmbientMeshShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/BillboardShader.ts":
/*!*******************************************************!*\
  !*** ../engine/src/render/shaders/BillboardShader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Billboard\": () => (/* binding */ Billboard),\n/* harmony export */   \"BillboardShader\": () => (/* binding */ BillboardShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n// https://webgl.brown37.net/12_advanced_rendering/07_rendering_points.html\r\n\r\n\r\n\r\n/**\r\n * A single billboard\r\n */\r\nclass Billboard {\r\n    constructor(position, image) {\r\n        this.position = position;\r\n        this.image = image;\r\n    }\r\n    static new(position, image) {\r\n        return new Billboard(position, image);\r\n    }\r\n    toPayload() {\r\n        return {\r\n            positions: _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList([this.position]),\r\n            uvs: _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData([0, 0]),\r\n            uvSizes: _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData([this.image.width, this.image.height]),\r\n            texture: this.image,\r\n        };\r\n    }\r\n}\r\n/**\r\n * Used to render multiple billboards.\r\n * One Texture per billboard.\r\n */\r\nclass BillboardShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__.ShaderProgram {\r\n    constructor(gl, color = [1, 1, 1, 1], radius = 100) {\r\n        let vertexSource = `\r\n        // Vertex Shader\r\n        precision mediump int;\r\n        precision mediump float;\r\n        \r\n        uniform mat4  u_transform;\r\n        uniform vec3  u_camera_position;\r\n        uniform float u_size;\r\n \r\n        attribute vec3 a_vertex;\r\n        attribute vec2 a_uv;\r\n        attribute vec2 a_uv_wh;\r\n        \r\n        varying vec2  uv;\r\n        varying vec2  uv_size;\r\n        varying float point_size;\r\n        \r\n        void main() {\r\n        \r\n            // edit size based on distance from camera\r\n            float value = 15.0; // TODO how to derrive this???\r\n            float dis = distance(a_vertex, u_camera_position);\r\n            float size = u_size / (dis / value);\r\n            gl_PointSize = size;\r\n            point_size = size;\r\n\r\n            // Pass the point's texture coordinate to the fragment shader\r\n            uv = a_uv;\r\n            uv_size = a_uv_wh;\r\n            \r\n            // Transform the location of the vertex.\r\n            gl_Position = u_transform * vec4(a_vertex, 1.0);\r\n        }\r\n\r\n        `;\r\n        let fragmentSource = `\r\n\r\n        precision mediump int;\r\n        precision mediump float;\r\n    \r\n        uniform sampler2D u_texture;\r\n        uniform vec2      u_texture_size;  // delta_s, delta_t\r\n        \r\n        varying vec2  uv;\r\n        varying vec2  uv_size;\r\n        varying float point_size; // can this be replaced with u_size ??\r\n\r\n\r\n        void main() {\r\n            // NOTE this can be done way easier, we dont need uv sized, we just need to go to pixel space\r\n            \r\n            // make pixel-perfect, but round it so it has no artefacts.\r\n            // coord ~= gp_PointCoord\r\n            vec2 sprite_uv = gl_PointCoord * uv_size;\r\n            vec2 alpha = vec2(0.03);\r\n            vec2 x = fract(sprite_uv);\r\n            vec2 x_ = clamp(0.5 / alpha * x, 0.0, 0.5) +\r\n                      clamp(0.5 / alpha * (x - 1.0) + 0.5, 0.0, 0.5);\r\n            vec2 coord = (floor(sprite_uv) + x_);\r\n\r\n            // take the right part of the spritemap\r\n            vec2 texture_fraction = 1.0 / u_texture_size;\r\n            vec2 texture_topleft = uv * texture_fraction;\r\n            vec2 realCoord = texture_topleft + coord / u_texture_size;\r\n\r\n            gl_FragColor = texture2D(u_texture, realCoord);\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vertexSource, fragmentSource);\r\n        this.uniforms.add(\"u_transform\", 16);\r\n        this.radius = this.uniforms.add(\"u_size\", 1, [radius]);\r\n        this.color = this.uniforms.add(\"u_color\", 4, color);\r\n        this.uniforms.add(\"u_camera_position\", 3);\r\n        this.uniforms.add(\"u_texture_size\", 2, [16, 16]);\r\n        this.uniforms.addTexture(\"u_texture\");\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"a_vertex\", 3);\r\n        this.attributes.add(\"a_uv\", 2);\r\n        this.attributes.add(\"a_uv_wh\", 2);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawMode.Points;\r\n    }\r\n    onLoad(payload, speed) {\r\n        if (payload instanceof Billboard) {\r\n            payload = payload.toPayload();\r\n        }\r\n        this.attributes.load(\"a_vertex\", (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(payload.positions).data, speed);\r\n        this.attributes.load(\"a_uv\", (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(payload.uvs).data, speed);\r\n        this.attributes.load(\"a_uv_wh\", (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(payload.uvSizes).data, speed);\r\n        this.uniforms.loadTexture(\"u_texture\", payload.texture);\r\n        this.uniforms.load2(\"u_texture_size\", _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(payload.texture.width, payload.texture.height));\r\n        return payload.positions.count;\r\n    }\r\n    onDraw(c) {\r\n        this.uniforms.load3(\"u_camera_position\", c.camera.pos.scaled(-1));\r\n        this.uniforms.loadMatrix4(\"u_transform\", c.camera.totalMatrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/BillboardShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/DepthMeshShader.ts":
/*!*******************************************************!*\
  !*** ../engine/src/render/shaders/DepthMeshShader.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DepthMeshShader\": () => (/* binding */ DepthMeshShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\n\r\nclass DepthMeshShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_1__.ShaderProgram {\r\n    constructor(gl) {\r\n        const vertexShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 vertexPosition;\r\n\r\n        uniform mat4 worldMatrix;\r\n\r\n        void main() {\r\n            gl_Position = worldMatrix * vertexPosition;\r\n        }\r\n        `;\r\n        const fragmentShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 ambientColor;\r\n\r\n        uniform float far;\r\n        uniform float near;\r\n\r\n        void main () {\r\n\r\n            float depth = gl_FragCoord.z * 0.06 + 0.6;\r\n            gl_FragColor = vec4(depth);\r\n        }\r\n        `;\r\n        super(gl, vertexShader, fragmentShader);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"vertexPosition\", 3);\r\n        this.attributes.addIndex(_webgl_Constants__WEBPACK_IMPORTED_MODULE_0__.DrawElementsType.UnsignedShort);\r\n        this.uniforms.add(\"ambientColor\", 4, [1.0, 1.0, 1.0, 1.0]);\r\n        this.uniforms.add(\"worldMatrix\", 16);\r\n        this.uniforms.add(\"far\", 1);\r\n        this.uniforms.add(\"near\", 1);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_0__.DrawMode.Triangles;\r\n    }\r\n    onLoad(mesh, speed) {\r\n        this.attributes.load(\"vertexPosition\", mesh.verts.slice().data, speed);\r\n        this.attributes.loadIndex(mesh.links.data, speed);\r\n        return mesh.links.data.length;\r\n    }\r\n    loadColor(color) {\r\n        this.useProgram();\r\n        this.uniforms.loadColor(\"ambientColor\", color);\r\n    }\r\n    onDraw(c) {\r\n        this.uniforms.loadMatrix4(\"worldMatrix\", c.camera.totalMatrix);\r\n        this.uniforms.load(\"far\", c.camera.zFar);\r\n        this.uniforms.load(\"near\", c.camera.zNear);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/DepthMeshShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/DotShaderWithHeight.ts":
/*!***********************************************************!*\
  !*** ../engine/src/render/shaders/DotShaderWithHeight.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotShaderWithHeight\": () => (/* binding */ DotShaderWithHeight)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n// jos feenstra\r\n\r\n\r\n\r\nclass DotShaderWithHeight extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__.ShaderProgram {\r\n    constructor(gl, radius = 5, color = [1, 1, 1, 1], height, square = true) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n        uniform float u_range;\r\n        uniform float u_size;\r\n\r\n        attribute vec3 a_vertex;\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main() {\r\n            // Set the size of a rendered point.\r\n            gl_PointSize = u_size;\r\n            float factor = a_vertex.z / u_range;\r\n\r\n            v_color = vec4(u_color.xyz * factor, 1);\r\n\r\n            // Transform the location of the vertex.\r\n            gl_Position = u_transform * vec4(a_vertex, 1.0);\r\n        }\r\n\r\n        `;\r\n        let fragmentSourceSquare = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        // vec2 center = vec2(0.5, 0.5);\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main() {\r\n            gl_FragColor = v_color;\r\n        }\r\n        `;\r\n        let fragmentSourceRound = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        vec2 center = vec2(0.5, 0.5);\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main() {\r\n            if (distance(center, gl_PointCoord) > 0.5) {\r\n               discard;\r\n            }\r\n            gl_FragColor = v_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        if (square) {\r\n            super(gl, vertexSource, fragmentSourceSquare);\r\n        }\r\n        else {\r\n            super(gl, vertexSource, fragmentSourceRound);\r\n        }\r\n        this.uniforms.add(\"u_transform\", 16);\r\n        this.size = this.uniforms.add(\"u_size\", 1, [radius]);\r\n        this.color = this.uniforms.add(\"u_color\", 4, color);\r\n        this.height = this.uniforms.add(\"u_range\", 1, [height]);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"a_vertex\", 3);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawMode.Points;\r\n    }\r\n    onLoad(points, speed) {\r\n        let array = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(points);\r\n        this.attributes.load(\"a_vertex\", array.data, speed);\r\n        return array.count();\r\n    }\r\n    onDraw(c) {\r\n        this.uniforms.loadMatrix4(\"u_transform\", c.camera.totalMatrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/DotShaderWithHeight.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/PhongShader.ts":
/*!***************************************************!*\
  !*** ../engine/src/render/shaders/PhongShader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PhongShader\": () => (/* binding */ PhongShader)\n/* harmony export */ });\n/* harmony import */ var _image_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../image/Color */ \"../engine/src/image/Color.ts\");\n/* harmony import */ var _math_Transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Transform */ \"../engine/src/math/Transform.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\n\r\n\r\n\r\n// TODO: do we want to add textures? they complicate a lot....\r\n// PhongEntityShader | TextureEntityShader\r\nclass PhongShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_3__.ShaderProgram {\r\n    constructor(gl) {\r\n        const vertexShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 position;\r\n        attribute vec2 uv;\r\n        attribute vec3 normal;\r\n        attribute float occlusion;\r\n        \r\n        uniform mat4 worldMatrix;\r\n        uniform mat4 worldInverse;\r\n        uniform mat4 modelMatrix;\r\n        uniform vec3 sunPosition;\r\n        uniform vec3 cameraPosition;\r\n\r\n        varying vec2 varUv;\r\n        varying vec3 varNormal;\r\n        varying vec3 varToSun;\r\n        varying vec3 varToCamera;\r\n        varying float varVectorOcclusion;\r\n\r\n        void main() {\r\n            vec4 worldPosition = modelMatrix * position;\r\n            gl_Position = worldMatrix * worldPosition;\r\n            \r\n            varUv = uv;\r\n            varNormal = mat3(modelMatrix) * normal;\r\n            varToSun = sunPosition - worldPosition.xyz;\r\n            varToCamera = cameraPosition - worldPosition.xyz;\r\n            varVectorOcclusion = occlusion;\r\n        }\r\n        `;\r\n        const fragmentShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 ambient;\r\n        uniform vec4 diffuse;\r\n        uniform vec4 specular;\r\n        uniform vec4 occluded;\r\n        uniform float opacity;\r\n        uniform float specularDampner;\r\n\r\n        uniform float textureBlend;\r\n        uniform sampler2D u_texture;\r\n\r\n        varying float varVectorOcclusion;\r\n        varying vec2 varUv;\r\n        varying vec3 varNormal;\r\n        varying vec3 varToSun;\r\n        varying vec3 varToCamera;\r\n\r\n        // float smooth(float t) {\r\n        //     // Fade function as defined by Ken Perlin.  This eases coordinate values\r\n        //     // so that they will ease towards integral values.  This ends up smoothing\r\n        //     // the final output.\r\n        //     return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); // 6t^5 - 15t^4 + 10t^3\r\n        // }\r\n    \r\n        void main () {\r\n\r\n            // normalize \r\n            // vec3 toSun = varToSun;\r\n            // vec3 normal = varNormal;\r\n            // vec3 toCamera = varToCamera;\r\n\r\n            vec3 toSun = normalize(varToSun);\r\n            vec3 normal = normalize(varNormal);\r\n            vec3 toCamera = normalize(varToCamera);\r\n            \r\n            // ambient\r\n            // vec4 ambientColor = ambient * (1.0 - textureBlend) + textureBlend * texture2D(u_texture, varUv);\r\n            vec4 ambientColor = ambient;\r\n\r\n            // occluded (TODO: expand upon this using ambient occlusion)\r\n            float sunDot = dot(normal, toSun);\r\n            float occlusion = clamp(sunDot, -1.0, 0.0) * -1.0;\r\n            occlusion = min(occlusion + varVectorOcclusion, 1.0);\r\n            vec4 occludedColor = occluded * occlusion + ambientColor * (1.0 - occlusion);\r\n\r\n            // diffuse \r\n            float diffusion = max(0.0, sunDot);\r\n            vec4 diffuseColor = diffuse * diffusion; \r\n\r\n            // specular\r\n            vec3 reflectedLight = reflect(-toSun, normal);\r\n            float reflection = max(0.0, dot(reflectedLight, toCamera));\r\n            reflection = pow(reflection, specularDampner);\r\n            // reflection = smooth(reflection);\r\n            vec4 specularColor = vec4(reflection * specular.xyz, 1.0); \r\n\r\n            gl_FragColor = max(occludedColor, diffuseColor) + specularColor;\r\n            // gl_FragColor = vec4(normal, 1.0);\r\n        }\r\n        `;\r\n        super(gl, vertexShader, fragmentShader);\r\n    }\r\n    static new(gl) {\r\n        return new PhongShader(gl);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"position\", 3);\r\n        this.attributes.add(\"uv\", 2);\r\n        this.attributes.add(\"normal\", 3);\r\n        this.attributes.add(\"occlusion\", 1);\r\n        this.attributes.addIndex(_webgl_Constants__WEBPACK_IMPORTED_MODULE_2__.DrawElementsType.UnsignedShort);\r\n        this.uniforms.add(\"worldMatrix\", 16);\r\n        this.uniforms.add(\"worldInverse\", 16);\r\n        this.uniforms.add(\"modelMatrix\", 16);\r\n        this.uniforms.add(\"sunPosition\", 3);\r\n        this.uniforms.add(\"cameraPosition\", 3);\r\n        this.uniforms.add(\"ambient\", 4, _image_Color__WEBPACK_IMPORTED_MODULE_0__.Color.fromHSL(0, 0).data);\r\n        this.uniforms.add(\"diffuse\", 4, [1.0, 1.0, 1.0, 1.0]);\r\n        this.uniforms.add(\"specular\", 4, [1.0, 1.0, 1.0, 1.0]);\r\n        this.uniforms.add(\"occluded\", 4, [0.2, 0.2, 0.2, 1.0]);\r\n        this.uniforms.add(\"opacity\", 1, [1.0]);\r\n        this.uniforms.add(\"specularDampner\", 1, [0.5]);\r\n        this.uniforms.add(\"textureBlend\", 1, [0.0]);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_2__.DrawMode.Triangles;\r\n    }\r\n    onLoad(e, speed) {\r\n        this.loadTransform(e.xform);\r\n        this.loadMesh(e.model.mesh, speed);\r\n        this.loadMaterial(e.model.material);\r\n        return e.model.mesh.maxSize;\r\n    }\r\n    loadOcclusion(data, speed) {\r\n        this.useProgram();\r\n        this.attributes.load(\"occlusion\", data, speed);\r\n    }\r\n    loadTransform(xform) {\r\n        this.useProgram();\r\n        // let euler = position.decompose()[1];\r\n        // let rotation = Matrix3.newRotation(euler);\r\n        this.uniforms.loadMatrix4(\"modelMatrix\", xform instanceof _math_Transform__WEBPACK_IMPORTED_MODULE_1__.Transform ? xform.toMatrix() : xform);\r\n    }\r\n    loadMesh(mesh, speed) {\r\n        this.useProgram();\r\n        // handle index-less meshes \r\n        if (mesh.links) {\r\n            this.attributes.loadIndex(mesh.links.data, speed);\r\n        }\r\n        else {\r\n            this.setDrawCount(mesh.maxSize);\r\n            this.attributes.unloadIndex();\r\n            this.updateDrawMethod();\r\n        }\r\n        this.attributes.load(\"position\", mesh.verts.matrix.data, speed);\r\n        if (mesh.uvs)\r\n            this.attributes.load(\"uv\", mesh.uvs.matrix.data, speed); // this.attributes.unload(\"uv\");\r\n        if (mesh.normals)\r\n            this.attributes.load(\"normal\", mesh.normals.matrix.data, speed); //this.attributes.unload(\"normal\");\r\n        this.attributes.unload(\"occlusion\");\r\n    }\r\n    loadMaterial(material) {\r\n        this.useProgram();\r\n        this.uniforms.loadColor(\"ambient\", material.ambient);\r\n        this.uniforms.loadColor(\"diffuse\", material.diffuse);\r\n        this.uniforms.loadColor(\"specular\", material.specular);\r\n        this.uniforms.loadColor(\"occluded\", material.occluded);\r\n        this.uniforms.load(\"opacity\", material.opacity);\r\n        this.uniforms.load(\"specularDampner\", material.specularDampner);\r\n        if (material.texture) {\r\n            this.loadTexture(material.texture);\r\n        }\r\n    }\r\n    loadTexture(texture) {\r\n        this.useProgram();\r\n        this.uniforms.addTexture(\"u_texture\");\r\n        this.uniforms.loadTexture(\"u_texture\", texture);\r\n        this.uniforms.add(\"textureBlend\", 1, [1.0]);\r\n    }\r\n    onDraw(s) {\r\n        this.uniforms.loadMatrix4(\"worldMatrix\", s.camera.totalMatrix);\r\n        this.uniforms.loadMatrix4(\"worldInverse\", s.camera.inverseTransposeMatrix);\r\n        this.uniforms.load3(\"sunPosition\", s.sun.pos);\r\n        this.uniforms.load3(\"cameraPosition\", s.camera.getActualPosition());\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/PhongShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/SkyBoxShader.ts":
/*!****************************************************!*\
  !*** ../engine/src/render/shaders/SkyBoxShader.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SkyBoxShader\": () => (/* binding */ SkyBoxShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\n\r\n\r\n/**\r\n * quite literarly taken from https://webglfundamentals.org/webgl/lessons/webgl-skybox.html, saw no reason to change it\r\n */\r\nclass SkyBoxShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__.ShaderProgram {\r\n    constructor(gl) {\r\n        const vertexShader = `\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        varying vec4 v_position;\r\n        uniform mat4 u_viewDirectionProjectionInverse;\r\n\r\n        void main() {\r\n\r\n            v_position = a_position;\r\n            gl_Position = a_position;\r\n            gl_Position.z = 1.0;\r\n        }\r\n        `;\r\n        const CubeMapfragmentShader = `\r\n        #define PI 3.1415926538;\r\n        #define TWO_PI 2.0 * PI;\r\n\r\n        precision mediump float;\r\n     \r\n        uniform samplerCube u_skybox;\r\n        uniform mat4 u_viewDirectionProjectionInverse;\r\n         \r\n        varying vec4 v_position;\r\n\r\n        void main() {\r\n            vec4 t = u_viewDirectionProjectionInverse * v_position;\r\n            vec3 normal = normalize(t.xyz / t.w);\r\n\r\n            // using cubemap\r\n            gl_FragColor = textureCube(u_skybox, normal);\r\n        }\r\n        `;\r\n        const textureFragmentShader = `\r\n        #define PI 3.1415926538;\r\n        #define TWO_PI 2.0 * PI;\r\n\r\n        precision mediump float;\r\n     \r\n        uniform samplerCube u_skybox;\r\n        uniform mat4 u_viewDirectionProjectionInverse;\r\n         \r\n        varying vec4 v_position;\r\n\r\n        // vec2 to_lat_long_normalized(vec3 normal) {\r\n        //     float longitude = atan(normal.y, normal.x) / TWO_PI;\r\n        //     float latitude = 0.0;\r\n        //     return vec2(longitude, latitude);\r\n        // }\r\n\r\n        vec2 to_polar(vec3 normal) {\r\n            vec2 dir = normalize(normal.xy);\r\n            float delta = acos(abs(normal.z)) / PI;\r\n            return vec2(0.5, 0.5) + dir * delta; \r\n        }\r\n\r\n        // vec3 to_sphere(vec3 P) {\r\n        //     float r = sqrt(P.x*P.x + P.y*P.y + P.z*P.z);\r\n        //     float theta = atan(P.y, P.x);\r\n        //     float phi = acos(P.z/r);\r\n        //     return vec3(r, theta, phi);\r\n        // }\r\n        \r\n        // vec3 to_cart(vec3 P) {\r\n        //     float r = P.x;\r\n        //     float theta = P.y;\r\n        //     float phi = P.z;\r\n        //     return r * vec3(cos(phi)*sin(theta),sin(phi)*sin(theta),cos(theta));\r\n        // }\r\n\r\n        void main() {\r\n            vec4 t = u_viewDirectionProjectionInverse * v_position;\r\n            vec3 normal = normalize(t.xyz / t.w);\r\n\r\n            // debug\r\n            // gl_FragColor = vec4((normal + 1.0) * 0.5, 1.0);\r\n\r\n            // using cubemap\r\n            // gl_FragColor = textureCube(u_skybox, normal);\r\n\r\n            // using single texture with polar projection\r\n            // vec2 polar = to_polar(normal);\r\n            // gl_FragColor = texture2D(u_skybox, polar);\r\n            // gl_FragColor = vec4(1,0.8,0,1);\r\n        }\r\n        `;\r\n        super(gl, vertexShader, CubeMapfragmentShader);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"a_position\", 2);\r\n        this.uniforms.add(\"u_viewDirectionProjectionInverse\", 16, _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity().data);\r\n        this.uniforms.addCubeMap(\"u_skybox\");\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawMode.Triangles;\r\n    }\r\n    onLoad(urls, speed) {\r\n        var quad = new Float32Array([\r\n            -1, -1,\r\n            1, -1,\r\n            -1, 1,\r\n            -1, 1,\r\n            1, -1,\r\n            1, 1,\r\n        ]);\r\n        this.attributes.load(\"a_position\", quad, speed);\r\n        this.uniforms.loadCubeMapUrls(\"u_skybox\", urls);\r\n        return 6;\r\n    }\r\n    onDraw(c) {\r\n        // let our quad pass the depth test at 1.0\r\n        // this.gl.depthFunc(this.gl.LEQUAL);\r\n        this.uniforms.loadMatrix4(\"u_viewDirectionProjectionInverse\", c.camera.inverseTotalViewMatrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/SkyBoxShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/TemplateShader.ts":
/*!******************************************************!*\
  !*** ../engine/src/render/shaders/TemplateShader.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TemplateShader\": () => (/* binding */ TemplateShader)\n/* harmony export */ });\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\nclass TemplateShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__.ShaderProgram {\r\n    /**\r\n     * Compile the shader\r\n     */\r\n    constructor(gl) {\r\n        let vertexShader = ``;\r\n        let fragmentShader = ``;\r\n        super(gl, ``, ``);\r\n    }\r\n    /**\r\n     * Init all attributes & uniforms\r\n     * Return the DrawMore required for the vertexshader & fragmentshader\r\n     */\r\n    onInit() {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    /**\r\n     * Main load: fill attributes.\r\n     * Return the drawcount, aka the number to feed to DrawElements or DrawArrays\r\n     */\r\n    onLoad(data, speed) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    /**\r\n     * Sub load: fill other attributes or uniforms\r\n     */\r\n    loadSomeOtherUniform() {\r\n    }\r\n    /**\r\n     * Specify which data we need from the scene at runtime\r\n     */\r\n    onDraw(c) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/TemplateShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/TexturedMeshShader.ts":
/*!**********************************************************!*\
  !*** ../engine/src/render/shaders/TexturedMeshShader.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TexturedMeshShader\": () => (/* binding */ TexturedMeshShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\n\r\n\r\nclass TexturedMeshShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__.ShaderProgram {\r\n    constructor(gl) {\r\n        const vs = `\r\n        // precision mediump int;\r\n        // precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        attribute vec2 a_uv;\r\n\r\n        uniform mat4 u_transform;\r\n\r\n        varying vec2 v_texcoord;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n            v_texcoord = a_uv;\r\n        }\r\n        `;\r\n        let fs;\r\n        let pixelPerfext = true;\r\n        if (pixelPerfext) {\r\n            fs = `\r\n            precision mediump float;\r\n    \r\n            varying vec2 v_texcoord;\r\n\r\n            uniform vec2 u_texture_size;\r\n            uniform sampler2D u_texture;\r\n    \r\n            // make pixel-perfect, but round it so it has no artefacts.\r\n            vec2 snapPixel(vec2 uv, vec2 size, vec2 alpha) {\r\n                vec2 pixel_uv = uv * size;\r\n                vec2 x = fract(pixel_uv);\r\n                vec2 x_ = clamp(0.5 / alpha * x, 0.0, 0.5) +\r\n                          clamp(0.5 / alpha * (x - 1.0) + 0.5, 0.0, 0.5);\r\n                return clamp((floor(pixel_uv) + x_) / size, 0.0, 0.9999);\r\n            } \r\n\r\n            void main() {\r\n                vec2 coord = snapPixel(v_texcoord, u_texture_size, vec2(0.02));\r\n                gl_FragColor = texture2D(u_texture, coord);\r\n            }\r\n            `;\r\n        }\r\n        else {\r\n            fs = `\r\n            precision mediump float;\r\n    \r\n            varying vec2 v_texcoord;\r\n    \r\n            uniform vec2 u_texture_size;\r\n            uniform sampler2D u_texture;\r\n    \r\n            void main() {\r\n                gl_FragColor = texture2D(u_texture, v_texcoord);\r\n            }\r\n            `;\r\n        }\r\n        super(gl, vs, fs);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"a_position\", 3);\r\n        this.attributes.add(\"a_uv\", 2);\r\n        this.attributes.addIndex(_webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawElementsType.UnsignedShort);\r\n        this.uniforms.addTexture(\"u_texture\");\r\n        this.uniforms.add(\"u_transform\", 16);\r\n        this.uniforms.add(\"u_texture_size\", 2);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawMode.Triangles;\r\n    }\r\n    onLoad(mesh, speed) {\r\n        this.attributes.load(\"a_position\", mesh.verts.slice().data, speed);\r\n        this.attributes.load(\"a_uv\", mesh.uvs.data, speed);\r\n        this.attributes.loadIndex(mesh.links.data, speed);\r\n        return mesh.links.data.length;\r\n    }\r\n    loadTexture(width, height, source) {\r\n        this.useProgram();\r\n        this.uniforms.loadTextureSource(\"u_texture\", source);\r\n        this.uniforms.load2(\"u_texture_size\", _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(width, height));\r\n    }\r\n    onDraw(c) {\r\n        this.uniforms.loadMatrix4(\"u_transform\", c.camera.totalMatrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/TexturedMeshShader.ts?");

/***/ }),

/***/ "../engine/src/render/shaders/ZebraShader.ts":
/*!***************************************************!*\
  !*** ../engine/src/render/shaders/ZebraShader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZebraShader\": () => (/* binding */ ZebraShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl/Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl/ShaderProgram */ \"../engine/src/render/webgl/ShaderProgram.ts\");\n\r\n\r\n\r\nclass ZebraShader extends _webgl_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__.ShaderProgram {\r\n    constructor(gl, indexed = true) {\r\n        const vertexShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 position;\r\n        attribute vec2 uv;\r\n        attribute vec3 normal;\r\n        \r\n        uniform mat3 normalMatrix;\r\n        uniform mat4 worldMatrix;\r\n        uniform mat4 worldInverse;\r\n        uniform mat4 modelMatrix;\r\n        uniform vec3 sunPosition;\r\n        uniform vec3 cameraPosition;\r\n\r\n        varying vec2 varUv;\r\n        varying vec3 varNormal;\r\n        varying vec3 varToSun;\r\n        varying vec3 varToCamera;\r\n\r\n        void main() {\r\n            vec4 worldPosition = modelMatrix * position;\r\n            gl_Position = worldMatrix * worldPosition;\r\n            \r\n            varUv = uv;\r\n            varNormal = normalMatrix * normal;\r\n            varToSun = sunPosition - worldPosition.xyz;\r\n            varToCamera = cameraPosition - worldPosition.xyz;\r\n        }\r\n        `;\r\n        const fragmentShader = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        varying vec2 varUv;\r\n        varying vec3 varNormal;\r\n        varying vec3 varToSun;\r\n        varying vec3 varToCamera;\r\n    \r\n        uniform float zebraStripeCount;\r\n\r\n        // make from '/' curve a './' curve\r\n        float flattenPeakClamp(float x, float alpha) {\r\n            float beta = 0.5 - alpha;\r\n            float leftover = 1.0 - 2.0 * beta;\r\n            return clamp((x-beta) * (1.0 / leftover), 0.0, 1.0);\r\n        }\r\n\r\n        // make from '/' curve a '/\\' curve\r\n        float hillClamp(float x) {\r\n            float clamped = clamp(x, 0.0, 0.5) - clamp(x - 0.5, 0.0, 0.5);\r\n            return clamped * 2.0;\r\n        }\r\n\r\n        void main () {\r\n\r\n            // normalize \r\n            vec3 toSun = normalize(varToSun);\r\n            vec3 normal = normalize(varNormal);\r\n            vec3 toCamera = normalize(varToCamera);\r\n\r\n            // specular\r\n            vec3 reflectedLight = reflect(-toSun, normal);\r\n            float factor = dot(reflectedLight, toCamera);\r\n            factor = hillClamp(fract(factor * zebraStripeCount));\r\n            factor = flattenPeakClamp(factor, 0.05);\r\n\r\n            vec4 specularColor = vec4(vec3(factor), 1.0); \r\n\r\n            gl_FragColor = specularColor;\r\n        }\r\n        `;\r\n        super(gl, vertexShader, fragmentShader);\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"position\", 3);\r\n        this.attributes.add(\"uv\", 2);\r\n        this.attributes.add(\"normal\", 3);\r\n        this.attributes.addIndex(_webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawElementsType.UnsignedShort);\r\n        this.uniforms.add(\"worldMatrix\", 16);\r\n        this.uniforms.add(\"worldInverse\", 16);\r\n        this.uniforms.add(\"modelMatrix\", 16);\r\n        this.uniforms.add(\"normalMatrix\", 9);\r\n        this.uniforms.add(\"sunPosition\", 3);\r\n        this.uniforms.add(\"cameraPosition\", 3);\r\n        this.uniforms.add(\"zebraStripeCount\", 1, [7.0]);\r\n        return _webgl_Constants__WEBPACK_IMPORTED_MODULE_1__.DrawMode.Triangles;\r\n    }\r\n    onLoad(e, speed) {\r\n        this.loadPosition(e.xform.toMatrix());\r\n        this.loadMesh(e.model.mesh, speed);\r\n        return e.model.mesh.maxSize;\r\n    }\r\n    loadPosition(position) {\r\n        this.useProgram();\r\n        // let euler = position.toXform();\r\n        // let rotation = Matrix3.newRotation(euler);\r\n        this.uniforms.loadMatrix4(\"modelMatrix\", position);\r\n        this.uniforms.loadMatrix3(\"normalMatrix\", _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix3.newIdentity());\r\n    }\r\n    loadMesh(mesh, speed) {\r\n        this.useProgram();\r\n        this.attributes.loadIndex(mesh.links.data, speed);\r\n        this.attributes.load(\"position\", mesh.verts.matrix.data, speed);\r\n        this.attributes.load(\"uv\", mesh.uvs.matrix.data, speed);\r\n        this.attributes.load(\"normal\", mesh.normals.matrix.data, speed);\r\n    }\r\n    loadZebraStripeCount(count) {\r\n        this.uniforms.load(\"zebraStripeCount\", count);\r\n    }\r\n    onDraw(s) {\r\n        this.uniforms.loadMatrix4(\"worldMatrix\", s.camera.totalMatrix);\r\n        this.uniforms.load3(\"sunPosition\", s.sun.pos);\r\n        this.uniforms.load3(\"cameraPosition\", s.camera.getActualPosition());\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/shaders/ZebraShader.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/Attribute.ts":
/*!***********************************************!*\
  !*** ../engine/src/render/webgl/Attribute.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Attribute\": () => (/* binding */ Attribute)\n/* harmony export */ });\n// Purpose: I was getting sick of dealing with separate widths, buffers & positions, even though these values are tied together :)\r\n/**\r\n * Wrapper for a webgl buffer attibute\r\n */\r\nclass Attribute {\r\n    constructor(gl, buffer, position, width, type) {\r\n        this.gl = gl;\r\n        this.buffer = buffer;\r\n        this.position = position;\r\n        this.width = width;\r\n        this.type = type;\r\n    }\r\n    static new(gl, program, name, matrixWidth) {\r\n        let position = gl.getAttribLocation(program, name);\r\n        if (position == -1) {\r\n            console.error(`couldnt find attribute [${name}] within glsl! Keep in mind: webgl filters unused attributes automatically`);\r\n        }\r\n        let buffer = gl.createBuffer();\r\n        return new Attribute(gl, buffer, position, matrixWidth, gl.FLOAT);\r\n    }\r\n    /**\r\n     *  Load some new data into this attribute\r\n     */\r\n    load(gl, data, speed) {\r\n        // TODO experiment with switching these two\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        gl.enableVertexAttribArray(this.position);\r\n        gl.vertexAttribPointer(this.position, this.width, this.type, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, data, speed);\r\n    }\r\n    /**\r\n     * Enable the attribute / activate it, but do not set any data\r\n     * Must be called before rendering\r\n     */\r\n    bind(gl) {\r\n        gl.enableVertexAttribArray(this.position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        gl.vertexAttribPointer(this.position, this.width, this.type, false, 0, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/Attribute.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/Attributes.ts":
/*!************************************************!*\
  !*** ../engine/src/render/webgl/Attributes.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Attributes\": () => (/* binding */ Attributes)\n/* harmony export */ });\n/* harmony import */ var _Attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attribute */ \"../engine/src/render/webgl/Attribute.ts\");\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _IndexAttribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IndexAttribute */ \"../engine/src/render/webgl/IndexAttribute.ts\");\n\r\n\r\n\r\n/**\r\n * all attributes corresponding to one GL program.\r\n */\r\nclass Attributes {\r\n    constructor(gl, program, indexAttributeElementType, attributes = new Map()) {\r\n        this.gl = gl;\r\n        this.program = program;\r\n        this.indexAttributeElementType = indexAttributeElementType;\r\n        this.attributes = attributes;\r\n    }\r\n    add(name, width) {\r\n        this.attributes.set(name, _Attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.new(this.gl, this.program, name, width));\r\n    }\r\n    has(name) {\r\n        return this.attributes.has(name);\r\n    }\r\n    addIndex(type) {\r\n        this.indexAttributeElementType = type;\r\n        this.attributes.set(_Constants__WEBPACK_IMPORTED_MODULE_1__.INDEX_BUFFER_NAME, _IndexAttribute__WEBPACK_IMPORTED_MODULE_2__.IndexAttribute.new(this.gl));\r\n    }\r\n    load(name, data, speed) {\r\n        this.attributes.get(name).load(this.gl, data, speed);\r\n    }\r\n    unload(name) {\r\n        this.attributes.delete(name);\r\n    }\r\n    loadIndex(data, speed) {\r\n        this.attributes.get(_Constants__WEBPACK_IMPORTED_MODULE_1__.INDEX_BUFFER_NAME).load(this.gl, data, speed);\r\n    }\r\n    unloadIndex() {\r\n        this.attributes.delete(_Constants__WEBPACK_IMPORTED_MODULE_1__.INDEX_BUFFER_NAME);\r\n    }\r\n    getIndex() {\r\n        return this.attributes.get(_Constants__WEBPACK_IMPORTED_MODULE_1__.INDEX_BUFFER_NAME);\r\n    }\r\n    /**\r\n     * Load the state of all attributes, to prepare for rendering\r\n     */\r\n    bindAll() {\r\n        for (let [k, v] of this.attributes) {\r\n            v.bind(this.gl);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/Attributes.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/Constants.ts":
/*!***********************************************!*\
  !*** ../engine/src/render/webgl/Constants.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubeMapTarget\": () => (/* binding */ CubeMapTarget),\n/* harmony export */   \"CubeMapTargets\": () => (/* binding */ CubeMapTargets),\n/* harmony export */   \"ClearBufferBit\": () => (/* binding */ ClearBufferBit),\n/* harmony export */   \"DrawMode\": () => (/* binding */ DrawMode),\n/* harmony export */   \"PixelFormat\": () => (/* binding */ PixelFormat),\n/* harmony export */   \"DrawMethod\": () => (/* binding */ DrawMethod),\n/* harmony export */   \"DrawElementsType\": () => (/* binding */ DrawElementsType),\n/* harmony export */   \"DataType\": () => (/* binding */ DataType),\n/* harmony export */   \"TEXTURE_2D\": () => (/* binding */ TEXTURE_2D),\n/* harmony export */   \"INDEX_BUFFER_NAME\": () => (/* binding */ INDEX_BUFFER_NAME)\n/* harmony export */ });\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\r\n// I will add everything eventually\r\nvar CubeMapTarget;\r\n(function (CubeMapTarget) {\r\n    CubeMapTarget[CubeMapTarget[\"PosX\"] = 34069] = \"PosX\";\r\n    CubeMapTarget[CubeMapTarget[\"NegX\"] = 34070] = \"NegX\";\r\n    CubeMapTarget[CubeMapTarget[\"PosY\"] = 34071] = \"PosY\";\r\n    CubeMapTarget[CubeMapTarget[\"NegY\"] = 34072] = \"NegY\";\r\n    CubeMapTarget[CubeMapTarget[\"PosZ\"] = 34073] = \"PosZ\";\r\n    CubeMapTarget[CubeMapTarget[\"NegZ\"] = 34074] = \"NegZ\";\r\n})(CubeMapTarget || (CubeMapTarget = {}));\r\nconst CubeMapTargets = [\r\n    CubeMapTarget.PosX,\r\n    CubeMapTarget.NegX,\r\n    CubeMapTarget.PosY,\r\n    CubeMapTarget.NegY,\r\n    CubeMapTarget.PosZ,\r\n    CubeMapTarget.NegZ\r\n];\r\nvar ClearBufferBit;\r\n(function (ClearBufferBit) {\r\n    ClearBufferBit[ClearBufferBit[\"Depth\"] = 256] = \"Depth\";\r\n    ClearBufferBit[ClearBufferBit[\"Stencil\"] = 1024] = \"Stencil\";\r\n    ClearBufferBit[ClearBufferBit[\"Color\"] = 16384] = \"Color\";\r\n})(ClearBufferBit || (ClearBufferBit = {}));\r\nvar DrawMode;\r\n(function (DrawMode) {\r\n    DrawMode[DrawMode[\"Points\"] = 0] = \"Points\";\r\n    DrawMode[DrawMode[\"Lines\"] = 1] = \"Lines\";\r\n    DrawMode[DrawMode[\"LineLoop\"] = 2] = \"LineLoop\";\r\n    DrawMode[DrawMode[\"LineStrip\"] = 3] = \"LineStrip\";\r\n    DrawMode[DrawMode[\"Triangles\"] = 4] = \"Triangles\";\r\n    DrawMode[DrawMode[\"TriangleStrip\"] = 5] = \"TriangleStrip\";\r\n    DrawMode[DrawMode[\"TriangleFan\"] = 6] = \"TriangleFan\";\r\n})(DrawMode || (DrawMode = {}));\r\nvar PixelFormat;\r\n(function (PixelFormat) {\r\n    PixelFormat[PixelFormat[\"DepthComponent\"] = 6402] = \"DepthComponent\";\r\n    PixelFormat[PixelFormat[\"Alpha\"] = 6406] = \"Alpha\";\r\n    PixelFormat[PixelFormat[\"RGB\"] = 6407] = \"RGB\";\r\n    PixelFormat[PixelFormat[\"RGBA\"] = 6408] = \"RGBA\";\r\n    PixelFormat[PixelFormat[\"Luminance\"] = 6409] = \"Luminance\";\r\n    PixelFormat[PixelFormat[\"LuminanceAlpha\"] = 6410] = \"LuminanceAlpha\";\r\n})(PixelFormat || (PixelFormat = {}));\r\nvar DrawMethod;\r\n(function (DrawMethod) {\r\n    DrawMethod[DrawMethod[\"Arrays\"] = 0] = \"Arrays\";\r\n    DrawMethod[DrawMethod[\"Elements\"] = 1] = \"Elements\";\r\n})(DrawMethod || (DrawMethod = {}));\r\nvar DrawElementsType;\r\n(function (DrawElementsType) {\r\n    DrawElementsType[DrawElementsType[\"UnsignedByte\"] = 5121] = \"UnsignedByte\";\r\n    DrawElementsType[DrawElementsType[\"UnsignedShort\"] = 5123] = \"UnsignedShort\";\r\n    DrawElementsType[DrawElementsType[\"UnsignedInt\"] = 5125] = \"UnsignedInt\";\r\n})(DrawElementsType || (DrawElementsType = {}));\r\nvar DataType;\r\n(function (DataType) {\r\n    DataType[DataType[\"Byte\"] = 5120] = \"Byte\";\r\n    DataType[DataType[\"UnsignedByte\"] = 5121] = \"UnsignedByte\";\r\n    DataType[DataType[\"Short\"] = 5122] = \"Short\";\r\n    DataType[DataType[\"UnsignedShort\"] = 5123] = \"UnsignedShort\";\r\n    DataType[DataType[\"Int\"] = 5124] = \"Int\";\r\n    DataType[DataType[\"UnsignedInt\"] = 5125] = \"UnsignedInt\";\r\n    DataType[DataType[\"Float\"] = 5126] = \"Float\";\r\n})(DataType || (DataType = {}));\r\nconst TEXTURE_2D = 0x0DE1;\r\nconst INDEX_BUFFER_NAME = \"__index__\";\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/Constants.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/CubeMap.ts":
/*!*********************************************!*\
  !*** ../engine/src/render/webgl/CubeMap.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CubeMap\": () => (/* binding */ CubeMap)\n/* harmony export */ });\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n\r\n\r\nclass CubeMap {\r\n    constructor(gl, id, idPointer, texturePointer) {\r\n        this.gl = gl;\r\n        this.id = id;\r\n        this.idPointer = idPointer;\r\n        this.texturePointer = texturePointer;\r\n        this.start();\r\n    }\r\n    static new(gl, program, name) {\r\n        let location = gl.getUniformLocation(program, name);\r\n        let id = _HelpGl__WEBPACK_IMPORTED_MODULE_1__.HelpGl.getNextTextureID();\r\n        let texture = gl.createTexture();\r\n        return new CubeMap(gl, id, location, texture);\r\n    }\r\n    start() {\r\n        let gl = this.gl;\r\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texturePointer);\r\n        _Constants__WEBPACK_IMPORTED_MODULE_0__.CubeMapTargets.forEach((target) => {\r\n            gl.texImage2D(target, 0, gl.RGBA, 1024, 1024, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n        });\r\n        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\r\n    }\r\n    loadUrls(urls) {\r\n        let gl = this.gl;\r\n        const pointer = this.texturePointer;\r\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, pointer);\r\n        _Constants__WEBPACK_IMPORTED_MODULE_0__.CubeMapTargets.forEach((target, i) => {\r\n            const url = urls[i];\r\n            // Upload the canvas to the cubemap face.\r\n            const level = 0;\r\n            const internalFormat = gl.RGBA;\r\n            const format = gl.RGBA;\r\n            const type = gl.UNSIGNED_BYTE;\r\n            // Asynchronously load an image\r\n            const image = new Image();\r\n            image.src = url;\r\n            image.addEventListener('load', function () {\r\n                // Now that the image has loaded make copy it to the texture.\r\n                gl.bindTexture(gl.TEXTURE_CUBE_MAP, pointer);\r\n                gl.texImage2D(target, level, internalFormat, format, type, image);\r\n                gl.generateMipmap(gl.TEXTURE_CUBE_MAP);\r\n            });\r\n        });\r\n    }\r\n    bind(gl) {\r\n        gl.uniform1i(this.idPointer, this.id);\r\n        gl.activeTexture(gl.TEXTURE0 + this.id);\r\n        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texturePointer);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/CubeMap.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/DrawTarget.ts":
/*!************************************************!*\
  !*** ../engine/src/render/webgl/DrawTarget.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawTarget\": () => (/* binding */ DrawTarget)\n/* harmony export */ });\n/* harmony import */ var _HelpGl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n\r\n/**\r\n * This represent a draw target. when 'gl.drawElements' or 'gl.drawArrays' is called when this is bound,\r\n * the result of the render will be stored within the texture and depth buffer\r\n */\r\nclass DrawTarget {\r\n    constructor(width, height, texture, depthBuffer, frameBuffer) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.texture = texture;\r\n        this.depthBuffer = depthBuffer;\r\n        this.frameBuffer = frameBuffer;\r\n    }\r\n    /**\r\n     * Creation automatically binds it\r\n     */\r\n    static createAndBind(gl, width, height) {\r\n        // create to render to\r\n        const targetTexture = gl.createTexture();\r\n        gl.bindTexture(gl.TEXTURE_2D, targetTexture);\r\n        // define size and format of level 0\r\n        const level = 0;\r\n        const internalFormat = gl.RGBA;\r\n        const border = 0;\r\n        const format = gl.RGBA;\r\n        const type = gl.UNSIGNED_BYTE;\r\n        const data = null;\r\n        gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, width, height, border, format, type, data);\r\n        // set the filtering so we don't need mips\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        // Create and bind the framebuffer\r\n        const frameBuffer = gl.createFramebuffer();\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n        gl.viewport(0, 0, width, height);\r\n        // attach the texture as the first color attachment\r\n        const attachmentPoint = gl.COLOR_ATTACHMENT0;\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, targetTexture, level);\r\n        // create a depth renderbuffer\r\n        const depthBuffer = gl.createRenderbuffer();\r\n        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\r\n        // make a depth buffer and the same size as the targetTexture\r\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\r\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\r\n        return new DrawTarget(width, height, targetTexture, depthBuffer, frameBuffer);\r\n    }\r\n    bind(gl) {\r\n        _HelpGl__WEBPACK_IMPORTED_MODULE_0__.HelpGl.setDrawTarget(gl, this.frameBuffer, this.width, this.height);\r\n    }\r\n    unbind(gl) {\r\n        _HelpGl__WEBPACK_IMPORTED_MODULE_0__.HelpGl.resetDrawTarget(gl);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/DrawTarget.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/HelpGl.ts":
/*!********************************************!*\
  !*** ../engine/src/render/webgl/HelpGl.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawSpeed\": () => (/* binding */ DrawSpeed),\n/* harmony export */   \"HelpGl\": () => (/* binding */ HelpGl)\n/* harmony export */ });\n// purpose : webgl wrapping & helper functions\r\nvar nextTextureId = 0;\r\nvar rendercallsperframe = 0;\r\n// TODO move this to 'constants.ts' and refactor everything again :)\r\nvar DrawSpeed;\r\n(function (DrawSpeed) {\r\n    DrawSpeed[DrawSpeed[\"StreamDraw\"] = 35040] = \"StreamDraw\";\r\n    DrawSpeed[DrawSpeed[\"StaticDraw\"] = 35044] = \"StaticDraw\";\r\n    DrawSpeed[DrawSpeed[\"DynamicDraw\"] = 35048] = \"DynamicDraw\";\r\n})(DrawSpeed || (DrawSpeed = {}));\r\nvar HelpGl;\r\n(function (HelpGl) {\r\n    function clear(gl) {\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    }\r\n    HelpGl.clear = clear;\r\n    /**\r\n     * We need to keep track of all textures in the entire webgl application\r\n     */\r\n    function getNextTextureID() {\r\n        let id = nextTextureId;\r\n        nextTextureId += 1;\r\n        return id;\r\n    }\r\n    HelpGl.getNextTextureID = getNextTextureID;\r\n    function resizeViewportToCanvas(gl) {\r\n        // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n        let canvas = gl.canvas;\r\n        const displayWidth = canvas.clientWidth;\r\n        const displayHeight = canvas.clientHeight;\r\n        // Check if the canvas is not the same size.\r\n        const needResize = gl.canvas.width !== displayWidth || gl.canvas.height !== displayHeight;\r\n        if (needResize) {\r\n            // Make the canvas the same size\r\n            gl.canvas.width = displayWidth;\r\n            gl.canvas.height = displayHeight;\r\n        }\r\n        // Tell WebGL how to convert from clip space to pixels\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        return needResize;\r\n    }\r\n    HelpGl.resizeViewportToCanvas = resizeViewportToCanvas;\r\n    function initWebglContext(canvas, blend = false) {\r\n        let possiblyGl = canvas.getContext(\"webgl\");\r\n        if (possiblyGl == undefined) {\r\n            alert(\"webgl unavailable...\");\r\n            return undefined;\r\n        }\r\n        let gl = possiblyGl;\r\n        gl.enable(gl.CULL_FACE);\r\n        if (blend) {\r\n            gl.enable(gl.BLEND);\r\n            gl.enable(gl.DEPTH_TEST);\r\n            gl.depthFunc(gl.LEQUAL);\r\n            // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        }\r\n        else {\r\n            gl.disable(gl.BLEND);\r\n            gl.enable(gl.DEPTH_TEST);\r\n            gl.depthFunc(gl.LEQUAL);\r\n        }\r\n        // extensions\r\n        let ext = gl.getExtension(\"OES_element_index_uint\");\r\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        gl.clearDepth(1);\r\n        return gl;\r\n    }\r\n    HelpGl.initWebglContext = initWebglContext;\r\n    function compileShader(gl, shaderSource, shaderType) {\r\n        let shader = gl.createShader(shaderType);\r\n        gl.shaderSource(shader, shaderSource);\r\n        gl.compileShader(shader);\r\n        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!success) {\r\n            throw \"could not compile shader:\" + shaderSource + gl.getShaderInfoLog(shader);\r\n        }\r\n        return shader;\r\n    }\r\n    HelpGl.compileShader = compileShader;\r\n    function createProgram(gl, vertexShader, fragmentShader) {\r\n        let program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n        let success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!success) {\r\n            throw \"program failed to link:\" + gl.getProgramInfoLog(program);\r\n        }\r\n        return program;\r\n    }\r\n    HelpGl.createProgram = createProgram;\r\n    function createProgramFromScripts(gl, vertexScript, fragmentScript) {\r\n        let vertexShader = compileShader(gl, vertexScript, gl.VERTEX_SHADER);\r\n        let fragmentShader = compileShader(gl, fragmentScript, gl.FRAGMENT_SHADER);\r\n        return createProgram(gl, vertexShader, fragmentShader);\r\n    }\r\n    HelpGl.createProgramFromScripts = createProgramFromScripts;\r\n    /**\r\n     * WebGl only allows textures with a width and height of the power of two.\r\n     * This means `32x512` is valid, while `40x40` is not valid\r\n     * This function takes a size, lets say `40`, and rounds up to the nearest power of two, in this case `64`\r\n     */\r\n    function getNearestCorrectTextureSize(size) {\r\n        let base = Math.log2(size);\r\n        return Math.pow(2, Math.ceil(base));\r\n    }\r\n    HelpGl.getNearestCorrectTextureSize = getNearestCorrectTextureSize;\r\n    function fixTextureSizing(image) {\r\n        let goodWidth = getNearestCorrectTextureSize(image.width);\r\n        let goodHeight = getNearestCorrectTextureSize(image.height);\r\n        if (goodWidth !== image.width || goodHeight !== image.height) {\r\n            // we need to perform resizing!\r\n            console.log(\"resizing to \", goodWidth, goodHeight);\r\n            let u = image.width / goodWidth;\r\n            let v = image.height / goodHeight;\r\n            return image.buffer(goodWidth, goodHeight);\r\n            ;\r\n        }\r\n        return image;\r\n    }\r\n    HelpGl.fixTextureSizing = fixTextureSizing;\r\n    // -- this helps when switching draw targets\r\n    function resetDrawTarget(gl) {\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n        HelpGl.resizeViewportToCanvas(gl);\r\n    }\r\n    HelpGl.resetDrawTarget = resetDrawTarget;\r\n    function setDrawTarget(gl, fb, width, height) {\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\r\n        gl.viewport(0, 0, width, height);\r\n        HelpGl.clear(gl);\r\n    }\r\n    HelpGl.setDrawTarget = setDrawTarget;\r\n})(HelpGl || (HelpGl = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/HelpGl.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/IndexAttribute.ts":
/*!****************************************************!*\
  !*** ../engine/src/render/webgl/IndexAttribute.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IndexAttribute\": () => (/* binding */ IndexAttribute)\n/* harmony export */ });\n/**\r\n * Wrapper for a webgl index buffer\r\n */\r\nclass IndexAttribute {\r\n    constructor(gl, buffer) {\r\n        this.gl = gl;\r\n        this.buffer = buffer;\r\n    }\r\n    static new(gl) {\r\n        let buffer = gl.createBuffer();\r\n        return new IndexAttribute(gl, buffer);\r\n    }\r\n    load(gl, data, speed) {\r\n        // experiment with switching these two\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, speed);\r\n    }\r\n    bind(gl) {\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/IndexAttribute.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/ShaderProgram.ts":
/*!***************************************************!*\
  !*** ../engine/src/render/webgl/ShaderProgram.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShaderProgram\": () => (/* binding */ ShaderProgram)\n/* harmony export */ });\n/* harmony import */ var _Attributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Attributes */ \"../engine/src/render/webgl/Attributes.ts\");\n/* harmony import */ var _Uniforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Uniforms */ \"../engine/src/render/webgl/Uniforms.ts\");\n/* harmony import */ var _HelpGl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Constants */ \"../engine/src/render/webgl/Constants.ts\");\n// shader.ts\r\n// author: Jos Feenstra\r\n// credits to : https://webglfundamentals.org/\r\n// note: im still figuring out how to organize this\r\n\r\n\r\n\r\n\r\n/**\r\n * An implementation of 'program' needs to define 4 methods:\r\n * @param T = data to feed the renderer at 'load'\r\n * 1. `constructor`\r\n *    - state the vertex & fragment shader\r\n *    - call super\r\n *\r\n * 2. `onInit`\r\n *    - init all attributes\r\n *    - init all uniforms, state which ones should be exposed publicly\r\n *    - return the 'DrawMode' which needs to be used to draw this shader\r\n *\r\n * 2. `onLoad`\r\n *    - explain how 'T' set the main attributes\r\n *    - return a number representing how many 'drawmode' features need to be drawn\r\n *\r\n * 3. `onRender`\r\n *    - explain how 'Context' needs to be loaded into this shader\r\n */\r\nclass ShaderProgram {\r\n    constructor(gl, vertexScript, fragmentScript) {\r\n        // auto set\r\n        this.drawElementsOrArrays = () => { };\r\n        this.drawMethod = _Constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Arrays;\r\n        this.mode = _Constants__WEBPACK_IMPORTED_MODULE_3__.DrawMode.Triangles;\r\n        this.drawCount = 0; // number of times the shaders need to render\r\n        this.drawOffset = 0;\r\n        this.gl = gl;\r\n        this.program = _HelpGl__WEBPACK_IMPORTED_MODULE_2__.HelpGl.createProgramFromScripts(gl, vertexScript, fragmentScript);\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.useProgram();\r\n        this.uniforms = new _Uniforms__WEBPACK_IMPORTED_MODULE_1__.Uniforms(this.gl, this.program);\r\n        this.attributes = new _Attributes__WEBPACK_IMPORTED_MODULE_0__.Attributes(this.gl, this.program);\r\n        this.drawCount = 0;\r\n        this.mode = this.onInit();\r\n        this.updateDrawMethod();\r\n    }\r\n    load(r, speed = _HelpGl__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.StaticDraw) {\r\n        this.useProgram();\r\n        this.drawCount = this.onLoad(r, speed);\r\n    }\r\n    draw(s) {\r\n        this.useProgram();\r\n        this.onDraw(s);\r\n        this.uniforms.bindAll();\r\n        this.attributes.bindAll();\r\n        this.drawElementsOrArrays();\r\n    }\r\n    loadAndDraw(r, context) {\r\n        this.load(r, _HelpGl__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.DynamicDraw);\r\n        this.draw(context);\r\n    }\r\n    /**\r\n     *@deprecated\r\n     */\r\n    render(s) {\r\n        return this.draw(s);\r\n    }\r\n    // ---------------------------------------------------------------------------\r\n    useProgram() {\r\n        this.gl.useProgram(this.program);\r\n    }\r\n    setDrawCount(count) {\r\n        this.drawCount = count;\r\n    }\r\n    // ---------------------------------------------------------------------------\r\n    updateDrawMethod() {\r\n        if (this.attributes.has(_Constants__WEBPACK_IMPORTED_MODULE_3__.INDEX_BUFFER_NAME)) {\r\n            this.drawMethod = _Constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Elements;\r\n            this.drawElementsOrArrays = this.drawElements;\r\n        }\r\n        else {\r\n            this.drawMethod = _Constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Arrays;\r\n            this.drawElementsOrArrays = this.drawArrays;\r\n        }\r\n    }\r\n    drawElements() {\r\n        this.gl.drawElements(this.mode, this.drawCount, this.attributes.indexAttributeElementType, this.drawOffset);\r\n    }\r\n    drawArrays() {\r\n        this.gl.drawArrays(this.mode, this.drawOffset, this.drawCount);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/ShaderProgram.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/Uniform.ts":
/*!*********************************************!*\
  !*** ../engine/src/render/webgl/Uniform.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniformType\": () => (/* binding */ UniformType),\n/* harmony export */   \"Uniform\": () => (/* binding */ Uniform)\n/* harmony export */ });\nvar UniformType;\r\n(function (UniformType) {\r\n    UniformType[UniformType[\"Float\"] = 0] = \"Float\";\r\n    UniformType[UniformType[\"Int\"] = 1] = \"Int\";\r\n})(UniformType || (UniformType = {}));\r\nclass Uniform {\r\n    constructor(type, size, loc, setter) {\r\n        this.type = type;\r\n        this.size = size;\r\n        this.loc = loc;\r\n        this.setter = setter;\r\n    }\r\n    static new(gl, program, name, type, size, initState) {\r\n        let setter = getLoader(gl, type, size);\r\n        let loc = gl.getUniformLocation(program, name);\r\n        let u = new Uniform(type, size, loc, setter);\r\n        if (initState) {\r\n            u.loadAndBind(gl, initState);\r\n        }\r\n        return u;\r\n    }\r\n    loadAndBind(gl, state) {\r\n        this.setter(gl, this.loc, state);\r\n    }\r\n}\r\nfunction getLoader(gl, type, size) {\r\n    switch (size) {\r\n        case 1:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform1fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform1fv(loc, state);\r\n                };\r\n            }\r\n        case 2:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform2fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform2fv(loc, state);\r\n                };\r\n            }\r\n        case 3:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform3fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform3fv(loc, state);\r\n                };\r\n            }\r\n        case 4:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform4fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform4fv(loc, state);\r\n                };\r\n            }\r\n        case 9:\r\n            return (gl, loc, state) => {\r\n                gl.uniformMatrix3fv(loc, false, state);\r\n            };\r\n        case 16:\r\n            return (gl, loc, state) => {\r\n                gl.uniformMatrix4fv(loc, false, state);\r\n            };\r\n        default:\r\n            return (gl, loc, state) => {\r\n                console.error(\"could not set a certain uniform...\");\r\n            };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/Uniform.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/UniformTexture.ts":
/*!****************************************************!*\
  !*** ../engine/src/render/webgl/UniformTexture.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniformTexture\": () => (/* binding */ UniformTexture),\n/* harmony export */   \"isPowerOf2\": () => (/* binding */ isPowerOf2)\n/* harmony export */ });\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Constants */ \"../engine/src/render/webgl/Constants.ts\");\n/* harmony import */ var _HelpGl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HelpGl */ \"../engine/src/render/webgl/HelpGl.ts\");\n\r\n\r\n/**\r\n * Note: arguments can be made for splitting up 'uniform' & 'texture'\r\n */\r\nclass UniformTexture {\r\n    constructor(gl, id, texture, loc) {\r\n        this.gl = gl;\r\n        this.id = id;\r\n        this.texture = texture;\r\n        this.loc = loc;\r\n    }\r\n    static new(gl, program, name) {\r\n        let location = gl.getUniformLocation(program, name);\r\n        // let location = 0;\r\n        let id = _HelpGl__WEBPACK_IMPORTED_MODULE_1__.HelpGl.getNextTextureID();\r\n        let texture = gl.createTexture();\r\n        return new UniformTexture(gl, id, texture, location);\r\n    }\r\n    /**\r\n     * 'normal' loading\r\n     */\r\n    load(texture) {\r\n        if (texture.depth != 4) {\r\n            throw new Error(\"sorry, but I haven't figured out how to load non-rgba textures...\");\r\n        }\r\n        this.loadArrayBuffer(texture.width, texture.height, texture.data);\r\n    }\r\n    /**\r\n     * loading indirectly with imageData.\r\n     */\r\n    loadImageData(imgData) {\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\r\n        this.gl.bindTexture(_Constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, this.texture);\r\n        this.gl.texImage2D(_Constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, imgData);\r\n        // alternative texture -> Fill the texture with a 1x1 blue pixel.\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 128, 128, 255]));\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, mesh.texture.data);\r\n        this.gl.texParameteri(_Constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\r\n        this.gl.generateMipmap(_Constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D);\r\n    }\r\n    /**\r\n     * loading directly with an array buffer view.\r\n     */\r\n    loadArrayBuffer(width, height, source) {\r\n        let gl = this.gl;\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\r\n        this.gl.bindTexture(_Constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, this.texture);\r\n        const internalFormat = gl.RGBA;\r\n        const border = 0;\r\n        const srcFormat = gl.RGBA;\r\n        const srcType = gl.UNSIGNED_BYTE;\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, border, srcFormat, srcType, source);\r\n        // WebGL1 has different requirements for power of 2 images\r\n        // vs non power of 2 images so check if the image is a\r\n        // power of 2 in both dimensions.\r\n        if (isPowerOf2(width) && isPowerOf2(height)) {\r\n            // Yes, it's a power of 2. Generate mips.\r\n            gl.generateMipmap(gl.TEXTURE_2D);\r\n        }\r\n        else {\r\n            // No, it's not a power of 2. Turn off mips and set\r\n            // wrapping to clamp to edge\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        }\r\n    }\r\n    /**\r\n     * 'meta loading'. change the underlying webglTexture to a different adress.\r\n     * this way, prerendered textures can be 'loaded' from a drawTarget, for example\r\n     */\r\n    setSource(texture) {\r\n        this.texture = texture;\r\n    }\r\n    bind(gl) {\r\n        gl.uniform1i(this.loc, this.id);\r\n        gl.activeTexture(gl.TEXTURE0 + this.id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n    }\r\n    unbind() {\r\n        throw \"TODO\";\r\n    }\r\n}\r\nfunction isPowerOf2(value) {\r\n    return (value & (value - 1)) == 0;\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/UniformTexture.ts?");

/***/ }),

/***/ "../engine/src/render/webgl/Uniforms.ts":
/*!**********************************************!*\
  !*** ../engine/src/render/webgl/Uniforms.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Uniforms\": () => (/* binding */ Uniforms)\n/* harmony export */ });\n/* harmony import */ var _Uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Uniform */ \"../engine/src/render/webgl/Uniform.ts\");\n/* harmony import */ var _UniformTexture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UniformTexture */ \"../engine/src/render/webgl/UniformTexture.ts\");\n/* harmony import */ var _CubeMap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CubeMap */ \"../engine/src/render/webgl/CubeMap.ts\");\n\r\n\r\n\r\n/**\r\n * all uniforms corresponding to one GL program.\r\n */\r\nclass Uniforms {\r\n    constructor(gl, program, uniforms = new Map(), textures = new Map()) {\r\n        this.gl = gl;\r\n        this.program = program;\r\n        this.uniforms = uniforms;\r\n        this.textures = textures;\r\n    }\r\n    add(name, size, defaultState, type = _Uniform__WEBPACK_IMPORTED_MODULE_0__.UniformType.Float) {\r\n        let uniform = _Uniform__WEBPACK_IMPORTED_MODULE_0__.Uniform.new(this.gl, this.program, name, type, size, defaultState);\r\n        this.uniforms.set(name, uniform);\r\n        return uniform;\r\n    }\r\n    addTexture(name) {\r\n        let texture = _UniformTexture__WEBPACK_IMPORTED_MODULE_1__.UniformTexture.new(this.gl, this.program, name);\r\n        this.textures.set(name, texture);\r\n        return texture;\r\n    }\r\n    addCubeMap(name) {\r\n        let cubemap = _CubeMap__WEBPACK_IMPORTED_MODULE_2__.CubeMap.new(this.gl, this.program, name);\r\n        this.textures.set(name, cubemap);\r\n        return cubemap;\r\n    }\r\n    get(name) {\r\n        let u = this.uniforms.get(name);\r\n        if (u) {\r\n            return u;\r\n        }\r\n        else {\r\n            throw new Error(`uniform called [${name}] is not addded to the uniforms at init...`);\r\n        }\r\n    }\r\n    /**\r\n     * Load the state of all textures, to prepare for rendering\r\n     */\r\n    bindAll() {\r\n        for (let v of this.textures.values()) {\r\n            v.bind(this.gl);\r\n        }\r\n    }\r\n    loadCubeMapUrls(name, urls) {\r\n        this.textures.get(name).loadUrls(urls);\r\n    }\r\n    loadTexture(name, texture) {\r\n        this.textures.get(name).load(texture);\r\n    }\r\n    loadTextureSource(name, source) {\r\n        this.textures.get(name).setSource(source);\r\n    }\r\n    load(name, value) {\r\n        this.get(name).loadAndBind(this.gl, [value]);\r\n    }\r\n    load2(name, value) {\r\n        this.get(name).loadAndBind(this.gl, value.data);\r\n    }\r\n    load3(name, value) {\r\n        this.get(name).loadAndBind(this.gl, value.data);\r\n    }\r\n    load4(name, value) {\r\n        this.get(name).loadAndBind(this.gl, value);\r\n    }\r\n    loadColor(name, value) {\r\n        this.get(name).loadAndBind(this.gl, value.data);\r\n    }\r\n    loadMatrix3(name, value) {\r\n        this.get(name).loadAndBind(this.gl, value.data);\r\n    }\r\n    loadMatrix4(name, value) {\r\n        this.get(name).loadAndBind(this.gl, value.data);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/render/webgl/Uniforms.ts?");

/***/ }),

/***/ "../engine/src/util/Debug.ts":
/*!***********************************!*\
  !*** ../engine/src/util/Debug.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Debug\": () => (/* binding */ Debug)\n/* harmony export */ });\n/**\r\n * javascript / typescript users would prefer `debug.log()` over `Debug.log()` for convention's sake\r\n * BUT this clashes with many libraries and build tooling, so this is not used at the moment...\r\n */\r\n// export const debug = Debug;\r\n/**\r\n * wraps the native `console`, so we can be specific about when and how we log\r\n * NOTE: Debug is intented to be used as a singleton, so a namespace is used instead of a class\r\n */\r\nvar Debug;\r\n(function (Debug) {\r\n    Debug.Active = true;\r\n    Debug.Once = true;\r\n    Debug.Times = 0;\r\n    let TimesCount = 0;\r\n    /////////////////////////////////////////////////////////////////////////// Create a hook\r\n    let _onLogListener;\r\n    let _onErrorListener;\r\n    /**\r\n     * Highjack Debug.log, Debug.error, Debug.info and Debug.warn. This highjack ignores the active status of regular logging\r\n     */\r\n    function setLogListener(listener) {\r\n        _onLogListener = listener;\r\n    }\r\n    Debug.setLogListener = setLogListener;\r\n    function setErrorListener(listener) {\r\n        _onErrorListener = listener;\r\n    }\r\n    Debug.setErrorListener = setErrorListener;\r\n    /**\r\n     * DANGEROUS.\r\n     * Does not work if no log listener has been defined\r\n     */\r\n    function forceLogListenerUponConsole() {\r\n        if (!hasLogListener())\r\n            return;\r\n        console.log = (m, p) => onLog(\"log\", m, p);\r\n        console.info = (m, p) => onLog(\"info\", m, p);\r\n        console.warn = (m, p) => onLog(\"warn\", m, p);\r\n        console.error = (m, p) => onLog(\"error\", m, p);\r\n    }\r\n    Debug.forceLogListenerUponConsole = forceLogListenerUponConsole;\r\n    function hasLogListener() {\r\n        return (_onLogListener != undefined);\r\n    }\r\n    function hasErrorListener() {\r\n        return (_onErrorListener != undefined);\r\n    }\r\n    function onLog(tag, message, ...optionalParams) {\r\n        if (!_onLogListener)\r\n            return;\r\n        _onLogListener(`${String([message, ...optionalParams])}`, tag);\r\n    }\r\n    function onError(tag, message, ...optionalParams) {\r\n        if (!_onErrorListener)\r\n            return;\r\n        _onErrorListener(`${String([message, ...optionalParams])}`);\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////// Event based \r\n    function dispatch(message, type = \"my-log-event\") {\r\n        let event = new CustomEvent(type, {\r\n            detail: { message },\r\n        });\r\n        document.dispatchEvent(event);\r\n    }\r\n    Debug.dispatch = dispatch;\r\n    /////////////////////////////////////////////////////////////////////////// Additions\r\n    function logOnce(message, ...optionalParams) {\r\n        if (!Debug.Active)\r\n            return;\r\n        if (!Debug.Once)\r\n            return;\r\n        console.log(message, ...optionalParams);\r\n        Debug.Once = false;\r\n    }\r\n    Debug.logOnce = logOnce;\r\n    function logTimes(times, message, ...optionalParams) {\r\n        if (!Debug.Active)\r\n            return;\r\n        Debug.Times = times;\r\n        TimesCount += 1;\r\n        if (TimesCount > Debug.Times)\r\n            return;\r\n        console.log(message, ...optionalParams);\r\n        Debug.Once = false;\r\n    }\r\n    Debug.logTimes = logTimes;\r\n    /////////////////////////////////////////////////////////////////////////// Pass throughs\r\n    function assert(condition, ...data) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.assert(condition, ...data);\r\n    }\r\n    Debug.assert = assert;\r\n    function clear() {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.clear();\r\n    }\r\n    Debug.clear = clear;\r\n    function count(label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.count(label);\r\n    }\r\n    Debug.count = count;\r\n    function countReset(label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.countReset(label);\r\n    }\r\n    Debug.countReset = countReset;\r\n    function debug(message, ...optionalParams) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.debug(message, ...optionalParams);\r\n    }\r\n    Debug.debug = debug;\r\n    function dir(obj, options) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.dir(obj, options);\r\n    }\r\n    Debug.dir = dir;\r\n    function dirxml(...data) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.dir(...data);\r\n    }\r\n    Debug.dirxml = dirxml;\r\n    function error(message, ...optionalParams) {\r\n        if (hasLogListener())\r\n            onLog(\"error\", message, optionalParams);\r\n        if (hasErrorListener())\r\n            onError(\"error\", message, optionalParams);\r\n        if (!Debug.Active)\r\n            return;\r\n        console.error(message, ...optionalParams);\r\n    }\r\n    Debug.error = error;\r\n    function group(...label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.group(...label);\r\n    }\r\n    Debug.group = group;\r\n    function groupCollapsed(...label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.groupCollapsed(...label);\r\n    }\r\n    Debug.groupCollapsed = groupCollapsed;\r\n    function groupEnd() {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.groupEnd();\r\n    }\r\n    Debug.groupEnd = groupEnd;\r\n    function info(message, ...optionalParams) {\r\n        if (hasLogListener())\r\n            onLog(\"error\", message, optionalParams);\r\n        if (!Debug.Active)\r\n            return;\r\n        console.info(message, ...optionalParams);\r\n    }\r\n    Debug.info = info;\r\n    function log(message, ...optionalParams) {\r\n        if (hasLogListener())\r\n            onLog(\"error\", message, optionalParams);\r\n        if (!Debug.Active)\r\n            return;\r\n        console.log(message, ...optionalParams);\r\n    }\r\n    Debug.log = log;\r\n    function table(tabularData, properties) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.log(tabularData, properties);\r\n    }\r\n    Debug.table = table;\r\n    function time(label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.time(label);\r\n    }\r\n    Debug.time = time;\r\n    function timeEnd(label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.timeEnd(label);\r\n    }\r\n    Debug.timeEnd = timeEnd;\r\n    function timeLog(label, ...data) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.timeLog(label);\r\n    }\r\n    Debug.timeLog = timeLog;\r\n    function timeStamp(label) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.timeStamp(label);\r\n    }\r\n    Debug.timeStamp = timeStamp;\r\n    function trace(message, ...optionalParams) {\r\n        if (!Debug.Active)\r\n            return;\r\n        console.trace(message, ...optionalParams);\r\n    }\r\n    Debug.trace = trace;\r\n    function warn(message, ...optionalParams) {\r\n        if (hasLogListener())\r\n            onLog(\"error\", message, optionalParams);\r\n        if (!Debug.Active)\r\n            return;\r\n        console.warn(message, ...optionalParams);\r\n    }\r\n    Debug.warn = warn;\r\n    // export function profile(label?: string): void {\r\n    // \tif (!active) return;\r\n    // \tconsole.profile(label);\r\n    // }\r\n    // export function profileEnd(label?: string): void {\r\n    // \tif (!active) return;\r\n    // \tconsole.profileEnd(label);\r\n    // }\r\n})(Debug || (Debug = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/util/Debug.ts?");

/***/ }),

/***/ "../engine/src/util/FpsCounter.ts":
/*!****************************************!*\
  !*** ../engine/src/util/FpsCounter.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FpsCounter\": () => (/* binding */ FpsCounter)\n/* harmony export */ });\nclass FpsCounter {\r\n    constructor() {\r\n        this.fps = 0;\r\n        this.updateEveryXTicks = 100;\r\n        this.elapsed = 0;\r\n        this.frames = 0;\r\n        this.frameTime = 0;\r\n    }\r\n    static new() {\r\n        return new FpsCounter();\r\n    }\r\n    _update(dt) {\r\n        this.frames += 1;\r\n        this.elapsed += dt;\r\n        if (this.elapsed > this.updateEveryXTicks) {\r\n            this.setFps();\r\n            this.elapsed = 0;\r\n            this.frames = 0;\r\n        }\r\n    }\r\n    update(dt) {\r\n        this._update(dt);\r\n    }\r\n    setFps() {\r\n        this.fps = Math.round((this.frames / this.elapsed) * 1000);\r\n    }\r\n    getFps() {\r\n        return this.fps;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/util/FpsCounter.ts?");

/***/ }),

/***/ "../engine/src/util/Microphone.ts":
/*!****************************************!*\
  !*** ../engine/src/util/Microphone.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Microphone\": () => (/* binding */ Microphone)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n/**\r\n * Inspired by : https://www.youtube.com/watch?v=qNEb9of714U\r\n *\r\n */\r\nclass Microphone {\r\n    constructor(ac, microphone, analyser, array, normedArray, delayedArray) {\r\n        this.ac = ac;\r\n        this.microphone = microphone;\r\n        this.analyser = analyser;\r\n        this.array = array;\r\n        this.normedArray = normedArray;\r\n        this.delayedArray = delayedArray;\r\n    }\r\n    static new(fftSize = 512) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let stream = yield navigator.mediaDevices.getUserMedia({ audio: true });\r\n            let audioContext = new AudioContext;\r\n            let microphone = audioContext.createMediaStreamSource(stream);\r\n            let analyser = audioContext.createAnalyser();\r\n            analyser.fftSize = fftSize;\r\n            const bufferLength = analyser.frequencyBinCount;\r\n            let array = new Uint8Array(bufferLength);\r\n            let delayedArray = new Float32Array(bufferLength);\r\n            let normedArray = new Float32Array(bufferLength);\r\n            microphone.connect(analyser);\r\n            return new Microphone(audioContext, microphone, analyser, array, normedArray, delayedArray);\r\n        });\r\n    }\r\n    getTimeDomain() {\r\n        this.analyser.getByteTimeDomainData(this.array);\r\n        return this.array;\r\n    }\r\n    getFrequency() {\r\n        this.analyser.getByteFrequencyData(this.array);\r\n        return this.array;\r\n    }\r\n    getTimeDomainNormalized() {\r\n        this.getTimeDomain();\r\n        for (let i = 0; i < this.array.length; i++) {\r\n            this.normedArray[i] = (this.array[i] / 128) - 1;\r\n        }\r\n        return this.normedArray;\r\n    }\r\n    getFrequencyNormalized() {\r\n        this.getFrequency();\r\n        for (let i = 0; i < this.array.length; i++) {\r\n            this.normedArray[i] = (this.array[i] / 128) - 1;\r\n        }\r\n        return this.normedArray;\r\n    }\r\n    getTimeDomainDelayed(falloff = 0.97) {\r\n        this.getTimeDomainNormalized();\r\n        for (let i = 0; i < this.array.length; i++) {\r\n            if (this.normedArray[i] > this.delayedArray[i]) {\r\n                this.delayedArray[i] = this.normedArray[i];\r\n            }\r\n            else {\r\n                this.delayedArray[i] *= falloff;\r\n                // this.delayedArray[i] =  Math.max(0, this.delayedArray[i] - falloff);\r\n            }\r\n        }\r\n        return this.delayedArray;\r\n    }\r\n    getFrequencyDelayed(falloff = 0.97) {\r\n        this.getTimeDomainNormalized();\r\n        for (let i = 0; i < this.array.length; i++) {\r\n            if (this.normedArray[i] > this.delayedArray[i]) {\r\n                this.delayedArray[i] = this.normedArray[i];\r\n            }\r\n            else {\r\n                this.delayedArray[i] *= falloff;\r\n                // this.delayedArray[i] =  Math.max(0, this.delayedArray[i] - falloff);\r\n            }\r\n        }\r\n        return this.delayedArray;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/util/Microphone.ts?");

/***/ }),

/***/ "../engine/src/util/Stopwatch.ts":
/*!***************************************!*\
  !*** ../engine/src/util/Stopwatch.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stopwatch\": () => (/* binding */ Stopwatch)\n/* harmony export */ });\n/**\r\n * Note: this is obsolete, this functionality is build into the console.\r\n */\r\nclass Stopwatch {\r\n    constructor(oldTime, newTime) {\r\n        this.oldTime = oldTime;\r\n        this.newTime = newTime;\r\n    }\r\n    static new() {\r\n        let s = new Stopwatch(0, 0);\r\n        s.time();\r\n        return s;\r\n    }\r\n    time() {\r\n        this.newTime = this.getTime();\r\n        let timePast = this.newTime - this.oldTime;\r\n        this.oldTime = this.newTime;\r\n        return timePast;\r\n    }\r\n    log(event) {\r\n        console.log(`${event} took: ${this.time()} ms`);\r\n    }\r\n    getTime() {\r\n        return new Date().getTime();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/util/Stopwatch.ts?");

/***/ }),

/***/ "../engine/src/util/Time.ts":
/*!**********************************!*\
  !*** ../engine/src/util/Time.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Time\": () => (/* binding */ Time)\n/* harmony export */ });\nvar Time;\r\n(function (Time) {\r\n    function sleep(ms) {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n    Time.sleep = sleep;\r\n})(Time || (Time = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/util/Time.ts?");

/***/ }),

/***/ "../engine/src/util/Util.ts":
/*!**********************************!*\
  !*** ../engine/src/util/Util.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Util\": () => (/* binding */ Util)\n/* harmony export */ });\n// DUPLICATE!!\r\nvar Util;\r\n(function (Util) {\r\n    function range(count) {\r\n        let i = 0;\r\n        let numbers = Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            numbers[i] = i;\r\n        }\r\n        return numbers;\r\n    }\r\n    Util.range = range;\r\n    /**\r\n     * True if the current browser this code exists within is a mobile device's.\r\n     */\r\n    function isUserMobile() {\r\n        return (/Mobi|Android/i.test(navigator.userAgent));\r\n    }\r\n    Util.isUserMobile = isUserMobile;\r\n})(Util || (Util = {}));\r\n\n\n//# sourceURL=webpack://geon-demo/../engine/src/util/Util.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;