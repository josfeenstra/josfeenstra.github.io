/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../engine/src/algorithms/marching-cubes.ts":
/*!**************************************************!*\
  !*** ../engine/src/algorithms/marching-cubes.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mesh_mesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/mesh */ \"../engine/src/mesh/mesh.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n// name:    marching-cubes.ts\r\n// author:  Jos Feenstra\r\n// purpose: a marching cubes implementation useful for converting scalar discrete fields to contours\r\n\r\n\r\n// based upon:\r\n// http://paulbourke.net/geometry/polygonise/\r\n// Polygonising a scalar field\r\n// Also known as: \"3D Contouring\", \"Marching Cubes\", \"Surface Reconstruction\"\r\n// Written by Paul Bourke\r\n// May 1994\r\n//\r\n//\r\n// The cube model used:\r\n//\r\n//     (4) ------ 4 ------ (5)\r\n//     /|                  /|\r\n//    7 |                 5 |\r\n//   /  |                /  |\r\n// (7) ------ 6 ------ (6)  |\r\n//  |   8               |   9\r\n//  |   |               |   |\r\n//  |   |               |   |\r\n//  |  (0) ------ 0 ------ (1)\r\n//  11 /               10  /\r\n//  | 3                 | 1\r\n//  |/                  |/\r\n// (3) ------ 2 ------ (2)\r\n/*\r\n    Given a grid cell and an isolevel, calculate the triangular\r\n    facets required to represent the isosurface through the cell.\r\n    Return the number of triangular facets, the array \"triangles\"\r\n    will be loaded up with the vertices at most 5 triangular facets.\r\n     0 will be returned if the grid cell is either totally above\r\n    of totally below the isolevel.\r\n */\r\n// typedef struct {\r\n//     XYZ p[3];\r\n//  } TRIANGLE;\r\n//  typedef struct {\r\n//     XYZ p[8];\r\n//     double val[8];\r\n//  } GRIDCELL;\r\nclass Gridcell {\r\n    constructor() {\r\n        this.points = []; // 8\r\n        this.corner = []; // 8\r\n    }\r\n}\r\nclass Triangle {\r\n    constructor() {\r\n        this.xyz = []; // 3\r\n    }\r\n}\r\nconst edgeTable = [\r\n    0x0,\r\n    0x109,\r\n    0x203,\r\n    0x30a,\r\n    0x406,\r\n    0x50f,\r\n    0x605,\r\n    0x70c,\r\n    0x80c,\r\n    0x905,\r\n    0xa0f,\r\n    0xb06,\r\n    0xc0a,\r\n    0xd03,\r\n    0xe09,\r\n    0xf00,\r\n    0x190,\r\n    0x99,\r\n    0x393,\r\n    0x29a,\r\n    0x596,\r\n    0x49f,\r\n    0x795,\r\n    0x69c,\r\n    0x99c,\r\n    0x895,\r\n    0xb9f,\r\n    0xa96,\r\n    0xd9a,\r\n    0xc93,\r\n    0xf99,\r\n    0xe90,\r\n    0x230,\r\n    0x339,\r\n    0x33,\r\n    0x13a,\r\n    0x636,\r\n    0x73f,\r\n    0x435,\r\n    0x53c,\r\n    0xa3c,\r\n    0xb35,\r\n    0x83f,\r\n    0x936,\r\n    0xe3a,\r\n    0xf33,\r\n    0xc39,\r\n    0xd30,\r\n    0x3a0,\r\n    0x2a9,\r\n    0x1a3,\r\n    0xaa,\r\n    0x7a6,\r\n    0x6af,\r\n    0x5a5,\r\n    0x4ac,\r\n    0xbac,\r\n    0xaa5,\r\n    0x9af,\r\n    0x8a6,\r\n    0xfaa,\r\n    0xea3,\r\n    0xda9,\r\n    0xca0,\r\n    0x460,\r\n    0x569,\r\n    0x663,\r\n    0x76a,\r\n    0x66,\r\n    0x16f,\r\n    0x265,\r\n    0x36c,\r\n    0xc6c,\r\n    0xd65,\r\n    0xe6f,\r\n    0xf66,\r\n    0x86a,\r\n    0x963,\r\n    0xa69,\r\n    0xb60,\r\n    0x5f0,\r\n    0x4f9,\r\n    0x7f3,\r\n    0x6fa,\r\n    0x1f6,\r\n    0xff,\r\n    0x3f5,\r\n    0x2fc,\r\n    0xdfc,\r\n    0xcf5,\r\n    0xfff,\r\n    0xef6,\r\n    0x9fa,\r\n    0x8f3,\r\n    0xbf9,\r\n    0xaf0,\r\n    0x650,\r\n    0x759,\r\n    0x453,\r\n    0x55a,\r\n    0x256,\r\n    0x35f,\r\n    0x55,\r\n    0x15c,\r\n    0xe5c,\r\n    0xf55,\r\n    0xc5f,\r\n    0xd56,\r\n    0xa5a,\r\n    0xb53,\r\n    0x859,\r\n    0x950,\r\n    0x7c0,\r\n    0x6c9,\r\n    0x5c3,\r\n    0x4ca,\r\n    0x3c6,\r\n    0x2cf,\r\n    0x1c5,\r\n    0xcc,\r\n    0xfcc,\r\n    0xec5,\r\n    0xdcf,\r\n    0xcc6,\r\n    0xbca,\r\n    0xac3,\r\n    0x9c9,\r\n    0x8c0,\r\n    0x8c0,\r\n    0x9c9,\r\n    0xac3,\r\n    0xbca,\r\n    0xcc6,\r\n    0xdcf,\r\n    0xec5,\r\n    0xfcc,\r\n    0xcc,\r\n    0x1c5,\r\n    0x2cf,\r\n    0x3c6,\r\n    0x4ca,\r\n    0x5c3,\r\n    0x6c9,\r\n    0x7c0,\r\n    0x950,\r\n    0x859,\r\n    0xb53,\r\n    0xa5a,\r\n    0xd56,\r\n    0xc5f,\r\n    0xf55,\r\n    0xe5c,\r\n    0x15c,\r\n    0x55,\r\n    0x35f,\r\n    0x256,\r\n    0x55a,\r\n    0x453,\r\n    0x759,\r\n    0x650,\r\n    0xaf0,\r\n    0xbf9,\r\n    0x8f3,\r\n    0x9fa,\r\n    0xef6,\r\n    0xfff,\r\n    0xcf5,\r\n    0xdfc,\r\n    0x2fc,\r\n    0x3f5,\r\n    0xff,\r\n    0x1f6,\r\n    0x6fa,\r\n    0x7f3,\r\n    0x4f9,\r\n    0x5f0,\r\n    0xb60,\r\n    0xa69,\r\n    0x963,\r\n    0x86a,\r\n    0xf66,\r\n    0xe6f,\r\n    0xd65,\r\n    0xc6c,\r\n    0x36c,\r\n    0x265,\r\n    0x16f,\r\n    0x66,\r\n    0x76a,\r\n    0x663,\r\n    0x569,\r\n    0x460,\r\n    0xca0,\r\n    0xda9,\r\n    0xea3,\r\n    0xfaa,\r\n    0x8a6,\r\n    0x9af,\r\n    0xaa5,\r\n    0xbac,\r\n    0x4ac,\r\n    0x5a5,\r\n    0x6af,\r\n    0x7a6,\r\n    0xaa,\r\n    0x1a3,\r\n    0x2a9,\r\n    0x3a0,\r\n    0xd30,\r\n    0xc39,\r\n    0xf33,\r\n    0xe3a,\r\n    0x936,\r\n    0x83f,\r\n    0xb35,\r\n    0xa3c,\r\n    0x53c,\r\n    0x435,\r\n    0x73f,\r\n    0x636,\r\n    0x13a,\r\n    0x33,\r\n    0x339,\r\n    0x230,\r\n    0xe90,\r\n    0xf99,\r\n    0xc93,\r\n    0xd9a,\r\n    0xa96,\r\n    0xb9f,\r\n    0x895,\r\n    0x99c,\r\n    0x69c,\r\n    0x795,\r\n    0x49f,\r\n    0x596,\r\n    0x29a,\r\n    0x393,\r\n    0x99,\r\n    0x190,\r\n    0xf00,\r\n    0xe09,\r\n    0xd03,\r\n    0xc0a,\r\n    0xb06,\r\n    0xa0f,\r\n    0x905,\r\n    0x80c,\r\n    0x70c,\r\n    0x605,\r\n    0x50f,\r\n    0x406,\r\n    0x30a,\r\n    0x203,\r\n    0x109,\r\n    0x0,\r\n];\r\nconst triTable = [\r\n    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],\r\n    [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],\r\n    [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],\r\n    [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],\r\n    [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],\r\n    [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],\r\n    [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],\r\n    [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],\r\n    [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],\r\n    [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],\r\n    [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],\r\n    [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],\r\n    [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],\r\n    [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],\r\n    [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],\r\n    [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],\r\n    [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],\r\n    [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],\r\n    [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],\r\n    [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],\r\n    [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],\r\n    [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],\r\n    [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],\r\n    [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],\r\n    [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],\r\n    [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],\r\n    [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],\r\n    [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],\r\n    [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],\r\n    [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],\r\n    [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],\r\n    [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],\r\n    [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],\r\n    [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],\r\n    [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],\r\n    [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],\r\n    [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],\r\n    [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],\r\n    [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],\r\n    [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],\r\n    [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],\r\n    [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],\r\n    [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],\r\n    [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],\r\n    [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],\r\n    [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],\r\n    [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],\r\n    [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],\r\n    [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],\r\n    [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],\r\n    [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],\r\n    [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],\r\n    [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],\r\n    [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],\r\n    [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],\r\n    [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],\r\n    [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],\r\n    [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],\r\n    [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],\r\n    [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],\r\n    [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],\r\n    [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],\r\n    [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],\r\n    [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],\r\n    [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],\r\n    [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],\r\n    [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],\r\n    [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],\r\n    [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],\r\n    [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],\r\n    [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],\r\n    [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],\r\n    [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],\r\n    [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],\r\n    [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],\r\n    [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],\r\n    [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],\r\n    [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],\r\n    [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],\r\n    [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],\r\n    [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],\r\n    [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],\r\n    [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],\r\n    [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],\r\n    [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],\r\n    [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],\r\n    [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],\r\n    [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],\r\n    [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],\r\n    [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],\r\n    [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],\r\n    [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],\r\n    [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],\r\n    [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],\r\n    [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],\r\n    [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],\r\n    [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],\r\n    [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],\r\n    [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],\r\n    [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],\r\n    [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],\r\n    [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],\r\n    [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],\r\n    [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],\r\n    [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],\r\n    [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],\r\n    [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],\r\n    [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],\r\n    [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],\r\n    [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],\r\n    [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],\r\n];\r\nfunction polygonise(corners, values, level) {\r\n    let triangles = null;\r\n    // get the marching cube index based on corners\r\n    let cubeindex = 0;\r\n    if (values[0] < level)\r\n        cubeindex |= 1;\r\n    if (values[1] < level)\r\n        cubeindex |= 2;\r\n    if (values[2] < level)\r\n        cubeindex |= 4;\r\n    if (values[3] < level)\r\n        cubeindex |= 8;\r\n    if (values[4] < level)\r\n        cubeindex |= 16;\r\n    if (values[5] < level)\r\n        cubeindex |= 32;\r\n    if (values[6] < level)\r\n        cubeindex |= 64;\r\n    if (values[7] < level)\r\n        cubeindex |= 128;\r\n    /* Cube is entirely in/out of the surface */\r\n    let vertlist = []; // 12\r\n    if (edgeTable[cubeindex] == 0)\r\n        return _mesh_mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh.zero();\r\n    /* Find the vertices where the surface intersects the cube */\r\n    if (edgeTable[cubeindex] & 1)\r\n        vertlist[0] = lerp(level, corners[0], corners[1], values[0], values[1]);\r\n    if (edgeTable[cubeindex] & 2)\r\n        vertlist[1] = lerp(level, corners[1], corners[2], values[1], values[2]);\r\n    if (edgeTable[cubeindex] & 4)\r\n        vertlist[2] = lerp(level, corners[2], corners[3], values[2], values[3]);\r\n    if (edgeTable[cubeindex] & 8)\r\n        vertlist[3] = lerp(level, corners[3], corners[0], values[3], values[0]);\r\n    if (edgeTable[cubeindex] & 16)\r\n        vertlist[4] = lerp(level, corners[4], corners[5], values[4], values[5]);\r\n    if (edgeTable[cubeindex] & 32)\r\n        vertlist[5] = lerp(level, corners[5], corners[6], values[5], values[6]);\r\n    if (edgeTable[cubeindex] & 64)\r\n        vertlist[6] = lerp(level, corners[6], corners[7], values[6], values[7]);\r\n    if (edgeTable[cubeindex] & 128)\r\n        vertlist[7] = lerp(level, corners[7], corners[4], values[7], values[4]);\r\n    if (edgeTable[cubeindex] & 256)\r\n        vertlist[8] = lerp(level, corners[0], corners[4], values[0], values[4]);\r\n    if (edgeTable[cubeindex] & 512)\r\n        vertlist[9] = lerp(level, corners[1], corners[5], values[1], values[5]);\r\n    if (edgeTable[cubeindex] & 1024)\r\n        vertlist[10] = lerp(level, corners[2], corners[6], values[2], values[6]);\r\n    if (edgeTable[cubeindex] & 2048)\r\n        vertlist[11] = lerp(level, corners[3], corners[7], values[3], values[7]);\r\n    // create triangles\r\n    // ntriang = 0;\r\n    // for (let i = 0; triTable[cubeindex][i]!=-1; i+=3) {\r\n    //     triangles[ntriang].p[0] = vertlist[triTable[cubeindex][i  ]];\r\n    //     triangles[ntriang].p[1] = vertlist[triTable[cubeindex][i+1]];\r\n    //     triangles[ntriang].p[2] = vertlist[triTable[cubeindex][i+2]];\r\n    //     ntriang++;\r\n    // }\r\n    // return(ntriang);\r\n    return _mesh_mesh__WEBPACK_IMPORTED_MODULE_0__.Mesh.zero();\r\n}\r\n/*\r\n    Linearly interpolate the position where an isosurface cuts\r\n    an edge between two vertices, each with their own scalar value\r\n */\r\nfunction lerp(level, p1, p2, valp1, valp2) {\r\n    return _math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector3.fromLerpWeights(p1, p2, valp1, valp2, level);\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/algorithms/marching-cubes.ts?");

/***/ }),

/***/ "../engine/src/algorithms/perlin-noise.ts":
/*!************************************************!*\
  !*** ../engine/src/algorithms/perlin-noise.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Perlin\": () => (/* binding */ Perlin)\n/* harmony export */ });\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/math */ \"../engine/src/math/math.ts\");\n// name:        perlin-noise.ts\r\n// author:      Jos Feenstra\r\n// purpose:     Generate Perin Noise\r\n\r\n// a javascript implementation of:\r\n// Ref : https://adrianb.io/2014/08/09/perlinnoise.html\r\n// Hash lookup table as defined by Ken Perlin.  This is a randomly\r\n// arranged array of all numbers from 0-255 inclusive.\r\nclass Perlin {\r\n    constructor() {\r\n        this.permutation = [\r\n            151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30,\r\n            69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94,\r\n            252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171,\r\n            168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60,\r\n            211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216,\r\n            80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100,\r\n            109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85,\r\n            212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2,\r\n            44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79,\r\n            113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191,\r\n            179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84,\r\n            204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141,\r\n            128, 195, 78, 66, 215, 61, 156, 180,\r\n        ];\r\n        this.repeat = 0;\r\n        this.repeat = 0;\r\n        this.p = new Array(512);\r\n        for (let x = 0; x < 512; x++) {\r\n            this.p[x] = this.permutation[x % 256];\r\n        }\r\n    }\r\n    static new() {\r\n        return new Perlin();\r\n    }\r\n    grad(hash, x, y, z) {\r\n        switch (hash & 0xf) {\r\n            case 0x0:\r\n                return x + y;\r\n            case 0x1:\r\n                return -x + y;\r\n            case 0x2:\r\n                return x - y;\r\n            case 0x3:\r\n                return -x - y;\r\n            case 0x4:\r\n                return x + z;\r\n            case 0x5:\r\n                return -x + z;\r\n            case 0x6:\r\n                return x - z;\r\n            case 0x7:\r\n                return -x - z;\r\n            case 0x8:\r\n                return y + z;\r\n            case 0x9:\r\n                return -y + z;\r\n            case 0xa:\r\n                return y - z;\r\n            case 0xb:\r\n                return -y - z;\r\n            case 0xc:\r\n                return y + x;\r\n            case 0xd:\r\n                return -y + z;\r\n            case 0xe:\r\n                return y - x;\r\n            case 0xf:\r\n                return -y - z;\r\n            default:\r\n                return 0; // never happens\r\n        }\r\n    }\r\n    inc(num) {\r\n        num++;\r\n        if (this.repeat > 0)\r\n            num %= this.repeat;\r\n        return num;\r\n    }\r\n    noise(x, y, z) {\r\n        // If we have any repeat on, change the coordinates to their \"local\" repetitions\r\n        if (this.repeat > 0) {\r\n            x = x % this.repeat;\r\n            y = y % this.repeat;\r\n            z = z % this.repeat;\r\n        }\r\n        let xi = Math.floor(x) & 255; // Calculate the \"unit cube\" that the point asked will be located in\r\n        let yi = Math.floor(y) & 255; // The left bound is ( |_x_|,|_y_|,|_z_| ) and the right bound is that\r\n        let zi = Math.floor(z) & 255; // plus 1.  Next we calculate the location (from 0.0 to 1.0) in that cube.\r\n        let xf = x - Math.floor(x);\r\n        let yf = y - Math.floor(y);\r\n        let zf = z - Math.floor(z);\r\n        let p = this.p;\r\n        let aaa = p[p[p[xi] + yi] + zi];\r\n        let aba = p[p[p[xi] + this.inc(yi)] + zi];\r\n        let aab = p[p[p[xi] + yi] + this.inc(zi)];\r\n        let abb = p[p[p[xi] + this.inc(yi)] + this.inc(zi)];\r\n        let baa = p[p[p[this.inc(xi)] + yi] + zi];\r\n        let bba = p[p[p[this.inc(xi)] + this.inc(yi)] + zi];\r\n        let bab = p[p[p[this.inc(xi)] + yi] + this.inc(zi)];\r\n        let bbb = p[p[p[this.inc(xi)] + this.inc(yi)] + this.inc(zi)];\r\n        let u = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.smooth(xf);\r\n        let v = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.smooth(yf);\r\n        let w = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.smooth(zf);\r\n        let x1, x2, y1, y2;\r\n        x1 = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(aaa, xf, yf, zf), // The gradient function calculates the dot product between a pseudorandom\r\n        this.grad(baa, xf - 1, yf, zf), // gradient vector and the vector from the input coordinate to the 8\r\n        u); // surrounding points in its unit cube.\r\n        x2 = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(aba, xf, yf - 1, zf), // This is all then lerped together as a sort of weighted average based on the faded (u,v,w)\r\n        this.grad(bba, xf - 1, yf - 1, zf), // values we made earlier.\r\n        u);\r\n        y1 = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(x1, x2, v);\r\n        x1 = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(aab, xf, yf, zf - 1), this.grad(bab, xf - 1, yf, zf - 1), u);\r\n        x2 = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(this.grad(abb, xf, yf - 1, zf - 1), this.grad(bbb, xf - 1, yf - 1, zf - 1), u);\r\n        y2 = _math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(x1, x2, v);\r\n        return (_math_math__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(y1, y2, w) + 1) / 2;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/algorithms/perlin-noise.ts?");

/***/ }),

/***/ "../engine/src/app/app.ts":
/*!********************************!*\
  !*** ../engine/src/app/app.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"App\": () => (/* binding */ App)\n/* harmony export */ });\nclass App {\r\n    constructor(gl, des = \"\") {\r\n        // unique constructor\r\n        this.gl = gl;\r\n        this.name = this.constructor.name;\r\n        this.description = des;\r\n    }\r\n    ui(ui) {\r\n        // setup for UI\r\n    }\r\n    start() {\r\n        // additional setup of state\r\n    }\r\n    update(state) {\r\n        // updating state\r\n    }\r\n    draw(gl) {\r\n        // drawing state\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/app/app.ts?");

/***/ }),

/***/ "../engine/src/app/swap-app.ts":
/*!*************************************!*\
  !*** ../engine/src/app/swap-app.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SwapApp\": () => (/* binding */ SwapApp)\n/* harmony export */ });\n/* harmony import */ var _system_ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../system/ui */ \"../engine/src/system/ui.ts\");\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app */ \"../engine/src/app/app.ts\");\n// name:    swap-app\r\n// author:  Jos Feenstra\r\n// purpose: swap between different apps.\r\n//          - factory for initiazing these apps\r\n//          - making sure core deletes old apps\r\n\r\n\r\nclass SwapApp extends _app__WEBPACK_IMPORTED_MODULE_1__.App {\r\n    constructor(gl, core, possibleApps) {\r\n        super(gl);\r\n        this.currentAppIndex = -1;\r\n        this.isuihidden = false;\r\n        this.core = core;\r\n        this.possibleApps = possibleApps;\r\n    }\r\n    getAppNames() {\r\n        let names = [];\r\n        let count = this.possibleApps.length;\r\n        for (let i = 0; i < count; i++) {\r\n            names.push(this.possibleApps[i].name.replace(\"App\", \"\"));\r\n        }\r\n        return names;\r\n    }\r\n    ui(ui) {\r\n        let names = this.getAppNames();\r\n        this.param = _system_ui__WEBPACK_IMPORTED_MODULE_0__.EnumParameter.new(\"apps\", 0, names);\r\n        ui.addDropdown(this.param, (i) => {\r\n            this.swap(i);\r\n        });\r\n    }\r\n    swapFromUrl(hash, ifnot) {\r\n        // select one of the apps based on an url\r\n        let test = hash.substr(1);\r\n        let names = this.getAppNames();\r\n        for (let i = 0; i < names.length; i++) {\r\n            if (names[i].toLowerCase() === test) {\r\n                this.swap(i);\r\n                return;\r\n            }\r\n        }\r\n        // no match\r\n        console.log(\"no hash match, defaulting...\");\r\n        this.swap(ifnot);\r\n    }\r\n    swap(index) {\r\n        // todo do some range checking\r\n        let AppType = this.possibleApps[index];\r\n        if (this.currentAppIndex > -1) {\r\n            let PreviousType = this.possibleApps[this.currentAppIndex];\r\n            console.log(\"removing\", PreviousType.name);\r\n            this.core.removeApp(PreviousType.name);\r\n        }\r\n        console.log(\"constructing\", AppType.name);\r\n        this.currentAppIndex = index;\r\n        let app = new AppType(this.gl);\r\n        location.hash = \"#\" + AppType.name.replace(\"App\", \"\").toLowerCase();\r\n        this.core.addApp(app);\r\n    }\r\n    update(state) {\r\n        if (state.IsKeyPressed(\"m\")) {\r\n            // simple toggle\r\n            this.core.ui.toggleVisibility();\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/app/swap-app.ts?");

/***/ }),

/***/ "../engine/src/combo/combo.ts":
/*!************************************!*\
  !*** ../engine/src/combo/combo.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Combi\": () => (/* binding */ Combi),\n/* harmony export */   \"Combo\": () => (/* binding */ Combo)\n/* harmony export */ });\n// name:    combo.ts\r\n// author:  Jos Feenstra\r\n// purpose:\r\n// - combination of state, bufferedState, and renderer:\r\n//\r\n// 1.      state\r\n//           ||\r\n//        (buffer)\r\n//           \\/\r\n// 2.     buffered\r\n//           ||\r\n//        (render)\r\n//           \\/\r\n// 3. rendered to screen\r\n//\r\n// TODO: maybe find a better name, but 'combo' is quite distinct in a way\r\n// todo: force buffering a bit more. make a way that requiers this.buffered to be filled\r\n// staticcombo\r\n// dynacombo\r\n// multistaic combo\r\n// Vector3 & dotrenderer\r\nclass Combi {\r\n    constructor(gl, state, renderConstructor) {\r\n        this.buffered = [];\r\n        this.state = [];\r\n        this.buffered;\r\n        this.renderer = renderConstructor(gl);\r\n    }\r\n    buffer() { }\r\n    render(context) {\r\n        for (let i = 0; i < this.buffered.length; i++) {\r\n            const b = this.buffered[i];\r\n            this.renderer.setAndRender(b, context);\r\n        }\r\n    }\r\n}\r\nclass Combo {\r\n    constructor(gl, state, renderConstructor) {\r\n        this.state = state;\r\n        this.buffered;\r\n        this.renderer = renderConstructor(gl);\r\n    }\r\n    buffer() { }\r\n    render(context) {\r\n        this.renderer.render(context);\r\n    }\r\n}\r\n// Combi\r\n// // small tie-together of data & renderer.\r\n// // used to interact with the rendering behaviour of a renderableMesh.\r\n// // TODO: typecheck if data & renderer are compatible\r\n// import { Renderer, DrawSpeed } from \"./renderer\";\r\n// import { Scene } from \"./scene\";\r\n// // TODO add this information to the new Renderable\r\n// export class StaticRenderUnit<R extends Renderer, D> {\r\n//     renderer: R;\r\n//     data: D;\r\n//     constructor(renderer: R, data: D) {\r\n//         this.renderer = renderer;\r\n//         this.data = data;\r\n//     }\r\n//     static new<A extends Renderer, B>(renderer: A, data: B): StaticRenderUnit<A, B> {\r\n//         return new StaticRenderUnit(renderer, data);\r\n//     }\r\n//     buffer() {\r\n//         this.renderer.buffer(this.data);\r\n//     }\r\n//     render(context: Scene) {\r\n//         this.renderer.render(context);\r\n//     }\r\n// }\r\n// export class DynamicRenderUnit<R extends Renderer, D> {\r\n//     renderer: R;\r\n//     data: D;\r\n//     constructor(renderer: R, data: D) {\r\n//         this.renderer = renderer;\r\n//         this.data = data;\r\n//     }\r\n//     static new<A extends Renderer, B>(renderer: A, data: B): DynamicRenderUnit<A, B> {\r\n//         return new DynamicRenderUnit(renderer, data);\r\n//     }\r\n//     render(context: Scene) {\r\n//         this.renderer.buffer();\r\n//         this.renderer.render(context);\r\n//     }\r\n// }\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/combo/combo.ts?");

/***/ }),

/***/ "../engine/src/combo/image-combi.ts":
/*!******************************************!*\
  !*** ../engine/src/combo/image-combi.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ImageCombi\": () => (/* binding */ ImageCombi)\n/* harmony export */ });\n/* harmony import */ var _geo_plane__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geo/plane */ \"../engine/src/geo/plane.ts\");\n/* harmony import */ var _geo_rectangle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geo/rectangle */ \"../engine/src/geo/rectangle.ts\");\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _mesh_mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../mesh/mesh */ \"../engine/src/mesh/mesh.ts\");\n/* harmony import */ var _shaders_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../shaders/texture-mesh-shader */ \"../engine/src/shaders/texture-mesh-shader.ts\");\n/* harmony import */ var _combo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./combo */ \"../engine/src/combo/combo.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass ImageCombi extends _combo__WEBPACK_IMPORTED_MODULE_6__.Combi {\r\n    constructor(gl) {\r\n        super(gl, [], _shaders_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_5__.TextureMeshShader.new);\r\n    }\r\n    static new(gl) {\r\n        return new ImageCombi(gl);\r\n    }\r\n    buffer() {\r\n        // i was having trouble rendering images... this is a workaround:\r\n        // convert the this.images[] list into the this.imageMeshes list. then render that with the normal renderer\r\n        this.buffered = [];\r\n        let size = 256;\r\n        let accHeight = 0;\r\n        this.state.forEach((s, i) => {\r\n            let height = s.height;\r\n            let width = s.width;\r\n            let rec = new _geo_rectangle__WEBPACK_IMPORTED_MODULE_1__.Rectangle3(_geo_plane__WEBPACK_IMPORTED_MODULE_0__.Plane.fromPVV(new _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 0), new _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3(0, 0, 1), new _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3(-1, 0, 0)), _math_domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromBounds(10, 10 + width, accHeight, accHeight + height));\r\n            let mesh = _mesh_mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromRect(rec);\r\n            mesh.setTexture(s.resize(size, size).toImageData()); // note: webgl can only work with 2^x * 512 images\r\n            this.buffered.push(mesh);\r\n            accHeight += height + 10;\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/combo/image-combi.ts?");

/***/ }),

/***/ "../engine/src/data/float-matrix.ts":
/*!******************************************!*\
  !*** ../engine/src/data/float-matrix.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FloatMatrix\": () => (/* binding */ FloatMatrix)\n/* harmony export */ });\n// generic all-pupose matrix of floats\r\nclass FloatMatrix {\r\n    constructor(height, width, data = []) {\r\n        this.height = height;\r\n        this.width = width;\r\n        this.data = new Float32Array(this.width * this.height);\r\n        if (data == [] || data.length == 0) {\r\n            // this.fill(0); // not needed, and not efficient ;)\r\n        }\r\n        else\r\n            this.setData(data);\r\n    }\r\n    print() {\r\n        let strings = [];\r\n        const WIDTH = 8;\r\n        for (var i = 0; i < this.width; i++) {\r\n            strings.push(\"|\");\r\n            for (var j = 0; j < this.height; j++) {\r\n                let str = this.get(j, i).toFixed(2); // TODO THIS IS INCORRECT\r\n                str = str.padStart(WIDTH, \" \");\r\n                strings.push(str);\r\n                if (j < this.width - 2) {\r\n                    strings.push(\"  \");\r\n                }\r\n            }\r\n            strings.push(\"  |\\n\");\r\n        }\r\n        console.log(strings.join(\"\"));\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.height * this.width)\r\n            throw \"data.length does not match width * height \" + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    count() {\r\n        // number of entries / rows.\r\n        // when derrived classes ask for 'how many of x?' they usually mean this.\r\n        return this.height;\r\n    }\r\n    getDimensions() {\r\n        return [this.height, this.width];\r\n    }\r\n    fill(value) {\r\n        let size = this.height * this.width;\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    fillWith(data, valuesPerEntry = this.width) {\r\n        // values per entry can be used to setData which is not of the same shape.\r\n        let vpe = valuesPerEntry;\r\n        if (vpe > this.width)\r\n            throw \"values per entry is larger than this._width. This will spill over.\";\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < vpe; j++) {\r\n                this.set(i, j, data[i * vpe + j]);\r\n            }\r\n        }\r\n    }\r\n    fillFrom(other) {\r\n        if (other.height < this.height || other.width < this.width) {\r\n            throw new Error(\"need same dimentions\");\r\n        }\r\n        for (let i = 0; i < other.height; i++) {\r\n            for (let j = 0; j < 2; j++) {\r\n                this.set(i, j, other.get(i, j));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    get(i, j) {\r\n        return this.data[i * this.width + j];\r\n    }\r\n    getRow(i) {\r\n        // if (i < 0 || i > this.height) throw \"column is out of bounds for FloatArray\"\r\n        let data = new Float32Array(this.width);\r\n        for (let j = 0; j < this.width; j++) {\r\n            data[j] = this.get(i, j);\r\n        }\r\n        return data;\r\n    }\r\n    getColumn(j) {\r\n        // if (j < 0 || j > this.width) throw \"column is out of bounds for FloatArray\"\r\n        let data = new Float32Array(this.height);\r\n        for (let i = 0; i < this.height; i++) {\r\n            let index = i * this.width + j;\r\n            data[i] = this.data[index];\r\n        }\r\n        return data;\r\n    }\r\n    set(i, j, value) {\r\n        this.data[i * this.width + j] = value;\r\n    }\r\n    setRow(rowIndex, row) {\r\n        // if (this.width != row.length) throw \"dimention of floatarray is not \" + row.length;\r\n        for (let j = 0; j < this.width; j++) {\r\n            this.set(rowIndex, j, row[j]);\r\n        }\r\n    }\r\n    forEachValue(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n        return this;\r\n    }\r\n    takeRows(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = new FloatMatrix(count, this.width);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setRow(i, this.getRow(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    // create a new floatmatrix, processed by iterating\r\n    mapWith(other, callback) {\r\n        let result = this.clone();\r\n        let width = Math.min(this.width, other.height);\r\n        let height = Math.min(this.height, other.height);\r\n        for (var i = 0; i < height; i++) {\r\n            for (var j = 0; j < width; j++) {\r\n                result.set(i, j, callback(this.get(i, j), other.get(i, j)));\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // generalized multiplication\r\n    multiplied(b) {\r\n        let a = this;\r\n        if (b.height !== a.width) {\r\n            throw new Error(`Columns in A should be the same as the number of rows in B\r\n                b.width ${b.height},\r\n                a.height ${a.width}`);\r\n        }\r\n        var product = new FloatMatrix(a.height, b.width);\r\n        for (var i = 0; i < product.height; i++) {\r\n            for (var j = 0; j < b.width; j++) {\r\n                for (var k = 0; k < a.width; k++) {\r\n                    product.set(i, j, product.get(i, j) + a.get(i, k) * b.get(k, j));\r\n                }\r\n            }\r\n        }\r\n        return product;\r\n    }\r\n    multiply(b) {\r\n        let result = this.multiplied(b);\r\n        this.data = result.data;\r\n        return this;\r\n    }\r\n    static fromNative(native) {\r\n        // assume all subarrays have the same shape!!\r\n        let height = native.length;\r\n        let width = native[0].length;\r\n        let matrix = new FloatMatrix(height, width);\r\n        for (var i = 0; i < native.length; i++) {\r\n            for (var j = 0; j < native[0].length; j++) {\r\n                matrix.set(i, j, native[i][j]);\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n    toNative() {\r\n        let native = [];\r\n        for (var i = 0; i < this.height; i++) {\r\n            native[i] = [];\r\n            for (var j = 0; j < this.width; j++) {\r\n                native[i][j] = this.get(i, j);\r\n            }\r\n        }\r\n        return native;\r\n    }\r\n    // geo trait\r\n    clone() {\r\n        let clone = new FloatMatrix(this.height, this.width);\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            clone.data[i] = this.data[i];\r\n        }\r\n        return clone;\r\n    }\r\n}\r\n// stolen something from https://jamesmccaffrey.wordpress.com/2020/04/24/matrix-inverse-with-javascript/\r\n// James D. McCaffrey\r\n// function matInverse(m)\r\n// {\r\n//   // assumes determinant is not 0\r\n//   // that is, the matrix does have an inverse\r\n//   let n = m.length;\r\n//   let result = matMake(n, n, 0.0); // make a copy\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     for (let j = 0; j less-than n; ++j) {\r\n//       result[i][j] = m[i][j];\r\n//     }\r\n//   }\r\n//   let lum = matMake(n, n, 0.0); // combined lower & upper\r\n//   let perm = vecMake(n, 0.0);  // out parameter\r\n//   matDecompose(m, lum, perm);  // ignore return\r\n//   let b = vecMake(n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     for (let j = 0; j less-than n; ++j) {\r\n//       if (i == perm[j])\r\n//         b[j] = 1.0;\r\n//       else\r\n//         b[j] = 0.0;\r\n//     }\r\n//     let x = reduce(lum, b); //\r\n//     for (let j = 0; j less-than n; ++j)\r\n//       result[j][i] = x[j];\r\n//   }\r\n//   return result;\r\n// }\r\n// function matDeterminant(m)\r\n// {\r\n//   let n = m.length;\r\n//   let lum = matMake(n, n, 0.0);;\r\n//   let perm = vecMake(n, 0.0);\r\n//   let result = matDecompose(m, lum, perm);  // -1 or +1\r\n//   for (let i = 0; i less-than n; ++i)\r\n//     result *= lum[i][i];\r\n//   return result;\r\n// }\r\n// function matDecompose(m, lum, perm)\r\n// {\r\n//   // Crout's LU decomposition for matrix determinant and inverse\r\n//   // stores combined lower & upper in lum[][]\r\n//   // stores row permuations into perm[]\r\n//   // returns +1 or -1 according to even or odd perms\r\n//   // lower gets dummy 1.0s on diagonal (0.0s above)\r\n//   // upper gets lum values on diagonal (0.0s below)\r\n//   let toggle = +1; // even (+1) or odd (-1) row permutatuions\r\n//   let n = m.length;\r\n//   // make a copy of m[][] into result lum[][]\r\n//   //lum = matMake(n, n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     for (let j = 0; j less-than n; ++j) {\r\n//       lum[i][j] = m[i][j];\r\n//     }\r\n//   }\r\n//   // make perm[]\r\n//   //perm = vecMake(n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i)\r\n//     perm[i] = i;\r\n//   for (let j = 0; j less-than n - 1; ++j) {  // note n-1\r\n//     let max = Math.abs(lum[j][j]);\r\n//     let piv = j;\r\n//     for (let i = j + 1; i less-than n; ++i) {  // pivot index\r\n//       let xij = Math.abs(lum[i][j]);\r\n//       if (xij greater-than max) {\r\n//         max = xij;\r\n//         piv = i;\r\n//       }\r\n//     } // i\r\n//     if (piv != j) {\r\n//       let tmp = lum[piv];  // swap rows j, piv\r\n//       lum[piv] = lum[j];\r\n//       lum[j] = tmp;\r\n//       let t = perm[piv];  // swap perm elements\r\n//       perm[piv] = perm[j];\r\n//       perm[j] = t;\r\n//       toggle = -toggle;\r\n//     }\r\n//     let xjj = lum[j][j];\r\n//     if (xjj != 0.0) {  // TODO: fix bad compare here\r\n//       for (let i = j + 1; i less-than n; ++i) {\r\n//         let xij = lum[i][j] / xjj;\r\n//         lum[i][j] = xij;\r\n//         for (let k = j + 1; k less-than n; ++k) {\r\n//           lum[i][k] -= xij * lum[j][k];\r\n//         }\r\n//       }\r\n//     }\r\n//   } // j\r\n//   return toggle;  // for determinant\r\n// } // matDecompose\r\n// function reduce(lum, b) // helper\r\n// {\r\n//   let n = lum.length;\r\n//   let x = vecMake(n, 0.0);\r\n//   for (let i = 0; i less-than n; ++i) {\r\n//     x[i] = b[i];\r\n//   }\r\n//   for (let i = 1; i less-than n; ++i) {\r\n//     let sum = x[i];\r\n//     for (let j = 0; j less-than i; ++j) {\r\n//       sum -= lum[i][j] * x[j];\r\n//     }\r\n//     x[i] = sum;\r\n//   }\r\n//   x[n - 1] /= lum[n - 1][n - 1];\r\n//   for (let i = n - 2; i greater-than-equal 0; --i) {\r\n//     let sum = x[i];\r\n//     for (let j = i + 1; j less-than n; ++j) {\r\n//       sum -= lum[i][j] * x[j];\r\n//     }\r\n//     x[i] = sum / lum[i][i];\r\n//   }\r\n//   return x;\r\n// } // reduce\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/float-matrix.ts?");

/***/ }),

/***/ "../engine/src/data/hash-table.ts":
/*!****************************************!*\
  !*** ../engine/src/data/hash-table.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HashTable\": () => (/* binding */ HashTable)\n/* harmony export */ });\n// note: this wont always work, but it does in most cases\r\n// todo: implement proper hashtable\r\nclass HashTable {\r\n    constructor() {\r\n        this.data = new Map();\r\n    }\r\n    stringify(key) {\r\n        return key.toString();\r\n    }\r\n    set(key, value) {\r\n        return this.data.set(this.stringify(key), value);\r\n    }\r\n    has(key) {\r\n        return this.data.has(this.stringify(key));\r\n    }\r\n    get(key) {\r\n        return this.data.get(this.stringify(key));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/hash-table.ts?");

/***/ }),

/***/ "../engine/src/data/int-cube.ts":
/*!**************************************!*\
  !*** ../engine/src/data/int-cube.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntCube\": () => (/* binding */ IntCube)\n/* harmony export */ });\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n\r\n// a Cube of voxels\r\nclass IntCube {\r\n    constructor(height, width, depth, data = []) {\r\n        this._height = height;\r\n        this._width = width;\r\n        this._depth = depth;\r\n        let size = this._width * this._height * this._depth;\r\n        this.data = new Int32Array(size);\r\n        if (data == [] || data.length == 0)\r\n            this.fill(0);\r\n        else {\r\n            this.setData(data);\r\n        }\r\n    }\r\n    size() {\r\n        return this._width * this._height * this._depth;\r\n    }\r\n    // shallow copy\r\n    clone() {\r\n        let clone = new IntCube(this._height, this._width, this._depth);\r\n        clone.data = this.data;\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.size())\r\n            throw \"data.length does not match width * height \" + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    fill(value) {\r\n        let size = this.size();\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    inRange(i, j, k) {\r\n        return !(i < 0 || j < 0 || k < 0 || i > this._width - 1 || j > this._height - 1 || k > this._depth - 1);\r\n    }\r\n    getIndex(i, j, k) {\r\n        return i * (this._height * this._depth) + j * this._depth + k;\r\n    }\r\n    getCoords(index) {\r\n        // javascript, dont you dare turn  'int / int' into a float...\r\n        let i = Math.floor(index / (this._height * this._depth)) % this._width;\r\n        let j = Math.floor(index / this._depth) % this._height;\r\n        let k = index % this._depth;\r\n        return new _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3(i, j, k);\r\n    }\r\n    get(i, j, k) {\r\n        return this.data[this.getIndex(i, j, k)];\r\n    }\r\n    tryGet(i, j, k) {\r\n        if (this.inRange(i, j, k)) {\r\n            return this.data[this.getIndex(i, j, k)];\r\n        }\r\n        else {\r\n            return;\r\n        }\r\n    }\r\n    set(i, j, k, value) {\r\n        this.data[this.getIndex(i, j, k)] = value;\r\n    }\r\n    trySet(i, j, k, value) {\r\n        if (this.inRange(i, j, k)) {\r\n            this.data[this.getIndex(i, j, k)] = value;\r\n        }\r\n    }\r\n    iter(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            callbackfn(this.data[i], i);\r\n        }\r\n    }\r\n    map(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n    }\r\n    trueForAll(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (!callbackfn(this.data[i], i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/int-cube.ts?");

/***/ }),

/***/ "../engine/src/data/int-matrix.ts":
/*!****************************************!*\
  !*** ../engine/src/data/int-matrix.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IntMatrix\": () => (/* binding */ IntMatrix)\n/* harmony export */ });\n// generic all-pupose matrix of ints\r\nclass IntMatrix {\r\n    constructor(height, width, data = []) {\r\n        this._height = height;\r\n        this._width = width;\r\n        this.data = new Uint16Array(this._width * this._height);\r\n        if (data == [] || data.length == 0)\r\n            this.fill(0);\r\n        else\r\n            this.setData(data);\r\n    }\r\n    static fromList(list, width) {\r\n        let height = list.length / width;\r\n        let array = new IntMatrix(height, width);\r\n        for (let i = 0; i < list.length; i++) {\r\n            array.data[i] = list[i];\r\n        }\r\n        return array;\r\n    }\r\n    print() {\r\n        let strings = [];\r\n        const WIDTH = 8;\r\n        for (var i = 0; i < this._height; i++) {\r\n            strings.push(\"|\");\r\n            for (var j = 0; j < this._width; j++) {\r\n                let str = this.get(i, j).toFixed(2);\r\n                str = str.padStart(WIDTH, \" \");\r\n                strings.push(str);\r\n                if (j < this._width - 2) {\r\n                    strings.push(\"  \");\r\n                }\r\n            }\r\n            strings.push(\"  |\\n\");\r\n        }\r\n        console.log(strings.join(\"\"));\r\n    }\r\n    clone() {\r\n        let clone = new IntMatrix(this._height, this._width);\r\n        clone.data = this.data;\r\n        return clone;\r\n    }\r\n    setData(data) {\r\n        if (data.length != this._height * this._width)\r\n            throw \"data.length does not match width * height \" + data.length.toString();\r\n        this.data.set(data);\r\n    }\r\n    count() {\r\n        // number of entries / rows.\r\n        // when derrived classes ask for 'how many of x?' they usually mean this.\r\n        return this._height;\r\n    }\r\n    getDimensions() {\r\n        return [this._height, this._width];\r\n    }\r\n    inRange(i, j) {\r\n        return !(i < 0 || i > this._height - 1 || j < 0 || j > this._width - 1);\r\n    }\r\n    fill(value) {\r\n        let size = this._height * this._width;\r\n        for (let i = 0; i < size; i++) {\r\n            this.data[i] = value;\r\n        }\r\n    }\r\n    fillWith(data, valuesPerEntry = this._width) {\r\n        // values per entry can be used to setData which is not of the same shape.\r\n        let vpe = valuesPerEntry;\r\n        if (vpe > this._width)\r\n            throw \"values per entry is larger than this._width. This will spill over.\";\r\n        for (let i = 0; i < this._height; i++) {\r\n            for (let j = 0; j < vpe; j++) {\r\n                this.set(i, j, data[i * vpe + j]);\r\n            }\r\n        }\r\n    }\r\n    get(i, j) {\r\n        if (!this.inRange(i, j)) {\r\n            console.warn(\"out of range!\");\r\n            return 0;\r\n        }\r\n        return this.data[i * this._width + j];\r\n    }\r\n    getRow(i) {\r\n        // if (i < 0 || i > this.height) throw \"column is out of bounds for Array\"\r\n        let data = new Uint16Array(this._width);\r\n        for (let j = 0; j < this._width; j++) {\r\n            data[j] = this.get(i, j);\r\n        }\r\n        return data;\r\n    }\r\n    getColumn(j) {\r\n        // if (j < 0 || j > this.width) throw \"column is out of bounds for Array\"\r\n        let data = new Uint16Array(this._height);\r\n        for (let i = 0; i < this._height; i++) {\r\n            let index = i * this._width + j;\r\n            data[i] = this.data[index];\r\n        }\r\n        return data;\r\n    }\r\n    set(i, j, value) {\r\n        if (!this.inRange(i, j)) {\r\n            console.warn(\"out of range!\");\r\n            return;\r\n        }\r\n        this.data[i * this._width + j] = value;\r\n    }\r\n    setRow(rowIndex, row) {\r\n        // if (this.width != row.length) throw \"dimention of floatarray is not \" + row.length;\r\n        for (let j = 0; j < this._width; j++) {\r\n            this.set(rowIndex, j, row[j]);\r\n        }\r\n    }\r\n    takeRows(indices) {\r\n        // create a new array from a couple of rows\r\n        console.log(this._height, this._width);\r\n        const count = indices.length;\r\n        let array = new IntMatrix(count, this._width);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.setRow(i, this.getRow(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    getData() {\r\n        return this.data;\r\n    }\r\n    forEachValue(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            this.data[i] = callbackfn(this.data[i], i);\r\n        }\r\n        return this;\r\n    }\r\n    forEachRow(callbackfn) {\r\n        for (let i = 0; i < this._height; i++) {\r\n            let row = this.getRow(i);\r\n            callbackfn(row, i);\r\n            this.setRow(i, row);\r\n        }\r\n        return this;\r\n    }\r\n    trueForAll(callbackfn) {\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (!callbackfn(this.data[i], i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/int-matrix.ts?");

/***/ }),

/***/ "../engine/src/data/linked-list.ts":
/*!*****************************************!*\
  !*** ../engine/src/data/linked-list.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LinkedList\": () => (/* binding */ LinkedList)\n/* harmony export */ });\n//\r\n// note: taken from\r\n// https://medium.com/everything-javascript/implementing-a-hash-table-in-javascript-29aca1edfe2b\r\n// NOTE: Not used anymore, but i still find it interesting, so leave it here\r\nclass LinkedList {\r\n    constructor() {\r\n        this.head = null;\r\n    }\r\n    empty() {\r\n        if (this.head)\r\n            return false;\r\n        return true;\r\n    }\r\n    last() {\r\n        var cursor = this.head;\r\n        while (cursor.getNext()) {\r\n            cursor = cursor.getNext();\r\n        }\r\n        return cursor;\r\n    }\r\n    find(key) {\r\n        var cursor = this.head;\r\n        while (cursor) {\r\n            if (cursor.getKey() == key)\r\n                return cursor.value();\r\n            cursor = cursor.getNext();\r\n        }\r\n        return false;\r\n    }\r\n    insert(value, key) {\r\n        var node = new ListNode(value, key);\r\n        if (!this.head)\r\n            this.head = node;\r\n        else\r\n            this.last().next(node);\r\n    }\r\n    print() {\r\n        var cursor = this.head;\r\n        while (cursor) {\r\n            console.log(cursor.value() + \" \");\r\n            cursor = cursor.getNext();\r\n        }\r\n    }\r\n}\r\n//node\r\nclass ListNode {\r\n    constructor(value, key) {\r\n        this.nextNode = null;\r\n        this.key = key;\r\n        this.val = value;\r\n    }\r\n    getNext() {\r\n        return this.nextNode;\r\n    }\r\n    next(node) {\r\n        this.nextNode = node;\r\n    }\r\n    getKey() {\r\n        return this.key;\r\n    }\r\n    value() {\r\n        return this.val;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/linked-list.ts?");

/***/ }),

/***/ "../engine/src/data/multi-vector-2.ts":
/*!********************************************!*\
  !*** ../engine/src/data/multi-vector-2.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiVector2\": () => (/* binding */ MultiVector2)\n/* harmony export */ });\n/* harmony import */ var _geo_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geo/geo */ \"../engine/src/geo/geo.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _float_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./float-matrix */ \"../engine/src/data/float-matrix.ts\");\n/* harmony import */ var _multi_vector_3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n\r\n\r\n\r\n\r\nclass MultiVector2 extends _geo_geo__WEBPACK_IMPORTED_MODULE_0__.Geo {\r\n    constructor(matrix) {\r\n        super();\r\n        this.matrix = matrix;\r\n    }\r\n    static new(length) {\r\n        return new MultiVector2(new _float_matrix__WEBPACK_IMPORTED_MODULE_2__.FloatMatrix(length, 2));\r\n    }\r\n    static fromList(vecs) {\r\n        let length = vecs.length;\r\n        let multiVector = MultiVector2.new(length);\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            multiVector.matrix.set(i, 0, vecs[i].x);\r\n            multiVector.matrix.set(i, 1, vecs[i].y);\r\n        }\r\n        return multiVector;\r\n    }\r\n    static fromMatrix(data) {\r\n        if (data.width != 2) {\r\n            throw new Error(\"incorrect.\");\r\n        }\r\n        return new MultiVector2(data);\r\n    }\r\n    static fromData(data) {\r\n        let multi = MultiVector2.new(data.length / 2);\r\n        multi.matrix.fillWith(data);\r\n        return multi;\r\n    }\r\n    // pass through\r\n    get width() {\r\n        return this.matrix.width;\r\n    }\r\n    get height() {\r\n        return this.matrix.height;\r\n    }\r\n    get dimensions() {\r\n        return this.matrix.width;\r\n    }\r\n    get count() {\r\n        return this.matrix.height;\r\n    }\r\n    forEach(callbackfn) {\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            callbackfn(vec, i);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    map(callbackfn) {\r\n        let clone = this.clone();\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            let result = callbackfn(vec, i);\r\n            if (result instanceof _math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2) {\r\n                clone.set(i, result);\r\n            }\r\n            else {\r\n                clone.set(i, vec);\r\n            }\r\n        }\r\n        return clone;\r\n    }\r\n    set(i, vec) {\r\n        this.matrix.data[i * this.matrix.width + 0] = vec.x;\r\n        this.matrix.data[i * this.matrix.width + 1] = vec.y;\r\n    }\r\n    setXY(i, x, y) {\r\n        this.matrix.data[i * this.matrix.width + 0] = x;\r\n        this.matrix.data[i * this.matrix.width + 1] = y;\r\n    }\r\n    get(i) {\r\n        return new _math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2(this.matrix.data[i * this.width + 0], this.matrix.data[i * this.width + 1]);\r\n    }\r\n    /**\r\n     *  This is a Slice! Edit the matrix = edit the MultiVector!\r\n     */\r\n    toMatrixSlice() {\r\n        return this.matrix;\r\n    }\r\n    toList() {\r\n        let vecs = [];\r\n        for (let i = 0; i < this.height; i++) {\r\n            vecs.push(this.get(i));\r\n        }\r\n        return vecs;\r\n    }\r\n    to3D() {\r\n        let vecs = _multi_vector_3__WEBPACK_IMPORTED_MODULE_3__.MultiVector3.new(this.count);\r\n        for (let i = 0; i < this.count; i++) {\r\n            let row = this.matrix.getRow(i);\r\n            vecs.setXYZ(i, row[0], row[1], 0);\r\n        }\r\n        return vecs;\r\n    }\r\n    clone() {\r\n        let clone = MultiVector2.new(this.count);\r\n        clone.matrix = this.matrix.clone();\r\n        return clone;\r\n    }\r\n    transform(m) {\r\n        this.matrix.multiply(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        let clone = MultiVector2.new(this.count);\r\n        clone.matrix = this.matrix.multiplied(m);\r\n        return clone;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/multi-vector-2.ts?");

/***/ }),

/***/ "../engine/src/data/multi-vector-3.ts":
/*!********************************************!*\
  !*** ../engine/src/data/multi-vector-3.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiVector3\": () => (/* binding */ MultiVector3)\n/* harmony export */ });\n/* harmony import */ var _geo_geo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geo/geo */ \"../engine/src/geo/geo.ts\");\n/* harmony import */ var _math_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/matrix */ \"../engine/src/math/matrix.ts\");\n/* harmony import */ var _math_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/random */ \"../engine/src/math/random.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _system_stopwatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../system/stopwatch */ \"../engine/src/system/stopwatch.ts\");\n/* harmony import */ var _float_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./float-matrix */ \"../engine/src/data/float-matrix.ts\");\n/* harmony import */ var _multi_vector_2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multi-vector-2 */ \"../engine/src/data/multi-vector-2.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MultiVector3 extends _geo_geo__WEBPACK_IMPORTED_MODULE_0__.Geo {\r\n    constructor(matrix) {\r\n        super();\r\n        this.matrix = matrix;\r\n    }\r\n    static new(count) {\r\n        return new MultiVector3(new _float_matrix__WEBPACK_IMPORTED_MODULE_5__.FloatMatrix(count, 3));\r\n    }\r\n    static fromList(vecs) {\r\n        let length = vecs.length;\r\n        let multi = MultiVector3.new(length);\r\n        multi.fillFromList(vecs);\r\n        return multi;\r\n    }\r\n    static fromNative(native) {\r\n        // assume all subarrays have the same shape!!\r\n        return new MultiVector3(_float_matrix__WEBPACK_IMPORTED_MODULE_5__.FloatMatrix.fromNative(native));\r\n    }\r\n    static fromData(data) {\r\n        let multi = MultiVector3.new(data.length / 2);\r\n        multi.matrix.fillWith(data);\r\n        return multi;\r\n    }\r\n    static fromMatrix(data) {\r\n        if (data.width != 3) {\r\n            throw new Error(\"incorrect.\");\r\n        }\r\n        return new MultiVector3(data);\r\n    }\r\n    // pass through\r\n    get width() {\r\n        return this.matrix.width;\r\n    }\r\n    get height() {\r\n        return this.matrix.height;\r\n    }\r\n    get dimensions() {\r\n        return this.matrix.width;\r\n    }\r\n    get count() {\r\n        return this.matrix.height;\r\n    }\r\n    setXYZ(i, x, y, z) {\r\n        this.matrix.data[i * this.width + 0] = x;\r\n        this.matrix.data[i * this.width + 1] = y;\r\n        this.matrix.data[i * this.width + 2] = z;\r\n    }\r\n    set(i, vec) {\r\n        this.matrix.data[i * this.width + 0] = vec.x;\r\n        this.matrix.data[i * this.width + 1] = vec.y;\r\n        this.matrix.data[i * this.width + 2] = vec.z;\r\n    }\r\n    get(i) {\r\n        return new _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3(this.matrix.data[i * this.width + 0], this.matrix.data[i * this.width + 1], this.matrix.data[i * this.width + 2]);\r\n    }\r\n    slice() {\r\n        return this.matrix;\r\n    }\r\n    fillFromList(vecs) {\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            this.set(i, vecs[i]);\r\n        }\r\n    }\r\n    forEach(callbackfn) {\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            vec = callbackfn(vec, i);\r\n            if (vec instanceof _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3) {\r\n                this.set(i, vec);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    take(indices) {\r\n        // create a new floatarray\r\n        const count = indices.length;\r\n        let array = MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let getIndex = indices[i];\r\n            array.set(i, this.get(getIndex));\r\n        }\r\n        return array;\r\n    }\r\n    takeRange(start, end) {\r\n        let array = MultiVector3.new(end - start);\r\n        let j = 0;\r\n        for (let i = start; i < end; i++) {\r\n            array.set(j, this.get(i));\r\n            j++;\r\n        }\r\n        return array;\r\n    }\r\n    map(callbackfn) {\r\n        let clone = this.clone();\r\n        for (let i = 0; i < this.count; i++) {\r\n            let vec = this.get(i);\r\n            let result = callbackfn(vec, i);\r\n            if (result instanceof _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3) {\r\n                clone.set(i, result);\r\n            }\r\n            else {\r\n                clone.set(i, vec);\r\n            }\r\n        }\r\n        return clone;\r\n    }\r\n    mapWith(other, callback) {\r\n        let result = this.matrix.mapWith(other.matrix, callback);\r\n        return new MultiVector3(result);\r\n    }\r\n    toList() {\r\n        let vecs = [];\r\n        for (let i = 0; i < this.height; i++) {\r\n            vecs.push(this.get(i));\r\n        }\r\n        return vecs;\r\n    }\r\n    to2D() {\r\n        return _multi_vector_2__WEBPACK_IMPORTED_MODULE_6__.MultiVector2.fromMatrix(this.matrix);\r\n    }\r\n    mean() {\r\n        // the mean vector of a series of vectors\r\n        let sum = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n        let count = this.count;\r\n        for (let i = 0; i < count; i++) {\r\n            sum.x += this.matrix.data[i * 3];\r\n            sum.y += this.matrix.data[i * 3 + 1];\r\n            sum.z += this.matrix.data[i * 3 + 2];\r\n        }\r\n        return sum.scale(1 / count);\r\n    }\r\n    average() {\r\n        return this.mean();\r\n    }\r\n    closestId(point) {\r\n        let lowScore = Infinity;\r\n        let id = -1;\r\n        this.forEach((v, i) => {\r\n            let disSquared = point.disToSquared(v);\r\n            if (disSquared < lowScore) {\r\n                lowScore = disSquared;\r\n                id = i;\r\n            }\r\n        });\r\n        return id;\r\n    }\r\n    closestIds(point, n) {\r\n        // O(m*n)... TODO implement quicksort\r\n        let ids = [];\r\n        for (let i = 0; i < n; i++) {\r\n            let lowScore = Infinity;\r\n            let id = -1;\r\n            this.forEach((v, i) => {\r\n                if (ids.includes(id))\r\n                    return;\r\n                let disSquared = point.disToSquared(v);\r\n                if (disSquared < lowScore) {\r\n                    lowScore = disSquared;\r\n                    id = i;\r\n                }\r\n            });\r\n            ids.push(id);\r\n        }\r\n        return ids;\r\n    }\r\n    clone() {\r\n        return new MultiVector3(this.matrix.clone());\r\n    }\r\n    transform(m) {\r\n        // THIS CAN BE SPEED UP: BOTH MATRIX 4 & VECTOR3ARRAY ARE JUST FLOAT-MATRICES\r\n        // this.matrix = calc(this.matrix, m);\r\n        // I DONT KNOW WHY, BUT THIS IS QUICKER THAN MATRIX MULTIPLICATION\r\n        for (let i = 0; i < this.height; i++) {\r\n            let vec = this.get(i);\r\n            vec = m.multiplyVector(vec);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n        // // this.data = m.MultiplyM(this).data;\r\n    }\r\n    move(v) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            let vec = this.get(i);\r\n            vec.add(v);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    scale(s) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            let vec = this.get(i);\r\n            vec.mul(s);\r\n            this.set(i, vec);\r\n        }\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        return new MultiVector3(calc(this.matrix, m));\r\n    }\r\n    moved(m) {\r\n        let mover = _math_matrix__WEBPACK_IMPORTED_MODULE_1__.Matrix4.newTranslate(m);\r\n        return this.transformed(mover);\r\n    }\r\n    scaled(s) {\r\n        let scaler = _math_matrix__WEBPACK_IMPORTED_MODULE_1__.Matrix4.newScaler(s.x, s.y, s.z);\r\n        return this.transformed(scaler);\r\n    }\r\n}\r\nfunction calc(a, b) {\r\n    // we need to do something ugly here, because of the 4th column...\r\n    // and while im at it, I specified the rest of the values as well, for speed's sake\r\n    let product = new _float_matrix__WEBPACK_IMPORTED_MODULE_5__.FloatMatrix(a.height, b.width);\r\n    for (var i = 0; i < a.height; i++) {\r\n        for (var j = 0; j < 4; j++) {\r\n            for (var k = 0; k < 3; k++) {\r\n                product.set(i, j, product.get(i, j) + a.get(i, k) * b.get(k, j));\r\n            }\r\n            product.set(i, j, product.get(i, j) + 1 * b.get(3, j));\r\n        }\r\n    }\r\n    return product;\r\n}\r\nfunction benchmark2() {\r\n    let sw = _system_stopwatch__WEBPACK_IMPORTED_MODULE_4__.Stopwatch.new();\r\n    let count = 1000000;\r\n    let mv = MultiVector3.new(count);\r\n    let rng = _math_random__WEBPACK_IMPORTED_MODULE_2__.Random.fromSeed(1337);\r\n    for (let i = 0; i < count; i++) {\r\n        mv.set(i, _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromRandomUnit(rng));\r\n    }\r\n    sw.log(\"v1: init\");\r\n    let vecs = Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        vecs[i] = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromRandomUnit(rng);\r\n    }\r\n    sw.log(\"v2: init\");\r\n    let vecs3 = Array();\r\n    for (let i = 0; i < count; i++) {\r\n        vecs3.push(_math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromRandomUnit(rng));\r\n    }\r\n    sw.log(\"v3: init\");\r\n    // v1: init took: 123 ms\r\n    // v2: init took: 184 ms\r\n    // v3: init took: 469 ms\r\n    // conclusion: MultiVector3 works as intended!\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/multi-vector-3.ts?");

/***/ }),

/***/ "../engine/src/data/multi-vector.ts":
/*!******************************************!*\
  !*** ../engine/src/data/multi-vector.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ToFloatMatrix\": () => (/* binding */ ToFloatMatrix)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    array.ts\r\n// author:  Jos Feenstra\r\n// purpose: Small wrapper around Float32Array / FloatMatrix to add interoperability with Vector2 & Vector3,\r\n//          while remaining a datastructure thats easy to pass over to webgl\r\n//\r\n// NOTE:    all these small wrappers might not be good pratice, but I\r\n//          like to extract simple logic like this to not clutter the code too much\r\n\r\nfunction ToFloatMatrix(vectors) {\r\n    if (vectors instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix) {\r\n        return vectors;\r\n    }\r\n    else if (vectors instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2) {\r\n        return vectors.toMatrixSlice();\r\n    }\r\n    else if (vectors instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3) {\r\n        return vectors.slice();\r\n    }\r\n    else if (vectors[0] instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2) {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList(vectors).toMatrixSlice();\r\n    }\r\n    else {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(vectors).slice();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/data/multi-vector.ts?");

/***/ }),

/***/ "../engine/src/geo/circle2.ts":
/*!************************************!*\
  !*** ../engine/src/geo/circle2.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle2\": () => (/* binding */ Circle2)\n/* harmony export */ });\n/* harmony import */ var _math_const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n\r\n\r\nclass Circle2 {\r\n    constructor(center, radius) {\r\n        this.center = center;\r\n        this.radius = radius;\r\n    }\r\n    // thank you mr Mitteldorf for making me remember how basic math works\r\n    // http://mathforum.org/library/drmath/view/53027.html\r\n    // calculate the centers of two circles, defined by two points and a radius\r\n    static centersFromPPR(a, b, radius) {\r\n        // throw new Error(\"Method not implemented.\");\r\n        // get in between length and halfway point\r\n        let normal = b.clone().sub(a);\r\n        let dis = normal.length();\r\n        let middle = a\r\n            .clone()\r\n            .add(b)\r\n            .scale(1 / 2);\r\n        // scalar length on mirror line (pythagoras)\r\n        let value = Math.pow(radius, 2) - Math.pow((dis / 2), 2);\r\n        if (value < -_math_const__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n            // no sollution\r\n            return [];\r\n        }\r\n        else if (value < _math_const__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n            // center roughly in the middle, so just return the middle\r\n            return [middle];\r\n        }\r\n        else {\r\n            // two circles possible:\r\n            let disToCenter = Math.pow(value, 0.5);\r\n            let normY = new _math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2(normal.y, -normal.x).normalize();\r\n            // move the middle point up and down\r\n            return [\r\n                middle.clone().add(normY.clone().scale(disToCenter)),\r\n                middle.clone().add(normY.clone().scale(-disToCenter)),\r\n            ];\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/circle2.ts?");

/***/ }),

/***/ "../engine/src/geo/circle3.ts":
/*!************************************!*\
  !*** ../engine/src/geo/circle3.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle3\": () => (/* binding */ Circle3)\n/* harmony export */ });\n/* harmony import */ var _math_const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _mesh_multi_line__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../mesh/multi-line */ \"../engine/src/mesh/multi-line.ts\");\n/* harmony import */ var _plane__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plane */ \"../engine/src/geo/plane.ts\");\n// purpose: represents a 3d circle\r\n\r\n\r\n\r\nclass Circle3 {\r\n    constructor(plane, radius) {\r\n        this.plane = plane;\r\n        this.radius = radius;\r\n    }\r\n    static new(plane, radius) {\r\n        return new Circle3(plane, radius);\r\n    }\r\n    static newPlanar(point, radius) {\r\n        return new Circle3(_plane__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY().moveTo(point), radius);\r\n    }\r\n    static fromCircle2(circle2, plane = _plane__WEBPACK_IMPORTED_MODULE_2__.Plane.WorldXY()) {\r\n        // elevate center of circle, make it the center of a plane\r\n        let center3d = plane.pushToWorld(circle2.center.to3D());\r\n        plane = plane.clone();\r\n        plane.center = center3d;\r\n        return new Circle3(plane, circle2.radius);\r\n    }\r\n    // convert\r\n    buffer() {\r\n        return _mesh_multi_line__WEBPACK_IMPORTED_MODULE_1__.MultiLine.fromCircle(this);\r\n    }\r\n    includes(p) {\r\n        // test if the point falls in range of the circle, by regarding\r\n        // the circle as a torus\r\n        // CHANGE NOTE: i set this to zero, for testing\r\n        // vertical error\r\n        let [projPoint, yError] = this.plane.closestPoint(p);\r\n        yError = yError / 3;\r\n        // horizontal error: get the difference between point\r\n        let xError = this.plane.center.clone().disTo(projPoint) - this.radius;\r\n        // length of total error vector needs to be smaller than the given\r\n        // tolerance\r\n        return Math.pow(yError, 2) + Math.pow(xError, 2) < _math_const__WEBPACK_IMPORTED_MODULE_0__.Const.TOL_SQUARED;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/circle3.ts?");

/***/ }),

/***/ "../engine/src/geo/cube.ts":
/*!*********************************!*\
  !*** ../engine/src/geo/cube.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cube\": () => (/* binding */ Cube)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    cube.ts\r\n// author:  Jos Feenstra\r\n// purpose: Represents a cube in 3d space, in a certain pose.\r\n\r\nclass Cube {\r\n    constructor(plane, domain) {\r\n        this.plane = plane;\r\n        this.domain = domain;\r\n    }\r\n    static new(plane, domain) {\r\n        return new Cube(plane, domain);\r\n    }\r\n    static fromRadius(point, radius) {\r\n        return new Cube(_lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY().moveTo(point), _lib__WEBPACK_IMPORTED_MODULE_0__.Domain3.fromRadius(radius));\r\n    }\r\n    getCorners() {\r\n        return this.domain.corners(this.plane.matrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/cube.ts?");

/***/ }),

/***/ "../engine/src/geo/curve/bezier.ts":
/*!*****************************************!*\
  !*** ../engine/src/geo/curve/bezier.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bezier\": () => (/* binding */ Bezier),\n/* harmony export */   \"Cubez\": () => (/* binding */ Cubez)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _math_polynomial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/polynomial */ \"../engine/src/math/polynomial.ts\");\n/* harmony import */ var _math_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/random */ \"../engine/src/math/random.ts\");\n/* harmony import */ var _math_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/util */ \"../engine/src/math/util.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _system_stopwatch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../system/stopwatch */ \"../engine/src/system/stopwatch.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./curve */ \"../engine/src/geo/curve/curve.ts\");\n// name:    bezier.ts\r\n// author:  Jos Feenstra\r\n// purpose: mathematical representation of a simple parametric curve\r\n// notes:   based upon the excellent explainations from Prof. C.-K. Shene: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Bezier extends _curve__WEBPACK_IMPORTED_MODULE_8__.Curve {\r\n    constructor(verts, degree) {\r\n        super(verts, degree);\r\n    }\r\n    static fromList(verts) {\r\n        return this.new(_data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts));\r\n    }\r\n    static new(verts) {\r\n        return new Bezier(verts, verts.count - 1);\r\n    }\r\n    static equalizeDegrees(curves) {\r\n        // get highest degree\r\n        let maxDegree = 0;\r\n        for (let curve of curves) {\r\n            if (curve.degree > maxDegree) {\r\n                maxDegree = curve.degree;\r\n            }\r\n        }\r\n        // elevate each curve to that degree\r\n        for (let i = 0; i < curves.length; i++) {\r\n            let failsave = 0;\r\n            while (curves[i].degree < maxDegree && failsave < 100) {\r\n                curves[i] = curves[i].increaseDegree();\r\n                failsave++;\r\n            }\r\n        }\r\n        return curves;\r\n    }\r\n    /**\r\n     * Calculate the so-called hodograph of this curve, which is a curve representing all its tangents\r\n     */\r\n    hodograph() {\r\n        let hodoVerts = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.verts.count - 1);\r\n        for (let i = 0; i < this.verts.count - 1; i++) {\r\n            hodoVerts.set(i, this.verts.get(i + 1).subbed(this.verts.get(i)));\r\n        }\r\n        return Bezier.new(hodoVerts);\r\n    }\r\n    /**\r\n     * Return a new curve which is a copy of this curve, but with one added control point\r\n     * Do this recursively, and you have something like decastejau's\r\n     * However, this process cannot be rewritten as a polynomial, since the i / (n + 1) ratio changes every iteration\r\n     */\r\n    increaseDegree() {\r\n        // if (degree <= this.degree) {\r\n        //     console.warn(\"same or lower degree than my current degree...\");\r\n        //     return this.clone();\r\n        // }\r\n        // increase degree by one.\r\n        let n = this.degree;\r\n        let verts = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(n + 2);\r\n        // copy first and last\r\n        verts.set(0, this.verts.get(0));\r\n        verts.set(verts.count - 1, this.verts.get(this.verts.count - 1));\r\n        // interpolate in-betweens\r\n        for (let i = 1; i < n + 1; i++) {\r\n            let pa = this.verts.get(i - 1);\r\n            let pb = this.verts.get(i);\r\n            let sa = i / (n + 1);\r\n            let sb = 1 - sa;\r\n            let q = pa.scale(sa).add(pb.scale(sb));\r\n            verts.set(i, q);\r\n        }\r\n        // create a new curve from it\r\n        return Bezier.new(verts);\r\n    }\r\n    /**\r\n     * subdivide into to new bezier curves,\r\n     * with the same number of control points\r\n     */\r\n    splitAt(t) {\r\n        // get triangle\r\n        let size = this.degree + 1;\r\n        let tri = _math_polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejau(this.verts, t);\r\n        // prepare\r\n        let left = _math_util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleLeft(tri, size);\r\n        let right = _math_util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleRight(tri, size);\r\n        return [Bezier.new(left), Bezier.new(right)];\r\n    }\r\n    /**\r\n     * Extends the curve\r\n     *\r\n     * ```js\r\n     * (part1, part2) = whole.split(0.5)\r\n     * assert_eq!(part1.extend(1) == whole)\r\n     * ```\r\n     */\r\n    extend(extra) {\r\n        // get the decastejau piramid based on extrapolation instead of interpolation\r\n        let piramid = _math_polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejauExtrapolateEnd(this.verts, extra);\r\n        // the base of the piramid is the whole\r\n        let size = this.verts.count;\r\n        let base = _math_util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleBase(piramid, size);\r\n        this.verts = base;\r\n    }\r\n    getExtention(extra) {\r\n        // get the decastejau piramid based on extrapolation instead of interpolation\r\n        let piramid = _math_polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.decastejauExtrapolateEnd(this.verts, extra);\r\n        // the base of the piramid is the whole\r\n        let size = this.verts.count;\r\n        let right = _math_util__WEBPACK_IMPORTED_MODULE_5__.Util.getTriangleRight(piramid, size);\r\n        return Bezier.new(right);\r\n    }\r\n    /**\r\n     *\r\n     */\r\n    pointAt(t) {\r\n        let p = _math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector3.zero();\r\n        for (let i = 0; i < this.degree + 1; i++) {\r\n            p.add(this.verts.get(i).scaled(_math_polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.bernstein(t, i, this.degree)));\r\n        }\r\n        return p;\r\n    }\r\n    /**\r\n     * Calculate the tangent at parameter t.\r\n     * Tangent is calculated using a method described here: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/Bezier/bezier-der.html\r\n     * Note that is is not the fasted thing ever. Use the hodograph to eval a huge range of tangents if you desire that\r\n     */\r\n    tangentAt(t) {\r\n        // evaluate the so-called 'hodograph' of this curve\r\n        return this.hodograph().pointAt(t).normalize();\r\n    }\r\n    /**\r\n     * Calculate the normal at parameter t\r\n     */\r\n    normalAt(t, up = _math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector3.unitZ()) {\r\n        return this.tangentAt(t).cross(up);\r\n    }\r\n    /**\r\n     * Approximate the closest point with a wacky method\r\n     * partially taken from: https://stackoverflow.com/questions/2742610/closest-point-on-a-cubic-bezier-curve\r\n     *\r\n     * @param p\r\n     * @param precision 2 is very low res, 10 is maybe overkill\r\n     * @param tolerance\r\n     * @returns\r\n     */\r\n    ApproxClosestPoint(p, precision = 5, tolerance = _math_const__WEBPACK_IMPORTED_MODULE_2__.Const.TOLERANCE) {\r\n        let disToParam = (t) => p.disToSquared(this.pointAt(t));\r\n        // NOTE: \r\n        // we can get away with this, because bezier curves are guaranteed\r\n        // to not 'spike' like any higher order polynomial might\r\n        let scans = precision * this.verts.count;\r\n        let lowest_value = Infinity;\r\n        let best_t = -1;\r\n        for (let i = 1; i < scans + 1; i++) {\r\n            let t = i / scans;\r\n            let value = disToParam(t);\r\n            if (value < lowest_value) {\r\n                lowest_value = value;\r\n                best_t = i;\r\n            }\r\n        }\r\n        // now, binary-search the smallest value\r\n        let t0 = Math.max((best_t - 1) / scans, 0);\r\n        let t1 = Math.min((best_t + 1) / scans, 1);\r\n        let domain = _lib__WEBPACK_IMPORTED_MODULE_1__.Domain.new(t0, t1);\r\n        let t = _math_util__WEBPACK_IMPORTED_MODULE_5__.Util.lowestScore(domain, disToParam, tolerance);\r\n        return t;\r\n    }\r\n    /**\r\n     * NOTE: work in progress, I am trying a different method\r\n     */\r\n    uglyClosestPoint(p, precision = 4) {\r\n        // STEP 1 : get a number of suspect closest points.\r\n        let suspects = [];\r\n        let ts = [];\r\n        let addSuspect = (t) => {\r\n            suspects.push(this.pointAt(t));\r\n            ts.push(t);\r\n        };\r\n        // start and end are always suspect\r\n        addSuspect(this.domain.t0);\r\n        addSuspect(this.domain.t1);\r\n        // suspects are point 'v' whose tangents are 90 degrees towards the vector 'pv' \r\n        // in other words \r\n        // STEP 2 : get the actual closest suspect using pythagoras\r\n        let distance = Infinity;\r\n        let bestIdx = -1;\r\n        for (let i = 0; i < suspects.length; i++) {\r\n            let dis = p.disToSquared(suspects[i]);\r\n            if (dis < distance) {\r\n                distance = dis;\r\n                bestIdx = i;\r\n            }\r\n        }\r\n        return [suspects[bestIdx], ts[bestIdx]];\r\n    }\r\n    /**\r\n     * Note: All methods dealing with length are approximate\r\n     */\r\n    pointAtApproxLength(length) {\r\n        this.toPolyline(100).tAtLength(length);\r\n    }\r\n    getLazyApprox() {\r\n        if (!this._approx) {\r\n            this.bufferApprox();\r\n        }\r\n        return this._approx;\r\n    }\r\n    bufferApprox() {\r\n        this._approx = this.toPolyline(100);\r\n    }\r\n    // geo trait\r\n    clone() {\r\n        return Bezier.new(this.verts.clone());\r\n    }\r\n    transform(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        return Bezier.new(this.verts.transformed(m));\r\n    }\r\n}\r\n// Shorthand for Cubic Bezier\r\nclass Cubez extends Bezier {\r\n    constructor(verts) {\r\n        super(verts, 3);\r\n    }\r\n    static new(verts) {\r\n        return new Cubez(verts);\r\n    }\r\n}\r\nfunction test(times = 1000) {\r\n    let sw = _system_stopwatch__WEBPACK_IMPORTED_MODULE_7__.Stopwatch.new();\r\n    let bezier = Bezier.fromList([\r\n        _math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector3.new(-2, -2, 0),\r\n        _math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector3.new(-2, 2, 0),\r\n        _math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector3.new(2, 2, 0),\r\n        _math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector3.new(2, -2, 0),\r\n    ]);\r\n    let rng = _math_random__WEBPACK_IMPORTED_MODULE_4__.Random.fromRandom();\r\n    let domain = _lib__WEBPACK_IMPORTED_MODULE_1__.Domain2.fromRadii(2, 2);\r\n    for (let i = 0; i < times; i++) {\r\n        let randomVec = domain.elevate(_math_vector__WEBPACK_IMPORTED_MODULE_6__.Vector2.fromRandom(rng)).to3D();\r\n        bezier.ApproxClosestPoint(randomVec);\r\n    }\r\n    sw.log(`${times}x closest point`);\r\n    // 10000x closest point took: 144ms \r\n    // closest point takes approx. 0.0144ms on my machine\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/curve/bezier.ts?");

/***/ }),

/***/ "../engine/src/geo/curve/curve.ts":
/*!****************************************!*\
  !*** ../engine/src/geo/curve/curve.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Curve\": () => (/* binding */ Curve)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_const__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _mesh_multi_line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../mesh/multi-line */ \"../engine/src/mesh/multi-line.ts\");\n/* harmony import */ var _geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../geo */ \"../engine/src/geo/geo.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: base class for all parametric curves:\r\n// - Bezier\r\n// - Spline\r\n// - Polyline (not terminologically correct but in terms of logic it makes sense)\r\n\r\n\r\n\r\n\r\n\r\n\r\n// domain is always normalzed, from 0 to 1\r\nclass Curve extends _geo__WEBPACK_IMPORTED_MODULE_5__.Geo {\r\n    constructor(verts, degree, domain = _math_domain__WEBPACK_IMPORTED_MODULE_2__.Domain.new(0, 1)) {\r\n        super();\r\n        this.verts = verts;\r\n        this.degree = degree;\r\n        this.domain = domain;\r\n    }\r\n    toPolyline(segments) {\r\n        let count = segments + 1;\r\n        let verts = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let t = i / segments; // fraction\r\n            verts.set(i, this.pointAt(this.domain.elevate(t)));\r\n        }\r\n        return _lib__WEBPACK_IMPORTED_MODULE_1__.Polyline.new(verts);\r\n    }\r\n    buffer(segments = _math_const__WEBPACK_IMPORTED_MODULE_3__.Const.BEZIER_SEGMENTS) {\r\n        return _mesh_multi_line__WEBPACK_IMPORTED_MODULE_4__.MultiLine.fromPolyline(this.toPolyline(segments));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/curve/curve.ts?");

/***/ }),

/***/ "../engine/src/geo/curve/polyline.ts":
/*!*******************************************!*\
  !*** ../engine/src/geo/curve/polyline.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polyline\": () => (/* binding */ Polyline)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve */ \"../engine/src/geo/curve/curve.ts\");\n// name:    polyline.ts\r\n// author:  Jos Feenstra\r\n// purpose: Representation of a polyline.\r\n// Note: ive complicated this quite a bit, since we have to deal with the length of the polyline quite often.\r\n// I want to keep side effects to a minimum, so bufferLengths() needs to be called everytime the curve is changed in some way\r\n\r\n\r\nclass Polyline extends _curve__WEBPACK_IMPORTED_MODULE_1__.Curve {\r\n    constructor(verts) {\r\n        super(verts, 1);\r\n        this.bufferLengths();\r\n    }\r\n    static fromList(verts) {\r\n        return this.new(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts));\r\n    }\r\n    static new(verts) {\r\n        return new Polyline(verts);\r\n    }\r\n    // ----- Special\r\n    /**\r\n     * create a new, filleted polyline\r\n     */\r\n    fillet(radius) {\r\n        let count = this.verts.count + (this.verts.count - 2);\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let j = Math.ceil(i / 2); // index in original \r\n            verts.set(i, this.verts.get(j));\r\n        }\r\n        return Polyline.new(verts);\r\n    }\r\n    // -----\r\n    pointAt(t) {\r\n        let count = this.verts.count - 1;\r\n        let p = t * count;\r\n        let idxA = Math.floor(p);\r\n        let idxB = Math.ceil(p);\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromLerp(this.verts.get(idxA), this.verts.get(idxB), p - idxA);\r\n    }\r\n    lengthAt(t) {\r\n        let lengths = this.getLazyLengths();\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.sample(lengths, t);\r\n    }\r\n    tAtLength(length) {\r\n        let lengths = this.getLazyLengths();\r\n        let [idxA, idxB] = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.between(lengths, length);\r\n        let [min, max] = [lengths[idxA], lengths[idxB]];\r\n        let f = _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.fraction(length, min, max);\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.GeonMath.lerp(lengths[idxA], lengths[idxB], f);\r\n    }\r\n    length() {\r\n        return this.getLazyLengths()[this.verts.count - 1];\r\n    }\r\n    getLazyLengths() {\r\n        if (!this._lengths) {\r\n            this.bufferLengths();\r\n        }\r\n        return this._lengths;\r\n    }\r\n    bufferLengths() {\r\n        let count = this.verts.count;\r\n        let lengths = Array(count);\r\n        let acc = 0.0;\r\n        lengths[0] = acc;\r\n        for (let i = 0; i < count - 1; i++) {\r\n            acc += this.verts.get(i).disTo(this.verts.get(i + 1));\r\n            lengths[i + 1] = acc;\r\n        }\r\n        this._lengths = lengths;\r\n    }\r\n    buffer() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromPolyline(this);\r\n    }\r\n    // geo trait\r\n    clone() {\r\n        let b = Polyline.new(this.verts.clone());\r\n        return b;\r\n    }\r\n    transform(m) {\r\n        this._lengths = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._lengths = undefined; // invalidate buffered data\r\n        return Polyline.new(this.verts.transformed(m));\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/curve/polyline.ts?");

/***/ }),

/***/ "../engine/src/geo/curve/spline.ts":
/*!*****************************************!*\
  !*** ../engine/src/geo/curve/spline.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Spline\": () => (/* binding */ Spline)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_polynomial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/polynomial */ \"../engine/src/math/polynomial.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _bezier__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bezier */ \"../engine/src/geo/curve/bezier.ts\");\n/* harmony import */ var _curve__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./curve */ \"../engine/src/geo/curve/curve.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: B-Spline\r\n// NOTE:    [JF]: my spline implementation is not perfect.\r\n//                Due to behaviour of the coxdeboor algorithm which I dont fully understand,\r\n//                I am forced to create knots with very slight tolerances.\r\n//                This could create trouble down the road...\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * B-Spline\r\n */\r\nclass Spline extends _curve__WEBPACK_IMPORTED_MODULE_5__.Curve {\r\n    constructor(verts, degree, knots, domain) {\r\n        super(verts, degree, domain);\r\n        this.knots = knots;\r\n    }\r\n    static fromList(verts, degree) {\r\n        return this.new(_data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts), degree);\r\n    }\r\n    static calcKnots(n, degree) {\r\n        // TODO incorporate domain parameters in here\r\n        let m = n + degree + 1; // m = n + p + 1\r\n        let knots = new Float32Array(m);\r\n        for (let i = 0; i < degree + 1; i++) {\r\n            knots[i] = 0 - (degree - i) * 0.0001;\r\n        }\r\n        let count = knots.length - degree - degree - 1;\r\n        let j = 1;\r\n        for (let i = degree + 1; i < knots.length - degree - 1; i++) {\r\n            knots[i] = j / count;\r\n            j++;\r\n        }\r\n        j = 0;\r\n        for (let i = knots.length - degree - 1; i < knots.length; i++) {\r\n            knots[i] = 1 + j * 0.0001;\r\n            j++;\r\n        }\r\n        return knots;\r\n    }\r\n    static new(verts, degree) {\r\n        let domain = _math_domain__WEBPACK_IMPORTED_MODULE_1__.Domain.new(0, 1);\r\n        let n = verts.count;\r\n        if (n < degree + 1) {\r\n            return undefined;\r\n        }\r\n        let knots = this.calcKnots(n, degree);\r\n        return new Spline(verts, degree, knots, domain);\r\n    }\r\n    extend(extra) {\r\n        // create the last bit of this curve as a bezier curve\r\n        let count = this.degree + 1;\r\n        let points = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let j = this.verts.count - count + i;\r\n            points[i] = this.verts.get(j);\r\n        }\r\n        let bz = _bezier__WEBPACK_IMPORTED_MODULE_4__.Bezier.fromList(points);\r\n        // extend it\r\n        bz.extend(extra);\r\n        // assign the vertices\r\n        for (let i = 0; i < count; i++) {\r\n            let j = this.verts.count - count + i;\r\n            this.verts.set(j, bz.verts.get(i));\r\n        }\r\n        return this;\r\n    }\r\n    // calculate a piece of bezier which extends this curve\r\n    getExtention(extra) {\r\n        // create the last bit of this curve as a bezier curve\r\n        let count = this.degree + 1;\r\n        let points = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            points[i] = this.verts.get(this.verts.count - count + i);\r\n        }\r\n        let bz = _bezier__WEBPACK_IMPORTED_MODULE_4__.Bezier.fromList(points);\r\n        // get an extension from that\r\n        return bz.getExtention(extra);\r\n    }\r\n    pointAt(t) {\r\n        // console.clear();\r\n        // console.log(\"pointat\");\r\n        // console.log(\"knots:\", this.knots);\r\n        // console.log(\"degree: \", this.degree);\r\n        let p = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n        for (let i = 0; i < this.verts.count; i++) {\r\n            let factor = _math_polynomial__WEBPACK_IMPORTED_MODULE_2__.Polynomial.coxdeboor(t, i, this.degree, this.knots);\r\n            // console.log(\"factor: \", factor);\r\n            p.add(this.verts.get(i).scaled(factor));\r\n        }\r\n        return p;\r\n    }\r\n    clone() {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    transform(m) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n    transformed(m) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/curve/spline.ts?");

/***/ }),

/***/ "../engine/src/geo/geo.ts":
/*!********************************!*\
  !*** ../engine/src/geo/geo.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Geo\": () => (/* binding */ Geo)\n/* harmony export */ });\n/* harmony import */ var _math_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/matrix */ \"../engine/src/math/matrix.ts\");\n// name:    geo.ts\r\n// author:  Jos Feenstra\r\n// purpose: base class of all 3d geometry\r\n// note:    TODO\r\n\r\n// i want traits....\r\nclass Geo {\r\n    rotateX(radians) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newXRotation(radians);\r\n        return this.transform(rotater);\r\n    }\r\n    rotateY(radians) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newYRotation(radians);\r\n        return this.transform(rotater);\r\n    }\r\n    rotateZ(radians) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newZRotation(radians);\r\n        return this.transform(rotater);\r\n    }\r\n    rotate(radians, axis) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newAxisRotation(axis, radians);\r\n        return this.transform(rotater);\r\n    }\r\n    move(m) {\r\n        let mover = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslate(m);\r\n        return this.transform(mover);\r\n    }\r\n    scale(s) {\r\n        let scaler = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newScaler(s.x, s.y, s.z);\r\n        return this.transform(scaler);\r\n    }\r\n    // all past-tense functions return a copied object, just like the vectors\r\n    rotatedX(radians) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newXRotation(radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    rotatedY(radians) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newYRotation(radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    rotatedZ(radians) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newZRotation(radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    rotated(radians, axis) {\r\n        let rotater = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newAxisRotation(axis, radians);\r\n        return this.transformed(rotater);\r\n    }\r\n    moved(m) {\r\n        let mover = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslate(m);\r\n        return this.transformed(mover);\r\n    }\r\n    scaled(s) {\r\n        let scaler = _math_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newScaler(s.x, s.y, s.z);\r\n        return this.transformed(scaler);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/geo.ts?");

/***/ }),

/***/ "../engine/src/geo/intersect.ts":
/*!**************************************!*\
  !*** ../engine/src/geo/intersect.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    intersect.ts\r\n// author:  Jos Feenstra\r\n// purpose: intersection utility functions\r\n\r\n/**\r\n * @returns -1 if no intersection, 0 of parallel or touching, 1 if intersection;\r\n */\r\nfunction lineXplane(l1, l2, p1, p2, p3) {\r\n    let test1 = signed_volume(p1, p2, p3, l1);\r\n    let test2 = signed_volume(p1, p2, p3, l2);\r\n    if (Math.abs(test1) < _lib__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE || Math.abs(test2) < _lib__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n        return 0; // triangle touches plane with an edge\r\n    }\r\n    else if ((test1 < 0 && test2 > 0) || (test1 > 0 && test2 < 0)) {\r\n        return 1; // if 1 test pos and other negative -> line intersects plane!\r\n    }\r\n    else {\r\n        return -1; // no intersection\r\n    }\r\n}\r\n/**\r\n * Calculate if line and triangle intersect\r\n *\r\n * NOTE we could expand on the 'return 0' and explore if its touching a\r\n    vertex, line, or surface of triange\r\n * @returns 0  if line touches triangle\r\n            -1 if line misses  triangle\r\n             1  if line crosses triangle\r\n */\r\nfunction lineXtriangle(l1, l2, p1, p2, p3) {\r\n    // line points must be on opposite sides of the triangle\r\n    // return immidiately if -1: it means no intersection always\r\n    let test0 = lineXplane(l1, l2, p1, p2, p3);\r\n    if (test0 == -1)\r\n        return -1;\r\n    // plane tests\r\n    let test1 = lineXplane(p1, p2, l1, l2, p3);\r\n    if (test1 == -1)\r\n        return -1;\r\n    let test2 = lineXplane(p2, p3, l1, l2, p1);\r\n    if (test2 == -1)\r\n        return -1;\r\n    let test3 = lineXplane(p3, p1, l1, l2, p2);\r\n    if (test3 == -1)\r\n        return -1;\r\n    // debug\r\n    // print(\"points: \", l1, l2, p1, p2, p3)\r\n    // print('tests:', test0, test1, test2, test3)\r\n    // figure out if the line touches the triangle, or if it intersects\r\n    if (test0 == 1 && test1 == 1 && test2 == 1 && test3 == 1) {\r\n        return 1;\r\n    }\r\n    else {\r\n        // TODO based upon the different tests, we could determine what is hit\r\n        return 0;\r\n    }\r\n}\r\nfunction signed_volume(a, b, c, d) {\r\n    // with vertices a,b,c,d: get signed volume\r\n    // remember: vectors always remain state. We dont want to alter the abcd vectors.\r\n    a = a.clone();\r\n    b = b.clone();\r\n    c = c.clone();\r\n    return ((1 / 6) *\r\n        a\r\n            .clone()\r\n            .sub(d)\r\n            .dot(c.sub(d).cross(b.sub(d))));\r\n}\r\nfunction IsRoughly(test1, arg1) {\r\n    throw new Error(\"Function not implemented.\");\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/intersect.ts?");

/***/ }),

/***/ "../engine/src/geo/line.ts":
/*!*********************************!*\
  !*** ../engine/src/geo/line.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineCurve2\": () => (/* binding */ LineCurve2)\n/* harmony export */ });\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n\r\n\r\n// heavy weight Line class\r\nclass LineCurve2 {\r\n    constructor(from, to) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.vector = to.subbed(this.from);\r\n        this.normal = this.vector.normalized();\r\n        this.bounds = new _math_domain__WEBPACK_IMPORTED_MODULE_0__.Domain(0, this.vector.length());\r\n        this.length = this.vector.length();\r\n    }\r\n    at(t, bounded = true) {\r\n        if (bounded)\r\n            t = this.bounds.comform(t);\r\n        return _math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2.fromLerp(this.from, this.to, t / this.length);\r\n    }\r\n    atNormal(t, bounded = true) {\r\n        if (bounded)\r\n            t = new _math_domain__WEBPACK_IMPORTED_MODULE_0__.Domain(0, 1).comform(t);\r\n        return _math_vector__WEBPACK_IMPORTED_MODULE_1__.Vector2.fromLerp(this.from, this.to, t);\r\n    }\r\n    closestPoint(point, bounded = true) {\r\n        const d = this.vector.length();\r\n        if (d === 0)\r\n            return;\r\n        let lineToPoint = point.subbed(this.from);\r\n        let dot = lineToPoint.dot(this.vector);\r\n        return this.at(dot, bounded);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/line.ts?");

/***/ }),

/***/ "../engine/src/geo/plane.ts":
/*!**********************************!*\
  !*** ../engine/src/geo/plane.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Plane\": () => (/* binding */ Plane)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    plane.ts\r\n// author:  Jos Feenstra\r\n// purpose: definition of a 3d plane.\r\n// todo:    turn Center, Ihat, Jhat, Khat construction to an actual matrix\r\n\r\nclass Plane {\r\n    // _inverse!: Matrix4; // NOTE: currently im not caching this. Might be needed.\r\n    // NOTE : d is not really needed anymore...\r\n    constructor(m) {\r\n        this._matrix = m;\r\n    }\r\n    static fromPN(center, normal) {\r\n        let cross = normal.cross(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX());\r\n        if (cross.length() < _lib__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE) {\r\n            cross = normal.cross(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY());\r\n        }\r\n        let ihat = cross.normalize();\r\n        let jhat = normal.cross(ihat).normalize();\r\n        let mat = Plane.planeMatrixFromVecs(center, ihat, jhat, normal);\r\n        return new Plane(mat);\r\n    }\r\n    static fromPVV(a, v1, v2) {\r\n        // TODO check if we still need this -1 thing\r\n        let khat = v1.clone().cross(v2).normalize(); //.scale(-1);\r\n        let center = a.clone();\r\n        let ihat = v1.normalize();\r\n        let jhat = v1.clone().cross(khat);\r\n        let mat = Plane.planeMatrixFromVecs(center, ihat, jhat, khat);\r\n        return new Plane(mat);\r\n    }\r\n    static from3pt(a, b, c) {\r\n        let v1 = b.clone().sub(a);\r\n        let v2 = c.clone().sub(a);\r\n        return this.fromPVV(a, v1, v2);\r\n    }\r\n    static WorldXY() {\r\n        return Plane.from3pt(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY());\r\n    }\r\n    static WorldYZ() {\r\n        return Plane.from3pt(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ());\r\n    }\r\n    static WorldXZ() {\r\n        return Plane.from3pt(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX(), _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ());\r\n    }\r\n    static fromLeastSquares(pts) {\r\n        let mean = pts.mean();\r\n        let cov = _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.cov(pts.slice());\r\n        let [eigValues, eigVectors] = _lib__WEBPACK_IMPORTED_MODULE_0__.Stat.eig(cov);\r\n        console.log(eigValues);\r\n        let biggestEigenVector = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(eigVectors.getColumn(0));\r\n        let secondBiggestEigenVector = _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(eigVectors.getColumn(1));\r\n        return Plane.fromPVV(mean, biggestEigenVector, secondBiggestEigenVector);\r\n    }\r\n    static fromXYLeastSquares(pts) {\r\n        // quite specific, but this was needed.\r\n        let mean = pts.mean();\r\n        return Plane.WorldXY().transform(_lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newTranslation(mean.x, mean.y, mean.z));\r\n    }\r\n    static planeMatrixFromVecs(c, i, j, k) {\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4([\r\n            i.x,\r\n            i.y,\r\n            i.z,\r\n            0,\r\n            j.x,\r\n            j.y,\r\n            j.z,\r\n            0,\r\n            k.x,\r\n            k.y,\r\n            k.z,\r\n            0,\r\n            c.x,\r\n            c.y,\r\n            c.z,\r\n            1,\r\n        ]);\r\n    }\r\n    get ihat() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(0));\r\n    }\r\n    get jhat() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(1));\r\n    }\r\n    get khat() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(2));\r\n    }\r\n    get center() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromArray(this._matrix.getRow(3));\r\n    }\r\n    get matrix() {\r\n        return this._matrix.clone();\r\n    }\r\n    get normal() {\r\n        return this.khat;\r\n    }\r\n    get d() {\r\n        return this.closestPoint(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero())[1];\r\n    }\r\n    set ihat(v) {\r\n        this._matrix.setRow(0, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set jhat(v) {\r\n        this._matrix.setRow(1, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set khat(v) {\r\n        this._matrix.setRow(2, [v.x, v.y, v.z, 0]);\r\n    }\r\n    set center(v) {\r\n        this._matrix.setRow(3, [v.x, v.y, v.z, 1]);\r\n    }\r\n    set matrix(m) {\r\n        this._matrix = m;\r\n    }\r\n    get inverse() {\r\n        // TODO CACHE INVERSE MATRIX\r\n        return this._matrix.inverse();\r\n    }\r\n    setPosition(vec) {\r\n        this.center = vec;\r\n    }\r\n    setNormal(vec) {\r\n        this.khat = vec;\r\n    }\r\n    clone() {\r\n        return new Plane(this._matrix.clone());\r\n    }\r\n    transform(m) {\r\n        this._matrix = this._matrix.multiply(m);\r\n        return this;\r\n    }\r\n    moveTo(origin) {\r\n        this.center = origin;\r\n        return this;\r\n    }\r\n    // NOTE: pulling is inefficient since i do not cache the inverse.\r\n    pullToPlane(p) {\r\n        return this.inverse.multiplyVector(p);\r\n    }\r\n    pushToWorld(p) {\r\n        return this.matrix.multiplyVector(p);\r\n    }\r\n    closestPoint(p) {\r\n        let pulled = this.pullToPlane(p);\r\n        let distance = pulled.z;\r\n        pulled.z = 0;\r\n        let vec = this.pushToWorld(pulled);\r\n        return [vec, distance];\r\n    }\r\n    rotateVector(v, radians) {\r\n        let pulled = this.pullToPlane(v);\r\n        let rotation = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newAxisRotation(this.normal, radians);\r\n        pulled = rotation.multiplyVector(pulled);\r\n        return this.pushToWorld(pulled);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/plane.ts?");

/***/ }),

/***/ "../engine/src/geo/rectangle.ts":
/*!**************************************!*\
  !*** ../engine/src/geo/rectangle.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Rectangle2\": () => (/* binding */ Rectangle2),\n/* harmony export */   \"Rectangle3\": () => (/* binding */ Rectangle3)\n/* harmony export */ });\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/matrix */ \"../engine/src/math/matrix.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _plane__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./plane */ \"../engine/src/geo/plane.ts\");\n\r\n\r\n\r\n\r\nclass Rectangle2 {\r\n    constructor(pose, domain) {\r\n        this.pose = pose;\r\n        this.domain = domain;\r\n    }\r\n    static new(startX, startY, width, height) {\r\n        let pose = _math_matrix__WEBPACK_IMPORTED_MODULE_1__.Matrix3.newTranslation(startX, startY);\r\n        let domain = _math_domain__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromBounds(0, 0, width, height);\r\n    }\r\n    center() {\r\n        return this.pose.transformVector(new _math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector2(0, 0));\r\n    }\r\n    getVertices() {\r\n        let verts = [\r\n            new _math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t0, this.domain.y.t0),\r\n            new _math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t1, this.domain.y.t0),\r\n            new _math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t0, this.domain.y.t1),\r\n            new _math_vector__WEBPACK_IMPORTED_MODULE_2__.Vector2(this.domain.x.t1, this.domain.y.t1),\r\n        ];\r\n        verts.forEach((v) => this.pose.transformVector(v));\r\n        return verts;\r\n    }\r\n    to3D() {\r\n        let mat4 = this.pose.toMat4();\r\n        return new Rectangle3(new _plane__WEBPACK_IMPORTED_MODULE_3__.Plane(mat4), this.domain);\r\n    }\r\n}\r\nclass Rectangle3 {\r\n    constructor(plane, domain) {\r\n        this.plane = plane;\r\n        this.domain = domain;\r\n    }\r\n    static new(plane, domain) {\r\n        return new Rectangle3(plane, domain);\r\n    }\r\n    getCorners() {\r\n        let corners = this.domain.corners();\r\n        let corners3 = corners.map((c) => this.plane.pushToWorld(c.to3D()));\r\n        return corners3;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/rectangle.ts?");

/***/ }),

/***/ "../engine/src/geo/surface/bezier-square.ts":
/*!**************************************************!*\
  !*** ../engine/src/geo/surface/bezier-square.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BezierSquare\": () => (/* binding */ BezierSquare)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_polynomial__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/polynomial */ \"../engine/src/math/polynomial.ts\");\n/* harmony import */ var _math_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/random */ \"../engine/src/math/random.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _system_stopwatch__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../system/stopwatch */ \"../engine/src/system/stopwatch.ts\");\n/* harmony import */ var _curve_bezier__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../curve/bezier */ \"../engine/src/geo/curve/bezier.ts\");\n/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./surface */ \"../engine/src/geo/surface/surface.ts\");\n// todo : research tensor: https://en.wikipedia.org/wiki/Tensor_product\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Four sided Bezier Surface\r\n */\r\nclass BezierSquare extends _surface__WEBPACK_IMPORTED_MODULE_8__.BiSurface {\r\n    constructor(verts, degreeU, degreeV) {\r\n        super();\r\n        this.verts = verts;\r\n        this.degreeU = degreeU;\r\n        this.degreeV = degreeV;\r\n    }\r\n    static new(verts, degreeU, degreeV) {\r\n        // let degree = Math.sqrt(verts.count);\r\n        if (verts.count != (degreeU + 1) * (degreeV + 1)) {\r\n            console.warn(`BiSurface Not Created. ${verts.count} vertices \r\n                does not match ${degreeU} degreeU times ${degreeV} degreeV surface...`);\r\n            return undefined;\r\n        }\r\n        return new BezierSquare(verts, degreeU, degreeV);\r\n    }\r\n    /**\r\n     * ```\r\n     * 0----1-----2----3\r\n     * |    |  A  |    |\r\n     * 4----5?----6?---7\r\n     * | B  |     |    | D\r\n     * 8----9?---10?---11\r\n     * |    |     |    |\r\n     * 12---13----14---15\r\n     *         C\r\n     *```\r\n     * @param a\r\n     * @param b\r\n     * @param c\r\n     * @param d\r\n     * @returns\r\n     */\r\n    static fromFourEdge(a, b, c, d) {\r\n        // TODO do magic to discover the inner control points...\r\n        // NOTE: the magic is just a tensor product of control points : https://en.wikipedia.org/wiki/Tensor_product\r\n        // TODO bezier curves must be of the same degree\r\n        return undefined;\r\n    }\r\n    static fromLoft(curves) {\r\n        curves = _curve_bezier__WEBPACK_IMPORTED_MODULE_7__.Bezier.equalizeDegrees(curves);\r\n        let degreeV = curves[0].degree;\r\n        let degreeU = curves.length - 1;\r\n        let count = degreeV + 1 * curves.length;\r\n        let verts = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        let idx = 0;\r\n        for (let i = 0; i < curves.length; i++) {\r\n            for (let j = 0; j < curves[i].verts.count; j++) {\r\n                verts.set(idx, curves[i].verts.get(j));\r\n                idx++;\r\n            }\r\n        }\r\n        return BezierSquare.new(verts, degreeU, degreeV);\r\n    }\r\n    /////////// properties ///////////\r\n    pointAt(u, v) {\r\n        let p = _math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector3.zero();\r\n        for (let i = 0; i < this.degreeU + 1; i++) {\r\n            for (let j = 0; j < this.degreeV + 1; j++) {\r\n                let scalar = _math_polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.bernstein(u, i, this.degreeU) *\r\n                    _math_polynomial__WEBPACK_IMPORTED_MODULE_3__.Polynomial.bernstein(v, j, this.degreeV);\r\n                let index = i * (this.degreeV + 1) + j;\r\n                // console.log(i * count + j, s1, s2, scalar);\r\n                p.add(this.verts.get(index).scaled(scalar));\r\n            }\r\n        }\r\n        return p;\r\n    }\r\n    pointAtUV(uv) {\r\n        return this.pointAt(uv.x, uv.y);\r\n    }\r\n    //////////////// projection /////////////////\r\n    /**\r\n     * NOTE: this is tested hastely, use with care\r\n     * @param p\r\n     * @param precision 2 is low-res, 10 is high-res, but more expensive.\r\n     * @param tolerance\r\n     * @returns\r\n     */\r\n    approxClosestPoint(p, precision = 2, tolerance = _lib__WEBPACK_IMPORTED_MODULE_1__.Const.TOLERANCE) {\r\n        let disToParams = (u, v) => p.disToSquared(this.pointAt(u, v));\r\n        let scansU = precision * (this.degreeU + 1);\r\n        let scansV = precision * (this.degreeV + 1);\r\n        let lowest_value = Infinity;\r\n        let best_i = -1;\r\n        let best_j = -1;\r\n        for (let i = 1; i < scansU + 1; i++) {\r\n            let u = i / scansU;\r\n            for (let j = 1; j < scansU + 1; j++) {\r\n                let v = j / scansV;\r\n                let value = disToParams(u, v);\r\n                if (value < lowest_value) {\r\n                    lowest_value = value;\r\n                    best_i = i;\r\n                    best_j = j;\r\n                }\r\n            }\r\n        }\r\n        // now, binary-search the smallest value in a patch around the best guess\r\n        let domain = _math_domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromBounds(Math.max((best_i - 1) / scansU, 0), Math.min((best_i + 1) / scansU, 1), Math.max((best_j - 1) / scansV, 0), Math.min((best_j + 1) / scansV, 1));\r\n        let uv = _lib__WEBPACK_IMPORTED_MODULE_1__.Util.lowestScoreSquared(domain, disToParams, tolerance);\r\n        return uv;\r\n    }\r\n    /////////////////////////// geo //////////////////////////\r\n    clone() {\r\n        return BezierSquare.new(this.verts.clone(), this.degreeU, this.degreeV);\r\n    }\r\n    transform(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        this.verts.transform(m);\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        this._approx = undefined; // invalidate buffered data\r\n        return BezierSquare.new(this.verts.transformed(m), this.degreeU, this.degreeV);\r\n    }\r\n}\r\nfunction test(times = 1000) {\r\n    // get some points\r\n    let sw = _system_stopwatch__WEBPACK_IMPORTED_MODULE_6__.Stopwatch.new();\r\n    let rng = _math_random__WEBPACK_IMPORTED_MODULE_4__.Random.fromSeed(1234);\r\n    let degree = 2;\r\n    let displace = 5;\r\n    let vecs = _math_domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromRadius(-11) // span a (-size to size)**2 domain\r\n        .offset([-22, 22, 0, 0]) // flip it\r\n        .spawn(degree + 1, degree + 1) // spawn a bunch of points, the exact amound needed for the surface\r\n        .to3D()\r\n        .forEach((v) => {\r\n        return v\r\n            .add(_math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector3.fromRandomUnit(rng).scale(displace))\r\n            .add(_math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector3.unitZ().scale(5)); // and displace them slightly\r\n    });\r\n    // create a surface from it\r\n    let s = BezierSquare.new(vecs, degree, degree);\r\n    let domain = _math_domain__WEBPACK_IMPORTED_MODULE_2__.Domain2.fromRadii(11, 11);\r\n    sw.log(\"creation\");\r\n    for (let i = 0; i < times; i++) {\r\n        let randomVec = domain.elevate(_math_vector__WEBPACK_IMPORTED_MODULE_5__.Vector2.fromRandom(rng)).to3D();\r\n        s.approxClosestPoint(randomVec);\r\n    }\r\n    sw.log(`created ${times} closest points`); // 326 ms\r\n}\r\ntest();\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/surface/bezier-square.ts?");

/***/ }),

/***/ "../engine/src/geo/surface/loft.ts":
/*!*****************************************!*\
  !*** ../engine/src/geo/surface/loft.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Loft\": () => (/* binding */ Loft)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _mesh_mesh__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mesh/mesh */ \"../engine/src/mesh/mesh.ts\");\n/* harmony import */ var _curve_bezier__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../curve/bezier */ \"../engine/src/geo/curve/bezier.ts\");\n/* harmony import */ var _curve_polyline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../curve/polyline */ \"../engine/src/geo/curve/polyline.ts\");\n/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./surface */ \"../engine/src/geo/surface/surface.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: mathematical representation of a parametric loft surface\r\n\r\n\r\n\r\n\r\n\r\nclass Loft extends _surface__WEBPACK_IMPORTED_MODULE_4__.BiSurface {\r\n    constructor(curves) {\r\n        super();\r\n        this.curves = curves;\r\n    }\r\n    static new(curves) {\r\n        // make sure all curves are of the same degree, so we can easely interpolate\r\n        return new Loft(_curve_bezier__WEBPACK_IMPORTED_MODULE_2__.Bezier.equalizeDegrees(curves));\r\n    }\r\n    getTransposedCurves() {\r\n        // this can only happen if the curves are all of the same degree,\r\n        // and at the very least, have the same number of controlpoints\r\n        let curves = [];\r\n        let isize = this.curves[0].verts.count;\r\n        let jsize = this.curves.length;\r\n        for (let i = 0; i < isize; i++) {\r\n            let verts = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.curves.length);\r\n            for (let j = 0; j < jsize; j++) {\r\n                verts.set(j, this.curves[j].verts.get(i));\r\n            }\r\n            curves.push(_curve_bezier__WEBPACK_IMPORTED_MODULE_2__.Bezier.new(verts));\r\n        }\r\n        return curves;\r\n    }\r\n    pointAt(u, v) {\r\n        return this.isoCurveV(u).pointAt(v);\r\n    }\r\n    isoCurveV(u) {\r\n        return Loft.isoCurve(this.curves, u);\r\n    }\r\n    isoCurveU(v) {\r\n        let trans = this.getTransposedCurves();\r\n        return Loft.isoCurve(trans, v);\r\n    }\r\n    static isoCurve(curves, t) {\r\n        let pts = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(curves.length);\r\n        for (let i = 0; i < curves.length; i++) {\r\n            pts.set(i, curves[i].pointAt(t));\r\n        }\r\n        return _curve_bezier__WEBPACK_IMPORTED_MODULE_2__.Bezier.new(pts);\r\n    }\r\n    /**\r\n     * same as buffer, but the udetail is semi-automated\r\n     */\r\n    bufferExact() {\r\n        // NOTE : to make this always watertight: take note of the precision when using polylines:\r\n        let vals = [];\r\n        for (let c of this.curves) {\r\n            if (c instanceof _curve_polyline__WEBPACK_IMPORTED_MODULE_3__.Polyline) {\r\n                vals.push(c.verts.count - 1);\r\n            }\r\n        }\r\n        let perfectuSegments = vals.reduce((a, b) => {\r\n            return a * b;\r\n        });\r\n        return _mesh_mesh__WEBPACK_IMPORTED_MODULE_1__.Mesh.fromBiSurface(this, perfectuSegments, perfectuSegments);\r\n    }\r\n    clone() {\r\n        let curves = new Array();\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            curves[i] = this.curves[i].clone();\r\n        }\r\n        return Loft.new(curves);\r\n    }\r\n    transform(m) {\r\n        for (let c of this.curves) {\r\n            c.transform(m);\r\n        }\r\n        return this;\r\n    }\r\n    transformed(m) {\r\n        let curves = new Array();\r\n        for (let i = 0; i < this.curves.length; i++) {\r\n            curves[i] = this.curves[i].transformed(m);\r\n        }\r\n        return Loft.new(curves);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/surface/loft.ts?");

/***/ }),

/***/ "../engine/src/geo/surface/surface.ts":
/*!********************************************!*\
  !*** ../engine/src/geo/surface/surface.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Surface\": () => (/* binding */ Surface),\n/* harmony export */   \"BiSurface\": () => (/* binding */ BiSurface),\n/* harmony export */   \"TriSurface\": () => (/* binding */ TriSurface)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib */ \"../engine/src/lib.ts\");\n// name:    spline.ts\r\n// author:  Jos Feenstra\r\n// purpose: base interface / abstract classes for surfaces\r\n// todo : research this : https://graphics.pixar.com/library/HarmonicCoordinates/\r\n// todo : and this : https://doc.cgal.org/latest/Barycentric_coordinates_2/index.html\r\n\r\n/**\r\n * Any Surface. Maybe this will be expanded upon sometime in the future?\r\n */\r\nclass Surface extends _lib__WEBPACK_IMPORTED_MODULE_0__.Geo {\r\n}\r\n/**\r\n * Bidirectional surface\r\n */\r\nclass BiSurface extends Surface {\r\n    buffer(uSegments = 100, vSegments = 100) {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromBiSurface(this, uSegments, vSegments);\r\n    }\r\n}\r\n/**\r\n * Tridirectional surface\r\n */\r\nclass TriSurface extends Surface {\r\n    buffer(segments) {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.fromTriSurface(this, segments);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/surface/surface.ts?");

/***/ }),

/***/ "../engine/src/geo/triangle.ts":
/*!*************************************!*\
  !*** ../engine/src/geo/triangle.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Triangle2\": () => (/* binding */ Triangle2),\n/* harmony export */   \"Triangle3\": () => (/* binding */ Triangle3)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\nclass Triangle2 {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    points() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList([this.a, this.b, this.c]);\r\n    }\r\n    toBarycentric(point) {\r\n        let v0 = this.b.subbed(this.a);\r\n        let v1 = this.c.subbed(this.a);\r\n        let v2 = point.subbed(this.a);\r\n        let d00 = v0.dot(v0);\r\n        let d01 = v0.dot(v1);\r\n        let d11 = v1.dot(v1);\r\n        let d20 = v2.dot(v0);\r\n        let d21 = v2.dot(v1);\r\n        let denom = d00 * d11 - d01 * d01;\r\n        let v = (d11 * d20 - d01 * d21) / denom;\r\n        let w = (d00 * d21 - d01 * d20) / denom;\r\n        let u = 1.0 - v - w;\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(u, v, w);\r\n    }\r\n    fromBarycentric(bari) {\r\n        let a = this.a.scaled(bari.x);\r\n        let b = this.b.scaled(bari.y);\r\n        let c = this.c.scaled(bari.z);\r\n        return a.add(b).add(c);\r\n    }\r\n    closestPoint(point) {\r\n        // figure out roughly where the point is.\r\n        // note:\r\n        let ab = point.sign(this.a, this.b);\r\n        let bc = point.sign(this.b, this.c);\r\n        let ca = point.sign(this.c, this.a);\r\n        // if its fully within, return it!\r\n        if ((ab < 0 && bc < 0 && ca < 0) || (ab > 0 && bc > 0 && ca > 0)) {\r\n            console.log(\"fully inside!\");\r\n            return point;\r\n        }\r\n        else {\r\n            let abs = Math.abs(ab);\r\n            let bcs = Math.abs(bc);\r\n            let cas = Math.abs(ca);\r\n            if (abs < bcs && abs < cas) {\r\n                // ab\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.LineCurve2(this.a, this.b).closestPoint(point);\r\n            }\r\n            else if (bcs < cas) {\r\n                // bc\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.LineCurve2(this.b, this.c).closestPoint(point);\r\n            }\r\n            else {\r\n                // ca\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.LineCurve2(this.c, this.a).closestPoint(point);\r\n            }\r\n        }\r\n    }\r\n}\r\nclass Triangle3 {\r\n    constructor(a, b, c) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n    }\r\n    points() {\r\n        return [this.a, this.b, this.c];\r\n    }\r\n    getPlane() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.from3pt(this.a, this.b, this.c);\r\n    }\r\n    to2D(plane = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY()) {\r\n        return new Triangle2(plane.pullToPlane(this.a).to2D(), plane.pullToPlane(this.b).to2D(), plane.pullToPlane(this.c).to2D());\r\n    }\r\n    closestPoint(point) {\r\n        let plane = this.getPlane();\r\n        let [cp, _] = plane.closestPoint(point);\r\n        let planeCP = plane.pullToPlane(cp);\r\n        let planeTriangle = this.to2D(plane);\r\n        return point;\r\n    }\r\n    // Transcribed from Christer Ericson's Real-Time Collision Detection:\r\n    // http://realtimecollisiondetection.net/\r\n    toBarycentric(point) {\r\n        let v0 = this.b.subbed(this.a);\r\n        let v1 = this.c.subbed(this.a);\r\n        let v2 = point.subbed(this.a);\r\n        let d00 = v0.dot(v0);\r\n        let d01 = v0.dot(v1);\r\n        let d11 = v1.dot(v1);\r\n        let d20 = v2.dot(v0);\r\n        let d21 = v2.dot(v1);\r\n        let denom = d00 * d11 - d01 * d01;\r\n        let v = (d11 * d20 - d01 * d21) / denom;\r\n        let w = (d00 * d21 - d01 * d20) / denom;\r\n        let u = 1.0 - v - w;\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(u, v, w);\r\n    }\r\n    fromBarycentric(bari) {\r\n        let a = this.a.clone().scale(bari.x);\r\n        let b = this.b.clone().scale(bari.y);\r\n        let c = this.c.clone().scale(bari.z);\r\n        return a.added(b).add(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/geo/triangle.ts?");

/***/ }),

/***/ "../engine/src/img/Image.ts":
/*!**********************************!*\
  !*** ../engine/src/img/Image.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeonImage\": () => (/* binding */ GeonImage)\n/* harmony export */ });\n// image.ts\r\n// author: Jos Feenstra\r\n// purpose: wrapper around the ImageData class,\r\n// - in order to get more functionality out of it\r\n//\r\n// note: named GeonImage to not collide with Image classes.\r\n// TODO : x and y are not the same as i and j, and used inconsistently. fix this.\r\n// TODO : now that GEON is a package, we can use G.Image. the Geon suffix is not needed anymore is not needed anymore!\r\nconst acceptedKernels = [3, 5, 7, 9];\r\nclass GeonImage {\r\n    constructor(width, height, pixelSize = 4) {\r\n        this.width = width;\r\n        this.height = height;\r\n        this.pixelSize = pixelSize;\r\n        this.data = new Uint8ClampedArray(this.width * this.height * this.pixelSize);\r\n        this.data.fill(0);\r\n    }\r\n    static fromImageData(id) {\r\n        let image = new GeonImage(id.width, id.height);\r\n        image.setData(id.data);\r\n        return image;\r\n    }\r\n    toImageData() {\r\n        // imagedata requires pixelsize of 4.\r\n        if (this.pixelSize != 4)\r\n            throw \"pixelsize must be 4 for toImageData to work\";\r\n        return new ImageData(this.data, this.width, this.height);\r\n    }\r\n    setData(data) {\r\n        if (data.length != this.height * this.width * this.pixelSize)\r\n            throw \"data.length does not match width * height \";\r\n        this.data = data;\r\n    }\r\n    clone() {\r\n        let image = new GeonImage(this.width, this.height, this.pixelSize);\r\n        image.setData(this.data);\r\n        return image;\r\n    }\r\n    fill(pixel) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                this.set(j, i, pixel);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    fillEvery(filler) {\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                this.set(j, i, filler());\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    includes(x, y) {\r\n        return x < this.width && x >= 0 && y < this.height && y >= 0;\r\n    }\r\n    set(i, j, pixel) {\r\n        this.data[4 * (j * this.width + i)] = pixel[0];\r\n        this.data[4 * (j * this.width + i) + 1] = pixel[1];\r\n        this.data[4 * (j * this.width + i) + 2] = pixel[2];\r\n        this.data[4 * (j * this.width + i) + 3] = pixel[3];\r\n    }\r\n    get(i, j) {\r\n        return [\r\n            this.data[4 * (j * this.width + i)],\r\n            this.data[4 * (j * this.width + i) + 1],\r\n            this.data[4 * (j * this.width + i) + 2],\r\n            this.data[4 * (j * this.width + i) + 3],\r\n        ];\r\n    }\r\n    flipHor() {\r\n        let image = new GeonImage(this.width, this.height, this.pixelSize);\r\n        for (let i = 0; i < this.height; i++) {\r\n            for (let j = 0; j < this.width; j++) {\r\n                let jMirror = this.width - 1 - j;\r\n                image.set(j, i, this.get(jMirror, i));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    flipVer() {\r\n        let image = new GeonImage(this.width, this.height, this.pixelSize);\r\n        for (let i = 0; i < this.height; i++) {\r\n            let iMirror = this.height - 1 - i;\r\n            for (let j = 0; j < this.width; j++) {\r\n                image.set(j, i, this.get(j, iMirror));\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    applyKernel(kernel) {\r\n        // determine kernel size\r\n        let size = kernel.count();\r\n        let radius = size / 2 - 0.5;\r\n        let image = new GeonImage(this.width - radius * 2, this.height - radius * 2, this.pixelSize);\r\n        // old image space\r\n        for (let i = radius; i < this.width - radius; i++) {\r\n            for (let j = radius; j < this.height - radius; j++) {\r\n                let pixel = this.getWithKernel(i, j, kernel, radius);\r\n                image.set(i - radius, j - radius, pixel);\r\n            }\r\n        }\r\n        return image; // succes\r\n    }\r\n    getMinMax() {\r\n        // get the minimum and maximum pixel value\r\n        // assumes pixelsize = 1\r\n        let min = Infinity;\r\n        let max = 0;\r\n        for (let i = 0; i < this.data.length; i++) {\r\n            if (this.data[i] < min) {\r\n                min = this.data[i];\r\n            }\r\n            else if (this.data[i] > max) {\r\n                max = this.data[i];\r\n            }\r\n        }\r\n        return [min, max];\r\n    }\r\n    applyThreshold(lower, upper) {\r\n        return this.apply((x, y) => {\r\n            let pixel = this.get(x, y);\r\n            if (pixel[0] < lower) {\r\n                return [0, 0, 0, 0];\r\n            }\r\n            else if (pixel[0] > upper) {\r\n                return [255, 255, 255, 255];\r\n            }\r\n            else {\r\n                return pixel;\r\n            }\r\n        });\r\n    }\r\n    apply(filler) {\r\n        let copy = new GeonImage(this.width, this.height, this.pixelSize);\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                copy.set(x, y, filler(x, y));\r\n            }\r\n        }\r\n        return copy;\r\n    }\r\n    applyNMS() {\r\n        // determine kernel size\r\n        let size = 3;\r\n        let radius = size / 2 - 0.5;\r\n        let copy = new GeonImage(this.width - radius * 2, this.height - radius * 2, this.pixelSize);\r\n        // old image space\r\n        for (let i = radius; i < this.width - radius; i++) {\r\n            for (let j = radius; j < this.height - radius; j++) {\r\n                // let pixel = this.getWithKernel(i, j, kernel, radius)\r\n                // copy.set(i-radius, j-radius, pixel);\r\n            }\r\n        }\r\n        // img.eachPixel(3, function(x, y, c, n) {\r\n        //     if (n[1][1] > n[0][1] && n[1][1] > n[2][1]) {\r\n        //         copy.data[x][y] = n[1][1];\r\n        //     } else {\r\n        //         copy.data[x][y] = 0;\r\n        //     }\r\n        //     if (n[1][1] > n[0][2] && n[1][1] > n[2][0]) {\r\n        //         copy.data[x][y] = n[1][1];\r\n        //     } else {\r\n        //         copy.data[x][y] = 0;\r\n        //     }\r\n        //     if (n[1][1] > n[1][0] && n[1][1] > n[1][2]) {\r\n        //         copy.data[x][y] = n[1][1];\r\n        //     } else {\r\n        //         copy.data[x][y] = 0;\r\n        //     }\r\n        //     if (n[1][1] > n[0][0] && n[1][1] > n[2][2]) {\r\n        //         return copy.data[x][y] = n[1][1];\r\n        //     } else {\r\n        //         return copy.data[x][y] = 0;\r\n        //     }\r\n        // });\r\n        return copy;\r\n    }\r\n    getWithKernel(i, j, kernel, radius) {\r\n        // kernel space\r\n        let sum = [0, 0, 0, 255];\r\n        let [dimx, dimy] = kernel.getDimensions();\r\n        for (let ki = 0; ki < dimx; ki++) {\r\n            for (let kj = 0; kj < dimy; kj++) {\r\n                let weight = kernel.get(ki, kj);\r\n                let pixel = this.get(i + ki - radius, j + kj - radius);\r\n                for (let i = 0; i < 3; i++) {\r\n                    sum[i] += pixel[i] * weight;\r\n                }\r\n            }\r\n        }\r\n        return sum;\r\n    }\r\n    setAplha(a) {\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                let pixel = this.get(x, y);\r\n                this.set(x, y, [pixel[0], pixel[1], pixel[2], a]);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    scale(scaleX, scaleY) {\r\n        // scale the image to a new width and height, using nearest neighbour\r\n        return this.resize(Math.round(this.width * scaleX), Math.round(this.height * scaleY));\r\n    }\r\n    resize(width, height) {\r\n        // resize the image to a new width and height, using nearest neighbour\r\n        const image = new GeonImage(width, height, this.pixelSize);\r\n        const old = this;\r\n        const x_factor = (1 / image.width) * old.width;\r\n        const y_factor = (1 / image.height) * old.height;\r\n        for (let y = 0; y < image.height; y++) {\r\n            for (let x = 0; x < image.width; x++) {\r\n                let pixel = old.get(Math.round(x * x_factor), Math.round(y * y_factor));\r\n                image.set(x, y, pixel);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    // add borders till this size is achieved\r\n    buffer(width, height) {\r\n        // resize the image to a new width and height, using nearest neighbour\r\n        const image = new GeonImage(width, height, this.pixelSize);\r\n        const old = this;\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                // console.log(x, y);\r\n                let pixel = old.includes(x, y) ? old.get(x, y) : [0, 0, 0, 255];\r\n                image.set(x, y, pixel);\r\n            }\r\n        }\r\n        // for (let y = 0; y < height; y++) {\r\n        //     for (let x = 0; x < width; x++) {\r\n        //         image.set(x, y, [x,0,0,255]);\r\n        //     }\r\n        // }\r\n        // build some simple image instead to test\r\n        // for (let i = 0; i < image.data.length / 4; i++) {\r\n        //     image.data[i*4 + 0] = i % 255;\r\n        //     image.data[i*4 + 1] = 0;\r\n        //     image.data[i*4 + 2] = 0;\r\n        //     image.data[i*4 + 3] = 255;\r\n        // }\r\n        return image;\r\n    }\r\n    trimWithDomain(dom) {\r\n        const x1 = Math.round(dom.x.t0);\r\n        const x2 = Math.round(dom.x.t1);\r\n        const y1 = Math.round(dom.y.t0);\r\n        const y2 = Math.round(dom.y.t1);\r\n        return this.trim(x1, y1, x2, y2);\r\n    }\r\n    trim(x1, y1, x2, y2) {\r\n        // return a hardcopy of this particular window\r\n        const imageWidth = x2 - x1;\r\n        const imageHeight = y2 - y1;\r\n        const image = new GeonImage(imageWidth, imageHeight, this.pixelSize);\r\n        for (let y = 0; y < imageHeight; y++) {\r\n            for (let x = 0; x < imageWidth; x++) {\r\n                let pixel = this.get(x + x1, y + y1);\r\n                image.set(x, y, pixel);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    toGreyscale() {\r\n        if (this.pixelSize != 4)\r\n            throw \"please, only use this when pixelsize is 4\";\r\n        let image = new GeonImage(this.width, this.height, 4);\r\n        for (let y = 0; y < this.height; y++) {\r\n            for (let x = 0; x < this.width; x++) {\r\n                let pixel = this.get(x, y);\r\n                let avg = (pixel[0] + pixel[1] + pixel[2]) / 3;\r\n                image.set(x, y, [avg, avg, avg, 255]);\r\n            }\r\n        }\r\n        return image;\r\n    }\r\n    toRGBA() {\r\n        // if (this.pixelSize != 1) throw \"please, only use this when pixelsize is 1\"\r\n        return this;\r\n        // let image = new GeonImage(this.width, this.height, 4);\r\n        // for (let y = 0; y < this.height; y++) {\r\n        //     for (let x = 0; x < this.width; x++) {\r\n        //         let pixel = this.get(x,y);\r\n        //         let val = pixel[0];\r\n        //         image.set(x, y, [val, val, val, 255]);\r\n        //     }\r\n        // }\r\n        // return image;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/img/Image.ts?");

/***/ }),

/***/ "../engine/src/img/kernels.ts":
/*!************************************!*\
  !*** ../engine/src/img/kernels.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Kernels\": () => (/* binding */ Kernels)\n/* harmony export */ });\n/* harmony import */ var _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/float-matrix */ \"../engine/src/data/float-matrix.ts\");\n\r\n// kernels\r\n// note: wauw, prettify made a mess from this code...\r\nclass Kernels {\r\n    // inspired from https://github.com/yuta1984/CannyJS/blob/master/canny.js\r\n    static generateGaussianKernel(sigma, size) {\r\n        // messy, probably auto-generated\r\n        var e, gaussian, i, j, kernel, s, sum, x, y, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;\r\n        s = sigma;\r\n        e = 2.718;\r\n        kernel = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(size, size);\r\n        sum = 0;\r\n        for (i = _i = 0, _ref = size - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {\r\n            x = -(size - 1) / 2 + i;\r\n            for (j = _j = 0, _ref1 = size - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {\r\n                y = -(size - 1) / 2 + j;\r\n                gaussian =\r\n                    (1 / (2 * Math.PI * s * s)) * Math.pow(e, -(x * x + y * y) / (2 * s * s));\r\n                kernel.set(i, j, gaussian);\r\n                sum += gaussian;\r\n            }\r\n        }\r\n        for (i = _k = 0, _ref2 = size - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {\r\n            for (j = _l = 0, _ref3 = size - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {\r\n                kernel.set(i, j, kernel.get(i, j) / sum);\r\n            }\r\n        }\r\n        return kernel;\r\n    }\r\n}\r\nKernels.SmoothKernel = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 1, 1, 1, 1, 1, 1, 1, 1]).forEachValue((i) => (i * 1) / 9);\r\nKernels.SmoothKernel5 = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(5, 5, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]).forEachValue((v) => (v * 1) / 25);\r\nKernels.Gauss5 = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(5, 5, [2, 4, 5, 4, 2, 4, 9, 12, 9, 4, 5, 12, 15, 12, 5, 4, 9, 12, 9, 4, 2, 4, 5, 4, 2]).forEachValue((v) => (v * 1) / 159);\r\nKernels.TestKernel = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 0, -1, 0, 0, 0, -1, 0, 1]);\r\nKernels.SobelLeft = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 2, 1, 0, 0, 0, -1, -2, -1]);\r\nKernels.SobelRight = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [-1, -2, -1, 0, 0, 0, 1, 2, 1]);\r\nKernels.SobelUp = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [1, 0, -1, 2, 0, -2, 1, 0, -1]);\r\nKernels.SobelDown = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(3, 3, [-1, 0, 1, -2, 0, 2, -1, 0, 1]);\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/img/kernels.ts?");

/***/ }),

/***/ "../engine/src/lib.ts":
/*!****************************!*\
  !*** ../engine/src/lib.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Perlin\": () => (/* reexport safe */ _algorithms_perlin_noise__WEBPACK_IMPORTED_MODULE_1__.Perlin),\n/* harmony export */   \"App\": () => (/* reexport safe */ _app_app__WEBPACK_IMPORTED_MODULE_2__.App),\n/* harmony export */   \"SwapApp\": () => (/* reexport safe */ _app_swap_app__WEBPACK_IMPORTED_MODULE_3__.SwapApp),\n/* harmony export */   \"FloatMatrix\": () => (/* reexport safe */ _data_float_matrix__WEBPACK_IMPORTED_MODULE_4__.FloatMatrix),\n/* harmony export */   \"HashTable\": () => (/* reexport safe */ _data_hash_table__WEBPACK_IMPORTED_MODULE_5__.HashTable),\n/* harmony export */   \"IntCube\": () => (/* reexport safe */ _data_int_cube__WEBPACK_IMPORTED_MODULE_6__.IntCube),\n/* harmony export */   \"IntMatrix\": () => (/* reexport safe */ _data_int_matrix__WEBPACK_IMPORTED_MODULE_7__.IntMatrix),\n/* harmony export */   \"LinkedList\": () => (/* reexport safe */ _data_linked_list__WEBPACK_IMPORTED_MODULE_8__.LinkedList),\n/* harmony export */   \"ToFloatMatrix\": () => (/* reexport safe */ _data_multi_vector__WEBPACK_IMPORTED_MODULE_9__.ToFloatMatrix),\n/* harmony export */   \"MultiVector3\": () => (/* reexport safe */ _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_10__.MultiVector3),\n/* harmony export */   \"MultiVector2\": () => (/* reexport safe */ _data_multi_vector_2__WEBPACK_IMPORTED_MODULE_11__.MultiVector2),\n/* harmony export */   \"Const\": () => (/* reexport safe */ _math_const__WEBPACK_IMPORTED_MODULE_12__.Const),\n/* harmony export */   \"Domain\": () => (/* reexport safe */ _math_domain__WEBPACK_IMPORTED_MODULE_13__.Domain),\n/* harmony export */   \"Domain2\": () => (/* reexport safe */ _math_domain__WEBPACK_IMPORTED_MODULE_13__.Domain2),\n/* harmony export */   \"Domain3\": () => (/* reexport safe */ _math_domain__WEBPACK_IMPORTED_MODULE_13__.Domain3),\n/* harmony export */   \"GeonMath\": () => (/* reexport safe */ _math_math__WEBPACK_IMPORTED_MODULE_14__.GeonMath),\n/* harmony export */   \"Matrix3\": () => (/* reexport safe */ _math_matrix__WEBPACK_IMPORTED_MODULE_15__.Matrix3),\n/* harmony export */   \"Matrix4\": () => (/* reexport safe */ _math_matrix__WEBPACK_IMPORTED_MODULE_15__.Matrix4),\n/* harmony export */   \"Quaternion\": () => (/* reexport safe */ _math_quaternion__WEBPACK_IMPORTED_MODULE_16__.Quaternion),\n/* harmony export */   \"Ray\": () => (/* reexport safe */ _math_ray__WEBPACK_IMPORTED_MODULE_17__.Ray),\n/* harmony export */   \"Stat\": () => (/* reexport safe */ _math_statistics__WEBPACK_IMPORTED_MODULE_18__.Stat),\n/* harmony export */   \"Util\": () => (/* reexport safe */ _math_util__WEBPACK_IMPORTED_MODULE_19__.Util),\n/* harmony export */   \"Vector2\": () => (/* reexport safe */ _math_vector__WEBPACK_IMPORTED_MODULE_20__.Vector2),\n/* harmony export */   \"Vector3\": () => (/* reexport safe */ _math_vector__WEBPACK_IMPORTED_MODULE_20__.Vector3),\n/* harmony export */   \"Random\": () => (/* reexport safe */ _math_random__WEBPACK_IMPORTED_MODULE_21__.Random),\n/* harmony export */   \"createGUID\": () => (/* reexport safe */ _math_random__WEBPACK_IMPORTED_MODULE_21__.createGUID),\n/* harmony export */   \"createRandomGUID\": () => (/* reexport safe */ _math_random__WEBPACK_IMPORTED_MODULE_21__.createRandomGUID),\n/* harmony export */   \"Polynomial\": () => (/* reexport safe */ _math_polynomial__WEBPACK_IMPORTED_MODULE_22__.Polynomial),\n/* harmony export */   \"Graph\": () => (/* reexport safe */ _mesh_graph__WEBPACK_IMPORTED_MODULE_23__.Graph),\n/* harmony export */   \"MultiLine\": () => (/* reexport safe */ _mesh_multi_line__WEBPACK_IMPORTED_MODULE_24__.MultiLine),\n/* harmony export */   \"getDefaultIndices\": () => (/* reexport safe */ _mesh_multi_line__WEBPACK_IMPORTED_MODULE_24__.getDefaultIndices),\n/* harmony export */   \"Mesh\": () => (/* reexport safe */ _mesh_mesh__WEBPACK_IMPORTED_MODULE_25__.Mesh),\n/* harmony export */   \"MeshType\": () => (/* reexport safe */ _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_26__.MeshType),\n/* harmony export */   \"NormalKind\": () => (/* reexport safe */ _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_26__.NormalKind),\n/* harmony export */   \"ShaderMesh\": () => (/* reexport safe */ _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_26__.ShaderMesh),\n/* harmony export */   \"meshFromObj\": () => (/* reexport safe */ _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_26__.meshFromObj),\n/* harmony export */   \"TopoMesh\": () => (/* reexport safe */ _mesh_topo_mesh__WEBPACK_IMPORTED_MODULE_27__.TopoMesh),\n/* harmony export */   \"Geo\": () => (/* reexport safe */ _geo_geo__WEBPACK_IMPORTED_MODULE_28__.Geo),\n/* harmony export */   \"Circle2\": () => (/* reexport safe */ _geo_circle2__WEBPACK_IMPORTED_MODULE_29__.Circle2),\n/* harmony export */   \"Circle3\": () => (/* reexport safe */ _geo_circle3__WEBPACK_IMPORTED_MODULE_30__.Circle3),\n/* harmony export */   \"Cube\": () => (/* reexport safe */ _geo_cube__WEBPACK_IMPORTED_MODULE_31__.Cube),\n/* harmony export */   \"LineCurve2\": () => (/* reexport safe */ _geo_line__WEBPACK_IMPORTED_MODULE_33__.LineCurve2),\n/* harmony export */   \"Plane\": () => (/* reexport safe */ _geo_plane__WEBPACK_IMPORTED_MODULE_34__.Plane),\n/* harmony export */   \"Polyline\": () => (/* reexport safe */ _geo_curve_polyline__WEBPACK_IMPORTED_MODULE_35__.Polyline),\n/* harmony export */   \"Rectangle2\": () => (/* reexport safe */ _geo_rectangle__WEBPACK_IMPORTED_MODULE_36__.Rectangle2),\n/* harmony export */   \"Rectangle3\": () => (/* reexport safe */ _geo_rectangle__WEBPACK_IMPORTED_MODULE_36__.Rectangle3),\n/* harmony export */   \"Triangle2\": () => (/* reexport safe */ _geo_triangle__WEBPACK_IMPORTED_MODULE_37__.Triangle2),\n/* harmony export */   \"Triangle3\": () => (/* reexport safe */ _geo_triangle__WEBPACK_IMPORTED_MODULE_37__.Triangle3),\n/* harmony export */   \"Curve\": () => (/* reexport safe */ _geo_curve_curve__WEBPACK_IMPORTED_MODULE_38__.Curve),\n/* harmony export */   \"Bezier\": () => (/* reexport safe */ _geo_curve_bezier__WEBPACK_IMPORTED_MODULE_39__.Bezier),\n/* harmony export */   \"Cubez\": () => (/* reexport safe */ _geo_curve_bezier__WEBPACK_IMPORTED_MODULE_39__.Cubez),\n/* harmony export */   \"Spline\": () => (/* reexport safe */ _geo_curve_spline__WEBPACK_IMPORTED_MODULE_40__.Spline),\n/* harmony export */   \"BiSurface\": () => (/* reexport safe */ _geo_surface_surface__WEBPACK_IMPORTED_MODULE_41__.BiSurface),\n/* harmony export */   \"Surface\": () => (/* reexport safe */ _geo_surface_surface__WEBPACK_IMPORTED_MODULE_41__.Surface),\n/* harmony export */   \"TriSurface\": () => (/* reexport safe */ _geo_surface_surface__WEBPACK_IMPORTED_MODULE_41__.TriSurface),\n/* harmony export */   \"BezierSquare\": () => (/* reexport safe */ _geo_surface_bezier_square__WEBPACK_IMPORTED_MODULE_42__.BezierSquare),\n/* harmony export */   \"Loft\": () => (/* reexport safe */ _geo_surface_loft__WEBPACK_IMPORTED_MODULE_43__.Loft),\n/* harmony export */   \"GeonImage\": () => (/* reexport safe */ _img_Image__WEBPACK_IMPORTED_MODULE_44__.GeonImage),\n/* harmony export */   \"Kernels\": () => (/* reexport safe */ _img_kernels__WEBPACK_IMPORTED_MODULE_45__.Kernels),\n/* harmony export */   \"Camera\": () => (/* reexport safe */ _render_camera__WEBPACK_IMPORTED_MODULE_46__.Camera),\n/* harmony export */   \"Combi\": () => (/* reexport safe */ _combo_combo__WEBPACK_IMPORTED_MODULE_47__.Combi),\n/* harmony export */   \"Combo\": () => (/* reexport safe */ _combo_combo__WEBPACK_IMPORTED_MODULE_47__.Combo),\n/* harmony export */   \"Light\": () => (/* reexport safe */ _render_light__WEBPACK_IMPORTED_MODULE_48__.Light),\n/* harmony export */   \"Context\": () => (/* reexport safe */ _render_context__WEBPACK_IMPORTED_MODULE_49__.Context),\n/* harmony export */   \"Attribute\": () => (/* reexport safe */ _render_low_attribute__WEBPACK_IMPORTED_MODULE_50__.Attribute),\n/* harmony export */   \"IndexAttribute\": () => (/* reexport safe */ _render_low_attribute__WEBPACK_IMPORTED_MODULE_50__.IndexAttribute),\n/* harmony export */   \"Attributes\": () => (/* reexport safe */ _render_low_attributes__WEBPACK_IMPORTED_MODULE_51__.Attributes),\n/* harmony export */   \"Shader\": () => (/* reexport safe */ _render_low_shader__WEBPACK_IMPORTED_MODULE_52__.Shader),\n/* harmony export */   \"Uniform\": () => (/* reexport safe */ _render_low_uniform__WEBPACK_IMPORTED_MODULE_53__.Uniform),\n/* harmony export */   \"UniformTexture\": () => (/* reexport safe */ _render_low_uniform__WEBPACK_IMPORTED_MODULE_53__.UniformTexture),\n/* harmony export */   \"UniformType\": () => (/* reexport safe */ _render_low_uniform__WEBPACK_IMPORTED_MODULE_53__.UniformType),\n/* harmony export */   \"Uniforms\": () => (/* reexport safe */ _render_low_uniforms__WEBPACK_IMPORTED_MODULE_54__.Uniforms),\n/* harmony export */   \"DrawSpeed\": () => (/* reexport safe */ _render_low_webgl__WEBPACK_IMPORTED_MODULE_55__.DrawSpeed),\n/* harmony export */   \"HelpGl\": () => (/* reexport safe */ _render_low_webgl__WEBPACK_IMPORTED_MODULE_55__.HelpGl),\n/* harmony export */   \"MultiRenderer\": () => (/* reexport safe */ _renderers_multi_renderer__WEBPACK_IMPORTED_MODULE_56__.MultiRenderer),\n/* harmony export */   \"DotShader\": () => (/* reexport safe */ _shaders_dot_shader__WEBPACK_IMPORTED_MODULE_57__.DotShader),\n/* harmony export */   \"LineShader\": () => (/* reexport safe */ _shaders_line_shader__WEBPACK_IMPORTED_MODULE_58__.LineShader),\n/* harmony export */   \"MeshDebugShader\": () => (/* reexport safe */ _shaders_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_59__.MeshDebugShader),\n/* harmony export */   \"NormalShader\": () => (/* reexport safe */ _shaders_mesh_normals_shader__WEBPACK_IMPORTED_MODULE_60__.NormalShader),\n/* harmony export */   \"RectangleShader\": () => (/* reexport safe */ _shaders_rectangle_shader__WEBPACK_IMPORTED_MODULE_61__.RectangleShader),\n/* harmony export */   \"ShadedMeshShader\": () => (/* reexport safe */ _shaders_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_62__.ShadedMeshShader),\n/* harmony export */   \"SimpleMeshShader\": () => (/* reexport safe */ _shaders_simple_mesh_shader__WEBPACK_IMPORTED_MODULE_63__.SimpleMeshShader),\n/* harmony export */   \"TextureMeshShader\": () => (/* reexport safe */ _shaders_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_64__.TextureMeshShader),\n/* harmony export */   \"GraphDebugShader\": () => (/* reexport safe */ _shaders_graph_debug_shader__WEBPACK_IMPORTED_MODULE_65__.GraphDebugShader),\n/* harmony export */   \"BillboardShader\": () => (/* reexport safe */ _shaderprograms_billboard_shader__WEBPACK_IMPORTED_MODULE_66__.BillboardShader),\n/* harmony export */   \"DotShader2\": () => (/* reexport safe */ _shaders2_dot_shader_2__WEBPACK_IMPORTED_MODULE_67__.DotShader2),\n/* harmony export */   \"addDropFileEventListeners\": () => (/* reexport safe */ _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__.addDropFileEventListeners),\n/* harmony export */   \"loadImageFromBlob\": () => (/* reexport safe */ _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__.loadImageFromBlob),\n/* harmony export */   \"loadImageFromFile\": () => (/* reexport safe */ _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__.loadImageFromFile),\n/* harmony export */   \"loadImageFromSrc\": () => (/* reexport safe */ _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__.loadImageFromSrc),\n/* harmony export */   \"loadJSONFromFile\": () => (/* reexport safe */ _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__.loadJSONFromFile),\n/* harmony export */   \"loadTextFromFile\": () => (/* reexport safe */ _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__.loadTextFromFile),\n/* harmony export */   \"FpsCounter\": () => (/* reexport safe */ _system_fps_counter__WEBPACK_IMPORTED_MODULE_69__.FpsCounter),\n/* harmony export */   \"InputState\": () => (/* reexport safe */ _system_input_state__WEBPACK_IMPORTED_MODULE_70__.InputState),\n/* harmony export */   \"EnumParameter\": () => (/* reexport safe */ _system_ui__WEBPACK_IMPORTED_MODULE_71__.EnumParameter),\n/* harmony export */   \"Parameter\": () => (/* reexport safe */ _system_ui__WEBPACK_IMPORTED_MODULE_71__.Parameter),\n/* harmony export */   \"UI\": () => (/* reexport safe */ _system_ui__WEBPACK_IMPORTED_MODULE_71__.UI),\n/* harmony export */   \"Core\": () => (/* reexport safe */ _system_core__WEBPACK_IMPORTED_MODULE_72__.Core),\n/* harmony export */   \"ImageCombi\": () => (/* reexport safe */ _combo_image_combi__WEBPACK_IMPORTED_MODULE_73__.ImageCombi)\n/* harmony export */ });\n/* harmony import */ var _algorithms_marching_cubes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./algorithms/marching-cubes */ \"../engine/src/algorithms/marching-cubes.ts\");\n/* harmony import */ var _algorithms_perlin_noise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./algorithms/perlin-noise */ \"../engine/src/algorithms/perlin-noise.ts\");\n/* harmony import */ var _app_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./app/app */ \"../engine/src/app/app.ts\");\n/* harmony import */ var _app_swap_app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/swap-app */ \"../engine/src/app/swap-app.ts\");\n/* harmony import */ var _data_float_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/float-matrix */ \"../engine/src/data/float-matrix.ts\");\n/* harmony import */ var _data_hash_table__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data/hash-table */ \"../engine/src/data/hash-table.ts\");\n/* harmony import */ var _data_int_cube__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data/int-cube */ \"../engine/src/data/int-cube.ts\");\n/* harmony import */ var _data_int_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./data/int-matrix */ \"../engine/src/data/int-matrix.ts\");\n/* harmony import */ var _data_linked_list__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data/linked-list */ \"../engine/src/data/linked-list.ts\");\n/* harmony import */ var _data_multi_vector__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./data/multi-vector */ \"../engine/src/data/multi-vector.ts\");\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _data_multi_vector_2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./data/multi-vector-2 */ \"../engine/src/data/multi-vector-2.ts\");\n/* harmony import */ var _math_const__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./math/const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./math/math */ \"../engine/src/math/math.ts\");\n/* harmony import */ var _math_matrix__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./math/matrix */ \"../engine/src/math/matrix.ts\");\n/* harmony import */ var _math_quaternion__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./math/quaternion */ \"../engine/src/math/quaternion.ts\");\n/* harmony import */ var _math_ray__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./math/ray */ \"../engine/src/math/ray.ts\");\n/* harmony import */ var _math_statistics__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./math/statistics */ \"../engine/src/math/statistics.ts\");\n/* harmony import */ var _math_util__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./math/util */ \"../engine/src/math/util.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _math_random__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./math/random */ \"../engine/src/math/random.ts\");\n/* harmony import */ var _math_polynomial__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./math/polynomial */ \"../engine/src/math/polynomial.ts\");\n/* harmony import */ var _mesh_graph__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./mesh/graph */ \"../engine/src/mesh/graph.ts\");\n/* harmony import */ var _mesh_multi_line__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./mesh/multi-line */ \"../engine/src/mesh/multi-line.ts\");\n/* harmony import */ var _mesh_mesh__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./mesh/mesh */ \"../engine/src/mesh/mesh.ts\");\n/* harmony import */ var _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./mesh/shader-mesh */ \"../engine/src/mesh/shader-mesh.ts\");\n/* harmony import */ var _mesh_topo_mesh__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./mesh/topo-mesh */ \"../engine/src/mesh/topo-mesh.ts\");\n/* harmony import */ var _geo_geo__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./geo/geo */ \"../engine/src/geo/geo.ts\");\n/* harmony import */ var _geo_circle2__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./geo/circle2 */ \"../engine/src/geo/circle2.ts\");\n/* harmony import */ var _geo_circle3__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./geo/circle3 */ \"../engine/src/geo/circle3.ts\");\n/* harmony import */ var _geo_cube__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./geo/cube */ \"../engine/src/geo/cube.ts\");\n/* harmony import */ var _geo_intersect__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./geo/intersect */ \"../engine/src/geo/intersect.ts\");\n/* harmony import */ var _geo_line__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./geo/line */ \"../engine/src/geo/line.ts\");\n/* harmony import */ var _geo_plane__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./geo/plane */ \"../engine/src/geo/plane.ts\");\n/* harmony import */ var _geo_curve_polyline__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./geo/curve/polyline */ \"../engine/src/geo/curve/polyline.ts\");\n/* harmony import */ var _geo_rectangle__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./geo/rectangle */ \"../engine/src/geo/rectangle.ts\");\n/* harmony import */ var _geo_triangle__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./geo/triangle */ \"../engine/src/geo/triangle.ts\");\n/* harmony import */ var _geo_curve_curve__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./geo/curve/curve */ \"../engine/src/geo/curve/curve.ts\");\n/* harmony import */ var _geo_curve_bezier__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./geo/curve/bezier */ \"../engine/src/geo/curve/bezier.ts\");\n/* harmony import */ var _geo_curve_spline__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./geo/curve/spline */ \"../engine/src/geo/curve/spline.ts\");\n/* harmony import */ var _geo_surface_surface__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./geo/surface/surface */ \"../engine/src/geo/surface/surface.ts\");\n/* harmony import */ var _geo_surface_bezier_square__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./geo/surface/bezier-square */ \"../engine/src/geo/surface/bezier-square.ts\");\n/* harmony import */ var _geo_surface_loft__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./geo/surface/loft */ \"../engine/src/geo/surface/loft.ts\");\n/* harmony import */ var _img_Image__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./img/Image */ \"../engine/src/img/Image.ts\");\n/* harmony import */ var _img_kernels__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./img/kernels */ \"../engine/src/img/kernels.ts\");\n/* harmony import */ var _render_camera__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./render/camera */ \"../engine/src/render/camera.ts\");\n/* harmony import */ var _combo_combo__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./combo/combo */ \"../engine/src/combo/combo.ts\");\n/* harmony import */ var _render_light__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./render/light */ \"../engine/src/render/light.ts\");\n/* harmony import */ var _render_context__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./render/context */ \"../engine/src/render/context.ts\");\n/* harmony import */ var _render_low_attribute__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./render-low/attribute */ \"../engine/src/render-low/attribute.ts\");\n/* harmony import */ var _render_low_attributes__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./render-low/attributes */ \"../engine/src/render-low/attributes.ts\");\n/* harmony import */ var _render_low_shader__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./render-low/shader */ \"../engine/src/render-low/shader.ts\");\n/* harmony import */ var _render_low_uniform__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./render-low/uniform */ \"../engine/src/render-low/uniform.ts\");\n/* harmony import */ var _render_low_uniforms__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./render-low/uniforms */ \"../engine/src/render-low/uniforms.ts\");\n/* harmony import */ var _render_low_webgl__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./render-low/webgl */ \"../engine/src/render-low/webgl.ts\");\n/* harmony import */ var _renderers_multi_renderer__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./renderers/multi-renderer */ \"../engine/src/renderers/multi-renderer.ts\");\n/* harmony import */ var _shaders_dot_shader__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./shaders/dot-shader */ \"../engine/src/shaders/dot-shader.ts\");\n/* harmony import */ var _shaders_line_shader__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./shaders/line-shader */ \"../engine/src/shaders/line-shader.ts\");\n/* harmony import */ var _shaders_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./shaders/mesh-debug-shader */ \"../engine/src/shaders/mesh-debug-shader.ts\");\n/* harmony import */ var _shaders_mesh_normals_shader__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./shaders/mesh-normals-shader */ \"../engine/src/shaders/mesh-normals-shader.ts\");\n/* harmony import */ var _shaders_rectangle_shader__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./shaders/rectangle-shader */ \"../engine/src/shaders/rectangle-shader.ts\");\n/* harmony import */ var _shaders_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./shaders/shaded-mesh-shader */ \"../engine/src/shaders/shaded-mesh-shader.ts\");\n/* harmony import */ var _shaders_simple_mesh_shader__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./shaders/simple-mesh-shader */ \"../engine/src/shaders/simple-mesh-shader.ts\");\n/* harmony import */ var _shaders_texture_mesh_shader__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./shaders/texture-mesh-shader */ \"../engine/src/shaders/texture-mesh-shader.ts\");\n/* harmony import */ var _shaders_graph_debug_shader__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./shaders/graph-debug-shader */ \"../engine/src/shaders/graph-debug-shader.ts\");\n/* harmony import */ var _shaderprograms_billboard_shader__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./shaderprograms/billboard-shader */ \"../engine/src/shaderprograms/billboard-shader.ts\");\n/* harmony import */ var _shaders2_dot_shader_2__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./shaders2/dot-shader-2 */ \"../engine/src/shaders2/dot-shader-2.ts\");\n/* harmony import */ var _system_domwrappers__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./system/domwrappers */ \"../engine/src/system/domwrappers.ts\");\n/* harmony import */ var _system_fps_counter__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./system/fps-counter */ \"../engine/src/system/fps-counter.ts\");\n/* harmony import */ var _system_input_state__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./system/input-state */ \"../engine/src/system/input-state.ts\");\n/* harmony import */ var _system_ui__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./system/ui */ \"../engine/src/system/ui.ts\");\n/* harmony import */ var _system_core__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./system/core */ \"../engine/src/system/core.ts\");\n/* harmony import */ var _combo_image_combi__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./combo/image-combi */ \"../engine/src/combo/image-combi.ts\");\n// purpose: make sure the entire library is callable from one point.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/lib.ts?");

/***/ }),

/***/ "../engine/src/math/const.ts":
/*!***********************************!*\
  !*** ../engine/src/math/const.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Const\": () => (/* binding */ Const)\n/* harmony export */ });\n// name:    const.ts\r\n// author:  Jos Feenstra\r\n// purpose: Certain math constances\r\n// todo:    These are somewhat like the settings of the entire application. This could be expanded upon (json's, in-app functionalitiy)\r\nclass Const {\r\n    static IsRouglyZero(value) {\r\n        return Math.abs(value) < this.TOLERANCE;\r\n    }\r\n}\r\nConst.TOLERANCE = 0.0001; // tolerance used for determining if 1 value is the same as some other value, relatively speaking\r\nConst.TOL_SQUARED = Math.pow(Const.TOLERANCE, 2);\r\nConst.MAX_U16 = 65536;\r\n// ----- Line Render Settings -----\r\nConst.PLANE_RENDER_LINECOUNT = 9;\r\nConst.PLANE_RENDER_LINEDISTANCE = 0.3;\r\nConst.CIRCLE_SEGMENTS = 100;\r\nConst.BEZIER_SEGMENTS = 100;\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/const.ts?");

/***/ }),

/***/ "../engine/src/math/domain.ts":
/*!************************************!*\
  !*** ../engine/src/math/domain.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Domain\": () => (/* binding */ Domain),\n/* harmony export */   \"Domain2\": () => (/* binding */ Domain2),\n/* harmony export */   \"Domain3\": () => (/* binding */ Domain3)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _system_stopwatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../system/stopwatch */ \"../engine/src/system/stopwatch.ts\");\n// domain.ts\r\n//\r\n// author: Jos Feenstra\r\n// purpose: general representation of a domain / range / bound of numbers\r\n\r\n\r\nclass Domain {\r\n    // note: including t0, including t1\r\n    constructor(t0 = 0.0, t1 = 1.0) {\r\n        this.t0 = t0;\r\n        this.t1 = t1;\r\n        // if (t0 > t1) console.error(\"created a domain with negative size.\");\r\n        // if (t0 == t1) console.warn(\"created a domain with size is 0.0. could cause problems\");\r\n    }\r\n    static new(t0 = 0, t1 = 1) {\r\n        return new Domain(t0, t1);\r\n    }\r\n    static fromRadius(r) {\r\n        return new Domain(-r, r);\r\n    }\r\n    static fromInclude(data) {\r\n        // create a new domain which bounds all parsed values\r\n        let min = Number.MAX_VALUE;\r\n        let max = Number.MIN_VALUE;\r\n        for (let i = 0; i < data.length; i++) {\r\n            if (data[i] < min)\r\n                min = data[i];\r\n            if (data[i] > max)\r\n                max = data[i];\r\n        }\r\n        return new Domain(min, max);\r\n    }\r\n    offset(t0Offset, t1Offset) {\r\n        this.t0 += t0Offset;\r\n        this.t1 += t1Offset;\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return value >= this.t0 && value <= this.t1;\r\n    }\r\n    includesEx(value) {\r\n        // note: including t0, excluding t1\r\n        return value >= this.t0 && value < this.t1;\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return this.t1 - this.t0;\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return (value - this.t0) / this.size();\r\n    }\r\n    /**\r\n     * elevate a normalized parameter onto this domain\r\n     * @param t normalized parameter t in domain 0--1\r\n     * @returns parameter in domains numerical space\r\n     */\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return t * this.size() + this.t0;\r\n    }\r\n    /**\r\n     * Exact same thing as elevate\r\n     */\r\n    lerp(t) {\r\n        return this.elevate(t);\r\n    }\r\n    remap(value, other = new Domain()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    /**\r\n     * generate `count` values evenly distributed along the domain.\r\n     */\r\n    spawn(count) {\r\n        // this is almost 100x slower\r\n        // return new Float32Array(this.iter(count));\r\n        let result = new Float32Array(count);\r\n        let step = this.size() / (count - 1);\r\n        for (let i = 0; i < count; i++) {\r\n            result[i] = this.t0 + i * step;\r\n        }\r\n        return result;\r\n    }\r\n    *iter(count) {\r\n        // iterate over this Domain 'count' number of times\r\n        let step = this.size() / (count - 1);\r\n        for (let i = 0; i < count; i++) {\r\n            let val = this.t0 + i * step;\r\n            yield val;\r\n        }\r\n    }\r\n    *iterStep(step) {\r\n        // iterate over this domain with a stepsize of 'step'\r\n        for (let i = this.t0; i <= this.t1; i += step) {\r\n            yield i;\r\n        }\r\n    }\r\n    // comform a number to the bound\r\n    comform(value) {\r\n        if (value < this.t0) {\r\n            return this.t0;\r\n        }\r\n        else if (value > this.t1) {\r\n            return this.t1;\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    }\r\n}\r\nclass Domain2 {\r\n    constructor(x = new Domain(), y = new Domain()) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    static fromRadii(rx, ry) {\r\n        return new Domain2(Domain.fromRadius(rx), Domain.fromRadius(ry));\r\n    }\r\n    static fromRadius(r) {\r\n        return new Domain2(Domain.fromRadius(r), Domain.fromRadius(r));\r\n    }\r\n    static fromBounds(x0, x1, y0, y1) {\r\n        return new Domain2(new Domain(x0, x1), new Domain(y0, y1));\r\n    }\r\n    static fromWH(x, y, w, h) {\r\n        return new Domain2(new Domain(x, x + w), new Domain(y, y + h));\r\n    }\r\n    static fromInclude(data) {\r\n        // note : could be quicker by going verbose, this now iterates over data 4 times\r\n        let mat = data.toMatrixSlice();\r\n        return new Domain2(Domain.fromInclude(mat.getColumn(0)), Domain.fromInclude(mat.getColumn(1)));\r\n    }\r\n    offset(xXyYoffset) {\r\n        let off = xXyYoffset;\r\n        if (off.length != 4)\r\n            throw \"need 4 values\";\r\n        this.x.offset(off[0], off[1]);\r\n        this.y.offset(off[2], off[3]);\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includes(value.x) && this.y.includes(value.y);\r\n    }\r\n    includesEx(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includesEx(value.x) && this.y.includesEx(value.y);\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.x.size(), this.y.size());\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.x.normalize(value.x), this.y.normalize(value.y));\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2(this.x.elevate(t.x), this.y.elevate(t.y));\r\n    }\r\n    remap(value, other = new Domain2()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    corners() {\r\n        // render the extends of this boundary / domain\r\n        let dim = 2;\r\n        let corners = Math.pow(2, dim);\r\n        let data = [];\r\n        for (let x of [this.x.t0, this.x.t1]) {\r\n            for (let y of [this.y.t0, this.y.t1]) {\r\n                data.push(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y));\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     * generate `countX * CountY` vector2's evenly distributed along the domain.\r\n     */\r\n    spawn(countX, countY) {\r\n        // iterate over this Domain 'count' number of times\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(countX * countY);\r\n        let i = 0;\r\n        let yRange = this.y.spawn(countY);\r\n        let xRange = this.x.spawn(countX);\r\n        for (const y of yRange) {\r\n            for (const x of xRange) {\r\n                result.setXY(i, x, y);\r\n                i++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Generate a bunch of random points\r\n     */\r\n    populate(count, rng) {\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(count);\r\n        for (let i = 0; i < result.count; i++) {\r\n            result.set(i, this.elevate(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.fromRandom(rng)));\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass Domain3 {\r\n    constructor(x = new Domain(), y = new Domain(), z = new Domain()) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    static fromBounds(x0, x1, y0, y1, z0, z1) {\r\n        return new Domain3(new Domain(x0, x1), new Domain(y0, y1), new Domain(z0, z1));\r\n    }\r\n    static fromRadius(r) {\r\n        return new Domain3(Domain.fromRadius(r), Domain.fromRadius(r), Domain.fromRadius(r));\r\n    }\r\n    static fromRadii(rx, ry, rz) {\r\n        return new Domain3(Domain.fromRadius(rx), Domain.fromRadius(ry), Domain.fromRadius(rz));\r\n    }\r\n    static fromInclude(data) {\r\n        // note : could be quicker by going verbose, this now iterates over data 6 times\r\n        return new Domain3(Domain.fromInclude(data.slice().getColumn(0)), Domain.fromInclude(data.slice().getColumn(1)), Domain.fromInclude(data.slice().getColumn(2)));\r\n    }\r\n    offset(xXyYoffset) {\r\n        let off = xXyYoffset;\r\n        if (off.length != 6)\r\n            throw \"need 6 values\";\r\n        this.x.offset(off[0], off[1]);\r\n        this.y.offset(off[2], off[3]);\r\n        this.z.offset(off[4], off[5]);\r\n        return this;\r\n    }\r\n    includes(value) {\r\n        // note: including t0, including t1\r\n        return this.x.includes(value.x) && this.y.includes(value.y) && this.z.includes(value.z);\r\n    }\r\n    size() {\r\n        // the size or length of this domain\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x.size(), this.y.size(), this.z.size());\r\n    }\r\n    normalize(value) {\r\n        // normalize a parameter\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x.normalize(value.x), this.y.normalize(value.y), this.z.normalize(value.z));\r\n    }\r\n    elevate(t) {\r\n        // elevate a normalized parameter to the parameter space of this domain\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(this.x.elevate(t.x), this.y.elevate(t.y), this.z.elevate(t.z));\r\n    }\r\n    remap(value, other = new Domain3()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let norm = this.normalize(value);\r\n        return other.elevate(norm);\r\n    }\r\n    remapAll(values, other = new Domain3()) {\r\n        // normalize a value, then elevate it to a new domain\r\n        let newValues = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(values.count);\r\n        for (let i = 0; i < values.count; i++) {\r\n            let norm = this.normalize(values.get(i));\r\n            newValues.set(i, other.elevate(norm));\r\n        }\r\n        return newValues;\r\n    }\r\n    corners(matrix) {\r\n        // render the extends of this boundary / domain\r\n        let dim = 3;\r\n        let corners = 2 ^ dim;\r\n        let data = [];\r\n        for (let x of [this.x.t0, this.x.t1]) {\r\n            for (let y of [this.y.t0, this.y.t1]) {\r\n                for (let z of [this.z.t0, this.z.t1]) {\r\n                    data.push(matrix.multiplyVector(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z)));\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    /**\r\n     * generate `countX * countY * countZ` vector3's evenly distributed along the domain.\r\n     */\r\n    spawn(countX, countY, countZ) {\r\n        // iterate over this Domain 'count' number of times\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(countX * countY);\r\n        let i = 0;\r\n        // this looks dumb, i have tried other methods, this is still the fastest...\r\n        let zRange = this.z.spawn(countZ);\r\n        let yRange = this.y.spawn(countY);\r\n        let xRange = this.x.spawn(countX);\r\n        for (const z of zRange) {\r\n            for (const y of yRange) {\r\n                for (const x of xRange) {\r\n                    result.setXYZ(i, x, y, z);\r\n                    i++;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Generate a bunch of random points\r\n     */\r\n    populate(count, rng) {\r\n        let result = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < result.count; i++) {\r\n            result.set(i, this.elevate(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.fromRandom(rng)));\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction benchmark() {\r\n    // GENERAL BENCHMARKING CONCLUSIONS\r\n    // use typedarrays\r\n    // do not use yield. Its just not how javascript likes to function, often 100x slower\r\n    let sw = _system_stopwatch__WEBPACK_IMPORTED_MODULE_1__.Stopwatch.new();\r\n    let domain = Domain2.fromRadius(5);\r\n    sw.log(\"init\");\r\n    let count = 1000;\r\n    domain.spawn(count, count);\r\n    sw.log(\"spawn1\");\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/domain.ts?");

/***/ }),

/***/ "../engine/src/math/math.ts":
/*!**********************************!*\
  !*** ../engine/src/math/math.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeonMath\": () => (/* binding */ GeonMath)\n/* harmony export */ });\n// purpose: simple operations with only numbers\r\nclass GeonMath {\r\n    // make sure 'value' is more than 'lower', and less than 'upper'\r\n    static clamp(value, lower, upper) {\r\n        return Math.min(Math.max(value, lower), upper);\r\n    }\r\n    static smooth(t) {\r\n        // Fade function as defined by Ken Perlin.  This eases coordinate values\r\n        // so that they will ease towards integral values.  This ends up smoothing\r\n        // the final output.\r\n        return t * t * t * (t * (t * 6 - 15) + 10); // 6t^5 - 15t^4 + 10t^3\r\n    }\r\n    /**\r\n     *  get `value` as a fraction between `min` and `max`.\r\n     */\r\n    static fraction(value, min, max) {\r\n        return (value - min) / (max - min);\r\n    }\r\n    static lerp(a, b, x) {\r\n        return a + x * (b - a);\r\n    }\r\n    static radToDeg(r) {\r\n        return (r * 180) / Math.PI;\r\n    }\r\n    static degToRad(d) {\r\n        return (d * Math.PI) / 180;\r\n    }\r\n    static factorial(n) {\r\n        let prod = 1;\r\n        for (let i = 1; i < n + 1; i++) {\r\n            prod *= i;\r\n        }\r\n        return prod;\r\n    }\r\n    static stack(n) {\r\n        let prod = 0;\r\n        for (let i = 1; i < n + 1; i++) {\r\n            prod += i;\r\n        }\r\n        return prod;\r\n    }\r\n    // on the edge of math & utility...\r\n    static sample(values, t) {\r\n        let count = values.length - 1;\r\n        let p = t * count;\r\n        let idxA = Math.floor(p);\r\n        let idxB = Math.ceil(p);\r\n        return this.lerp(values[idxA], values[idxB], p - idxA);\r\n    }\r\n    static sampleSmooth(data, t) {\r\n        let count = data.length - 1;\r\n        let p = t * count;\r\n        let idxA = Math.floor(p);\r\n        let idxB = Math.ceil(p);\r\n        return this.lerp(data[idxA], data[idxB], this.smooth(p - idxA));\r\n    }\r\n    /**\r\n     * binary search to figure out between which two values this sample is\r\n     * assumes data is sorted!!\r\n     */\r\n    static between(data, sample) {\r\n        let start = 0;\r\n        let end = data.length - 1;\r\n        for (let _ = 0; _ < data.length; _++) {\r\n            if (start > end) {\r\n                // its between these values\r\n                console.log(\"start\", start, \"end\", end);\r\n                let temp = end;\r\n                end = start;\r\n                start = temp;\r\n                break;\r\n            }\r\n            let mid = Math.round((end - start) / 2);\r\n            if (sample < data[mid]) {\r\n                // lower | on the left\r\n                start = mid;\r\n            }\r\n            else if (sample > data[mid]) {\r\n                // higher | on the right\r\n                end = mid;\r\n            }\r\n            else {\r\n                // same!\r\n                start = mid;\r\n                end = mid;\r\n                break;\r\n            }\r\n        }\r\n        return [start, end];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/math.ts?");

/***/ }),

/***/ "../engine/src/math/matrix.ts":
/*!************************************!*\
  !*** ../engine/src/math/matrix.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Matrix3\": () => (/* binding */ Matrix3),\n/* harmony export */   \"Matrix4\": () => (/* binding */ Matrix4)\n/* harmony export */ });\n/* harmony import */ var _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/float-matrix */ \"../engine/src/data/float-matrix.ts\");\n/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vector */ \"../engine/src/math/vector.ts\");\n// matrix\r\n// author: Jos Feenstra\r\n// TODO: FIX MATRIX4 !!!\r\n// NOTE:\r\n\r\n\r\n// 3x3 matrix of floats used for 2d math\r\n// inspired by Gregg Tavares.\r\nclass Matrix3 extends _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix {\r\n    constructor(data = []) {\r\n        super(3, 3, data);\r\n    }\r\n    static newIdentity() {\r\n        return new Matrix3([1, 0, 0, 0, 1, 0, 0, 0, 1]);\r\n    }\r\n    static newProjection(width, height) {\r\n        // Note: This matrix flips the Y axis so 0 is at the top.\r\n        return new Matrix3([2 / width, 0, 0, 0, -2 / height, 0, -1, 1, 1]);\r\n    }\r\n    static newTranslation(dx, dy) {\r\n        return new Matrix3([1, 0, 0, 0, 1, 0, dx, dy, 1]);\r\n    }\r\n    // angle in radians\r\n    static newRotation(r) {\r\n        var c = Math.cos(r);\r\n        var s = Math.sin(r);\r\n        return new Matrix3([c, -s, 0, s, c, 0, 0, 0, 1]);\r\n    }\r\n    static newScalar(sx, sy) {\r\n        return new Matrix3([sx, 0, 0,\r\n            0, sy, 0,\r\n            0, 0, 1]);\r\n    }\r\n    toMat4() {\r\n        let d = this.data;\r\n        return new Matrix4([\r\n            d[0],\r\n            d[1],\r\n            0,\r\n            d[2],\r\n            d[3],\r\n            d[4],\r\n            0,\r\n            d[5],\r\n            0,\r\n            0,\r\n            1,\r\n            0,\r\n            d[6],\r\n            d[7],\r\n            0,\r\n            d[8],\r\n        ]);\r\n    }\r\n    project(width, height) {\r\n        return this.multiply(Matrix3.newProjection(width, height));\r\n    }\r\n    translateN(dx, dy) {\r\n        return this.multiply(Matrix3.newTranslation(dx, dy));\r\n    }\r\n    translate(v) {\r\n        return this.multiply(Matrix3.newTranslation(v.x, v.y));\r\n    }\r\n    rotate(r) {\r\n        return this.multiply(Matrix3.newRotation(r));\r\n    }\r\n    scale(sx, sy) {\r\n        return this.multiply(Matrix3.newScalar(sx, sy));\r\n    }\r\n    // multiply two m3's\r\n    multiply(other) {\r\n        let a = this.data;\r\n        let b = other.data;\r\n        var a00 = a[0 * 3 + 0];\r\n        var a01 = a[0 * 3 + 1];\r\n        var a02 = a[0 * 3 + 2];\r\n        var a10 = a[1 * 3 + 0];\r\n        var a11 = a[1 * 3 + 1];\r\n        var a12 = a[1 * 3 + 2];\r\n        var a20 = a[2 * 3 + 0];\r\n        var a21 = a[2 * 3 + 1];\r\n        var a22 = a[2 * 3 + 2];\r\n        var b00 = b[0 * 3 + 0];\r\n        var b01 = b[0 * 3 + 1];\r\n        var b02 = b[0 * 3 + 2];\r\n        var b10 = b[1 * 3 + 0];\r\n        var b11 = b[1 * 3 + 1];\r\n        var b12 = b[1 * 3 + 2];\r\n        var b20 = b[2 * 3 + 0];\r\n        var b21 = b[2 * 3 + 1];\r\n        var b22 = b[2 * 3 + 2];\r\n        return new Matrix3([\r\n            b00 * a00 + b01 * a10 + b02 * a20,\r\n            b00 * a01 + b01 * a11 + b02 * a21,\r\n            b00 * a02 + b01 * a12 + b02 * a22,\r\n            b10 * a00 + b11 * a10 + b12 * a20,\r\n            b10 * a01 + b11 * a11 + b12 * a21,\r\n            b10 * a02 + b11 * a12 + b12 * a22,\r\n            b20 * a00 + b21 * a10 + b22 * a20,\r\n            b20 * a01 + b21 * a11 + b22 * a21,\r\n            b20 * a02 + b21 * a12 + b22 * a22,\r\n        ]);\r\n    }\r\n    // transform a vector. RECYCLE IT\r\n    transformVector(v) {\r\n        let m = this.data;\r\n        let v0 = v.x;\r\n        let v1 = v.y;\r\n        let d = v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + m[2 * 3 + 2];\r\n        v.x = (v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + m[2 * 3 + 0]) / d;\r\n        v.y = (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + m[2 * 3 + 1]) / d;\r\n        return v;\r\n    }\r\n    // return the inverse of this matrix\r\n    inverse() {\r\n        // ive got no idea what is happening here,\r\n        // but apparantly, this is how you inverse a 3x3 matrix.\r\n        let m = this.data;\r\n        var t00 = m[1 * 3 + 1] * m[2 * 3 + 2] - m[1 * 3 + 2] * m[2 * 3 + 1];\r\n        var t10 = m[0 * 3 + 1] * m[2 * 3 + 2] - m[0 * 3 + 2] * m[2 * 3 + 1];\r\n        var t20 = m[0 * 3 + 1] * m[1 * 3 + 2] - m[0 * 3 + 2] * m[1 * 3 + 1];\r\n        // discriminant\r\n        var d = 1.0 / (m[0 * 3 + 0] * t00 - m[1 * 3 + 0] * t10 + m[2 * 3 + 0] * t20);\r\n        this.setData([\r\n            d * t00,\r\n            -d * t10,\r\n            d * t20,\r\n            -d * (m[1 * 3 + 0] * m[2 * 3 + 2] - m[1 * 3 + 2] * m[2 * 3 + 0]),\r\n            d * (m[0 * 3 + 0] * m[2 * 3 + 2] - m[0 * 3 + 2] * m[2 * 3 + 0]),\r\n            -d * (m[0 * 3 + 0] * m[1 * 3 + 2] - m[0 * 3 + 2] * m[1 * 3 + 0]),\r\n            d * (m[1 * 3 + 0] * m[2 * 3 + 1] - m[1 * 3 + 1] * m[2 * 3 + 0]),\r\n            -d * (m[0 * 3 + 0] * m[2 * 3 + 1] - m[0 * 3 + 1] * m[2 * 3 + 0]),\r\n            d * (m[0 * 3 + 0] * m[1 * 3 + 1] - m[0 * 3 + 1] * m[1 * 3 + 0]),\r\n        ]);\r\n        return this;\r\n    }\r\n}\r\n// 4x4 matrix of floats used for 3d math\r\n// inspired by Gregg Tavares.\r\nclass Matrix4 extends _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix {\r\n    constructor(data = []) {\r\n        super(4, 4, data);\r\n    }\r\n    static new(data) {\r\n        return new Matrix4(data);\r\n    }\r\n    static newIdentity() {\r\n        return new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newCopy(other) {\r\n        let result = new Matrix4();\r\n        for (let i = 0; i < 16; i++) {\r\n            result.data[i] = other.data[i];\r\n        }\r\n        return result;\r\n    }\r\n    clone() {\r\n        return Matrix4.newCopy(this);\r\n    }\r\n    multiplied(other) {\r\n        // NOTE: i swapped a and b, this makes more sense to me, but i could be wrong about it...\r\n        const a = other.data;\r\n        const b = this.data;\r\n        var b00 = b[0 * 4 + 0];\r\n        var b01 = b[0 * 4 + 1];\r\n        var b02 = b[0 * 4 + 2];\r\n        var b03 = b[0 * 4 + 3];\r\n        var b10 = b[1 * 4 + 0];\r\n        var b11 = b[1 * 4 + 1];\r\n        var b12 = b[1 * 4 + 2];\r\n        var b13 = b[1 * 4 + 3];\r\n        var b20 = b[2 * 4 + 0];\r\n        var b21 = b[2 * 4 + 1];\r\n        var b22 = b[2 * 4 + 2];\r\n        var b23 = b[2 * 4 + 3];\r\n        var b30 = b[3 * 4 + 0];\r\n        var b31 = b[3 * 4 + 1];\r\n        var b32 = b[3 * 4 + 2];\r\n        var b33 = b[3 * 4 + 3];\r\n        var a00 = a[0 * 4 + 0];\r\n        var a01 = a[0 * 4 + 1];\r\n        var a02 = a[0 * 4 + 2];\r\n        var a03 = a[0 * 4 + 3];\r\n        var a10 = a[1 * 4 + 0];\r\n        var a11 = a[1 * 4 + 1];\r\n        var a12 = a[1 * 4 + 2];\r\n        var a13 = a[1 * 4 + 3];\r\n        var a20 = a[2 * 4 + 0];\r\n        var a21 = a[2 * 4 + 1];\r\n        var a22 = a[2 * 4 + 2];\r\n        var a23 = a[2 * 4 + 3];\r\n        var a30 = a[3 * 4 + 0];\r\n        var a31 = a[3 * 4 + 1];\r\n        var a32 = a[3 * 4 + 2];\r\n        var a33 = a[3 * 4 + 3];\r\n        return new Matrix4([\r\n            b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\r\n            b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\r\n            b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\r\n            b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\r\n            b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\r\n            b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\r\n            b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\r\n            b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\r\n            b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\r\n            b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\r\n            b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\r\n            b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\r\n            b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\r\n            b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\r\n            b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\r\n            b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\r\n        ]);\r\n    }\r\n    multiply(other) {\r\n        this.data = this.multiplied(other).data;\r\n        return this;\r\n    }\r\n    transpose() {\r\n        let matrix = new Matrix4();\r\n        let res = matrix.data;\r\n        let old = this.data;\r\n        res[0] = old[0];\r\n        res[1] = old[4];\r\n        res[2] = old[8];\r\n        res[3] = old[12];\r\n        res[4] = old[1];\r\n        res[5] = old[5];\r\n        res[6] = old[9];\r\n        res[7] = old[13];\r\n        res[8] = old[2];\r\n        res[9] = old[6];\r\n        res[10] = old[10];\r\n        res[11] = old[14];\r\n        res[12] = old[3];\r\n        res[13] = old[7];\r\n        res[14] = old[11];\r\n        res[15] = old[15];\r\n        return matrix;\r\n    }\r\n    static newLookAt(cameraPosition, target, up) {\r\n        let matrix = new Matrix4();\r\n        let data = matrix.data;\r\n        let zAxis = cameraPosition.clone().sub(target).normalize();\r\n        let xAxis = up.clone().cross(up).normalize();\r\n        let yAxis = zAxis.clone().cross(xAxis).normalize();\r\n        data[0] = xAxis.x;\r\n        data[1] = xAxis.y;\r\n        data[2] = xAxis.z;\r\n        data[3] = 0;\r\n        data[4] = yAxis.x;\r\n        data[5] = yAxis.y;\r\n        data[6] = yAxis.z;\r\n        data[7] = 0;\r\n        data[8] = zAxis.x;\r\n        data[9] = zAxis.y;\r\n        data[10] = zAxis.z;\r\n        data[11] = 0;\r\n        data[12] = cameraPosition.x;\r\n        data[13] = cameraPosition.y;\r\n        data[14] = cameraPosition.z;\r\n        data[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 perspective transformation matrix given the angular height\r\n     * of the frustum, the aspect ratio, and the near and far clipping planes.  The\r\n     * arguments define a frustum extending in the negative z direction.  The given\r\n     * angle is the vertical angle of the frustum, and the horizontal angle is\r\n     * determined to produce the given aspect ratio.  The arguments near and far are\r\n     * the distances to the near and far clipping planes.  Note that near and far\r\n     * are not z coordinates, but rather they are distances along the negative\r\n     * z-axis.  The matrix generated sends the viewing frustum to the unit box.\r\n     * We assume a unit box extending from -1 to 1 in the x and y dimensions and\r\n     * from -1 to 1 in the z dimension.\r\n     * @param {number} fieldOfViewInRadians field of view in y axis.\r\n     * @param {number} aspect aspect of viewport (width / height)\r\n     * @param {number} near near Z clipping plane\r\n     * @param {number} far far Z clipping plane\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newPerspective(fov, aspect, near, far) {\r\n        let matrix = new Matrix4();\r\n        let data = matrix.data;\r\n        var f = Math.tan(Math.PI * 0.5 - 0.5 * fov);\r\n        var rangeInv = 1.0 / (near - far);\r\n        data[0] = f / aspect;\r\n        data[1] = 0;\r\n        data[2] = 0;\r\n        data[3] = 0;\r\n        data[4] = 0;\r\n        data[5] = f;\r\n        data[6] = 0;\r\n        data[7] = 0;\r\n        data[8] = 0;\r\n        data[9] = 0;\r\n        data[10] = (near + far) * rangeInv;\r\n        data[11] = -1;\r\n        data[12] = 0;\r\n        data[13] = 0;\r\n        data[14] = near * far * rangeInv * 2;\r\n        data[15] = 0;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 orthographic projection matrix given the coordinates of the\r\n     * planes defining the axis-aligned, box-shaped viewing volume.  The matrix\r\n     * generated sends that box to the unit box.  Note that although left and right\r\n     * are x coordinates and bottom and top are y coordinates, near and far\r\n     * are not z coordinates, but rather they are distances along the negative\r\n     * z-axis.  We assume a unit box extending from -1 to 1 in the x and y\r\n     * dimensions and from -1 to 1 in the z dimension.\r\n     * @param {number} left The x coordinate of the left plane of the box.\r\n     * @param {number} right The x coordinate of the right plane of the box.\r\n     * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n     * @param {number} top The y coordinate of the right plane of the box.\r\n     * @param {number} near The negative z coordinate of the near plane of the box.\r\n     * @param {number} far The negative z coordinate of the far plane of the box.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newOrthographic(left, right, bottom, top, near, far) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        dst[0] = 2 / (right - left);\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = 2 / (top - bottom);\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = 0;\r\n        dst[9] = 0;\r\n        dst[10] = 2 / (near - far);\r\n        dst[11] = 0;\r\n        dst[12] = (left + right) / (left - right);\r\n        dst[13] = (bottom + top) / (bottom - top);\r\n        dst[14] = (near + far) / (near - far);\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Computes a 4-by-4 perspective transformation matrix given the left, right,\r\n     * top, bottom, near and far clipping planes. The arguments define a frustum\r\n     * extending in the negative z direction. The arguments near and far are the\r\n     * distances to the near and far clipping planes. Note that near and far are not\r\n     * z coordinates, but rather they are distances along the negative z-axis. The\r\n     * matrix generated sends the viewing frustum to the unit box. We assume a unit\r\n     * box extending from -1 to 1 in the x and y dimensions and from -1 to 1 in the z\r\n     * dimension.\r\n     * @param {number} left The x coordinate of the left plane of the box.\r\n     * @param {number} right The x coordinate of the right plane of the box.\r\n     * @param {number} bottom The y coordinate of the bottom plane of the box.\r\n     * @param {number} top The y coordinate of the right plane of the box.\r\n     * @param {number} near The negative z coordinate of the near plane of the box.\r\n     * @param {number} far The negative z coordinate of the far plane of the box.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newFrustum(left, right, bottom, top, near, far) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        var dx = right - left;\r\n        var dy = top - bottom;\r\n        var dz = far - near;\r\n        dst[0] = (2 * near) / dx;\r\n        dst[1] = 0;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = 0;\r\n        dst[5] = (2 * near) / dy;\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = (left + right) / dx;\r\n        dst[9] = (top + bottom) / dy;\r\n        dst[10] = -(far + near) / dz;\r\n        dst[11] = -1;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = (-2 * near * far) / dz;\r\n        dst[15] = 0;\r\n        return matrix;\r\n    }\r\n    static newTranslation(tx, ty, tz) {\r\n        return new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1]);\r\n    }\r\n    static newTranslate(v) {\r\n        return new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v.x, v.y, v.z, 1]);\r\n    }\r\n    static newXRotation(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        return new Matrix4([1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newYRotation(angleInRadians) {\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        return new Matrix4([c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1]);\r\n    }\r\n    static newZRotation(angleInRadians) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        dst[0] = c;\r\n        dst[1] = s;\r\n        dst[2] = 0;\r\n        dst[3] = 0;\r\n        dst[4] = -s;\r\n        dst[5] = c;\r\n        dst[6] = 0;\r\n        dst[7] = 0;\r\n        dst[8] = 0;\r\n        dst[9] = 0;\r\n        dst[10] = 1;\r\n        dst[11] = 0;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = 0;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Makes an rotation matrix around an arbitrary axis\r\n     * @param {Vector3} axis axis to rotate around\r\n     * @param {number} angleInRadians amount to rotate\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    static newAxisRotation(axis, angleInRadians) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let x = axis.x;\r\n        let y = axis.y;\r\n        let z = axis.z;\r\n        let n = Math.sqrt(x * x + y * y + z * z);\r\n        x /= n;\r\n        y /= n;\r\n        z /= n;\r\n        let xx = x * x;\r\n        let yy = y * y;\r\n        let zz = z * z;\r\n        let c = Math.cos(angleInRadians);\r\n        let s = Math.sin(angleInRadians);\r\n        let oneMinusCosine = 1 - c;\r\n        dst[0] = xx + (1 - xx) * c;\r\n        dst[1] = x * y * oneMinusCosine + z * s;\r\n        dst[2] = x * z * oneMinusCosine - y * s;\r\n        dst[3] = 0;\r\n        dst[4] = x * y * oneMinusCosine - z * s;\r\n        dst[5] = yy + (1 - yy) * c;\r\n        dst[6] = y * z * oneMinusCosine + x * s;\r\n        dst[7] = 0;\r\n        dst[8] = x * z * oneMinusCosine + y * s;\r\n        dst[9] = y * z * oneMinusCosine - x * s;\r\n        dst[10] = zz + (1 - zz) * c;\r\n        dst[11] = 0;\r\n        dst[12] = 0;\r\n        dst[13] = 0;\r\n        dst[14] = 0;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    /**\r\n     * Multiply by an axis rotation matrix\r\n     * @param {Matrix4} m matrix to multiply\r\n     * @param {Vector3} axis axis to rotate around\r\n     * @param {number} angleInRadians amount to rotate\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     * @memberOf module:webgl-3d-math\r\n     */\r\n    axisRotate(axis, angleInRadians) {\r\n        // This is the optimized version of\r\n        // return multiply(m, axisRotation(axis, angleInRadians), dst);\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        var x = axis.x;\r\n        var y = axis.y;\r\n        var z = axis.z;\r\n        var n = Math.sqrt(x * x + y * y + z * z);\r\n        x /= n;\r\n        y /= n;\r\n        z /= n;\r\n        var xx = x * x;\r\n        var yy = y * y;\r\n        var zz = z * z;\r\n        var c = Math.cos(angleInRadians);\r\n        var s = Math.sin(angleInRadians);\r\n        var oneMinusCosine = 1 - c;\r\n        var r00 = xx + (1 - xx) * c;\r\n        var r01 = x * y * oneMinusCosine + z * s;\r\n        var r02 = x * z * oneMinusCosine - y * s;\r\n        var r10 = x * y * oneMinusCosine - z * s;\r\n        var r11 = yy + (1 - yy) * c;\r\n        var r12 = y * z * oneMinusCosine + x * s;\r\n        var r20 = x * z * oneMinusCosine + y * s;\r\n        var r21 = y * z * oneMinusCosine - x * s;\r\n        var r22 = zz + (1 - zz) * c;\r\n        var m00 = m[0];\r\n        var m01 = m[1];\r\n        var m02 = m[2];\r\n        var m03 = m[3];\r\n        var m10 = m[4];\r\n        var m11 = m[5];\r\n        var m12 = m[6];\r\n        var m13 = m[7];\r\n        var m20 = m[8];\r\n        var m21 = m[9];\r\n        var m22 = m[10];\r\n        var m23 = m[11];\r\n        dst[0] = r00 * m00 + r01 * m10 + r02 * m20;\r\n        dst[1] = r00 * m01 + r01 * m11 + r02 * m21;\r\n        dst[2] = r00 * m02 + r01 * m12 + r02 * m22;\r\n        dst[3] = r00 * m03 + r01 * m13 + r02 * m23;\r\n        dst[4] = r10 * m00 + r11 * m10 + r12 * m20;\r\n        dst[5] = r10 * m01 + r11 * m11 + r12 * m21;\r\n        dst[6] = r10 * m02 + r11 * m12 + r12 * m22;\r\n        dst[7] = r10 * m03 + r11 * m13 + r12 * m23;\r\n        dst[8] = r20 * m00 + r21 * m10 + r22 * m20;\r\n        dst[9] = r20 * m01 + r21 * m11 + r22 * m21;\r\n        dst[10] = r20 * m02 + r21 * m12 + r22 * m22;\r\n        dst[11] = r20 * m03 + r21 * m13 + r22 * m23;\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return matrix;\r\n    }\r\n    // make a scaling matrix\r\n    static newScaler(sx, sy, sz) {\r\n        return new Matrix4([sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1]);\r\n    }\r\n    /**\r\n     * Multiply by a scaling matrix\r\n     * @param {Matrix4} m matrix to multiply\r\n     * @param {number} sx x scale.\r\n     * @param {number} sy y scale.\r\n     * @param {number} sz z scale.\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     * @memberOf module:webgl-3d-math\r\n     */\r\n    scale(sx, sy, sz) {\r\n        // This is the optimized version of\r\n        // return multiply(m, scaling(sx, sy, sz), dst);\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        dst[0] = sx * m[0 * 4 + 0];\r\n        dst[1] = sx * m[0 * 4 + 1];\r\n        dst[2] = sx * m[0 * 4 + 2];\r\n        dst[3] = sx * m[0 * 4 + 3];\r\n        dst[4] = sy * m[1 * 4 + 0];\r\n        dst[5] = sy * m[1 * 4 + 1];\r\n        dst[6] = sy * m[1 * 4 + 2];\r\n        dst[7] = sy * m[1 * 4 + 3];\r\n        dst[8] = sz * m[2 * 4 + 0];\r\n        dst[9] = sz * m[2 * 4 + 1];\r\n        dst[10] = sz * m[2 * 4 + 2];\r\n        dst[11] = sz * m[2 * 4 + 3];\r\n        if (m !== dst) {\r\n            dst[12] = m[12];\r\n            dst[13] = m[13];\r\n            dst[14] = m[14];\r\n            dst[15] = m[15];\r\n        }\r\n        return matrix;\r\n    }\r\n    /**\r\n     * creates a matrix from translation, quaternion, scale\r\n     * @param {Number[]} translation [x, y, z] translation\r\n     * @param {Number[]} quaternion [x, y, z, z] quaternion rotation\r\n     * @param {Number[]} scale [x, y, z] scale\r\n     * @param {Matrix4} [dst] optional matrix to store result\r\n     * @return {Matrix4} dst or a new matrix if none provided\r\n     */\r\n    newCompose(translation, quaternion, scale) {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        const x = quaternion.x;\r\n        const y = quaternion.y;\r\n        const z = quaternion.z;\r\n        const w = quaternion.w;\r\n        const x2 = x + x;\r\n        const y2 = y + y;\r\n        const z2 = z + z;\r\n        const xx = x * x2;\r\n        const xy = x * y2;\r\n        const xz = x * z2;\r\n        const yy = y * y2;\r\n        const yz = y * z2;\r\n        const zz = z * z2;\r\n        const wx = w * x2;\r\n        const wy = w * y2;\r\n        const wz = w * z2;\r\n        const sx = scale.x;\r\n        const sy = scale.y;\r\n        const sz = scale.z;\r\n        dst[0] = (1 - (yy + zz)) * sx;\r\n        dst[1] = (xy + wz) * sx;\r\n        dst[2] = (xz - wy) * sx;\r\n        dst[3] = 0;\r\n        dst[4] = (xy - wz) * sy;\r\n        dst[5] = (1 - (xx + zz)) * sy;\r\n        dst[6] = (yz + wx) * sy;\r\n        dst[7] = 0;\r\n        dst[8] = (xz + wy) * sz;\r\n        dst[9] = (yz - wx) * sz;\r\n        dst[10] = (1 - (xx + yy)) * sz;\r\n        dst[11] = 0;\r\n        dst[12] = translation.x;\r\n        dst[13] = translation.y;\r\n        dst[14] = translation.z;\r\n        dst[15] = 1;\r\n        return matrix;\r\n    }\r\n    // quatFromRotationMatrix() {\r\n    //     // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n    //     // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n    //     const m11 = m[0];\r\n    //     const m12 = m[4];\r\n    //     const m13 = m[8];\r\n    //     const m21 = m[1];\r\n    //     const m22 = m[5];\r\n    //     const m23 = m[9];\r\n    //     const m31 = m[2];\r\n    //     const m32 = m[6];\r\n    //     const m33 = m[10];\r\n    //     const trace = m11 + m22 + m33;\r\n    //     if (trace > 0) {\r\n    //         const s = 0.5 / Math.sqrt(trace + 1);\r\n    //         dst[3] = 0.25 / s;\r\n    //         dst[0] = (m32 - m23) * s;\r\n    //         dst[1] = (m13 - m31) * s;\r\n    //         dst[2] = (m21 - m12) * s;\r\n    //     } else if (m11 > m22 && m11 > m33) {\r\n    //         const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\r\n    //         dst[3] = (m32 - m23) / s;\r\n    //         dst[0] = 0.25 * s;\r\n    //         dst[1] = (m12 + m21) / s;\r\n    //         dst[2] = (m13 + m31) / s;\r\n    //     } else if (m22 > m33) {\r\n    //         const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\r\n    //         dst[3] = (m13 - m31) / s;\r\n    //         dst[0] = (m12 + m21) / s;\r\n    //         dst[1] = 0.25 * s;\r\n    //         dst[2] = (m23 + m32) / s;\r\n    //     } else {\r\n    //         const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\r\n    //         dst[3] = (m21 - m12) / s;\r\n    //         dst[0] = (m13 + m31) / s;\r\n    //         dst[1] = (m23 + m32) / s;\r\n    //         dst[2] = 0.25 * s;\r\n    //     }\r\n    // }\r\n    // decompose(mat, translation, quaternion, scale) {\r\n    //     let sx = m4.length(mat.slice(0, 3));\r\n    //     const sy = m4.length(mat.slice(4, 7));\r\n    //     const sz = m4.length(mat.slice(8, 11));\r\n    //     // if determinate is negative, we need to invert one scale\r\n    //     const det = determinate(mat);\r\n    //     if (det < 0) {\r\n    //         sx = -sx;\r\n    //     }\r\n    //     translation[0] = mat[12];\r\n    //     translation[1] = mat[13];\r\n    //     translation[2] = mat[14];\r\n    //     // scale the rotation part\r\n    //     const matrix = m4.copy(mat);\r\n    //     const invSX = 1 / sx;\r\n    //     const invSY = 1 / sy;\r\n    //     const invSZ = 1 / sz;\r\n    //     matrix[0] *= invSX;\r\n    //     matrix[1] *= invSX;\r\n    //     matrix[2] *= invSX;\r\n    //     matrix[4] *= invSY;\r\n    //     matrix[5] *= invSY;\r\n    //     matrix[6] *= invSY;\r\n    //     matrix[8] *= invSZ;\r\n    //     matrix[9] *= invSZ;\r\n    //     matrix[10] *= invSZ;\r\n    //     quatFromRotationMatrix(matrix, quaternion);\r\n    //     scale[0] = sx;\r\n    //     scale[1] = sy;\r\n    //     scale[2] = sz;\r\n    // }\r\n    determinate() {\r\n        let m = this.data;\r\n        var m00 = m[0 * 4 + 0];\r\n        var m01 = m[0 * 4 + 1];\r\n        var m02 = m[0 * 4 + 2];\r\n        var m03 = m[0 * 4 + 3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        var tmp_0 = m22 * m33;\r\n        var tmp_1 = m32 * m23;\r\n        var tmp_2 = m12 * m33;\r\n        var tmp_3 = m32 * m13;\r\n        var tmp_4 = m12 * m23;\r\n        var tmp_5 = m22 * m13;\r\n        var tmp_6 = m02 * m33;\r\n        var tmp_7 = m32 * m03;\r\n        var tmp_8 = m02 * m23;\r\n        var tmp_9 = m22 * m03;\r\n        var tmp_10 = m02 * m13;\r\n        var tmp_11 = m12 * m03;\r\n        var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n        return 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n    }\r\n    inverse() {\r\n        let matrix = new Matrix4();\r\n        let dst = matrix.data;\r\n        let m = this.data;\r\n        var m00 = m[0 * 4 + 0];\r\n        var m01 = m[0 * 4 + 1];\r\n        var m02 = m[0 * 4 + 2];\r\n        var m03 = m[0 * 4 + 3];\r\n        var m10 = m[1 * 4 + 0];\r\n        var m11 = m[1 * 4 + 1];\r\n        var m12 = m[1 * 4 + 2];\r\n        var m13 = m[1 * 4 + 3];\r\n        var m20 = m[2 * 4 + 0];\r\n        var m21 = m[2 * 4 + 1];\r\n        var m22 = m[2 * 4 + 2];\r\n        var m23 = m[2 * 4 + 3];\r\n        var m30 = m[3 * 4 + 0];\r\n        var m31 = m[3 * 4 + 1];\r\n        var m32 = m[3 * 4 + 2];\r\n        var m33 = m[3 * 4 + 3];\r\n        var tmp_0 = m22 * m33;\r\n        var tmp_1 = m32 * m23;\r\n        var tmp_2 = m12 * m33;\r\n        var tmp_3 = m32 * m13;\r\n        var tmp_4 = m12 * m23;\r\n        var tmp_5 = m22 * m13;\r\n        var tmp_6 = m02 * m33;\r\n        var tmp_7 = m32 * m03;\r\n        var tmp_8 = m02 * m23;\r\n        var tmp_9 = m22 * m03;\r\n        var tmp_10 = m02 * m13;\r\n        var tmp_11 = m12 * m03;\r\n        var tmp_12 = m20 * m31;\r\n        var tmp_13 = m30 * m21;\r\n        var tmp_14 = m10 * m31;\r\n        var tmp_15 = m30 * m11;\r\n        var tmp_16 = m10 * m21;\r\n        var tmp_17 = m20 * m11;\r\n        var tmp_18 = m00 * m31;\r\n        var tmp_19 = m30 * m01;\r\n        var tmp_20 = m00 * m21;\r\n        var tmp_21 = m20 * m01;\r\n        var tmp_22 = m00 * m11;\r\n        var tmp_23 = m10 * m01;\r\n        var t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\r\n        var t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\r\n        var t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\r\n        var t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\r\n        var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\r\n        dst[0] = d * t0;\r\n        dst[1] = d * t1;\r\n        dst[2] = d * t2;\r\n        dst[3] = d * t3;\r\n        dst[4] =\r\n            d *\r\n                (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\r\n        dst[5] =\r\n            d *\r\n                (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\r\n        dst[6] =\r\n            d *\r\n                (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\r\n        dst[7] =\r\n            d *\r\n                (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\r\n        dst[8] =\r\n            d *\r\n                (tmp_12 * m13 +\r\n                    tmp_15 * m23 +\r\n                    tmp_16 * m33 -\r\n                    (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\r\n        dst[9] =\r\n            d *\r\n                (tmp_13 * m03 +\r\n                    tmp_18 * m23 +\r\n                    tmp_21 * m33 -\r\n                    (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\r\n        dst[10] =\r\n            d *\r\n                (tmp_14 * m03 +\r\n                    tmp_19 * m13 +\r\n                    tmp_22 * m33 -\r\n                    (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\r\n        dst[11] =\r\n            d *\r\n                (tmp_17 * m03 +\r\n                    tmp_20 * m13 +\r\n                    tmp_23 * m23 -\r\n                    (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\r\n        dst[12] =\r\n            d *\r\n                (tmp_14 * m22 +\r\n                    tmp_17 * m32 +\r\n                    tmp_13 * m12 -\r\n                    (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\r\n        dst[13] =\r\n            d *\r\n                (tmp_20 * m32 +\r\n                    tmp_12 * m02 +\r\n                    tmp_19 * m22 -\r\n                    (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\r\n        dst[14] =\r\n            d *\r\n                (tmp_18 * m12 +\r\n                    tmp_23 * m32 +\r\n                    tmp_15 * m02 -\r\n                    (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\r\n        dst[15] =\r\n            d *\r\n                (tmp_22 * m22 +\r\n                    tmp_16 * m02 +\r\n                    tmp_21 * m12 -\r\n                    (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\r\n        return matrix;\r\n    }\r\n    multiplyVector(v) {\r\n        let data = new Array(3);\r\n        for (var i = 0; i < 3; ++i) {\r\n            data[i] = 0.0;\r\n            for (var j = 0; j < 4; ++j) {\r\n                data[i] += v.item(j) * this.get(j, i);\r\n            }\r\n        }\r\n        return new _vector__WEBPACK_IMPORTED_MODULE_1__.Vector3(data[0], data[1], data[2]);\r\n    }\r\n    multipliedVectorList(vecs) {\r\n        let result = Array(vecs.length);\r\n        for (let i = 0; i < vecs.length; i++) {\r\n            result[i] = this.multiplyVector(vecs[i]);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/matrix.ts?");

/***/ }),

/***/ "../engine/src/math/polynomial.ts":
/*!****************************************!*\
  !*** ../engine/src/math/polynomial.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polynomial\": () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"../engine/src/math/math.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"../engine/src/math/util.ts\");\n// purpose: polynomial math needed for curves & surfaces\r\n// note: uses a hardcoded pascal's triangle for performance reasons\r\n// notes:   based upon the excellent explainations from Prof. C.-K. Shene: https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/\r\n\r\n\r\n\r\nclass Polynomial {\r\n    /**\r\n     *   calculate weight using the Bernstein Polynomials:\r\n     *   (n over i) t^i * (1-t)^(n - i).\r\n     *   precalculated Pascal's triangle for a bit more efficiency\r\n     * @param t parameter t\r\n     * @param i vert index\r\n     * @param n degree\r\n     * @returns\r\n     */\r\n    static bernstein(t, i, n) {\r\n        return this.getBicoef(n, i) * Math.pow(t, i) * Math.pow(1 - t, n - i);\r\n    }\r\n    /**\r\n     * CoxDeboor's recusion formula.\r\n     * Basicly bernstein, but for b-splines\r\n     * NOTE: inefficient calculation: recursive in the dumb sense\r\n     */\r\n    static coxdeboor(t, i, degree, knots) {\r\n        // console.log(\"t\", t, \"i\", i, \"degree\", degree);\r\n        // let ui = knots[i];\r\n        // let ui1 = knots[i+1];\r\n        // let uip = knots[i+degree];\r\n        // let uip1 = knots[i + degree + 1];\r\n        if (degree == 0) {\r\n            // console.log(\"range\", knots[i], \" to \", knots[i + 1]);\r\n            if (t >= knots[i] && t < knots[i + 1]) {\r\n                // console.log(\"in between!\");\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n        let denom1 = knots[i + degree] - knots[i];\r\n        let denom2 = knots[i + degree + 1] - knots[i + 1];\r\n        // if (denom1 == 0 || denom2 == 0) {\r\n        //     console.log(\"zero\");\r\n        //     return 0;\r\n        // }\r\n        let c1 = (t - knots[i]) / denom1;\r\n        let c2 = (knots[i + degree + 1] - t) / denom2;\r\n        // console.log(c1);\r\n        // console.log(c2);\r\n        return (c1 * this.coxdeboor(t, i, degree - 1, knots) +\r\n            c2 * this.coxdeboor(t, i + 1, degree - 1, knots));\r\n    }\r\n    /**\r\n     * CoxDeboor's recusion formula.\r\n     * Basicly bernstein, but for b-splines\r\n     * NOTE: this is but a sketch, this is not correct yet...\r\n     * NOTE: the result will be\r\n     */\r\n    static coxdeboorTriangle(t, i, p, knots) {\r\n        let size = knots.length;\r\n        // console.log(points.count);\r\n        // create the triangle of resulting points\r\n        let result = new Float32Array(_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let tri = _util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        // copy paste the base\r\n        let basecolumn = size - 1;\r\n        let j = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = tri(basecolumn, row);\r\n            if (knots[i] <= t || t < knots[i + 1]) {\r\n                result[idx] = 1;\r\n            }\r\n            result[idx] = 0;\r\n            j++;\r\n        }\r\n        // iterate over this triangle, starting at the base + 1\r\n        for (let col = size - 2; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = tri(col, row);\r\n                let left = result[tri(col + 1, row)];\r\n                let right = result[tri(col + 1, row + 1)];\r\n                let c1 = (t - knots[i]) / (knots[i + p] - knots[i]);\r\n                let c2 = (knots[i + p + 1] - t) / (knots[i + p + 1] - knots[i + 1]);\r\n                result[idx] = c1 * left + c2 * right;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Binomial coeficient\r\n     */\r\n    static getBicoef(n, i) {\r\n        return this._pascal[n][i];\r\n    }\r\n    /**\r\n     * Binomial coeficient\r\n     */\r\n    static calcBicoef(n, i) {\r\n        let f = _math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.factorial;\r\n        return f(n) / (f(i) * f(n - i));\r\n    }\r\n    static calcPascal(limit) {\r\n        let pascal = Array(limit);\r\n        for (let n = 0; n < limit; n++) {\r\n            pascal[n] = Array(n + 1);\r\n            for (let i = 0; i < n + 1; i++) {\r\n                pascal[n][i] = this.calcBicoef(n, i);\r\n            }\r\n        }\r\n        return pascal;\r\n    }\r\n    /**\r\n     *  This function returns the entire castejau piramid.\r\n     *  the final point is the first: verts[0].\r\n     *  Hovever, this is slower than the PointAt() method,\r\n     *  which uses bernstein polynomials\r\n     *\r\n     *  useful for:\r\n     *  Subdividing bezier curves, debugging, and splines\r\n     */\r\n    static decastejau(verts, t) {\r\n        let size = verts.count;\r\n        // console.log(points.count);\r\n        // create the triangle of resulting points\r\n        let result = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let tri = _util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        // copy paste the base\r\n        let basecolumn = size - 1;\r\n        let i = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = tri(basecolumn, row);\r\n            result.set(idx, verts.get(i));\r\n            i++;\r\n        }\r\n        // iterate over this triangle, starting at the base + 1\r\n        for (let col = size - 2; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = tri(col, row);\r\n                let p_a = result.get(tri(col + 1, row));\r\n                let p_b = result.get(tri(col + 1, row + 1));\r\n                let q = p_b.scale(t).add(p_a.scale(1 - t));\r\n                result.set(idx, q);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    // calculate the decastejau piramid based on extrapolation\r\n    static decastejauExtrapolateEnd(verts, t) {\r\n        let size = verts.count;\r\n        // create the triangle of resulting points\r\n        let triangle = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let iterTri = _util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        let i = 0;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            let idx = iterTri(col, 0);\r\n            triangle.set(idx, verts.get(i));\r\n            i++;\r\n        }\r\n        // per triangle of 3 within this triangle (hard to put into words...)\r\n        for (let col = 1; col < size; col++) {\r\n            for (let row = 1; row <= col; row++) {\r\n                let a = iterTri(col - 1, row - 1);\r\n                let b = iterTri(col, row - 1);\r\n                let c = iterTri(col, row);\r\n                // set C based upon extrapolation of B past A\r\n                let C = triangle.get(b).lerp(triangle.get(a), 1 + t);\r\n                triangle.set(c, C);\r\n            }\r\n        }\r\n        // triangle.map(v => console.log(v));\r\n        return triangle;\r\n    }\r\n    static decastejauExtrapolateStart(verts, t) {\r\n        let size = verts.count;\r\n        // console.log(points.count);\r\n        // create the triangle of resulting points\r\n        let result = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(size));\r\n        // triangle iteration is complex :)\r\n        let tri = _util__WEBPACK_IMPORTED_MODULE_2__.Util.iterateTriangle;\r\n        // copy paste the base\r\n        let basecolumn = size - 1;\r\n        let i = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = tri(basecolumn, row);\r\n            result.set(idx, verts.get(i));\r\n            i++;\r\n        }\r\n        // iterate over this triangle, starting at the base + 1\r\n        for (let col = size - 2; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = tri(col, row);\r\n                let p_a = result.get(tri(col + 1, row));\r\n                let p_b = result.get(tri(col + 1, row + 1));\r\n                let q = p_b.scale(t).add(p_a.scale(1 - t));\r\n                result.set(idx, q);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n// pascals's triangle. Hardcoded for performance\r\nPolynomial.MAX_DEGREE = 15;\r\nPolynomial._pascal = Polynomial.calcPascal(Polynomial.MAX_DEGREE);\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/polynomial.ts?");

/***/ }),

/***/ "../engine/src/math/quaternion.ts":
/*!****************************************!*\
  !*** ../engine/src/math/quaternion.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Quaternion\": () => (/* binding */ Quaternion)\n/* harmony export */ });\n// author: Jos Feenstra\r\n// purpose: Quaternion to be used for rotation\r\nclass Quaternion {\r\n    constructor(x, y, z, w) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        this.w = w;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/quaternion.ts?");

/***/ }),

/***/ "../engine/src/math/random.ts":
/*!************************************!*\
  !*** ../engine/src/math/random.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Random\": () => (/* binding */ Random),\n/* harmony export */   \"createGUID\": () => (/* binding */ createGUID),\n/* harmony export */   \"createRandomGUID\": () => (/* binding */ createRandomGUID)\n/* harmony export */ });\n//\r\n// note: thank you, stackoverflow!\r\n// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript\r\n/**\r\n * Pseudo random number generator. based on simple fast counter (sfc32)\r\n */\r\nclass Random {\r\n    constructor(a, b, c, d) {\r\n        this.a = a;\r\n        this.b = b;\r\n        this.c = c;\r\n        this.d = d;\r\n    }\r\n    static new(a, b, c, d) {\r\n        return new Random(a, b, c, d);\r\n    }\r\n    static randomSeed() {\r\n        return Math.random() * 393847477636;\r\n    }\r\n    static fromSeed(n) {\r\n        var seed = n ^ 0xdeadbeef; // 32-bit seed with optional XOR value\r\n        // Pad seed with Phi, Pi and E.\r\n        // https://en.wikipedia.org/wiki/Nothing-up-my-sleeve_number\r\n        var rand = Random.new(0x9e3779b9, 0x243f6a88, 0xb7e15162, seed);\r\n        for (var i = 0; i < 15; i++)\r\n            rand.get();\r\n        return rand;\r\n    }\r\n    static fromRandom() {\r\n        // stacking random for maximum randomness i guess...\r\n        return this.fromSeed(Math.random() * 103948857);\r\n    }\r\n    static fromHash(seed) {\r\n        var seeder = xmur3(seed);\r\n        return this.new(seeder(), seeder(), seeder(), seeder());\r\n    }\r\n    get() {\r\n        // sfc32\r\n        this.a >>>= 0;\r\n        this.b >>>= 0;\r\n        this.c >>>= 0;\r\n        this.d >>>= 0;\r\n        let t = (this.a + this.b) | 0;\r\n        this.a = this.b ^ (this.b >>> 9);\r\n        this.b = (this.c + (this.c << 3)) | 0;\r\n        this.c = (this.c << 21) | (this.c >>> 11);\r\n        this.d = (this.d + 1) | 0;\r\n        t = (t + this.d) | 0;\r\n        this.c = (this.c + t) | 0;\r\n        return (t >>> 0) / 4294967296;\r\n    }\r\n}\r\n// not using this right now, but could be fun\r\nfunction mulberry32(a) {\r\n    return function () {\r\n        var t = (a += 0x6d2b79f5);\r\n        t = Math.imul(t ^ (t >>> 15), t | 1);\r\n        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\r\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\r\n    };\r\n}\r\nfunction xmur3(str) {\r\n    for (var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)\r\n        (h = Math.imul(h ^ str.charCodeAt(i), 3432918353)), (h = (h << 13) | (h >>> 19));\r\n    return function () {\r\n        h = Math.imul(h ^ (h >>> 16), 2246822507);\r\n        h = Math.imul(h ^ (h >>> 13), 3266489909);\r\n        return (h ^= h >>> 16) >>> 0;\r\n    };\r\n}\r\n/**\r\n * https://www.tutorialspoint.com/how-to-create-guid-uuid-in-javascript\r\n * @returns guid\r\n */\r\nfunction createGUID(rng) {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        var r = rng.get() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\r\n        return v.toString(16);\r\n    });\r\n}\r\n/**\r\n * https://www.tutorialspoint.com/how-to-create-guid-uuid-in-javascript\r\n * @returns guid\r\n */\r\nfunction createRandomGUID() {\r\n    let rng = Random.fromRandom();\r\n    return createGUID(rng);\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/random.ts?");

/***/ }),

/***/ "../engine/src/math/ray.ts":
/*!*********************************!*\
  !*** ../engine/src/math/ray.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ray\": () => (/* binding */ Ray)\n/* harmony export */ });\n/* harmony import */ var _mesh_multi_line__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mesh/multi-line */ \"../engine/src/mesh/multi-line.ts\");\n// author:  Jos Feenstra\r\n// purpose: infinite Ray used for projection and similar actions\r\n// notes:   found some nice examples at https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld004.htm\r\n\r\nclass Ray {\r\n    // i do this to force intent : from points, or from normal. Both vector3, so otherwise confusing\r\n    constructor(origin, normal) {\r\n        this.origin = origin;\r\n        this.normal = normal.normalize();\r\n    }\r\n    static fromNormal(origin, normal) {\r\n        return new Ray(origin, normal);\r\n    }\r\n    static fromPoints(origin, through) {\r\n        return new Ray(origin, through.subbed(origin).normalize());\r\n    }\r\n    at(t) {\r\n        return this.origin.added(this.normal.scaled(t));\r\n    }\r\n    xPlane(plane) {\r\n        // ray : pt = rOrigin + t * rNormal\r\n        // plane : a, b, c, d -> pNormal(a, b, c) , d\r\n        // plane : P . N + d = 0;\r\n        // substitute for p:\r\n        // t = -(rOrigin . N + d) / (V . N)\r\n        let ray = this; // to be clear\r\n        return -(ray.origin.dot(plane.normal) + plane.d) / ray.normal.dot(plane.normal);\r\n    }\r\n    toLine(length) {\r\n        let toPoint = this.at(length);\r\n        return _mesh_multi_line__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromLines([this.origin, toPoint]);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/ray.ts?");

/***/ }),

/***/ "../engine/src/math/statistics.ts":
/*!****************************************!*\
  !*** ../engine/src/math/statistics.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stat\": () => (/* binding */ Stat)\n/* harmony export */ });\n/* harmony import */ var _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/float-matrix */ \"../engine/src/data/float-matrix.ts\");\n// name:    statistics.ts\r\n// author:  Jos Feenstra\r\n// purpose: functionality and documentation of variance,\r\n//          covariance, eigen vectors, least squares, and other\r\n//          statistical operations.\r\n// source:  been a while since I did this,\r\n//          https://datascienceplus.com/understanding-the-covariance-matrix/\r\n//          https://wiki.pathmind.com/eigenvector\r\n//          used to make sure the basics are correct :).\r\n// notes:   Whats the difference between a Principal Component and an Eigen vector?\r\n//          \"Because eigenvectors trace the principal lines of force, and the axes of greatest variance and covariance illustrate where the data is most susceptible to change.\"\r\n\r\nclass Stat {\r\n    // calculate sum\r\n    static sum(x) {\r\n        let sum = 0;\r\n        for (let i = 0; i < x.length; i++) {\r\n            sum += x[i];\r\n        }\r\n        return sum;\r\n    }\r\n    // calculate average\r\n    static mean(x) {\r\n        return this.sum(x) / x.length;\r\n    }\r\n    // calculate weighted mean\r\n    static meanWeighted(values, weights) {\r\n        if (values.length != weights.length) {\r\n            throw new Error(\"values & weights need same length\");\r\n        }\r\n        var sum = 0.0;\r\n        var sumweight = 0.0;\r\n        for (let i = 0; i < values.length; i++) {\r\n            sum += values[i] * weights[i];\r\n            sumweight += weights[i];\r\n        }\r\n        return sum / sumweight;\r\n    }\r\n    // calculate variance\r\n    static variance(x) {\r\n        //^2x = (1/n1) * ni=1 (x[i]  xAvr)^2\r\n        let n = x.length;\r\n        let avr = this.mean(x);\r\n        let sum = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sum += Math.pow((x[i] - avr), 2);\r\n        }\r\n        return sum / (n - 1);\r\n    }\r\n    // calculate the standard deviation\r\n    static deviation(x) {\r\n        return Math.pow(this.variance(x), 0.5);\r\n    }\r\n    // calculate covariance\r\n    static covariance(x, y) {\r\n        if (x.length != y.length)\r\n            throw \"this is not how covariance works...\";\r\n        let n = x.length;\r\n        let xAvr = this.mean(x);\r\n        let yAvr = this.mean(y);\r\n        let sum = 0;\r\n        for (let i = 0; i < n; i++) {\r\n            sum += (x[i] - xAvr) * (y[i] - yAvr);\r\n        }\r\n        return sum / (n - 1); // losing one degree of freedom\r\n    }\r\n    // calculate variance / covariance matrix\r\n    static cov(matrix) {\r\n        let size = matrix.width;\r\n        let cov = new _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix(size, size);\r\n        let columns = Array(size);\r\n        for (let i = 0; i < size; i++) {\r\n            columns[i] = matrix.getColumn(i);\r\n        }\r\n        // matrix is symmertical, so only run through one half\r\n        for (let i = 0; i < size; i++) {\r\n            for (let j = i; j < size; j++) {\r\n                let value = this.covariance(columns[i], columns[j]);\r\n                cov.set(i, j, value);\r\n                cov.set(j, i, value);\r\n            }\r\n        }\r\n        return cov;\r\n    }\r\n    static eig(A) {\r\n        let results = this.svd(A);\r\n        return [results[1], results[2]];\r\n    }\r\n    /**\r\n     * Single Value Decomposition.\r\n     * Can be used for Eigen Value Decomposition\r\n     * from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970).\r\n     * Taken from numeric.js. not yet cleaned & optimized.\r\n     * https://en.wikipedia.org/wiki/Singular_value_decomposition\r\n     * @param  {FloatMatrix} A matrix to decompose, such as a covariance matrix\r\n     * @returns [U, , V]\r\n     * U -> during EVD, these are the eigen vectors of A transposed, if im not mistaken\r\n     *  -> during EVD, this are the eigen values\r\n     * V -> during EVD, the columns are eigen vectors\r\n     */\r\n    static svd(A) {\r\n        var prec = Math.pow(2, -52); // assumes double prec\r\n        var tolerance = 1e-64 / prec;\r\n        var itmax = 50;\r\n        var c = 0;\r\n        var i = 0;\r\n        var j = 0;\r\n        var k = 0;\r\n        var l = 0;\r\n        var u = A.clone().toNative();\r\n        var m = u.length;\r\n        var n = u[0].length;\r\n        if (m < n)\r\n            throw \"Need more rows than columns\";\r\n        var e = new Array(n);\r\n        var q = new Array(n);\r\n        for (i = 0; i < n; i++)\r\n            e[i] = q[i] = 0.0;\r\n        var v = rep([n, n], 0);\r\n        function pythag(a, b) {\r\n            a = Math.abs(a);\r\n            b = Math.abs(b);\r\n            if (a > b)\r\n                return a * Math.sqrt(1.0 + (b * b) / a / a);\r\n            else if (b == 0.0)\r\n                return a;\r\n            return b * Math.sqrt(1.0 + (a * a) / b / b);\r\n        }\r\n        //rep function, [JF] : dont know what this does exactly...\r\n        function rep(s, v, k = 0) {\r\n            let n = s[k];\r\n            let ret = Array(n);\r\n            let i;\r\n            if (k === s.length - 1) {\r\n                for (i = n - 2; i >= 0; i -= 2) {\r\n                    ret[i + 1] = v;\r\n                    ret[i] = v;\r\n                }\r\n                if (i === -1) {\r\n                    ret[0] = v;\r\n                }\r\n                return ret;\r\n            }\r\n            for (i = n - 1; i >= 0; i--) {\r\n                ret[i] = rep(s, v, k + 1);\r\n            }\r\n            return ret;\r\n        }\r\n        //Householder's reduction to bidiagonal form\r\n        var f = 0.0;\r\n        var g = 0.0;\r\n        var h = 0.0;\r\n        var x = 0.0;\r\n        var y = 0.0;\r\n        var z = 0.0;\r\n        var s = 0.0;\r\n        for (i = 0; i < n; i++) {\r\n            e[i] = g;\r\n            s = 0.0;\r\n            l = i + 1;\r\n            for (j = i; j < m; j++)\r\n                s += u[j][i] * u[j][i];\r\n            if (s <= tolerance)\r\n                g = 0.0;\r\n            else {\r\n                f = u[i][i];\r\n                g = Math.sqrt(s);\r\n                if (f >= 0.0)\r\n                    g = -g;\r\n                h = f * g - s;\r\n                u[i][i] = f - g;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = i; k < m; k++)\r\n                        s += u[k][i] * u[k][j];\r\n                    f = s / h;\r\n                    for (k = i; k < m; k++)\r\n                        u[k][j] += f * u[k][i];\r\n                }\r\n            }\r\n            q[i] = g;\r\n            s = 0.0;\r\n            for (j = l; j < n; j++)\r\n                s = s + u[i][j] * u[i][j];\r\n            if (s <= tolerance)\r\n                g = 0.0;\r\n            else {\r\n                f = u[i][i + 1];\r\n                g = Math.sqrt(s);\r\n                if (f >= 0.0)\r\n                    g = -g;\r\n                h = f * g - s;\r\n                u[i][i + 1] = f - g;\r\n                for (j = l; j < n; j++)\r\n                    e[j] = u[i][j] / h;\r\n                for (j = l; j < m; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < n; k++)\r\n                        s += u[j][k] * u[i][k];\r\n                    for (k = l; k < n; k++)\r\n                        u[j][k] += s * e[k];\r\n                }\r\n            }\r\n            y = Math.abs(q[i]) + Math.abs(e[i]);\r\n            if (y > x)\r\n                x = y;\r\n        }\r\n        // accumulation of right hand gtransformations\r\n        for (i = n - 1; i != -1; i += -1) {\r\n            if (g != 0.0) {\r\n                h = g * u[i][i + 1];\r\n                for (j = l; j < n; j++)\r\n                    v[j][i] = u[i][j] / h;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < n; k++)\r\n                        s += u[i][k] * v[k][j];\r\n                    for (k = l; k < n; k++)\r\n                        v[k][j] += s * v[k][i];\r\n                }\r\n            }\r\n            for (j = l; j < n; j++) {\r\n                v[i][j] = 0;\r\n                v[j][i] = 0;\r\n            }\r\n            v[i][i] = 1;\r\n            g = e[i];\r\n            l = i;\r\n        }\r\n        // accumulation of left hand transformations\r\n        for (i = n - 1; i != -1; i += -1) {\r\n            l = i + 1;\r\n            g = q[i];\r\n            for (j = l; j < n; j++)\r\n                u[i][j] = 0;\r\n            if (g != 0.0) {\r\n                h = u[i][i] * g;\r\n                for (j = l; j < n; j++) {\r\n                    s = 0.0;\r\n                    for (k = l; k < m; k++)\r\n                        s += u[k][i] * u[k][j];\r\n                    f = s / h;\r\n                    for (k = i; k < m; k++)\r\n                        u[k][j] += f * u[k][i];\r\n                }\r\n                for (j = i; j < m; j++)\r\n                    u[j][i] = u[j][i] / g;\r\n            }\r\n            else\r\n                for (j = i; j < m; j++)\r\n                    u[j][i] = 0;\r\n            u[i][i] += 1;\r\n        }\r\n        // diagonalization of the bidiagonal form\r\n        prec = prec * x;\r\n        for (k = n - 1; k != -1; k += -1) {\r\n            for (var iteration = 0; iteration < itmax; iteration++) {\r\n                // test f splitting\r\n                var test_convergence = false;\r\n                for (l = k; l != -1; l += -1) {\r\n                    if (Math.abs(e[l]) <= prec) {\r\n                        test_convergence = true;\r\n                        break;\r\n                    }\r\n                    if (Math.abs(q[l - 1]) <= prec)\r\n                        break;\r\n                }\r\n                if (!test_convergence) {\r\n                    // cancellation of e[l] if l>0\r\n                    c = 0.0;\r\n                    s = 1.0;\r\n                    var l1 = l - 1;\r\n                    for (i = l; i < k + 1; i++) {\r\n                        f = s * e[i];\r\n                        e[i] = c * e[i];\r\n                        if (Math.abs(f) <= prec)\r\n                            break;\r\n                        g = q[i];\r\n                        h = pythag(f, g);\r\n                        q[i] = h;\r\n                        c = g / h;\r\n                        s = -f / h;\r\n                        for (j = 0; j < m; j++) {\r\n                            y = u[j][l1];\r\n                            z = u[j][i];\r\n                            u[j][l1] = y * c + z * s;\r\n                            u[j][i] = -y * s + z * c;\r\n                        }\r\n                    }\r\n                }\r\n                // test f convergence\r\n                z = q[k];\r\n                if (l == k) {\r\n                    //convergence\r\n                    if (z < 0.0) {\r\n                        //q[k] is made non-negative\r\n                        q[k] = -z;\r\n                        for (j = 0; j < n; j++)\r\n                            v[j][k] = -v[j][k];\r\n                    }\r\n                    break; //break out of iteration loop and move on to next k value\r\n                }\r\n                if (iteration >= itmax - 1)\r\n                    throw \"Error: no convergence.\";\r\n                // shift from bottom 2x2 minor\r\n                x = q[l];\r\n                y = q[k - 1];\r\n                g = e[k - 1];\r\n                h = e[k];\r\n                f = ((y - z) * (y + z) + (g - h) * (g + h)) / (2.0 * h * y);\r\n                g = pythag(f, 1.0);\r\n                if (f < 0.0)\r\n                    f = ((x - z) * (x + z) + h * (y / (f - g) - h)) / x;\r\n                else\r\n                    f = ((x - z) * (x + z) + h * (y / (f + g) - h)) / x;\r\n                // next QR transformation\r\n                c = 1.0;\r\n                s = 1.0;\r\n                for (i = l + 1; i < k + 1; i++) {\r\n                    g = e[i];\r\n                    y = q[i];\r\n                    h = s * g;\r\n                    g = c * g;\r\n                    z = pythag(f, h);\r\n                    e[i - 1] = z;\r\n                    c = f / z;\r\n                    s = h / z;\r\n                    f = x * c + g * s;\r\n                    g = -x * s + g * c;\r\n                    h = y * s;\r\n                    y = y * c;\r\n                    for (j = 0; j < n; j++) {\r\n                        x = v[j][i - 1];\r\n                        z = v[j][i];\r\n                        v[j][i - 1] = x * c + z * s;\r\n                        v[j][i] = -x * s + z * c;\r\n                    }\r\n                    z = pythag(f, h);\r\n                    q[i - 1] = z;\r\n                    c = f / z;\r\n                    s = h / z;\r\n                    f = c * g + s * y;\r\n                    x = -s * g + c * y;\r\n                    for (j = 0; j < m; j++) {\r\n                        y = u[j][i - 1];\r\n                        z = u[j][i];\r\n                        u[j][i - 1] = y * c + z * s;\r\n                        u[j][i] = -y * s + z * c;\r\n                    }\r\n                }\r\n                e[l] = 0.0;\r\n                e[k] = f;\r\n                q[k] = x;\r\n            }\r\n        }\r\n        for (i = 0; i < q.length; i++)\r\n            if (q[i] < prec)\r\n                q[i] = 0;\r\n        //sort eigenvalues\r\n        var temp;\r\n        for (i = 0; i < n; i++) {\r\n            for (j = i - 1; j >= 0; j--) {\r\n                if (q[j] < q[i]) {\r\n                    c = q[j];\r\n                    q[j] = q[i];\r\n                    q[i] = c;\r\n                    for (k = 0; k < u.length; k++) {\r\n                        temp = u[k][i];\r\n                        u[k][i] = u[k][j];\r\n                        u[k][j] = temp;\r\n                    }\r\n                    for (k = 0; k < v.length; k++) {\r\n                        temp = v[k][i];\r\n                        v[k][i] = v[k][j];\r\n                        v[k][j] = temp;\r\n                    }\r\n                    i = j;\r\n                }\r\n            }\r\n        }\r\n        return [_data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.fromNative(u), new Float32Array(q), _data_float_matrix__WEBPACK_IMPORTED_MODULE_0__.FloatMatrix.fromNative(v)];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/statistics.ts?");

/***/ }),

/***/ "../engine/src/math/util.ts":
/*!**********************************!*\
  !*** ../engine/src/math/util.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Util\": () => (/* binding */ Util)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"../engine/src/math/math.ts\");\n/* harmony import */ var _vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vector */ \"../engine/src/math/vector.ts\");\n\r\n\r\n\r\nclass Util {\r\n    static range(n) {\r\n        let array = [];\r\n        for (let i = 0; i < n; i++) {\r\n            array.push(i);\r\n        }\r\n        return array;\r\n    }\r\n    static collect(gen) {\r\n        let arr = new Array();\r\n        for (let item of gen) {\r\n            arr.push(item);\r\n        }\r\n        return arr;\r\n    }\r\n    /** binary-seach an equation, to get the smallest x.\r\n     * from   : https://stackoverflow.com/questions/2742610/closest-point-on-a-cubic-bezier-curve/57315396#57315396\r\n     * formatted differently\r\n     * ```\r\n     * minX   : the smallest input value\r\n     * maxX   : the largest input value\r\n     *       : a function that returns a value `y` given an `x`\r\n     *       : how close in `x` the bounds must be before returning\r\n     * returns: the `x` value that produces the smallest `y`\r\n     * ```\r\n     */\r\n    static lowestScore(domain, score, tol = 1e-10) {\r\n        let half = Infinity;\r\n        // binary seach-like procedure:\r\n        while ((domain.t1 - domain.t0) > tol) {\r\n            half = (domain.t1 + domain.t0) / 2;\r\n            if (score(half - tol) < score(half + tol)) {\r\n                domain.t1 = half;\r\n            }\r\n            else {\r\n                domain.t0 = half;\r\n            }\r\n        }\r\n        return half;\r\n    }\r\n    static lowestScoreSquared(domain, score, tol = 1e-10) {\r\n        let halfX = Infinity;\r\n        let halfY = Infinity;\r\n        // binary seach-like procedure:\r\n        while ((domain.x.t1 - domain.x.t0) > tol || (domain.y.t1 - domain.y.t0) > tol) {\r\n            halfX = (domain.x.t1 + domain.x.t0) / 2;\r\n            halfY = (domain.y.t1 + domain.y.t0) / 2;\r\n            // select smallest quadrant\r\n            if (score(halfX - tol, halfY) < score(halfX + tol, halfY)) {\r\n                domain.x.t1 = halfX;\r\n            }\r\n            else {\r\n                domain.x.t0 = halfX;\r\n            }\r\n            if (score(halfX, halfY - tol) < score(halfX, halfY + tol)) {\r\n                domain.y.t1 = halfY;\r\n            }\r\n            else {\r\n                domain.y.t0 = halfY;\r\n            }\r\n        }\r\n        return _vector__WEBPACK_IMPORTED_MODULE_2__.Vector2.new(halfX, halfY);\r\n    }\r\n    //      triangle business\r\n    // ============================\r\n    /**\r\n     * ```\r\n     *         column\r\n     *      4  3  2  1  0\r\n     *   0 |>\r\n     * r 1 |>     >\r\n     * o 2 |>     >     >\r\n     * w 3 |>     >\r\n     *   4 |>\r\n     *\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            for (let row = 0; row <= col; row++) {\r\n                let idx = Util.iterateTriangle(col, row);\r\n            }\r\n        }\r\n     * ```\r\n     */\r\n    static iterateTriangle(column, row) {\r\n        return _math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(column) + row;\r\n    }\r\n    static getTriangleBase(triangle, size) {\r\n        let base = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(size);\r\n        let basecolumn = size - 1;\r\n        let i = 0;\r\n        for (let row = 0; row <= basecolumn; row++) {\r\n            let idx = Util.iterateTriangle(basecolumn, row);\r\n            base.set(i, triangle.get(idx));\r\n            i++;\r\n        }\r\n        return base;\r\n    }\r\n    static getTriangleLeft(triangle, size) {\r\n        // prepare\r\n        let left = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(size);\r\n        // the two edges of the triangle opposite to the base are the vertices we are interested in\r\n        let i = 0;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            left.set(i, triangle.get(Util.iterateTriangle(col, 0)));\r\n            i++;\r\n        }\r\n        return left;\r\n    }\r\n    static getTriangleRight(triangle, size) {\r\n        // prepare\r\n        let right = _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(size);\r\n        // the two edges of the triangle opposite to the base are the vertices we are interested in\r\n        let i = 0;\r\n        for (let col = size - 1; col > -1; col -= 1) {\r\n            right.set(i, triangle.get(Util.iterateTriangle(col, col)));\r\n            i++;\r\n        }\r\n        return right;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/util.ts?");

/***/ }),

/***/ "../engine/src/math/vector.ts":
/*!************************************!*\
  !*** ../engine/src/math/vector.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Vector3\": () => (/* binding */ Vector3),\n/* harmony export */   \"Vector2\": () => (/* binding */ Vector2)\n/* harmony export */ });\n/* harmony import */ var _const__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"../engine/src/math/math.ts\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix */ \"../engine/src/math/matrix.ts\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ \"../engine/src/math/util.ts\");\n// author: \tJos Feenstra\r\n// inspiration from Three.js\r\n// note: \trecycle the class as much as possble, building a new class is expensive,\r\n// \t\t\tespecially in javascript\r\n// todo: \tBIJ NADER INZIEN: dont go the copy route. rewrite this in a more functional way creating new classes is expensive, but we really need immutable vectors.\r\n// \t\t\tthese types of consistent vectors are only useful in niche cases, and complitate a lot of common cases.\r\n\r\n\r\n\r\n\r\nclass Vector3 {\r\n    // #region constructors\r\n    constructor(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n    }\r\n    static new(x = 0, y = 0, z = 0) {\r\n        return new Vector3(x, y, z);\r\n    }\r\n    static calculateWheelOrder(vectors, ihat, jhat) {\r\n        // console.log(\"wheel order\");\r\n        // console.log(\"hats\", ihat, jhat)\r\n        let angles = [];\r\n        vectors.forEach((v) => {\r\n            angles.push(new Vector2(v.dot(ihat), v.dot(jhat)).angle());\r\n        });\r\n        // console.log(\"angles\", angles);\r\n        let ids = _util__WEBPACK_IMPORTED_MODULE_3__.Util.range(vectors.length);\r\n        ids.sort((a, b) => {\r\n            return angles[a] - angles[b];\r\n        });\r\n        return ids;\r\n    }\r\n    static fromLerp(v1, v2, alpha) {\r\n        return new Vector3(v1.x + (v2.x - v1.x) * alpha, v1.y + (v2.y - v1.y) * alpha, v1.z + (v2.z - v1.z) * alpha);\r\n    }\r\n    static fromArray(a) {\r\n        return new Vector3(a[0], a[1], a[2]);\r\n    }\r\n    static fromRandom(rng) {\r\n        return new Vector3(rng.get(), rng.get(), rng.get());\r\n    }\r\n    static fromRandomUnit(rng) {\r\n        // NOTE : this is not perfectly random, but good enough...\r\n        return this.fromRandom(rng).sub(Vector3.new(0.5, 0.5, 0.5)).normalize();\r\n    }\r\n    static fromSphere(radius, theta, phi) {\r\n        const sinPhiRadius = Math.sin(phi) * radius;\r\n        return this.constructor(sinPhiRadius * Math.sin(theta), Math.cos(phi) * radius, sinPhiRadius * Math.cos(theta));\r\n    }\r\n    static fromCylinder(radius, theta, height) {\r\n        return this.constructor(radius * Math.sin(theta), height, radius * Math.cos(theta));\r\n    }\r\n    static fromLerpWeights(p1, p2, tP1, tP2, t) {\r\n        if (Math.abs(t - tP1) < 0.00001)\r\n            return p1;\r\n        if (Math.abs(t - tP2) < 0.00001)\r\n            return p2;\r\n        if (Math.abs(tP1 - tP2) < 0.00001)\r\n            return p1;\r\n        let mu = (t - tP1) / (tP2 - tP1);\r\n        return new Vector3(p1.x + mu * (p2.x - p1.x), p1.y + mu * (p2.y - p1.y), p1.z + mu * (p2.z - p1.z));\r\n    }\r\n    // #endregion\r\n    // #region defaults\r\n    static zero() {\r\n        return new Vector3(0, 0, 0);\r\n    }\r\n    static unitX() {\r\n        return new Vector3(1, 0, 0);\r\n    }\r\n    static unitY() {\r\n        return new Vector3(0, 1, 0);\r\n    }\r\n    static unitZ() {\r\n        return new Vector3(0, 0, 1);\r\n    }\r\n    // #endregion\r\n    // #region basics\r\n    toArray() {\r\n        return new Float32Array([this.x, this.y, this.z]);\r\n    }\r\n    set(x, y, z) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.z = z;\r\n        return this;\r\n    }\r\n    equals(v) {\r\n        return v.x === this.x && v.y === this.y && v.z === this.z;\r\n    }\r\n    toString() {\r\n        return `Vector3(${this.x}, ${this.y}, ${this.z})`;\r\n    }\r\n    toVector2() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    clone() {\r\n        return new Vector3(this.x, this.y, this.z);\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        this.z = v.z;\r\n        return this;\r\n    }\r\n    to2D() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    // #endregion\r\n    // #region math like vector2\r\n    largestValue() {\r\n        return Math.max(this.x, this.y, this.z);\r\n    }\r\n    added(v) {\r\n        return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);\r\n    }\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        this.z += v.z;\r\n        return this;\r\n    }\r\n    subbed(v) {\r\n        return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);\r\n    }\r\n    sub(v) {\r\n        (this.x -= v.x), (this.y -= v.y), (this.z -= v.z);\r\n        return this;\r\n    }\r\n    item(i) {\r\n        switch (i) {\r\n            case 0:\r\n                return this.x;\r\n            case 1:\r\n                return this.y;\r\n            case 2:\r\n                return this.z;\r\n            case 3:\r\n                return 1;\r\n            default:\r\n                throw \"nope\";\r\n        }\r\n    }\r\n    scaled(v) {\r\n        return new Vector3(this.x * v, this.y * v, this.z * v);\r\n    }\r\n    scale(v) {\r\n        this.x *= v;\r\n        this.y *= v;\r\n        this.z *= v;\r\n        return this;\r\n    }\r\n    mul(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        this.z *= v.z;\r\n        return this;\r\n    }\r\n    multiplied(v) {\r\n        return new Vector3(this.x * v.x, this.y * v.y, this.z * v.z);\r\n    }\r\n    divVector(v) {\r\n        return new Vector3(this.x / v.x, this.y / v.y, this.z / v.z);\r\n    }\r\n    divided(value) {\r\n        return new Vector3(this.x / value, this.y / value, this.z / value);\r\n    }\r\n    div(value) {\r\n        (this.x /= value), (this.y /= value), (this.z /= value);\r\n        return this;\r\n    }\r\n    minimumed(other) {\r\n        return new Vector3(Math.min(this.x, other.x), Math.min(this.y, other.y), Math.min(this.z, other.z));\r\n    }\r\n    maximumed(other) {\r\n        return new Vector3(Math.max(this.x, other.x), Math.max(this.y, other.y), Math.max(this.z, other.z));\r\n    }\r\n    clamped(min, max) {\r\n        return new Vector3(Math.max(min.x, Math.min(max.x, this.x)), Math.max(min.y, Math.min(max.y, this.y)), Math.max(min.z, Math.min(max.z, this.z)));\r\n    }\r\n    clampScalared(min, max) {\r\n        return new Vector3(_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.x, min, max), _math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.y, min, max), _math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.z, min, max));\r\n    }\r\n    clampLengthed(min, max) {\r\n        const length = this.length();\r\n        return this.div(length || 1).scale(Math.max(min, Math.min(max, length)));\r\n    }\r\n    floored() {\r\n        return new Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\r\n    }\r\n    ceiled() {\r\n        return new Vector3(Math.ceil(this.x), Math.ceil(this.y), Math.ceil(this.z));\r\n    }\r\n    rounded() {\r\n        return new Vector3(Math.round(this.x), Math.round(this.y), Math.round(this.z));\r\n    }\r\n    roundedToZero() {\r\n        return new Vector3(this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z));\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        this.z = -this.z;\r\n        return this;\r\n    }\r\n    negated() {\r\n        return new Vector3(-this.x, -this.y, -this.z);\r\n    }\r\n    angle(other, normal) {\r\n        let thisProjected = this.subbed(normal.scaled(this.dot(normal)));\r\n        let otherProjected = other.subbed(normal.scaled(other.dot(normal)));\r\n        console.log(thisProjected);\r\n        console.log(otherProjected);\r\n        return 0;\r\n    }\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    }\r\n    cross(other) {\r\n        const ax = this.x, ay = this.y, az = this.z;\r\n        const bx = other.x, by = other.y, bz = other.z;\r\n        return new Vector3(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);\r\n    }\r\n    getLengthSquared() {\r\n        return this.x * this.x + this.y * this.y + this.z * this.z;\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.getLengthSquared());\r\n    }\r\n    manhat() {\r\n        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\r\n    }\r\n    normalize() {\r\n        return this.div(this.length() || 1);\r\n    }\r\n    normalized() {\r\n        return this.divided(this.length() || 1);\r\n    }\r\n    isNormal() {\r\n        return Math.abs(this.length() - 1) < _const__WEBPACK_IMPORTED_MODULE_0__.Const.TOLERANCE;\r\n    }\r\n    disTo(v) {\r\n        return Math.sqrt(this.disToSquared(v));\r\n    }\r\n    disToSquared(v) {\r\n        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n        return dx * dx + dy * dy + dz * dz;\r\n    }\r\n    disToManhat(v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\r\n    }\r\n    setLength(length) {\r\n        return this.normalize().scale(length);\r\n    }\r\n    lerp(other, alpha) {\r\n        return Vector3.fromLerp(this, other, alpha);\r\n    }\r\n    // #endregion\r\n    // #region math specific\r\n    projectOnVector(other) {\r\n        // use dot product to project this vector on the other vector\r\n        const denominator = other.getLengthSquared();\r\n        if (denominator === 0)\r\n            return this.set(0, 0, 0);\r\n        const scalar = other.dot(this) / denominator;\r\n        return this.copy(other).scale(scalar);\r\n    }\r\n    projectedOnPlane(normal) {\r\n        // project a vector\r\n        _vector.copy(this).projectOnVector(normal);\r\n        return this.minimumed(_vector);\r\n    }\r\n    mirrored(normal) {\r\n        // mirror incident vector off plane orthogonal to normal\r\n        // normal is assumed to have unit length\r\n        return this.minimumed(_vector.copy(normal).scale(2 * this.dot(normal)));\r\n    }\r\n    rotated(axis, angle) {\r\n        let mat = _matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newAxisRotation(axis, angle);\r\n        return mat.multiplyVector(this);\r\n    }\r\n}\r\nconst _vector = new Vector3(0, 0, 0);\r\nclass Vector2 {\r\n    constructor(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n    // --- factories & other statics\r\n    static new(x = 0, y = 0) {\r\n        return new Vector2(x, y);\r\n    }\r\n    static fromArray(a) {\r\n        return new Vector2(a[0], a[1]);\r\n    }\r\n    static fromLerp(v1, v2, alpha) {\r\n        return new Vector2(v1.x + (v2.x - v1.x) * alpha, v1.y + (v2.y - v1.y) * alpha);\r\n    }\r\n    static fromRandom(rng) {\r\n        return new Vector2(rng.get(), rng.get());\r\n    }\r\n    static fromRandomAngle() {\r\n        let alpha = Math.random() * Math.PI * 2;\r\n        return new Vector2(Math.cos(alpha), Math.sin(alpha));\r\n    }\r\n    // static from2Pt(from: Vector2, to: Vector2) : Vector2 {\r\n    // \treturn new Vector2(\r\n    // \t\tfrom.x - to.x,\r\n    // \t\tfrom.y - to.y\r\n    // \t)\r\n    // }\r\n    static fromCircle(center, radius, theta) {\r\n        return new Vector2(center.x + radius * Math.sin(theta), center.y + radius * Math.cos(theta));\r\n    }\r\n    static fromCopy(other) {\r\n        return this.zero().copy(other);\r\n    }\r\n    static zero() {\r\n        return new Vector2(0, 0);\r\n    }\r\n    static NaN() {\r\n        return new Vector2(NaN, NaN);\r\n    }\r\n    static fromCircumcenter(a, b, c) {\r\n        const asum = a.squareSum();\r\n        const bsum = b.squareSum();\r\n        const csum = c.squareSum();\r\n        // sort of cross product\r\n        let d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));\r\n        // if this triangle has no circumcenter?\r\n        if (d < 0.000001)\r\n            return Vector2.NaN();\r\n        let x = (asum * (b.y - c.y) + bsum * (c.y - a.y) + csum * (a.y - b.y)) / d;\r\n        let y = (asum * (c.x - b.x) + bsum * (a.x - c.x) + csum * (b.x - a.x)) / d;\r\n        return new Vector2(x, y);\r\n    }\r\n    static getSign(a, b, c) {\r\n        // test half plane relationship\r\n        // <0 : point on first half\r\n        // 0  : points collinear\r\n        // >0 : point on second half\r\n        return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);\r\n    }\r\n    // --- basics\r\n    to3D() {\r\n        return new Vector3(this.x, this.y, 0);\r\n    }\r\n    set(x, y) {\r\n        this.x = x;\r\n        this.y = y;\r\n        return this;\r\n    }\r\n    roughlyEquals(v, tol) {\r\n        return Math.abs(this.x - v.x) < tol && Math.abs(this.y - v.y) < tol;\r\n    }\r\n    equals(v) {\r\n        return v.x === this.x && v.y === this.y;\r\n    }\r\n    toString() {\r\n        return `Vector2(${this.x}, ${this.y})`;\r\n    }\r\n    clone() {\r\n        return new Vector2(this.x, this.y);\r\n    }\r\n    copy(v) {\r\n        this.x = v.x;\r\n        this.y = v.y;\r\n        return this;\r\n    }\r\n    // --- math\r\n    add(v) {\r\n        this.x += v.x;\r\n        this.y += v.y;\r\n        return this;\r\n    }\r\n    added(v) {\r\n        return new Vector2(this.x + v.x, this.y + v.y);\r\n    }\r\n    addn(arg0, arg1) {\r\n        this.x += arg0;\r\n        this.y += arg1;\r\n        return this;\r\n    }\r\n    sub(v) {\r\n        this.x -= v.x;\r\n        this.y -= v.y;\r\n        return this;\r\n    }\r\n    subbed(v) {\r\n        return new Vector2(this.x - v.x, this.y - v.y);\r\n    }\r\n    mul(v) {\r\n        this.x *= v.x;\r\n        this.y *= v.y;\r\n        return this;\r\n    }\r\n    scale(v) {\r\n        this.x *= v;\r\n        this.y *= v;\r\n        return this;\r\n    }\r\n    scaled(v) {\r\n        return new Vector2(this.x * v, this.y * v);\r\n    }\r\n    divVector(v) {\r\n        this.x /= v.x;\r\n        this.y /= v.y;\r\n        return this;\r\n    }\r\n    div(v) {\r\n        this.x /= v;\r\n        this.y /= v;\r\n        return this;\r\n    }\r\n    dived(v) {\r\n        return new Vector2(this.x / v, this.y / v);\r\n    }\r\n    minimum(other) {\r\n        this.x = Math.min(this.x, other.x);\r\n        this.y = Math.min(this.y, other.y);\r\n        return this;\r\n    }\r\n    maximum(other) {\r\n        this.x = Math.max(this.x, other.x);\r\n        this.y = Math.max(this.y, other.y);\r\n        return this;\r\n    }\r\n    clamp(min, max) {\r\n        // assumes min < max, componentwise\r\n        this.x = Math.max(min.x, Math.min(max.x, this.x));\r\n        this.y = Math.max(min.y, Math.min(max.y, this.y));\r\n        return this;\r\n    }\r\n    clampScalar(minVal, maxVal) {\r\n        this.x = Math.max(minVal, Math.min(maxVal, this.x));\r\n        this.y = Math.max(minVal, Math.min(maxVal, this.y));\r\n        return this;\r\n    }\r\n    clampLength(min, max) {\r\n        const length = this.length();\r\n        return this.div(length || 1).scale(Math.max(min, Math.min(max, length)));\r\n    }\r\n    floor() {\r\n        this.x = Math.floor(this.x);\r\n        this.y = Math.floor(this.y);\r\n        return this;\r\n    }\r\n    ceil() {\r\n        this.x = Math.ceil(this.x);\r\n        this.y = Math.ceil(this.y);\r\n        return this;\r\n    }\r\n    round() {\r\n        this.x = Math.round(this.x);\r\n        this.y = Math.round(this.y);\r\n        return this;\r\n    }\r\n    rounded() {\r\n        return Vector2.new(Math.round(this.x), Math.round(this.y));\r\n    }\r\n    roundToZero() {\r\n        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\r\n        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\r\n        return this;\r\n    }\r\n    negate() {\r\n        this.x = -this.x;\r\n        this.y = -this.y;\r\n        return this;\r\n    }\r\n    dot(v) {\r\n        return this.x * v.x + this.y * v.y;\r\n    }\r\n    cross(v) {\r\n        return this.x * v.y - this.y * v.x; // ????\r\n    }\r\n    squareSum() {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n    length() {\r\n        return Math.sqrt(this.lengthSquared());\r\n    }\r\n    lengthSquared() {\r\n        return this.x * this.x + this.y * this.y;\r\n    }\r\n    manhat() {\r\n        return Math.abs(this.x) + Math.abs(this.y);\r\n    }\r\n    normalize() {\r\n        return this.div(this.length() || 1);\r\n    }\r\n    normalized() {\r\n        return this.dived(this.length() || 1);\r\n    }\r\n    angle() {\r\n        // computes the angle in radians with respect to the positive x-axis\r\n        const angle = Math.atan2(-this.y, -this.x) + Math.PI;\r\n        return angle;\r\n    }\r\n    disTo(v) {\r\n        return Math.sqrt(this.disToSquared(v));\r\n    }\r\n    disToSquared(v) {\r\n        let dx = this.x - v.x;\r\n        let dy = this.y - v.y;\r\n        return dx * dx + dy * dy;\r\n    }\r\n    disToManhat(v) {\r\n        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\r\n    }\r\n    setLength(length) {\r\n        return this.normalize().scale(length);\r\n    }\r\n    lerp(other, alpha) {\r\n        return new Vector2(this.x + (other.x - this.x) * alpha, this.y + (other.y - this.y) * alpha);\r\n    }\r\n    // calculate the 'triangle sign' of three points. Can be used to determine clockwise & counter clockwise\r\n    sign(b, c) {\r\n        return (this.x - c.x) * (b.y - c.y) - (b.x - c.x) * (this.y - c.y);\r\n    }\r\n    // use dot product to project this vector on the other vector\r\n    projectOnVector(other) {\r\n        const denominator = other.lengthSquared();\r\n        if (denominator === 0)\r\n            return this.set(0, 0);\r\n        const scalar = other.dot(this) / denominator;\r\n        return this.copy(other).scale(scalar);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/math/vector.ts?");

/***/ }),

/***/ "../engine/src/mesh/graph.ts":
/*!***********************************!*\
  !*** ../engine/src/mesh/graph.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graph\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _data_hash_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/hash-table */ \"../engine/src/data/hash-table.ts\");\n/* harmony import */ var _geo_plane__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geo/plane */ \"../engine/src/geo/plane.ts\");\n/* harmony import */ var _math_const__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/const */ \"../engine/src/math/const.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n/* harmony import */ var _mesh__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mesh */ \"../engine/src/mesh/mesh.ts\");\n/* harmony import */ var _shader_mesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shader-mesh */ \"../engine/src/mesh/shader-mesh.ts\");\n// name: graph.ts\r\n// author:  Jos Feenstra\r\n// purpose: HalfEdge Mesh in 3D.\r\n// This does mean that the order around a vertex is not staight forward, and must be handled using normals.\r\n// TODO\r\n// - graph clean\r\n// - graph delete vert\r\n// - to line renderable\r\n// - keep track of faces, for quick meshification\r\n//   - THIS WILL SPEED UP 'GET ALL FACES THREMENDOUSLY, WHICH WILL SPEED UP SUBDIVISONS'\r\n// - remove ambiguity of halfedges & edges\r\n//   - fix the fact that we 'dont' realllly use halfedges, we consistently use pairs of two.\r\n//   - aka, twins are implicit: 0 -> 1 & 1 -> 0 OR 21 -> 20 & 20 -> 21\r\n\r\n\r\n\r\n\r\n\r\n\r\n// FACES MUST BE CONVEX, OR BUGS MIGHT OCCUR!!!!\r\n// interface Face {\r\n//    edge: EdgeIndex,\r\n// }\r\n// NOTE: create an interface which hides the Edge, Vert & Face interfaces.\r\n// NOTE: half edge is implied\r\nclass Graph {\r\n    constructor() {\r\n        this.verts = [];\r\n        this.edges = [];\r\n    }\r\n    static new() {\r\n        return new Graph();\r\n    }\r\n    static fromMesh(mesh) {\r\n        let graph = Graph.new();\r\n        let normals = mesh.calculateVertexNormals();\r\n        mesh.verts.forEach((v, i) => {\r\n            graph.addVert(v, normals[i]);\r\n        });\r\n        let type = mesh.getType();\r\n        if (type == _shader_mesh__WEBPACK_IMPORTED_MODULE_5__.MeshType.Invalid || type == _shader_mesh__WEBPACK_IMPORTED_MODULE_5__.MeshType.Points) {\r\n            return graph;\r\n        }\r\n        let map = new _data_hash_table__WEBPACK_IMPORTED_MODULE_0__.HashTable();\r\n        let width = mesh.links._width;\r\n        mesh.links.forEachRow((row, i) => {\r\n            // go through pairs\r\n            // NOTE: this can be done way easier by creating 1 half edge per pair\r\n            for (let i = 0; i < width; i++) {\r\n                let iNext = (i + 1) % width;\r\n                let a = row[i];\r\n                let b = row[iNext];\r\n                // console.log(a, b);\r\n                if (a == -1 || b == -1)\r\n                    continue;\r\n                graph.addEdgeIfNew(a, b);\r\n                // let normal = normals[a].add(normals[b]).normalize();\r\n                // if (map.has([a, b])) {\r\n                //     console.log(\"GOT IT ALREADY\")\r\n                //     continue;\r\n                // }\r\n                // graph.addEdgeWithCustomNormal(a, b, normal);\r\n                // map.set([b, a], true);\r\n                // graph.addEdge(a, b);\r\n            }\r\n        });\r\n        return graph;\r\n    }\r\n    // geometry trait\r\n    clone() {\r\n        throw new Error(\"not yet implemented...\");\r\n    }\r\n    transform(matrix) {\r\n        for (let i = 0; i < this.verts.length; i++) {\r\n            let v = this.verts[i];\r\n            v.pos = matrix.multiplyVector(v.pos);\r\n        }\r\n    }\r\n    // UTILITY\r\n    print() {\r\n        console.log(\"graph\");\r\n        console.log(\"--------\");\r\n        console.log(`${this.verts.length} verts: `);\r\n        for (let i = 0; i < this.verts.length; i++) {\r\n            let v = this.verts[i];\r\n            console.log(`v(${i}) | edge: ${v.edge}, data: ${v.pos.toString()} normal: ${v.normal.toString()}`);\r\n        }\r\n        console.log(\"--------\");\r\n        console.log(`${this.edges.length} edges:  `);\r\n        for (let i = 0; i < this.edges.length; i++) {\r\n            let e = this.edges[i];\r\n            console.log(`e(${i}) | vert: ${e.vert}, twin: ${e.twin}, next: ${e.next}, dead ${e.dead}`);\r\n        }\r\n        console.log(\"--------\");\r\n    }\r\n    // CONVERTERS\r\n    toMesh() {\r\n        return _mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.fromGraph(this);\r\n    }\r\n    toLines() {\r\n        return _mesh__WEBPACK_IMPORTED_MODULE_4__.Mesh.newLines(this.allVertPositions(), this.allUniqueEdgeVerts());\r\n    }\r\n    toShaderMesh() {\r\n        return _shader_mesh__WEBPACK_IMPORTED_MODULE_5__.ShaderMesh.fromGraph(this);\r\n    }\r\n    // public getters\r\n    allNorms() {\r\n        let data = [];\r\n        this.verts.forEach((v) => {\r\n            data.push(v.normal);\r\n        });\r\n        return data;\r\n    }\r\n    allVertPositions() {\r\n        let data = [];\r\n        this.verts.forEach((v) => {\r\n            data.push(v.pos);\r\n        });\r\n        return data;\r\n    }\r\n    allUniqueEdges() {\r\n        let edges = [];\r\n        let count = this.edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let i1 = i * 2;\r\n            let i2 = i * 2 + 1;\r\n            let a = this.getEdge(i1);\r\n            let b = this.getEdge(i2);\r\n            if (a.dead || b.dead) {\r\n                continue;\r\n            }\r\n            edges.push(i1);\r\n        }\r\n        return edges;\r\n    }\r\n    allUniqueEdgeVerts() {\r\n        let edges = [];\r\n        let count = this.edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let i1 = i * 2;\r\n            let i2 = i * 2 + 1;\r\n            let a = this.getEdge(i1);\r\n            let b = this.getEdge(i2);\r\n            if (a.dead || b.dead) {\r\n                continue;\r\n            }\r\n            edges.push(a.vert, b.vert);\r\n        }\r\n        return edges;\r\n    }\r\n    allEdgeVerts() {\r\n        let data = [];\r\n        // let edges = new Map<number, number>()\r\n        this.edges.forEach((e, i) => {\r\n            if (e.dead)\r\n                return;\r\n            let a = e.vert;\r\n            let b = this.getEdge(e.twin).vert;\r\n            if (a < b) {\r\n                data.push(a);\r\n                data.push(b);\r\n            }\r\n        });\r\n        return data;\r\n    }\r\n    allVertLoops() {\r\n        throw \"TODO\";\r\n    }\r\n    allVertLoopsAsInts() {\r\n        // TODO speed this up\r\n        let loops = [];\r\n        let unvisited = new Set();\r\n        this.edges.forEach((e, i) => {\r\n            if (e.dead) {\r\n                return;\r\n            }\r\n            unvisited.add(i);\r\n        });\r\n        let i = 0;\r\n        const limit = this.edges.length; // we will never visit an edge twice if all is according to plan\r\n        while (unvisited.size > 0) {\r\n            let loop = [];\r\n            let ei = unvisited.entries().next().value[0];\r\n            let start = ei;\r\n            do {\r\n                if (i > limit) {\r\n                    // this.print();\r\n                    throw \"topology is corrupt!\";\r\n                }\r\n                i += 1;\r\n                let e = this.getEdge(ei);\r\n                unvisited.delete(ei);\r\n                loop.push(e.vert);\r\n                ei = e.next;\r\n            } while (ei != start);\r\n            loops.push(loop);\r\n        }\r\n        return loops;\r\n    }\r\n    getLoop(ei) {\r\n        let loop = [];\r\n        let i = 0;\r\n        const limit = this.edges.length;\r\n        let start = ei;\r\n        do {\r\n            if (i > limit) {\r\n                // this.print();\r\n                throw \"topology is corrupt!\";\r\n            }\r\n            i += 1;\r\n            let e = this.getEdge(ei);\r\n            loop.push(ei);\r\n            ei = e.next;\r\n        } while (ei != start);\r\n        return loop;\r\n    }\r\n    getVertexPos(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw \"out of range\";\r\n        }\r\n        return this.verts[vi].pos;\r\n    }\r\n    getVertexNormal(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw \"out of range\";\r\n        }\r\n        return this.verts[vi].normal;\r\n    }\r\n    getVertexCount() {\r\n        return this.verts.length;\r\n    }\r\n    getHalfEdgeCount() {\r\n        return this.edges.length;\r\n    }\r\n    changeVertex(vi, pos, norm) {\r\n        let v = this.verts[vi];\r\n        v.pos = pos;\r\n        v.normal = norm;\r\n    }\r\n    getVert(vi) {\r\n        if (vi < 0 || vi >= this.verts.length) {\r\n            throw \"out of range\";\r\n        }\r\n        return this.verts[vi];\r\n    }\r\n    getEdge(ei) {\r\n        if (ei < 0 || ei >= this.edges.length) {\r\n            console.error(\"out of range\");\r\n        }\r\n        return this.edges[ei];\r\n    }\r\n    getEdgeIndexBetween(ai, bi) {\r\n        let res = this.getEdgeBetween(ai, bi);\r\n        if (res)\r\n            return this.getEdgeIndex(res);\r\n        return undefined;\r\n    }\r\n    getEdgeBetween(ai, bi) {\r\n        let edges = this.getVertEdgeFan(ai);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            if (this.getEdge(edges[i].twin).vert == bi) {\r\n                return edges[i];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    getVertEdgeFan(vi) {\r\n        // get all edges connected to this vertex.\r\n        // NOTE: all are outgoing (e.vert == vi)\r\n        // console.log(\"getting fan\");\r\n        let fan = [];\r\n        let v = this.verts[vi];\r\n        let ei = v.edge;\r\n        let start = ei;\r\n        if (ei == -1) {\r\n            return fan;\r\n        }\r\n        let count = 0;\r\n        while (true) {\r\n            if (count > this.verts.length) {\r\n                this.print();\r\n                console.log(\"fan: \", fan);\r\n                throw \"nope\";\r\n            }\r\n            count += 1;\r\n            // console.log(\"step\", count, \"ei\", ei);\r\n            let e = this.getEdge(ei);\r\n            let e_twin = this.getEdgeTwin(ei);\r\n            fan.push(e);\r\n            ei = e_twin.next;\r\n            if (ei == start) {\r\n                break;\r\n            }\r\n        }\r\n        // console.log(\"returning fan: \", fan);\r\n        return fan;\r\n    }\r\n    getLoopsAdjacentToEdge(ei) {\r\n        let loops = [];\r\n        loops.push(this.getLoop(ei));\r\n        loops.push(this.getLoop(this.getEdge(ei).twin));\r\n        return loops;\r\n    }\r\n    getVertNeighbors(vi) {\r\n        let ids = [];\r\n        this.getVertEdgeFan(vi).forEach((e) => {\r\n            ids.push(this.getEdge(e.twin).vert);\r\n        });\r\n        return ids;\r\n    }\r\n    getEdgeIndex(e) {\r\n        return this.getEdge(e.twin).twin;\r\n    }\r\n    getEdgeTwin(ei) {\r\n        return this.edges[this.edges[ei].twin];\r\n    }\r\n    hasEdge(a, b) {\r\n        let nbs = this.getVertNeighbors(a);\r\n        return nbs.includes(b);\r\n    }\r\n    addVert(vector, normal) {\r\n        this.verts.push({ pos: vector, edge: -1, normal: normal, dead: false });\r\n        return this.verts.length - 1;\r\n    }\r\n    removeVert(a) {\r\n        throw \"TODO FIGURE OUT NULL & REMOVAL\";\r\n    }\r\n    addEdgeIfNew(a, b) {\r\n        if (!this.hasEdge(a, b)) {\r\n            // console.log(\"not there!\");\r\n            this.addEdge(a, b);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    addEdge(vi_1, vi_2) {\r\n        //             ei1\r\n        // / vi1 \\  ---------> / vi2 \\\r\n        // \\     / <---------  \\     /\r\n        //             ei2\r\n        let ei_1 = this.edges.length;\r\n        let ei_2 = ei_1 + 1;\r\n        this.edges.push({\r\n            next: -1,\r\n            twin: ei_2,\r\n            vert: vi_1,\r\n            dead: false,\r\n        });\r\n        this.edges.push({\r\n            next: -1,\r\n            twin: ei_1,\r\n            vert: vi_2,\r\n            dead: false,\r\n        });\r\n        // make sure the 'next' things are fixed, and more\r\n        this.addEdgeToDisk(vi_1, ei_1);\r\n        this.addEdgeToDisk(vi_2, ei_2);\r\n    }\r\n    deleteEdgeByIndex(id) {\r\n        // flag it as 'to be removed'\r\n        this.deleteEdge(this.getEdge(id));\r\n    }\r\n    deleteEdge(edge) {\r\n        // flag it as 'to be removed'\r\n        let twin = this.getEdge(edge.twin);\r\n        edge.dead = true;\r\n        twin.dead = true;\r\n        // remove all pointers\r\n        this.deleteEdgeFromDisk(edge);\r\n        this.deleteEdgeFromDisk(twin);\r\n    }\r\n    // SETTERS\r\n    getDiskPositions(ei) {\r\n        // returns edgeIndex before, edgeIndex after\r\n        let e = this.getEdge(ei);\r\n        let v = this.getVert(e.vert);\r\n        let twin = this.getEdgeTwin(ei);\r\n        let v_twin = this.verts[twin.vert];\r\n        let myVector = v.pos.subbed(v_twin.pos);\r\n        // get all vectors\r\n        let vectors = [];\r\n        vectors.push(myVector);\r\n        // get more vectors by getting all edges currently connected to vertex v\r\n        // if this Edge is already within the fan, filter it out, so this assessment can be correctly made\r\n        let edgesPotentiallyWithExistingEdge = this.getVertEdgeFan(e.vert);\r\n        let edges = [];\r\n        for (let i = 0; i < edgesPotentiallyWithExistingEdge.length; i++) {\r\n            let edge = edgesPotentiallyWithExistingEdge[i];\r\n            if (this.getEdgeIndex(edge) == ei) {\r\n                // console.log(\"edge is in the fan!\");\r\n            }\r\n            else {\r\n                edges.push(edge);\r\n            }\r\n        }\r\n        if (edges.length == 0) {\r\n            return [ei, ei];\r\n        }\r\n        if (edges.length == 1) {\r\n            let e = edges[0];\r\n            return [this.getEdgeIndex(e), this.getEdgeIndex(e)];\r\n        }\r\n        // console.log(\"edges\", edges);\r\n        for (let i = 0; i < edges.length; i++) {\r\n            let edge = edges[i];\r\n            let twin = this.getEdge(edge.twin);\r\n            let neighbor = this.verts[twin.vert];\r\n            let neighborVector = v.pos.subbed(neighbor.pos);\r\n            vectors.push(neighborVector);\r\n        }\r\n        // console.log(\"all vectors: \", vectors);\r\n        // order them by 'wheel'\r\n        let plane = _geo_plane__WEBPACK_IMPORTED_MODULE_1__.Plane.fromPN(v.pos, v.normal);\r\n        let ihat = plane.ihat;\r\n        let jhat = plane.jhat;\r\n        let order = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.calculateWheelOrder(vectors, ihat, jhat);\r\n        // console.log(\"order\", order);\r\n        // find index 0 in the ordering. that is the position of this new edge. get the edges before and after this edge\r\n        let i_before = -1;\r\n        let i_after = -1;\r\n        for (let a = 0; a < order.length; a++) {\r\n            let b = (a + 1) % order.length;\r\n            let c = (a + 2) % order.length;\r\n            if (order[b] == 0) {\r\n                i_before = order[a];\r\n                i_after = order[c];\r\n                break;\r\n            }\r\n        }\r\n        // pick. NOTE: IF CCW / CC OF GRAPH NEEDS TO BE CHANGED, CHANGE THIS ORDER, BUT USE WITH CAUTION\r\n        // minus one, since we have 1 vector more than the edge list\r\n        let e_before = edges[i_after - 1];\r\n        let e_after = edges[i_before - 1];\r\n        return [this.getEdgeIndex(e_before), this.getEdgeIndex(e_after)];\r\n    }\r\n    addEdgeToDisk(vi, ei) {\r\n        let v = this.getVert(vi);\r\n        let twin = this.getEdgeTwin(ei);\r\n        if (v.edge == -1) {\r\n            // set two pointers:\r\n            v.edge = ei; // I am the vertex's first edge\r\n            twin.next = ei; // that means my twin points back to me\r\n        }\r\n        else {\r\n            let [ei_before, ei_after] = this.getDiskPositions(ei);\r\n            let [e_before, e_after] = [this.getEdge(ei_before), this.getEdge(ei_after)];\r\n            // set two pointers:\r\n            this.getEdge(e_before.twin).next = ei;\r\n            twin.next = this.getEdgeIndex(e_after);\r\n        }\r\n    }\r\n    deleteEdgeFromDisk(edge) {\r\n        let ei = this.getEdgeIndex(edge);\r\n        // console.log(\"deleting...\", ei);\r\n        let vert = this.getVert(edge.vert);\r\n        // console.log(\"deleting from disk...\");\r\n        let [ei_before, ei_after] = this.getDiskPositions(ei);\r\n        if (ei_before == ei) {\r\n            vert.edge = -1;\r\n            return;\r\n        }\r\n        // let flower = this.getVertEdgeFan(edge.vert);\r\n        // flower.forEach((e) => {console.log(this.getEdgeIndex(e))});\r\n        let [e_before, e_after] = [this.getEdge(ei_before), this.getEdge(ei_after)];\r\n        // set one pointer\r\n        // console.log(\"this is edge\", ei);\r\n        // // console.log(\"before is\", ei_before);\r\n        // console.log(\"after is\", ei_after);\r\n        // console.log(\"before.twin.next is\", this.getEdge(e_before.twin).next);\r\n        // console.log(\"after.twin.next is\", this.getEdge(e_after.twin).next);\r\n        this.getEdge(e_before.twin).next = ei_after;\r\n        if (vert.edge == ei) {\r\n            vert.edge = ei_after;\r\n        }\r\n    }\r\n    // MISC\r\n    splitEdge(ai, bi, alpha) {\r\n        // get the edge\r\n        let edge = this.getEdgeBetween(ai, bi);\r\n        if (!edge)\r\n            throw new Error(`No Edge found between ${ai} and ${bi}`);\r\n        let twin = this.getEdge(edge.twin);\r\n        let a = this.getVert(ai);\r\n        let b = this.getVert(bi);\r\n        let v = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromLerp(a.pos, b.pos, alpha);\r\n        let n = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.fromLerp(a.normal, b.normal, alpha);\r\n        let ci = this.addVert(v, n);\r\n        let c = this.getVert(ci);\r\n        // change the edges\r\n        // if (ai == 0) {\r\n        // }\r\n        this.deleteEdge(edge);\r\n        this.addEdge(ai, ci);\r\n        this.addEdge(ci, bi);\r\n        return ci;\r\n    }\r\n    subdivide() {\r\n        // 1. get all edges\r\n        let edges = this.allEdgeVerts();\r\n        let faces = this.allVertLoopsAsInts();\r\n        // this maps old edges to new vertices\r\n        let deadEdgeMap = new _data_hash_table__WEBPACK_IMPORTED_MODULE_0__.HashTable(); // this\r\n        // 2. split all edges, map\r\n        let count = edges.length / 2;\r\n        let middlePoints = new Array(count);\r\n        for (let i = 0; i < count; i++) {\r\n            let vai = edges[i * 2];\r\n            let vbi = edges[i * 2 + 1];\r\n            // let edgeI = this.getEdgeIndexBetween(vai, vbi)!;\r\n            // let edgeII = this.getEdgeIndexBetween(vbi, vai)!;\r\n            let vci = this.splitEdge(vai, vbi, 0.5);\r\n            middlePoints[i] = vci;\r\n            deadEdgeMap.set([vai, vbi], vci);\r\n            deadEdgeMap.set([vbi, vai], vci);\r\n        }\r\n        // 3. per old face: connect the dots\r\n        for (let i = 0; i < faces.length; i++) {\r\n            let face = faces[i];\r\n            // get all middle points\r\n            let middlePoints = new Array(face.length);\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                let via = face[j];\r\n                let vib = face[jNext];\r\n                // console.log(via, vib);\r\n                middlePoints[j] = deadEdgeMap.get([via, vib]);\r\n            }\r\n            // console.log(middlePoints);\r\n            // connect the dots\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                this.addEdge(middlePoints[j], middlePoints[jNext]);\r\n            }\r\n        }\r\n    }\r\n    subdivideQuad() {\r\n        // 1. get all edges\r\n        let edges = this.allEdgeVerts();\r\n        let faces = this.allVertLoopsAsInts();\r\n        // this maps old edges to new vertices\r\n        let deadEdgeMap = new _data_hash_table__WEBPACK_IMPORTED_MODULE_0__.HashTable(); // this\r\n        // 2. split all edges, map\r\n        let count = edges.length / 2;\r\n        for (let i = 0; i < count; i++) {\r\n            let vai = edges[i * 2];\r\n            let vbi = edges[i * 2 + 1];\r\n            // let edgeI = this.getEdgeIndexBetween(vai, vbi)!;\r\n            // let edgeII = this.getEdgeIndexBetween(vbi, vai)!;\r\n            let vci = this.splitEdge(vai, vbi, 0.5);\r\n            deadEdgeMap.set([vai, vbi], vci);\r\n            deadEdgeMap.set([vbi, vai], vci);\r\n        }\r\n        // 3. per old face: connect the dots\r\n        for (let i = 0; i < faces.length; i++) {\r\n            let face = faces[i];\r\n            // get center point\r\n            let pos = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n            for (let j = 0; j < face.length; j++) {\r\n                pos.add(this.getVertexPos(face[j]));\r\n            }\r\n            pos.scale(1 / face.length);\r\n            let norm = calcPlanarFaceNormal(face.map((v) => this.getVertexPos(v)));\r\n            let si = this.addVert(pos, norm);\r\n            // per middle point, connect the dots\r\n            for (let j = 0; j < face.length; j++) {\r\n                let jNext = (j + 1) % face.length;\r\n                let via = face[j];\r\n                let vib = face[jNext];\r\n                // console.log(via, vib);\r\n                let c = deadEdgeMap.get([via, vib]);\r\n                this.addEdge(si, c);\r\n            }\r\n        }\r\n    }\r\n    forEveryEdgeVerts(callback) {\r\n        let edges = this.allUniqueEdgeVerts();\r\n        let edgeCount = edges.length / 2;\r\n        for (let i = 0; i < edgeCount; i++) {\r\n            let a = this.getVert(edges[i * 2]);\r\n            let b = this.getVert(edges[i * 2 + 1]);\r\n            callback(a.pos, b.pos);\r\n        }\r\n    }\r\n}\r\nfunction calcPlanarFaceNormal(face) {\r\n    // ASSUMES : FACE = PLANAR & FACE = NOT SLIVER POLYGON (AREA > 0)\r\n    let count = face.length;\r\n    if (count < 3) {\r\n        throw \"cannot get face planar with 2 or less edges\";\r\n    }\r\n    // get the normal of a planar face\r\n    let normal = _math_vector__WEBPACK_IMPORTED_MODULE_3__.Vector3.zero();\r\n    // two edges could be parallel, but there will be two edges in the face that are different.\r\n    let ihat = face[1].subbed(face[0]);\r\n    let jhat = face[2].subbed(face[1]);\r\n    for (let i = 1; i < count; i++) {\r\n        if (Math.abs(ihat.dot(jhat)) > _math_const__WEBPACK_IMPORTED_MODULE_2__.Const.TOLERANCE) {\r\n            return ihat.cross(jhat);\r\n        }\r\n        else {\r\n            // try again with next pair of\r\n            let i2 = (i + 1) % count;\r\n            let i3 = (i + 2) % count;\r\n            jhat = face[i3].subbed(face[i2]);\r\n        }\r\n    }\r\n    throw \"get planar face failed...\";\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/mesh/graph.ts?");

/***/ }),

/***/ "../engine/src/mesh/mesh.ts":
/*!**********************************!*\
  !*** ../engine/src/mesh/mesh.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/math */ \"../engine/src/math/math.ts\");\n// mesh.ts\r\n// Author: Jos Feenstra\r\n// Purpose:\r\n\r\n\r\n// a very pure idea of a mesh : Vertices + links between vertices.\r\n// Could be anything with these properties: lines, triangle-mesh, quads\r\n// idea: should normals be part of the Mesh?\r\nclass Mesh {\r\n    // CONSTRUCTORS\r\n    constructor(verts, links) {\r\n        this.verts = verts;\r\n        this.links = links;\r\n    }\r\n    clone() {\r\n        return new Mesh(this.verts.clone(), this.links.clone());\r\n    }\r\n    static new(verts, links) {\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromLists(verts, faces) {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(verts), _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList(faces, 3));\r\n    }\r\n    static newEmpty(vertCount, linkCount, perLinkCount) {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount), new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(linkCount, perLinkCount));\r\n    }\r\n    static newLines(positions, edges) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(positions);\r\n        let links = _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix.fromList(edges, 2);\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromBiSurface(srf, uSegments = 10, vSegments = 10) {\r\n        // returns vertices & indices of a flat grid\r\n        let uPoints = uSegments + 1;\r\n        let vPoints = vSegments + 1;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(uPoints * vPoints);\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(uSegments * vSegments * 2, 3);\r\n        // create all positions\r\n        for (let u = 0; u < uPoints; u++) {\r\n            for (let v = 0; v < vPoints; v++) {\r\n                let i = u * vPoints + v;\r\n                verts.set(i, srf.pointAt(u / uSegments, v / vSegments));\r\n            }\r\n        }\r\n        // create all indices\r\n        // a---c\r\n        // | \\ |\r\n        // b---d\r\n        for (let u = 0; u < uSegments; u++) {\r\n            for (let v = 0; v < vSegments; v++) {\r\n                let start_index = 2 * (u * vSegments + v);\r\n                let a = u * uPoints + v;\r\n                let b = a + vPoints;\r\n                let c = a + 1;\r\n                let d = b + 1;\r\n                links.setRow(start_index, [a, b, d]);\r\n                links.setRow(start_index + 1, [c, a, d]);\r\n            }\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromTriSurface(srf, segments = 10) {\r\n        // returns vertices & indices of a flat grid\r\n        let uPoints = segments + 1;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(_math_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(uPoints));\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(_math_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.stack(uPoints), 3);\r\n        // // create all positions\r\n        // for (let u = 0; u < uPoints; u++) {\r\n        //     for (let v = 0; v < vPoints; v++) {\r\n        //         let i = u * vPoints + v;\r\n        //         verts.set(i, srf.pointAt(u / uSegments, v / vSegments));\r\n        //     }\r\n        // }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static zero() {\r\n        return new Mesh(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(0), new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(0, 0));\r\n    }\r\n    static fromJoin(meshes) {\r\n        // join meshes, dont try to look for duplicate vertices\r\n        // TODO : make this the trouble of Matrices and Arrays\r\n        let vertCount = 0;\r\n        let faceCount = 0;\r\n        for (let mesh of meshes) {\r\n            vertCount += mesh.verts.count;\r\n            faceCount += mesh.links.count();\r\n        }\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount);\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(faceCount, 3);\r\n        let accVerts = 0;\r\n        let accFaces = 0;\r\n        for (let mesh of meshes) {\r\n            for (let i = 0; i < mesh.verts.count; i++) {\r\n                verts.set(accVerts + i, mesh.verts.get(i));\r\n            }\r\n            for (let i = 0; i < mesh.links.count(); i++) {\r\n                let face = mesh.links.getRow(i);\r\n                for (let j = 0; j < face.length; j++) {\r\n                    face[j] = face[j] + accVerts;\r\n                }\r\n                links.setRow(accFaces + i, face);\r\n            }\r\n            accVerts += mesh.verts.count;\r\n            accFaces += mesh.links.count();\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromRect(rect) {\r\n        let verts = rect.getCorners();\r\n        // we cant handle quads yet\r\n        let faces = [];\r\n        faces.push(...quadToTri(cubeFaces[0]));\r\n        let rend = new _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh(4, 0, 0, 2);\r\n        rend.mesh.verts.fillFromList(verts);\r\n        rend.mesh.links.setData(faces);\r\n        // console.log(mesh.verts);\r\n        // console.log(mesh.links);\r\n        rend.setUvs(new Float32Array([0.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]));\r\n        return rend;\r\n    }\r\n    static fromRectangle(rect) {\r\n        let verts = rect.getCorners();\r\n        // we cant handle quads yet\r\n        let faces = [];\r\n        faces.push(...quadToTri(cubeFaces[0]));\r\n        return this.fromLists(verts, faces);\r\n    }\r\n    static newQuad(corners) {\r\n        let faces = [...quadToTri(cubeFaces[0])];\r\n        return this.fromLists(corners, faces);\r\n    }\r\n    static newOct(corners) {\r\n        let faces = [];\r\n        for (let face of cubeFaces) {\r\n            faces.push(...quadToTri(face));\r\n        }\r\n        return this.fromLists(corners, faces);\r\n    }\r\n    static fromCube(cube) {\r\n        let verts = cube.getCorners();\r\n        return Mesh.newOct(verts);\r\n    }\r\n    static newIcosahedron(scale = 1) {\r\n        let graph = new _lib__WEBPACK_IMPORTED_MODULE_0__.Graph();\r\n        let a = scale;\r\n        let phi = (1 + Math.pow(5, 0.5)) / 2;\r\n        let b = a * phi;\r\n        let addVert = (v) => {\r\n            graph.addVert(v, v);\r\n        };\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-a, -b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(a, -b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-a, b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(a, b, 0));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -a, -b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, a, -b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -a, b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, a, b));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b, 0, -a));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-b, 0, a));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(b, 0, -a));\r\n        addVert(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(b, 0, a));\r\n        // build edges\r\n        let addEdge = (a, b) => {\r\n            graph.addEdge(a, b);\r\n        };\r\n        for (let i = 0; i < 12; i += 4) {\r\n            addEdge(i + 0, i + 1);\r\n            addEdge(i + 2, i + 3);\r\n            let inext = (i + 4) % 12;\r\n            addEdge(i + 0, inext + 2);\r\n            addEdge(i + 0, inext + 0);\r\n            addEdge(i + 1, inext + 2);\r\n            addEdge(i + 1, inext + 0);\r\n            addEdge(i + 2, inext + 3);\r\n            addEdge(i + 2, inext + 1);\r\n            addEdge(i + 3, inext + 3);\r\n            addEdge(i + 3, inext + 1);\r\n        }\r\n        return this.fromGraph(graph);\r\n    }\r\n    static newSphere(center, radius, numRings, numPerRing) {\r\n        // verts\r\n        let vertCount = numRings * numPerRing + 2;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount);\r\n        let setVert = function (i, vector) {\r\n            verts.set(i, vector.scale(radius).add(center));\r\n        };\r\n        setVert(0, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1));\r\n        for (let ring = 0; ring < numRings; ring++) {\r\n            for (let perRing = 0; perRing < numPerRing; perRing++) {\r\n                let alpha = (Math.PI * (ring + 1)) / (numRings + 1);\r\n                let beta = (2 * Math.PI * perRing) / numPerRing;\r\n                let x = Math.sin(alpha) * Math.cos(beta);\r\n                let y = Math.sin(alpha) * Math.sin(beta);\r\n                let z = Math.cos(alpha);\r\n                let index = 1 + ring * numPerRing + perRing;\r\n                setVert(index, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(x, y, z));\r\n            }\r\n        }\r\n        setVert(vertCount - 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, -1));\r\n        // faces\r\n        let faceCount = numPerRing * numRings * 2;\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(faceCount, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // faces top\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            setFace(i, [0, i + 1, ((i + 1) % numPerRing) + 1]);\r\n        }\r\n        // faces middle\r\n        // we are at this cursor\r\n        // console.log(\"faces\", faceCount);\r\n        for (let ring = 0; ring < numRings - 1; ring++) {\r\n            let vertCursor = numPerRing * ring + 1;\r\n            let vertCursorBelow = vertCursor + numPerRing;\r\n            for (let perRing = 0; perRing < numPerRing; perRing++) {\r\n                let a = vertCursor + perRing;\r\n                let b = vertCursor + ((perRing + 1) % numPerRing);\r\n                let c = vertCursorBelow + perRing;\r\n                let d = vertCursorBelow + ((perRing + 1) % numPerRing);\r\n                let iFace = numPerRing + numPerRing * ring * 2 + perRing * 2;\r\n                // console.log(iFace);\r\n                setFace(iFace, [a, c, b]);\r\n                setFace(iFace + 1, [c, d, b]);\r\n            }\r\n        }\r\n        // faces bottom\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let iNext = (i + 1) % numPerRing;\r\n            let last = vertCount - 1;\r\n            let iFace = faceCount - numPerRing + i;\r\n            let zero = vertCount - numPerRing - 1;\r\n            let vertI = zero + i;\r\n            let vertINext = zero + iNext;\r\n            // console.log(iFace);\r\n            // console.log(\"face\", last, vertINext, vertI);\r\n            setFace(iFace, [last, vertINext, vertI]);\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static newCylinder(from, to, radius, numPerRing) {\r\n        let normal = to.subbed(from);\r\n        let numVerts = numPerRing * 2 + 2;\r\n        let numFaces = (numVerts - 2) * 2;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(numVerts);\r\n        // some dumb stuff\r\n        let setVert = function (i, vector) {\r\n            verts.set(i, vector);\r\n        };\r\n        // planes to represent top & bottom\r\n        let planeFrom = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.fromPN(from, normal);\r\n        // console.log(planeFrom);\r\n        let planeTo = _lib__WEBPACK_IMPORTED_MODULE_0__.Plane.fromPN(to, normal);\r\n        // console.log(planeFrom);\r\n        // verts 'from ring\r\n        setVert(0, from);\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let v = new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos((Math.PI * 2 * i) / numPerRing), Math.sin((Math.PI * 2 * i) / numPerRing), 0).scale(radius);\r\n            v = planeFrom.matrix.multiplyVector(v);\r\n            setVert(i + 1, v);\r\n        }\r\n        // verts 'to' ring\r\n        let numVertsHalf = numVerts / 2;\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let v = new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos((Math.PI * 2 * i) / numPerRing), Math.sin((Math.PI * 2 * i) / numPerRing), 0).scale(radius);\r\n            v = planeTo.matrix.multiplyVector(v);\r\n            setVert(numVertsHalf + i, v);\r\n        }\r\n        setVert(numVerts - 1, to);\r\n        // start making links\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(numFaces, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // set faces\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let a = 0;\r\n            let b = 1 + i;\r\n            let c = 1 + ((i + 1) % numPerRing);\r\n            let d = numVerts - 1;\r\n            let e = numVertsHalf + i;\r\n            let f = numVertsHalf + ((i + 1) % numPerRing);\r\n            setFace(i * 4, [a, c, b]);\r\n            setFace(i * 4 + 1, [b, c, e]);\r\n            setFace(i * 4 + 2, [c, f, e]);\r\n            setFace(i * 4 + 3, [d, e, f]);\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static newCone(center, radius, height, numPerRing) {\r\n        let numVerts = numPerRing + 2;\r\n        let numFaces = numPerRing * 2;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(numVerts);\r\n        let setVert = function (i, vector) {\r\n            verts.set(i, vector.add(center));\r\n        };\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(numFaces, 3);\r\n        links.fill(-1);\r\n        let setFace = function (i, row) {\r\n            links.setRow(i, row);\r\n        };\r\n        // set verts\r\n        setVert(0, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            setVert(i + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos((Math.PI * 2 * i) / numPerRing), Math.sin((Math.PI * 2 * i) / numPerRing), 0).scale(radius));\r\n        }\r\n        setVert(numVerts - 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, height));\r\n        // set faces\r\n        for (let i = 0; i < numPerRing; i++) {\r\n            let a = 0;\r\n            let b = numVerts - 1;\r\n            let c = 1 + i;\r\n            let d = 1 + ((i + 1) % numPerRing);\r\n            setFace(i * 2, [a, d, c]);\r\n            setFace(i * 2 + 1, [c, d, b]);\r\n        }\r\n        return new Mesh(verts, links);\r\n    }\r\n    static fromGraph(graph) {\r\n        // NOTE : doesnt really work if the loops are not of size 3.\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(graph.allVertPositions());\r\n        let loops = graph.allVertLoopsAsInts();\r\n        let links = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(loops.length, 3);\r\n        loops.forEach((loop, i) => {\r\n            if (loop.length == 3) {\r\n                links.setRow(i, loop);\r\n            }\r\n            else {\r\n                console.log(\"cant convert loop\");\r\n            }\r\n        });\r\n        return Mesh.new(verts, links);\r\n    }\r\n    // CONVERTERS\r\n    toLines() {\r\n        const getLines = (num) => {\r\n            let count = this.links.count() * num;\r\n            let lines = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(count, 2);\r\n            for (let i = 0; i < this.links.count(); i++) {\r\n                for (let j = 0; j < num; j++) {\r\n                    let jnext = (j + 1) % num;\r\n                    let iLines = i * num + j;\r\n                    lines.set(iLines, 0, this.links.get(i, j));\r\n                    lines.set(iLines, 1, this.links.get(i, jnext));\r\n                }\r\n            }\r\n            return lines;\r\n        };\r\n        let type = this.getType();\r\n        if (type == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Lines) {\r\n            return this.clone();\r\n        }\r\n        else if (type == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Triangles) {\r\n            let lines = getLines(3);\r\n            return Mesh.new(this.verts.clone(), lines);\r\n        }\r\n        else if (type == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Quads) {\r\n            let lines = getLines(4);\r\n            return Mesh.new(this.verts.clone(), lines);\r\n        }\r\n        else {\r\n            console.warn(\"cannot convert to lines\");\r\n            return Mesh.newEmpty(0, 0, 0);\r\n        }\r\n    }\r\n    ToShaderMesh() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh.fromMesh(this);\r\n    }\r\n    toGraph() {\r\n        return _lib__WEBPACK_IMPORTED_MODULE_0__.Graph.fromMesh(this);\r\n    }\r\n    // GETTERS\r\n    getType() {\r\n        if (this.links._width == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Points) {\r\n            return _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Points;\r\n        }\r\n        else if (this.links._width == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Lines) {\r\n            return _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Lines;\r\n        }\r\n        else if (this.links._width == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Triangles) {\r\n            return _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Triangles;\r\n        }\r\n        else if (this.links._width == _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Quads) {\r\n            return _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Quads;\r\n        }\r\n        else {\r\n            return _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Invalid;\r\n        }\r\n    }\r\n    getLinkVerts(f) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.links._width);\r\n        this.links.getRow(f).forEach((v, i) => {\r\n            verts.set(i, this.verts.get(v));\r\n        });\r\n        return verts;\r\n    }\r\n    // MISC\r\n    calculateFaceNormals() {\r\n        let norms = [];\r\n        if (this.getType() != _lib__WEBPACK_IMPORTED_MODULE_0__.MeshType.Triangles) {\r\n            console.error(\"can only calculate normals from triangular meshes\");\r\n            return norms;\r\n        }\r\n        let faceCount = this.links.count();\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let verts = this.getLinkVerts(i).toList();\r\n            let normal = verts[1].subbed(verts[0]).cross(verts[2].subbed(verts[0])).normalize();\r\n            norms.push(normal);\r\n        }\r\n        return norms;\r\n    }\r\n    calculateVertexNormals() {\r\n        let faceCount = this.links.count();\r\n        let faceNormals = this.calculateFaceNormals();\r\n        // stack all face normals per vertex\r\n        let array = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.verts.count);\r\n        for (let i = 0; i < faceCount; i++) {\r\n            let normal = faceNormals[i];\r\n            this.links.getRow(i).forEach((vertexIndex) => {\r\n                let v = array.get(vertexIndex);\r\n                array.set(vertexIndex, v.add(normal));\r\n            });\r\n        }\r\n        // normalize all\r\n        let normals = array.toList();\r\n        for (let i = 0; i < normals.length; i++) {\r\n            normals[i].normalize();\r\n        }\r\n        return normals;\r\n    }\r\n}\r\n// ================ Help ==================\r\n// 0 ------- 1\r\n// | \\     / |\r\n// |  4---5  |\r\n// |  |   |  |\r\n// |  6---7  |\r\n// | /     \\ |\r\n// 2 ------- 3\r\nconst cubeFaces = [\r\n    [0, 1, 3, 2],\r\n    [4, 0, 2, 6],\r\n    [1, 0, 4, 5],\r\n    [1, 5, 7, 3],\r\n    [2, 3, 7, 6],\r\n    [5, 4, 6, 7], // back\r\n];\r\nfunction quadToTri(abcd) {\r\n    return [abcd[0], abcd[2], abcd[1], abcd[0], abcd[3], abcd[2]];\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/mesh/mesh.ts?");

/***/ }),

/***/ "../engine/src/mesh/multi-line.ts":
/*!****************************************!*\
  !*** ../engine/src/mesh/multi-line.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiLine\": () => (/* binding */ MultiLine),\n/* harmony export */   \"getDefaultIndices\": () => (/* binding */ getDefaultIndices)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    line-render-data.ts\r\n// author:  Jos Feenstra\r\n// purpose: represents an object which can be fed directly to a linerenderer.\r\n//          use it to not continuously have to calculate these aspects if the underlying object is unchanged.\r\n\r\n// represents a collection of multiple lines. These could form 1 polyline, but this is not a requirement\r\nclass MultiLine {\r\n    constructor(verts, ids) {\r\n        this.verts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(verts);\r\n        if (ids == undefined) {\r\n            this.links = getDefaultIndices(this.verts.height);\r\n        }\r\n        else {\r\n            this.links = ids;\r\n        }\r\n    }\r\n    // this assumes even vectices are 'from' points, and odd vertices are 'to' points\r\n    static fromLines(verts) {\r\n        let data = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(verts);\r\n        return new MultiLine(data);\r\n    }\r\n    // get all lines from a mesh\r\n    static fromMesh(rend, uv = false) {\r\n        // 3 edges per face, 2 indices per edge\r\n        let mesh = rend.mesh;\r\n        let count = mesh.links.count() * 6;\r\n        let data = new Uint16Array(count);\r\n        for (let i = 0; i < mesh.links.count(); i++) {\r\n            let iData = i * 6;\r\n            data[iData] = mesh.links.get(i, 0);\r\n            data[iData + 1] = mesh.links.get(i, 1);\r\n            data[iData + 2] = mesh.links.get(i, 1);\r\n            data[iData + 3] = mesh.links.get(i, 2);\r\n            data[iData + 4] = mesh.links.get(i, 2);\r\n            data[iData + 5] = mesh.links.get(i, 0);\r\n        }\r\n        if (uv) {\r\n            return new MultiLine(rend.uvs.toMatrixSlice(), data);\r\n        }\r\n        else {\r\n            return new MultiLine(mesh.verts.slice(), data);\r\n        }\r\n    }\r\n    // create lines as a grid centered at a plane\r\n    static fromGrid(plane, count, dis) {\r\n        let halfTotalSize = ((count - 1) * dis) / 2;\r\n        // 2 vectors per line, 2 lines per count\r\n        // plus 5 lines, for ihat and jhat icons\r\n        let lines = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count * 4);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, -halfTotalSize, 0));\r\n            lines.set(i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, halfTotalSize, 0));\r\n        }\r\n        // y lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(2 * count + i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-halfTotalSize, -halfTotalSize + dis * i, 0));\r\n            lines.set(2 * count + i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize, -halfTotalSize + dis * i, 0));\r\n        }\r\n        // finally, transform everything to worldspace, and create the linerenderdata object\r\n        lines.forEach((v) => plane.pushToWorld(v));\r\n        return new MultiLine(lines.slice());\r\n    }\r\n    // get all lines from a plane\r\n    static fromPlane(plane) {\r\n        let count = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.PLANE_RENDER_LINECOUNT;\r\n        let dis = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.PLANE_RENDER_LINEDISTANCE;\r\n        let disSmall = dis / 10;\r\n        let halfTotalSize = ((count - 1) * dis) / 2;\r\n        // 2 vectors per line, 2 lines per count\r\n        // plus 5 lines, for ihat and jhat icons\r\n        let lines = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count * 4 + 5 * 2);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, -halfTotalSize, 0));\r\n            lines.set(i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(t, halfTotalSize, 0));\r\n        }\r\n        // y lines\r\n        for (let i = 0; i < count; i++) {\r\n            let t = -halfTotalSize + dis * i;\r\n            lines.set(2 * count + i * 2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-halfTotalSize, -halfTotalSize + dis * i, 0));\r\n            lines.set(2 * count + i * 2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize, -halfTotalSize + dis * i, 0));\r\n        }\r\n        // icon I  to show ihat\r\n        let iconLine1 = lines.count - 10;\r\n        lines.set(iconLine1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall, -disSmall, 0));\r\n        lines.set(iconLine1 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall * 4, disSmall, 0));\r\n        let iconLine2 = lines.count - 8;\r\n        lines.set(iconLine2, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall, disSmall, 0));\r\n        lines.set(iconLine2 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(halfTotalSize + disSmall * 4, -disSmall, 0));\r\n        // icon II to show jhat\r\n        let iconLine3 = lines.count - 6;\r\n        lines.set(iconLine3, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, halfTotalSize + disSmall * 2.5, 0));\r\n        lines.set(iconLine3 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(disSmall, halfTotalSize + disSmall * 4, 0));\r\n        let iconLine4 = lines.count - 4;\r\n        lines.set(iconLine4, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(disSmall, halfTotalSize + disSmall, 0));\r\n        lines.set(iconLine4 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(-disSmall, halfTotalSize + disSmall * 4, 0));\r\n        // icon III to show khat / normal direction\r\n        let iconLine5 = lines.count - 2;\r\n        lines.set(iconLine5, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));\r\n        lines.set(iconLine5 + 1, new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, dis));\r\n        // finally, transform everything to worldspace, and create the linerenderdata object\r\n        lines.forEach((v) => plane.pushToWorld(v));\r\n        return new MultiLine(lines.slice());\r\n    }\r\n    static fromCircle(c, numSegments = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.CIRCLE_SEGMENTS) {\r\n        let count = numSegments;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        // x lines\r\n        for (let i = 0; i < count; i++) {\r\n            // radial fraction of a circle\r\n            let t = (i / count) * (Math.PI * 2);\r\n            verts.set(i, c.plane.pushToWorld(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos(t) * c.radius, Math.sin(t) * c.radius, 0)));\r\n        }\r\n        return new MultiLine(verts.slice(), getPairIndices(count, true));\r\n    }\r\n    static fromPolyline(p) {\r\n        return new MultiLine(p.verts, getPairIndices(p.verts.count, false));\r\n    }\r\n    static fromBezier(b, numSegments = _lib__WEBPACK_IMPORTED_MODULE_0__.Const.BEZIER_SEGMENTS) {\r\n        let count = numSegments + 1;\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(count);\r\n        for (let i = 0; i < count; i++) {\r\n            // fraction\r\n            let t = i / numSegments;\r\n            verts.set(i, b.pointAt(t));\r\n        }\r\n        return new MultiLine(verts.slice(), getPairIndices(count, false));\r\n    }\r\n    static fromCube(cube) {\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(cube.getCorners());\r\n        return new MultiLine(verts);\r\n    }\r\n    static fromJoin(lines) {\r\n        // join meshes, dont try to look for duplicate vertices\r\n        // TODO : make this the trouble of Matrices and Arrays\r\n        let idsCount = 0;\r\n        let vertCount = 0;\r\n        for (let line of lines) {\r\n            idsCount += line.links.length;\r\n            vertCount += line.verts.count();\r\n        }\r\n        let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(vertCount);\r\n        let ids = new Uint16Array(idsCount);\r\n        let accVerts = 0;\r\n        let accFaces = 0;\r\n        for (let lineset of lines) {\r\n            for (let i = 0; i < lineset.verts.count(); i++) {\r\n                verts.slice().setRow(accVerts + i, lineset.verts.getRow(i));\r\n            }\r\n            for (let i = 0; i < lineset.links.length; i++) {\r\n                ids[accFaces + i] = lineset.links[i] + accVerts;\r\n            }\r\n            accVerts += lineset.verts.count();\r\n            accFaces += lineset.links.length;\r\n        }\r\n        return new MultiLine(verts, ids);\r\n    }\r\n}\r\n// just get an int sequence from 0 to length.\r\nfunction getDefaultIndices(count) {\r\n    let data = new Uint16Array(count);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i] = i;\r\n    }\r\n    return data;\r\n}\r\nfunction getPairIndices(count, cyclic) {\r\n    // given count of 3 => return 0,1 | 1,2 | 2,0\r\n    let length = count * 2;\r\n    if (!cyclic) {\r\n        length -= 2;\r\n    }\r\n    let data = new Uint16Array(length);\r\n    for (let i = 0; i < count; i++) {\r\n        data[i * 2] = i;\r\n        data[i * 2 + 1] = (i + 1) % count;\r\n    }\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/mesh/multi-line.ts?");

/***/ }),

/***/ "../engine/src/mesh/shader-mesh.ts":
/*!*****************************************!*\
  !*** ../engine/src/mesh/shader-mesh.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshType\": () => (/* binding */ MeshType),\n/* harmony export */   \"NormalKind\": () => (/* binding */ NormalKind),\n/* harmony export */   \"ShaderMesh\": () => (/* binding */ ShaderMesh),\n/* harmony export */   \"meshFromObj\": () => (/* binding */ meshFromObj)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// Name: render-mesh.ts\r\n// Author: Jos Feenstra\r\n// Purpose:\r\n// a mesh representation which can be feed to a shader.\r\n// - fixed length attributes\r\n// - can represent:\r\n//   - pointcloud (links = null)\r\n//   - graph (links.width = 2)\r\n//   - triangles (links.width = 3)\r\n//   - quads (links.width = 4. will need to be converted to triangles for now...)\r\n\r\nvar MeshType;\r\n(function (MeshType) {\r\n    MeshType[MeshType[\"Invalid\"] = 0] = \"Invalid\";\r\n    MeshType[MeshType[\"Points\"] = 1] = \"Points\";\r\n    MeshType[MeshType[\"Lines\"] = 2] = \"Lines\";\r\n    MeshType[MeshType[\"Triangles\"] = 3] = \"Triangles\";\r\n    MeshType[MeshType[\"Quads\"] = 4] = \"Quads\";\r\n})(MeshType || (MeshType = {}));\r\nvar NormalKind;\r\n(function (NormalKind) {\r\n    NormalKind[NormalKind[\"None\"] = 0] = \"None\";\r\n    NormalKind[NormalKind[\"Vertex\"] = 1] = \"Vertex\";\r\n    NormalKind[NormalKind[\"Face\"] = 2] = \"Face\";\r\n    NormalKind[NormalKind[\"MultiVertex\"] = 3] = \"MultiVertex\";\r\n})(NormalKind || (NormalKind = {}));\r\n// RENAME : SHADABLEMESH or something...\r\n// ShadableMesh\r\nclass ShaderMesh {\r\n    constructor(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        this._normKind = NormalKind.None;\r\n        // render speed\r\n        // shader\r\n        this.color = [1, 1, 1, 1];\r\n        this.linecolor = [1, 1, 1, 1];\r\n        let perFaceCount = 3;\r\n        this.mesh = _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh.newEmpty(vertCount, faceCount, perFaceCount);\r\n        this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(normCount);\r\n        this.uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(uvCount);\r\n        this.ambi = new Float32Array(vertCount);\r\n        this.texture = texture;\r\n        this.position = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity();\r\n    }\r\n    static new(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        return new ShaderMesh(vertCount, normCount, uvCount, faceCount, texture);\r\n    }\r\n    static fromMesh(mesh) {\r\n        let r = new ShaderMesh(mesh.verts.count, 0, 0, mesh.links.count());\r\n        r.mesh = mesh;\r\n        return r;\r\n    }\r\n    static fromData(verts, norms, uvs, faces) {\r\n        // NOTE : this type of parsing makes my life easy, but is dangerous. This is why i created the\r\n        // Array class.\r\n        let r = new ShaderMesh(verts.length / 3, norms.length / 3, uvs.length / 2, faces.length / 3);\r\n        r.mesh.verts.slice().fillWith(verts);\r\n        r.mesh.links.fillWith(faces);\r\n        r.norms.slice().fillWith(norms);\r\n        r.uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData(uvs);\r\n        return r;\r\n    }\r\n    static fromGraph(graph) {\r\n        let mesh = graph.toMesh();\r\n        let r = ShaderMesh.fromMesh(mesh);\r\n        r.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(graph.allNorms());\r\n        r._normKind = NormalKind.Vertex; // fix this!!\r\n        return r;\r\n    }\r\n    // geometry trait\r\n    transform(matrix) {\r\n        for (let i = 0; i < this.mesh.verts.count; i++) {\r\n            let v = this.mesh.verts.get(i);\r\n            let n = this.norms.get(i);\r\n            this.mesh.verts.set(i, matrix.multiplyVector(v));\r\n            this.norms.set(i, matrix.multiplyVector(n)); // TODO, EXTRACT ONLY ROTATION PART FROM THE MATRIX\r\n        }\r\n    }\r\n    // getters & selectors\r\n    // VERY POORLY OPTIMIZED\r\n    getAdjacentFaces(v) {\r\n        let faces = [];\r\n        let count = this.mesh.links.count();\r\n        for (let i = 0; i < count; i++) {\r\n            if (this.mesh.links.getRow(i).find(j => j == v)) {\r\n                faces.push(i);\r\n            }\r\n        }\r\n        return faces;\r\n    }\r\n    getFaceVertices(f) {\r\n        return this.mesh.getLinkVerts(f);\r\n    }\r\n    getType() {\r\n        return this.mesh.getType();\r\n    }\r\n    getNormalType() {\r\n        return this._normKind;\r\n    }\r\n    // setters\r\n    setTexture(texture) {\r\n        this.texture = texture;\r\n        // recalculate things if needed\r\n    }\r\n    setUvs(uvs) {\r\n        if (uvs instanceof Float32Array) {\r\n            this.uvs = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromData(uvs);\r\n        }\r\n        else {\r\n            this.uvs = uvs;\r\n        }\r\n        // recalculate if needed\r\n    }\r\n    // convert\r\n    exportToObj(path) {\r\n        throw \"todo\";\r\n    }\r\n    // ------ normals ------\r\n    // set 1 normal per face\r\n    calculateFaceNormals() {\r\n        if (this.getType() != MeshType.Triangles) {\r\n            console.error(\"can only calculate normals from triangular meshes\");\r\n            this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(0);\r\n            return;\r\n        }\r\n        let norms = this.mesh.calculateFaceNormals();\r\n        this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(norms);\r\n        this._normKind = NormalKind.Face;\r\n    }\r\n    calculateVertexNormals() {\r\n        let norms = this.mesh.calculateVertexNormals();\r\n        this.norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.fromList(norms);\r\n        this._normKind = NormalKind.Vertex;\r\n    }\r\n    calculateMultiVertexNormals() {\r\n        // set type\r\n        this._normKind = NormalKind.MultiVertex;\r\n        // calculate\r\n        this.calculateFaceNormals();\r\n        let vertNormals = this.mesh.verts.map((v, i) => {\r\n            let adjFaces = this.getAdjacentFaces(i);\r\n            vertNormals.set(i, this.norms.take(adjFaces).average());\r\n        });\r\n        this.norms = vertNormals;\r\n    }\r\n}\r\n// ================ Obj ===================\r\nfunction meshFromObj(text) {\r\n    // This is not a full .obj parser.\r\n    // see http://paulbourke.net/dataformats/obj/\r\n    // INDEXES ORIGINALLY REFER TO LINES, so -1 is needed\r\n    // run through all lines, and temporarely store\r\n    // all data in raw number lists, since we dont know how\r\n    // many vertices or faces well get.\r\n    let verts = []; // 3 long float\r\n    let norms = []; // 3 long float\r\n    let uvs = []; // 2 long float\r\n    let faces = []; // 9 long ints, u16's should suffice.\r\n    // note : this is very inefficient, but it'll have to do for now...\r\n    const keywordRE = /(\\w*)(?: )*(.*)/;\r\n    const lines = text.split(\"\\n\");\r\n    for (let i = 0; i < lines.length; ++i) {\r\n        const line = lines[i].trim();\r\n        // filter out comments\r\n        if (line === \"\" || line.startsWith(\"#\")) {\r\n            continue;\r\n        }\r\n        const m = keywordRE.exec(line);\r\n        if (!m) {\r\n            continue;\r\n        }\r\n        const [, keyword, unparsedArgs] = m;\r\n        const parts = line.split(/\\s+/).slice(1);\r\n        switch (keyword) {\r\n            case \"v\":\r\n                for (const part of parts) {\r\n                    verts.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case \"vn\":\r\n                for (const part of parts) {\r\n                    norms.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case \"vt\":\r\n                for (const part of parts) {\r\n                    uvs.push(parseFloat(part));\r\n                }\r\n                break;\r\n            case \"f\":\r\n                for (const value of ProcessObjFace(parts)) {\r\n                    faces.push(value);\r\n                }\r\n                break;\r\n            default:\r\n                console.warn(\"unhandled keyword:\", keyword); // eslint-disable-line no-console\r\n                continue;\r\n        }\r\n    }\r\n    // console.log(\"number of vertices: \" + verts.length / 3);\r\n    // console.log(\"number of faces: \" + faces.length / 3);\r\n    // console.log(\"number of uvs: \" + uvs.length / 2);\r\n    // console.log(\"number of norms: \" + norms.length / 3);\r\n    let mesh = ShaderMesh.fromData(verts, norms, uvs, faces);\r\n    return mesh;\r\n}\r\n// NOTE: for now, uv and normals are completely ignored!!!\r\n// we assume the indices are the same als the vertices!!!\r\n// verbose way of processing one single vertex/normal/uv combination in a face.\r\nfunction ProcessObjFaceVertex(part) {\r\n    // make sure data always has length: 3\r\n    let data = [];\r\n    // cut string apart and process it\r\n    let subparts = part.split(\"/\");\r\n    if (subparts.length == 1) {\r\n        data.push(parseInt(subparts[0]) - 1);\r\n        // data.push(0);\r\n        // data.push(0);\r\n    }\r\n    else if (subparts.length == 3) {\r\n        data.push(parseInt(subparts[0]) - 1);\r\n        // data.push(parseInt(subparts[1])-1);\r\n        // data.push(parseInt(subparts[2])-1);\r\n    }\r\n    else {\r\n        throw \"invalid face found when processing\";\r\n    }\r\n    return data;\r\n}\r\n// process a face entry in an obj file\r\nfunction ProcessObjFace(parts) {\r\n    let data = [];\r\n    if (parts.length == 4) {\r\n        // i dont want to deal with quads for now, create 2 faces from a quad\r\n        let a = ProcessObjFaceVertex(parts[0]);\r\n        let b = ProcessObjFaceVertex(parts[1]);\r\n        let c = ProcessObjFaceVertex(parts[2]);\r\n        let d = ProcessObjFaceVertex(parts[3]);\r\n        data.push(...a, ...b, ...c, ...a, ...c, ...d);\r\n    }\r\n    else if (parts.length == 3) {\r\n        // as normal\r\n        let a = ProcessObjFaceVertex(parts[0]);\r\n        let b = ProcessObjFaceVertex(parts[1]);\r\n        let c = ProcessObjFaceVertex(parts[2]);\r\n        data.push(...a, ...b, ...c);\r\n    }\r\n    // data always has length 9 or 18\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/mesh/shader-mesh.ts?");

/***/ }),

/***/ "../engine/src/mesh/topo-mesh.ts":
/*!***************************************!*\
  !*** ../engine/src/mesh/topo-mesh.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TopoMesh\": () => (/* binding */ TopoMesh)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\n// a mesh with topological information\r\nclass TopoMesh extends _lib__WEBPACK_IMPORTED_MODULE_0__.ShaderMesh {\r\n    // private -> should only be used with factory methods\r\n    constructor(vertCount, normCount, uvCount, faceCount, texture = undefined) {\r\n        super(vertCount, normCount, uvCount, faceCount, texture);\r\n        this.lastTouched = 0; // needed for triangle walk\r\n        this.neighborMap = new _lib__WEBPACK_IMPORTED_MODULE_0__.IntMatrix(this.mesh.links.count(), 3);\r\n    }\r\n    static copyFromShaderMesh(rend) {\r\n        let topoMesh = new TopoMesh(rend.mesh.verts.count, rend.norms.count, rend.uvs.count, rend.mesh.links.count());\r\n        topoMesh.mesh.verts = rend.mesh.verts.clone();\r\n        topoMesh.norms = rend.norms.clone();\r\n        topoMesh.uvs = rend.uvs.clone();\r\n        topoMesh.mesh.links = rend.mesh.links.clone();\r\n        topoMesh.setNeighborMap();\r\n        return topoMesh;\r\n    }\r\n    setNeighborMap() {\r\n        // this method fills this.neighborMap after data is loaded\r\n        //\r\n        let edges = new _lib__WEBPACK_IMPORTED_MODULE_0__.HashTable();\r\n        let pairs = new _lib__WEBPACK_IMPORTED_MODULE_0__.HashTable();\r\n        // 1 | per triangle\r\n        this.mesh.links.forEachRow((f, faceIndex) => {\r\n            let faceEdges = [\r\n                [f[0], f[1]],\r\n                [f[1], f[2]],\r\n                [f[2], f[0]],\r\n            ];\r\n            faceEdges.forEach((e) => {\r\n                // if (4, 1), orientation is True | if (1, 4), orientation is False\r\n                let orientation = e[0] > e[1];\r\n                // use this min max construction to only store one edge per triangle pair\r\n                // let edge: [number, number] = e.sort();\r\n                let edge = new Int32Array([Math.min(...e), Math.max(...e)]);\r\n                // console.log(edge);\r\n                if (!edges.has(edge)) {\r\n                    // orientation, first tr ID, second tr ID\r\n                    edges.set(edge, [orientation, faceIndex, -1]);\r\n                }\r\n                else {\r\n                    // an edge match is made!\r\n                    // console.log(\"matched!\");\r\n                    let other = edges.get(edge);\r\n                    let nbOrientation = other[0];\r\n                    let nbIndex = other[1];\r\n                    other[2] = faceIndex;\r\n                    edges.set(edge, other); // edge is put away again, if an edge map is ever needed.\r\n                    // assign neighbours\r\n                    this.setNb(faceIndex, edge, nbIndex);\r\n                    this.setNb(nbIndex, edge, faceIndex);\r\n                    // use this info to fill self.pairs\r\n                    // if orientation != other orientation, edge is 'good' -> False\r\n                    // else -> True, one of the neighbour triangles needs to be flipped\r\n                    let pair = [nbIndex, faceIndex];\r\n                    pair.sort();\r\n                    // pair = (Math.min(...pair), Math.max(...pair))\r\n                    if (orientation != nbOrientation)\r\n                        pairs.set(pair, false);\r\n                    else\r\n                        pairs.set(pair, true);\r\n                }\r\n            });\r\n        });\r\n        // Done. Give feedback\r\n        let count = 0;\r\n        // for pair in pairs.items():\r\n        //     if not pair: count +=1;\r\n        console.log(\"number of 'wrong' face neighbours: \", count);\r\n        return;\r\n    }\r\n    /**\r\n     * Get the triangle based on a UV point somewhere on the mesh.\r\n     * Returns -1 if the point is not on the mesh TODO OR IF THE PATH HAS HOLES IN IT TODO FIX THIS!\r\n     * @param  {Vector2} point\r\n     * @returns triangleIndex, or -1 if failure\r\n     */\r\n    walkUV(point) {\r\n        // start where we last stopped\r\n        let faceIndex = this.lastTouched;\r\n        // make sure we never take more steps than triangles in the triangulation.\r\n        // this would mean something went wrong\r\n        let count = this.mesh.links.count();\r\n        for (let _ = 0; _ < count; _++) {\r\n            // i dont know how, but if we accidentally landed outside of the mesh\r\n            if (faceIndex == -1) {\r\n                return -1;\r\n            }\r\n            for (let i = 0; i < 3; i++) {\r\n                let j = (i + 1) % 3;\r\n                let face = this.mesh.links.getRow(faceIndex);\r\n                let edge = [face[i], face[j]];\r\n                let b = this.uvs.get(edge[0]);\r\n                let c = this.uvs.get(edge[1]);\r\n                let sign = point.sign(b, c);\r\n                if (sign < 0) {\r\n                    faceIndex = this.getNb(faceIndex, edge);\r\n                    // if its ouside, return -1\r\n                    if (faceIndex == -1)\r\n                        return -1;\r\n                    // else: go there immidiately\r\n                    this.lastTouched = faceIndex;\r\n                    break;\r\n                }\r\n                // if this ran 3 times, the point must be within the triangle\r\n                if (i == 2)\r\n                    return faceIndex;\r\n            }\r\n        }\r\n        // something went wrong\r\n        return -1;\r\n    }\r\n    // find the faces closest to the point\r\n    // -1 if the mesh does not contain triangles\r\n    closestFaces(point) {\r\n        let closestVertexId = this.mesh.verts.closestId(point);\r\n        // get all face ids containing closestVertex, along with their centers\r\n        let closestFaces = [];\r\n        //let centers: Vector3[] = []\r\n        this.mesh.links.forEachRow((tr, i) => {\r\n            if (tr.includes(closestVertexId)) {\r\n                closestFaces.push(i);\r\n                //let center = Vector3Array.fromList(this.getFacePoints(i, false)).average();\r\n                //centers.push(center);\r\n            }\r\n        });\r\n        // select the triangle with the closest baricenter\r\n        return closestFaces;\r\n    }\r\n    elevate(p) {\r\n        // 'elevate' a point in UV space to vertex space using a barycentric remap\r\n        // figure out where this point is located on the mesh\r\n        let face = this.walkUV(p);\r\n        if (face == -1) {\r\n            console.warn(\"got a point not on triangle...\");\r\n            return new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);\r\n        }\r\n        let tr3 = this.getTriangle3(face);\r\n        let tr2 = this.getTriangle2(face);\r\n        let bari = tr2.toBarycentric(p);\r\n        return tr3.fromBarycentric(bari);\r\n    }\r\n    closestFace(p) {\r\n        // NOTE this doesnt really work all that well...\r\n        let faceIds = this.closestFaces(p);\r\n        let closestPoints = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(faceIds.length);\r\n        faceIds.forEach((id, i) => {\r\n            let tr = this.getTriangle3(id);\r\n            let cp = tr.closestPoint(p);\r\n            closestPoints.set(i, cp);\r\n        });\r\n        // find the closest closest point\r\n        let id = closestPoints.closestId(p);\r\n        return faceIds[id];\r\n    }\r\n    // 'flatten' a point in vertex space to uv space using a barycentric remap\r\n    // NOTE : this is not exactly a 'project to closest triangle', something like that wouldnt always work\r\n    flatten(p, face) {\r\n        let tr3 = this.getTriangle3(face);\r\n        let tr2 = this.getTriangle2(face);\r\n        let bari = tr3.toBarycentric(p);\r\n        return tr2.fromBarycentric(bari);\r\n    }\r\n    // combo\r\n    flattenClosestPoint(p) {\r\n        let face = this.closestFace(p);\r\n        return this.flatten(p, face);\r\n    }\r\n    closestPoint(p) {\r\n        let face = this.closestFace(p);\r\n        let triangle = this.getTriangle3(face);\r\n        let bari = triangle.toBarycentric(p);\r\n        return triangle.fromBarycentric(bari);\r\n    }\r\n    getTriangle2(id) {\r\n        let p = this.getFacePoints(id, true);\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Triangle2(p[0], p[1], p[2]);\r\n    }\r\n    getTriangle3(id) {\r\n        let p = this.getFacePoints(id, false);\r\n        return new _lib__WEBPACK_IMPORTED_MODULE_0__.Triangle3(p[0], p[1], p[2]);\r\n    }\r\n    setNb(faceIndex, commonEdge, nbIndex) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (!commonEdge.includes(this.mesh.links.get(faceIndex, j))) {\r\n                this.neighborMap.set(faceIndex, j, nbIndex);\r\n                return;\r\n            }\r\n        }\r\n        console.log(this.mesh.links.getRow(faceIndex));\r\n        console.log(commonEdge);\r\n        throw \"these are not actually neighbors!\";\r\n    }\r\n    getNb(faceIndex, commonEdge) {\r\n        for (let j = 0; j < 3; j++) {\r\n            if (!commonEdge.includes(this.mesh.links.get(faceIndex, j))) {\r\n                return this.neighborMap.get(faceIndex, j);\r\n            }\r\n        }\r\n        console.log(this.mesh.links.getRow(faceIndex));\r\n        console.log(commonEdge);\r\n        throw \"common edge does not match triangle index!\";\r\n    }\r\n    getFacePoints(tr, uv) {\r\n        let pointIds = this.mesh.links.getRow(tr);\r\n        if (uv) {\r\n            return [\r\n                this.uvs.get(pointIds[0]),\r\n                this.uvs.get(pointIds[1]),\r\n                this.uvs.get(pointIds[2]),\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                this.mesh.verts.get(pointIds[0]),\r\n                this.mesh.verts.get(pointIds[1]),\r\n                this.mesh.verts.get(pointIds[2]),\r\n            ];\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/mesh/topo-mesh.ts?");

/***/ }),

/***/ "../engine/src/render-low/attribute.ts":
/*!*********************************************!*\
  !*** ../engine/src/render-low/attribute.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Attribute\": () => (/* binding */ Attribute),\n/* harmony export */   \"IndexAttribute\": () => (/* binding */ IndexAttribute)\n/* harmony export */ });\n// Purpose: I was getting sick of dealing with separate widths, buffers & positions, even though these values are tied together :)\r\n/**\r\n * Wrapper for a webgl buffer attibute\r\n */\r\nclass Attribute {\r\n    constructor(gl, buffer, position, width, type) {\r\n        this.gl = gl;\r\n        this.buffer = buffer;\r\n        this.position = position;\r\n        this.width = width;\r\n        this.type = type;\r\n    }\r\n    static new(gl, program, name, matrixWidth) {\r\n        let position = gl.getAttribLocation(program, name);\r\n        let buffer = gl.createBuffer();\r\n        return new Attribute(gl, buffer, position, matrixWidth, gl.FLOAT);\r\n    }\r\n    /**\r\n     *  Load some new data into this attribute\r\n     */\r\n    set(gl, data, speed) {\r\n        // TODO experiment with switching these two\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        gl.enableVertexAttribArray(this.position);\r\n        gl.vertexAttribPointer(this.position, this.width, this.type, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, data, speed);\r\n    }\r\n    /**\r\n     * Enable the attribute / activate it, but do not set any data\r\n     * Must be called before rendering\r\n     */\r\n    load(gl) {\r\n        gl.enableVertexAttribArray(this.position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);\r\n        gl.vertexAttribPointer(this.position, this.width, this.type, false, 0, 0);\r\n    }\r\n}\r\n/**\r\n * Wrapper for a webgl index buffer\r\n */\r\nclass IndexAttribute {\r\n    constructor(gl, buffer, type) {\r\n        this.gl = gl;\r\n        this.buffer = buffer;\r\n        this.type = type;\r\n    }\r\n    static new(gl, type) {\r\n        let buffer = gl.createBuffer();\r\n        return new IndexAttribute(gl, buffer, type);\r\n    }\r\n    set(gl, data, speed) {\r\n        // experiment with switching these two\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, speed);\r\n    }\r\n    load(gl) {\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/attribute.ts?");

/***/ }),

/***/ "../engine/src/render-low/attributes.ts":
/*!**********************************************!*\
  !*** ../engine/src/render-low/attributes.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Attributes\": () => (/* binding */ Attributes)\n/* harmony export */ });\n/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attribute */ \"../engine/src/render-low/attribute.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ \"../engine/src/render-low/constants.ts\");\n\r\n\r\n/**\r\n * all attributes corresponding to one GL program.\r\n */\r\nclass Attributes {\r\n    constructor(gl, program, attributes = new Map()) {\r\n        this.gl = gl;\r\n        this.program = program;\r\n        this.attributes = attributes;\r\n    }\r\n    add(name, width) {\r\n        this.attributes.set(name, _attribute__WEBPACK_IMPORTED_MODULE_0__.Attribute.new(this.gl, this.program, name, width));\r\n    }\r\n    has(name) {\r\n        return this.attributes.has(name);\r\n    }\r\n    addIndex(type) {\r\n        this.attributes.set(_constants__WEBPACK_IMPORTED_MODULE_1__.INDEX_BUFFER_NAME, _attribute__WEBPACK_IMPORTED_MODULE_0__.IndexAttribute.new(this.gl, type));\r\n    }\r\n    set(name, data, speed) {\r\n        this.attributes.get(name).set(this.gl, data, speed);\r\n    }\r\n    /**\r\n     * Load the state of all attributes, to prepare for rendering\r\n     */\r\n    loadAll() {\r\n        for (let [k, v] of this.attributes) {\r\n            v.load(this.gl);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/attributes.ts?");

/***/ }),

/***/ "../engine/src/render-low/constants.ts":
/*!*********************************************!*\
  !*** ../engine/src/render-low/constants.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ClearBufferBit\": () => (/* binding */ ClearBufferBit),\n/* harmony export */   \"DrawMode\": () => (/* binding */ DrawMode),\n/* harmony export */   \"DrawMethod\": () => (/* binding */ DrawMethod),\n/* harmony export */   \"DrawElementsType\": () => (/* binding */ DrawElementsType),\n/* harmony export */   \"DataType\": () => (/* binding */ DataType),\n/* harmony export */   \"TEXTURE_2D\": () => (/* binding */ TEXTURE_2D),\n/* harmony export */   \"INDEX_BUFFER_NAME\": () => (/* binding */ INDEX_BUFFER_NAME)\n/* harmony export */ });\n// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\r\n// I will add everything eventually\r\nvar ClearBufferBit;\r\n(function (ClearBufferBit) {\r\n    ClearBufferBit[ClearBufferBit[\"Depth\"] = 256] = \"Depth\";\r\n    ClearBufferBit[ClearBufferBit[\"Stencil\"] = 1024] = \"Stencil\";\r\n    ClearBufferBit[ClearBufferBit[\"Color\"] = 16384] = \"Color\";\r\n})(ClearBufferBit || (ClearBufferBit = {}));\r\nvar DrawMode;\r\n(function (DrawMode) {\r\n    DrawMode[DrawMode[\"Points\"] = 0] = \"Points\";\r\n    DrawMode[DrawMode[\"Lines\"] = 1] = \"Lines\";\r\n    DrawMode[DrawMode[\"LineLoop\"] = 2] = \"LineLoop\";\r\n    DrawMode[DrawMode[\"LineStrip\"] = 3] = \"LineStrip\";\r\n    DrawMode[DrawMode[\"Triangles\"] = 4] = \"Triangles\";\r\n    DrawMode[DrawMode[\"TriangleStrip\"] = 5] = \"TriangleStrip\";\r\n    DrawMode[DrawMode[\"TriangleFan\"] = 6] = \"TriangleFan\";\r\n})(DrawMode || (DrawMode = {}));\r\nvar DrawMethod;\r\n(function (DrawMethod) {\r\n    DrawMethod[DrawMethod[\"Arrays\"] = 0] = \"Arrays\";\r\n    DrawMethod[DrawMethod[\"Elements\"] = 1] = \"Elements\";\r\n})(DrawMethod || (DrawMethod = {}));\r\nvar DrawElementsType;\r\n(function (DrawElementsType) {\r\n    DrawElementsType[DrawElementsType[\"UnsignedByte\"] = 5121] = \"UnsignedByte\";\r\n    DrawElementsType[DrawElementsType[\"UnsignedShort\"] = 5123] = \"UnsignedShort\";\r\n    DrawElementsType[DrawElementsType[\"UnsignedInt\"] = 5125] = \"UnsignedInt\";\r\n})(DrawElementsType || (DrawElementsType = {}));\r\nvar DataType;\r\n(function (DataType) {\r\n    DataType[DataType[\"Byte\"] = 5120] = \"Byte\";\r\n    DataType[DataType[\"UnsignedByte\"] = 5121] = \"UnsignedByte\";\r\n    DataType[DataType[\"Short\"] = 5122] = \"Short\";\r\n    DataType[DataType[\"UnsignedShort\"] = 5123] = \"UnsignedShort\";\r\n    DataType[DataType[\"Int\"] = 5124] = \"Int\";\r\n    DataType[DataType[\"UnsignedInt\"] = 5125] = \"UnsignedInt\";\r\n    DataType[DataType[\"Float\"] = 5126] = \"Float\";\r\n})(DataType || (DataType = {}));\r\nconst TEXTURE_2D = 0x0DE1;\r\nconst INDEX_BUFFER_NAME = \"__index__\";\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/constants.ts?");

/***/ }),

/***/ "../engine/src/render-low/program.ts":
/*!*******************************************!*\
  !*** ../engine/src/render-low/program.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Program\": () => (/* binding */ Program)\n/* harmony export */ });\n/* harmony import */ var _attributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attributes */ \"../engine/src/render-low/attributes.ts\");\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniforms */ \"../engine/src/render-low/uniforms.ts\");\n/* harmony import */ var _webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl */ \"../engine/src/render-low/webgl.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"../engine/src/render-low/constants.ts\");\n// shader.ts\r\n// author: Jos Feenstra\r\n// credits to : https://webglfundamentals.org/\r\n// note: im still figuring out how to organize this\r\n// TODO: incorrect terminology: this is not a Shader, this is a ShaderSet, ShaderDuo, or something like that\r\n// still tho, within a larger context, the whole of a fragment & vertex shader can be named Shader for the time being...\r\n\r\n\r\n\r\n\r\n/**\r\n * An implementation of 'program' needs to define 4 methods:\r\n * @param T = data to feed the renderer at 'set'\r\n * 1. `constructor`\r\n *    - state the vertex & fragment shader\r\n *    - init all uniforms, state which ones should be exposed publicly\r\n *    - explain how 'S' set the uniforms, possibly\r\n *    - DO NOT INIT ATTRIBUTES IN HERE\r\n *\r\n * 2. `onInit`\r\n *    - init all attributes\r\n *    - return the 'DrawMode' which needs to be used to draw this shader\r\n *\r\n * 2. `onSet`\r\n *    - explain how 'T' set the attributes\r\n *    - return a number representing how many 'drawmode' features need to be drawn\r\n *\r\n * 3. `onRender`\r\n *    - explain how 'Context' needs to be loaded into this shader\r\n *    - call 'loadAll()' on both attributes & uniforms\r\n *    - render using either 'DrawArrays()' or 'DrawElements()' (TODO could get some more automation)\r\n */\r\nclass Program {\r\n    constructor(gl, vertexScript, fragmentScript) {\r\n        // auto set\r\n        this.draw = () => { };\r\n        this.method = _constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Arrays;\r\n        this.mode = _constants__WEBPACK_IMPORTED_MODULE_3__.DrawMode.Triangles;\r\n        this.drawCount = 0; // number of times the shaders need to render\r\n        this.drawOffset = 0;\r\n        this.gl = gl;\r\n        this.program = _webgl__WEBPACK_IMPORTED_MODULE_2__.HelpGl.createProgramFromScripts(gl, vertexScript, fragmentScript);\r\n        this.init();\r\n    }\r\n    init(settings) {\r\n        this.gl.useProgram(this.program);\r\n        this.uniforms = new _uniforms__WEBPACK_IMPORTED_MODULE_1__.Uniforms(this.gl, this.program);\r\n        this.attributes = new _attributes__WEBPACK_IMPORTED_MODULE_0__.Attributes(this.gl, this.program);\r\n        this.drawCount = 0;\r\n        this.mode = this.onInit(settings);\r\n        this.setDrawMethod();\r\n    }\r\n    set(r, speed) {\r\n        this.gl.useProgram(this.program);\r\n        this.drawCount = this.onSet(r, speed);\r\n    }\r\n    render(c) {\r\n        this.gl.useProgram(this.program);\r\n        this.onRender(c);\r\n        this.uniforms.loadAll();\r\n        this.attributes.loadAll();\r\n        this.draw();\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n    // ---------------------------------------------------------------------------\r\n    setDrawMethod() {\r\n        if (this.attributes.has(_constants__WEBPACK_IMPORTED_MODULE_3__.INDEX_BUFFER_NAME)) {\r\n            this.method = _constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Elements;\r\n            this.draw = this.drawElements;\r\n        }\r\n        else {\r\n            this.method = _constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Arrays;\r\n            this.draw = this.drawArrays;\r\n        }\r\n    }\r\n    drawElements() {\r\n        this.gl.drawElements(this.mode, this.drawCount, this.elementType, this.drawOffset);\r\n    }\r\n    drawArrays() {\r\n        this.gl.drawArrays(this.mode, this.drawOffset, this.drawCount);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/program.ts?");

/***/ }),

/***/ "../engine/src/render-low/shader.ts":
/*!******************************************!*\
  !*** ../engine/src/render-low/shader.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shader\": () => (/* binding */ Shader)\n/* harmony export */ });\n/* harmony import */ var _attributes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./attributes */ \"../engine/src/render-low/attributes.ts\");\n/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uniforms */ \"../engine/src/render-low/uniforms.ts\");\n/* harmony import */ var _webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl */ \"../engine/src/render-low/webgl.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"../engine/src/render-low/constants.ts\");\n// shader.ts\r\n// author: Jos Feenstra\r\n// credits to : https://webglfundamentals.org/\r\n// note: im still figuring out how to organize this\r\n// TODO: incorrect terminology: this is not a Shader, this is a ShaderSet, ShaderDuo, or something like that\r\n// still tho, within a larger context, the whole of a fragment & vertex shader can be named Shader for the time being...\r\n// This is old, not needed anymore\r\n\r\n\r\n\r\n\r\n/**\r\n * An implementation of 'Shader' needs to define 3 methods:\r\n *\r\n * 1. `constructor`\r\n *    - state the vertex & fragment shader\r\n *    - init all uniforms, state which ones should be exposed publicly (TODO could be automated...)\r\n *    - init all attributes (TODO could be automated...)\r\n * 2. `Set`\r\n *    - explain how 'T' set the attributes\r\n *    - give a number to 'this.drawCount'\r\n * 3. `Render`\r\n *    - explain how 'Context' needs to be loaded into this shader\r\n *    - call 'loadAll()' on both attributes & uniforms\r\n *    - render using either 'DrawArrays()' or 'DrawElements()' (TODO could get some more automation)\r\n */\r\n// @param T = data to feed the renderer at 'set'\r\nclass Shader {\r\n    constructor(gl, vertexScript, fragmentScript) {\r\n        // auto set\r\n        this.draw = () => { };\r\n        this.method = _constants__WEBPACK_IMPORTED_MODULE_3__.DrawMethod.Arrays;\r\n        this.mode = _constants__WEBPACK_IMPORTED_MODULE_3__.DrawMode.Triangles;\r\n        this.drawCount = 0; // number of times the shaders need to render\r\n        this.drawOffset = 0;\r\n        this.gl = gl;\r\n        this.program = _webgl__WEBPACK_IMPORTED_MODULE_2__.HelpGl.createProgramFromScripts(gl, vertexScript, fragmentScript);\r\n        this.uniforms = new _uniforms__WEBPACK_IMPORTED_MODULE_1__.Uniforms(this.gl, this.program);\r\n        this.attributes = new _attributes__WEBPACK_IMPORTED_MODULE_0__.Attributes(this.gl, this.program);\r\n        this.drawCount = 0;\r\n        gl.useProgram(this.program);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _webgl__WEBPACK_IMPORTED_MODULE_2__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n    setDrawCount(drawCount) {\r\n        this.drawCount = drawCount;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/shader.ts?");

/***/ }),

/***/ "../engine/src/render-low/uniform.ts":
/*!*******************************************!*\
  !*** ../engine/src/render-low/uniform.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UniformType\": () => (/* binding */ UniformType),\n/* harmony export */   \"Uniform\": () => (/* binding */ Uniform),\n/* harmony export */   \"UniformTexture\": () => (/* binding */ UniformTexture)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"../engine/src/render-low/constants.ts\");\n/* harmony import */ var _webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl */ \"../engine/src/render-low/webgl.ts\");\n\r\n\r\nvar UniformType;\r\n(function (UniformType) {\r\n    UniformType[UniformType[\"Float\"] = 0] = \"Float\";\r\n    UniformType[UniformType[\"Int\"] = 1] = \"Int\";\r\n})(UniformType || (UniformType = {}));\r\nclass Uniform {\r\n    constructor(type, size, loc, setter, state) {\r\n        this.type = type;\r\n        this.size = size;\r\n        this.loc = loc;\r\n        this.setter = setter;\r\n        this.state = state;\r\n    }\r\n    static new(gl, program, name, type, size, initState) {\r\n        let setter = determineSetter(gl, type, size);\r\n        let loc = gl.getUniformLocation(program, name);\r\n        return new Uniform(type, size, loc, setter, initState);\r\n    }\r\n    set(state) {\r\n        this.state = state;\r\n    }\r\n    load(gl) {\r\n        this.setter(gl, this.loc, this.state);\r\n    }\r\n}\r\n/**\r\n * Note: arguments can be made for splitting up 'uniform' & 'texture'\r\n */\r\nclass UniformTexture {\r\n    constructor(gl, id, texture, loc) {\r\n        this.gl = gl;\r\n        this.id = id;\r\n        this.texture = texture;\r\n        this.loc = loc;\r\n    }\r\n    static new(gl, program, name) {\r\n        let location = gl.getUniformLocation(program, name);\r\n        let id = _webgl__WEBPACK_IMPORTED_MODULE_1__.HelpGl.getNextTextureID();\r\n        let texture = gl.createTexture();\r\n        return new UniformTexture(gl, id, texture, location);\r\n    }\r\n    set(source) {\r\n        this.gl.activeTexture(this.gl.TEXTURE0 + this.id);\r\n        this.gl.bindTexture(_constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, this.texture);\r\n        this.gl.texImage2D(_constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, source);\r\n        // alternative texture -> Fill the texture with a 1x1 blue pixel.\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 128, 128, 255]));\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, mesh.texture.data);\r\n        this.gl.texParameteri(_constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\r\n        this.gl.generateMipmap(_constants__WEBPACK_IMPORTED_MODULE_0__.TEXTURE_2D);\r\n    }\r\n    load(gl) {\r\n        gl.uniform1i(this.loc, this.id);\r\n        gl.activeTexture(gl.TEXTURE0 + this.id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n    }\r\n}\r\nfunction determineSetter(gl, type, size) {\r\n    switch (size) {\r\n        case 1:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform1fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform1fv(loc, state);\r\n                };\r\n            }\r\n        case 2:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform2fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform2fv(loc, state);\r\n                };\r\n            }\r\n        case 3:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform3fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform3fv(loc, state);\r\n                };\r\n            }\r\n        case 4:\r\n            if (type == UniformType.Float) {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform4fv(loc, state);\r\n                };\r\n            }\r\n            else {\r\n                return (gl, loc, state) => {\r\n                    gl.uniform4fv(loc, state);\r\n                };\r\n            }\r\n        case 9:\r\n            return (gl, loc, state) => {\r\n                gl.uniformMatrix3fv(loc, false, state);\r\n            };\r\n        case 16:\r\n            return (gl, loc, state) => {\r\n                gl.uniformMatrix4fv(loc, false, state);\r\n            };\r\n        default:\r\n            return (gl, loc, state) => {\r\n                console.error(\"could not set a certain uniform...\");\r\n            };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/uniform.ts?");

/***/ }),

/***/ "../engine/src/render-low/uniforms.ts":
/*!********************************************!*\
  !*** ../engine/src/render-low/uniforms.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Uniforms\": () => (/* binding */ Uniforms)\n/* harmony export */ });\n/* harmony import */ var _uniform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uniform */ \"../engine/src/render-low/uniform.ts\");\n\r\n/**\r\n * all uniforms corresponding to one GL program.\r\n */\r\nclass Uniforms {\r\n    constructor(gl, program, uniforms = new Map(), textures = new Map()) {\r\n        this.gl = gl;\r\n        this.program = program;\r\n        this.uniforms = uniforms;\r\n        this.textures = textures;\r\n    }\r\n    add(name, size, state = [], type = _uniform__WEBPACK_IMPORTED_MODULE_0__.UniformType.Float) {\r\n        let uniform = _uniform__WEBPACK_IMPORTED_MODULE_0__.Uniform.new(this.gl, this.program, name, type, size, state);\r\n        this.uniforms.set(name, uniform);\r\n        return uniform;\r\n    }\r\n    addTexture(name) {\r\n        let texture = _uniform__WEBPACK_IMPORTED_MODULE_0__.UniformTexture.new(this.gl, this.program, name);\r\n        this.textures.set(name, texture);\r\n        return texture;\r\n    }\r\n    setTexture(name, source) {\r\n        this.textures.get(name).set(source.toImageData());\r\n    }\r\n    setTextureSource(name, source) {\r\n        this.textures.get(name).set(source);\r\n    }\r\n    set(name, value) {\r\n        this.get(name).set([value]);\r\n    }\r\n    set2(name, value) {\r\n        this.get(name).set([value.x, value.y]);\r\n    }\r\n    set3(name, value) {\r\n        this.get(name).set([value.x, value.y, value.z]);\r\n    }\r\n    set4(name, value) {\r\n        this.get(name).set(value);\r\n    }\r\n    setMatrix3(name, value) {\r\n        this.get(name).set(value.data);\r\n    }\r\n    setMatrix4(name, value) {\r\n        this.get(name).set(value.data);\r\n    }\r\n    get(name) {\r\n        return this.uniforms.get(name);\r\n    }\r\n    /**\r\n     * Load the state of all uniforms, to prepare for rendering\r\n     */\r\n    loadAll() {\r\n        for (let v of this.uniforms.values()) {\r\n            v.load(this.gl);\r\n        }\r\n        for (let v of this.textures.values()) {\r\n            v.load(this.gl);\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/uniforms.ts?");

/***/ }),

/***/ "../engine/src/render-low/webgl.ts":
/*!*****************************************!*\
  !*** ../engine/src/render-low/webgl.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawSpeed\": () => (/* binding */ DrawSpeed),\n/* harmony export */   \"HelpGl\": () => (/* binding */ HelpGl)\n/* harmony export */ });\n// purpose : webgl wrapping & helper functions\r\nvar nextTextureId = 0;\r\nvar rendercallsperframe = 0;\r\n// TODO move this to 'constants.ts' and refactor everything again :)\r\nvar DrawSpeed;\r\n(function (DrawSpeed) {\r\n    DrawSpeed[DrawSpeed[\"StreamDraw\"] = 35040] = \"StreamDraw\";\r\n    DrawSpeed[DrawSpeed[\"StaticDraw\"] = 35044] = \"StaticDraw\";\r\n    DrawSpeed[DrawSpeed[\"DynamicDraw\"] = 35048] = \"DynamicDraw\";\r\n})(DrawSpeed || (DrawSpeed = {}));\r\nclass HelpGl {\r\n    constructor() { }\r\n    static new() { }\r\n    /**\r\n     * We need to keep track of all textures in the entire webgl application\r\n     */\r\n    static getNextTextureID() {\r\n        let id = nextTextureId;\r\n        nextTextureId += 1;\r\n        return id;\r\n    }\r\n    static resizeCanvas(gl) {\r\n        // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n        let canvas = gl.canvas;\r\n        const displayWidth = canvas.clientWidth;\r\n        const displayHeight = canvas.clientHeight;\r\n        // Check if the canvas is not the same size.\r\n        const needResize = gl.canvas.width !== displayWidth || gl.canvas.height !== displayHeight;\r\n        if (needResize) {\r\n            // Make the canvas the same size\r\n            gl.canvas.width = displayWidth;\r\n            gl.canvas.height = displayHeight;\r\n        }\r\n        // Tell WebGL how to convert from clip space to pixels\r\n        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n        return needResize;\r\n    }\r\n    static initWebglContext(canvas, blend = false) {\r\n        let possiblyGl = canvas.getContext(\"webgl\");\r\n        if (possiblyGl == undefined) {\r\n            console.log(\"webgl unavailable...\");\r\n        }\r\n        let gl = possiblyGl;\r\n        gl.enable(gl.CULL_FACE);\r\n        if (blend) {\r\n            gl.enable(gl.BLEND);\r\n            gl.disable(gl.DEPTH_TEST);\r\n            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        }\r\n        else {\r\n            gl.disable(gl.BLEND);\r\n            gl.enable(gl.DEPTH_TEST);\r\n            gl.depthFunc(gl.LEQUAL);\r\n        }\r\n        // extensions\r\n        let ext = gl.getExtension(\"OES_element_index_uint\");\r\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        gl.clearDepth(1);\r\n        return gl;\r\n    }\r\n    static compileShader(gl, shaderSource, shaderType) {\r\n        let shader = gl.createShader(shaderType);\r\n        gl.shaderSource(shader, shaderSource);\r\n        gl.compileShader(shader);\r\n        let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\r\n        if (!success) {\r\n            throw \"could not compile shader:\" + shaderSource + gl.getShaderInfoLog(shader);\r\n        }\r\n        return shader;\r\n    }\r\n    static createProgram(gl, vertexShader, fragmentShader) {\r\n        let program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n        let success = gl.getProgramParameter(program, gl.LINK_STATUS);\r\n        if (!success) {\r\n            throw \"program failed to link:\" + gl.getProgramInfoLog(program);\r\n        }\r\n        return program;\r\n    }\r\n    static createProgramFromScripts(gl, vertexScript, fragmentScript) {\r\n        let vertexShader = HelpGl.compileShader(gl, vertexScript, gl.VERTEX_SHADER);\r\n        let fragmentShader = HelpGl.compileShader(gl, fragmentScript, gl.FRAGMENT_SHADER);\r\n        return HelpGl.createProgram(gl, vertexShader, fragmentShader);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render-low/webgl.ts?");

/***/ }),

/***/ "../engine/src/render/camera.ts":
/*!**************************************!*\
  !*** ../engine/src/render/camera.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Camera\": () => (/* binding */ Camera)\n/* harmony export */ });\n/* harmony import */ var _geo_plane__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geo/plane */ \"../engine/src/geo/plane.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/math */ \"../engine/src/math/math.ts\");\n/* harmony import */ var _math_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/matrix */ \"../engine/src/math/matrix.ts\");\n/* harmony import */ var _math_ray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/ray */ \"../engine/src/math/ray.ts\");\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n// author : Jos Feenstra\r\n// purpose : contain all logic regarding\r\n\r\n\r\n\r\n\r\n\r\nclass Camera {\r\n    constructor(canvas, z_offset = 1, canMove = false, canControl = true) {\r\n        this.angleAlpha = 0; // rotation x\r\n        this.angleBeta = 0; // rotation y\r\n        this.mousePos = _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector2.zero();\r\n        // camera matrix properties\r\n        this.fov = (20 * Math.PI) / 100;\r\n        this.zFar = 10000;\r\n        this.zNear = 0.01;\r\n        // other consts\r\n        this.speed = 1;\r\n        this.worldPlane = _geo_plane__WEBPACK_IMPORTED_MODULE_0__.Plane.WorldXY();\r\n        this.canMove = canMove;\r\n        this.canControl = canControl;\r\n        this.pos = new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);\r\n        this.z_offset = -z_offset;\r\n        this.offset = new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, -z_offset);\r\n        this.updateMatrices(canvas);\r\n    }\r\n    new(canvas, zOffset = 1, canMove = false) {\r\n        return new Camera(canvas, zOffset, canMove);\r\n    }\r\n    update(state) {\r\n        this.updateControls(state);\r\n        this.updateMatrices(state.canvas);\r\n        this.updateClick(state);\r\n        if (state.IsKeyPressed(\"p\")) {\r\n            console.log(`camera state: [${this.pos.x.toPrecision(5)}, ${this.pos.y.toPrecision(5)}, ${this.pos.z.toPrecision(5)}, ${this.z_offset}, ${this.angleAlpha},${this.angleBeta}]`);\r\n            // console.log(\r\n            //     `printing camera status.\r\n            //     pos: ${this.pos},\r\n            //     offset: ${this.offset},\r\n            //     speed: ${this.speed},\r\n            //     alpha ${this.angleAlpha},\r\n            //     beta: ${this.angleBeta}`,\r\n            // );\r\n            console.log(\"speed is now: \" + this.speed);\r\n        }\r\n    }\r\n    // just a quick way of getting & setting\r\n    getState() {\r\n        return [this.pos.x, this.pos.y, this.pos.z, this.z_offset, this.angleAlpha, this.angleBeta];\r\n    }\r\n    setState(state) {\r\n        this.pos.x = state[0];\r\n        this.pos.y = state[1];\r\n        this.pos.z = state[2];\r\n        this.z_offset = state[3];\r\n        this.angleAlpha = state[4];\r\n        this.angleBeta = state[5];\r\n    }\r\n    set(offset, alpha, beta) {\r\n        this.z_offset = offset;\r\n        this.angleAlpha = alpha;\r\n        this.angleBeta = beta;\r\n    }\r\n    updateMatrices(canvas) {\r\n        this.worldMatrix = this.getWorldMatrix();\r\n        this.projectMatrix = this.getProjectionMatrix(canvas);\r\n        this.totalMatrix = this.worldMatrix.multiplied(this.projectMatrix);\r\n    }\r\n    lookat(position, target) {\r\n        // set matrices to the thing\r\n        let matrix = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newLookAt(position, target, this.worldPlane.khat);\r\n    }\r\n    updateClick(state) {\r\n        // todo\r\n    }\r\n    updateControls(state) {\r\n        if (!this.canControl) {\r\n            return;\r\n        }\r\n        let deltaScroll = state.scrollValue * 1.2;\r\n        this.offset.z = Math.min(-0.001, this.z_offset - deltaScroll);\r\n        if (state.IsKeyPressed(\"shift\")) {\r\n            this.speed *= 2;\r\n        }\r\n        if (state.IsKeyPressed(\"control\")) {\r\n            this.speed = Math.max(this.speed * 0.5, 0.1);\r\n        }\r\n        // deal with mouse\r\n        let prevPos = this.mousePos.clone();\r\n        this.mousePos = state.mousePos.clone();\r\n        let delta = prevPos.clone().sub(this.mousePos);\r\n        this.getMouseWorldRay(state.canvas.width, state.canvas.height);\r\n        if (state.mouseRightDown) {\r\n            this.angleAlpha = _math_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(this.angleAlpha + delta.y * 0.01, 0, Math.PI);\r\n            this.angleBeta += delta.x * -0.01;\r\n        }\r\n        function relativeUnitY(angle) {\r\n            let m = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newZRotation(angle);\r\n            return m.multiplyVector(_math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3.unitY());\r\n        }\r\n        function relativeUnitX(angle) {\r\n            let m = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newZRotation(angle);\r\n            return m.multiplyVector(_math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3.unitX());\r\n        }\r\n        if (!this.canMove) {\r\n            return;\r\n        }\r\n        if (state.IsKeyDown(\"s\"))\r\n            this.pos.add(relativeUnitY(-this.angleBeta).scale(0.01 * this.speed));\r\n        if (state.IsKeyDown(\"w\"))\r\n            this.pos.add(relativeUnitY(-this.angleBeta).scale(-0.01 * this.speed));\r\n        if (state.IsKeyDown(\"a\"))\r\n            this.pos.add(relativeUnitX(-this.angleBeta).scale(0.01 * this.speed));\r\n        if (state.IsKeyDown(\"d\"))\r\n            this.pos.add(relativeUnitX(-this.angleBeta).scale(-0.01 * this.speed));\r\n        if (state.IsKeyDown(\"q\"))\r\n            this.pos.z += 0.01 * this.speed;\r\n        if (state.IsKeyDown(\"e\"))\r\n            this.pos.z -= 0.01 * this.speed;\r\n    }\r\n    getCameraPoint() {\r\n        return this.worldMatrix.inverse().multiplyVector(new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0));\r\n    }\r\n    getMouseWorldRay(canvasWidth, canvasHeight, useMouse = true) {\r\n        // get a ray from origin through mousepos\r\n        // mouse unit screen position:\r\n        //       -------------- -0.5\r\n        //       |            |\r\n        //       |      .(0,0)|\r\n        //       |            |\r\n        //       -------------- 0.5\r\n        //     -0.72        0.72\r\n        //    (0.72 = 0.5 * aspect)\r\n        //\r\n        let size = 0.5; // size indicator of the fustrum\r\n        let mp = this.mousePos;\r\n        let aspect = canvasWidth / canvasHeight;\r\n        let mouseUnitX = (-size + mp.x / canvasWidth) * aspect;\r\n        let mouseUnitY = -size + mp.y / canvasHeight;\r\n        let f = size / Math.tan(this.fov / 2); // focal length\r\n        let invWorld = this.worldMatrix.inverse();\r\n        let origin = invWorld.multiplyVector(new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0));\r\n        // TODO instead of doing this, just extract the x, y, and z columns of invWorld\r\n        let iDestiny = invWorld.multiplyVector(new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(1, 0, 0));\r\n        let jDestiny = invWorld.multiplyVector(new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0));\r\n        let kDestiny = invWorld.multiplyVector(new _math_vector__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, -1));\r\n        let ihat = iDestiny.sub(origin).normalize();\r\n        let jhat = jDestiny.sub(origin).normalize();\r\n        let khat = kDestiny.sub(origin).normalize();\r\n        // pardon this insanely ugly statement\r\n        let screenPoint = useMouse\r\n            ? origin\r\n                .added(khat.scaled(f))\r\n                .add(ihat.scaled(mouseUnitX))\r\n                .add(jhat.scaled(-mouseUnitY))\r\n            : origin.added(khat.scaled(f));\r\n        return _math_ray__WEBPACK_IMPORTED_MODULE_3__.Ray.fromPoints(origin, screenPoint);\r\n    }\r\n    getWorldMatrix() {\r\n        let offset = this.offset;\r\n        let angleA = this.angleAlpha;\r\n        let angleB = this.angleBeta;\r\n        // translate so z means 'up'\r\n        let yzFlip = new _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4([1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\r\n        // translated to fit screen\r\n        let position = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newTranslation(this.pos.x, this.pos.y, this.pos.z);\r\n        let mOffset = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newTranslation(offset.x, offset.y, offset.z);\r\n        // rotated by user\r\n        let x_rotation = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newXRotation(angleA);\r\n        let z_rotation = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newZRotation(angleB);\r\n        let rotation = z_rotation.multiply(x_rotation);\r\n        // let transform = mOffset.multiply(rotation).multiply(position);\r\n        let transform = position.multiply(rotation).multiply(mOffset);\r\n        return transform;\r\n    }\r\n    getProjectionMatrix(canvas) {\r\n        // aspects\r\n        let aspect = canvas.width / canvas.height; // note: this should be constant\r\n        // let z_plane = -1. / Math.tan(pi / 8.);\r\n        // projection to screen\r\n        // let projection = Matrix4.newOrthographic(-1, 1, -1, 1, 0.1, 0.1);\r\n        let projection = _math_matrix__WEBPACK_IMPORTED_MODULE_2__.Matrix4.newPerspective(this.fov, aspect, this.zNear, this.zFar);\r\n        return projection;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render/camera.ts?");

/***/ }),

/***/ "../engine/src/render/context.ts":
/*!***************************************!*\
  !*** ../engine/src/render/context.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Context\": () => (/* binding */ Context)\n/* harmony export */ });\nclass Context {\r\n    constructor(camera) {\r\n        this.camera = camera;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render/context.ts?");

/***/ }),

/***/ "../engine/src/render/light.ts":
/*!*************************************!*\
  !*** ../engine/src/render/light.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Light\": () => (/* binding */ Light)\n/* harmony export */ });\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n// Name:    scene.ts\r\n// Author:  Jos Feenstra\r\n// NOTE:    not used yet \r\n\r\nclass Light {\r\n    constructor(pos, color, spot, dir) {\r\n        this.pos = pos;\r\n        this.color = color;\r\n        this.spot = spot;\r\n        this.dir = dir;\r\n    }\r\n    static new(pos, color = [1, 1, 1, 1]) {\r\n        return new Light(pos, color, false, _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector3.zero());\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render/light.ts?");

/***/ }),

/***/ "../engine/src/render/multi-shader.ts":
/*!********************************************!*\
  !*** ../engine/src/render/multi-shader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiShader\": () => (/* binding */ MultiShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n\r\nclass MultiShader {\r\n    setAndRender(r, context) {\r\n        this.set(r, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/render/multi-shader.ts?");

/***/ }),

/***/ "../engine/src/renderers/multi-renderer.ts":
/*!*************************************************!*\
  !*** ../engine/src/renderers/multi-renderer.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MultiRenderer\": () => (/* binding */ MultiRenderer)\n/* harmony export */ });\n/* harmony import */ var _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../data/multi-vector-3 */ \"../engine/src/data/multi-vector-3.ts\");\n/* harmony import */ var _geo_curve_curve__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geo/curve/curve */ \"../engine/src/geo/curve/curve.ts\");\n/* harmony import */ var _geo_curve_polyline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geo/curve/polyline */ \"../engine/src/geo/curve/polyline.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _math_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/random */ \"../engine/src/math/random.ts\");\n/* harmony import */ var _mesh_mesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../mesh/mesh */ \"../engine/src/mesh/mesh.ts\");\n/* harmony import */ var _mesh_multi_line__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../mesh/multi-line */ \"../engine/src/mesh/multi-line.ts\");\n/* harmony import */ var _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../mesh/shader-mesh */ \"../engine/src/mesh/shader-mesh.ts\");\n/* harmony import */ var _shaders_dot_shader__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shaders/dot-shader */ \"../engine/src/shaders/dot-shader.ts\");\n/* harmony import */ var _shaders_line_shader__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../shaders/line-shader */ \"../engine/src/shaders/line-shader.ts\");\n/* harmony import */ var _shaders_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../shaders/mesh-debug-shader */ \"../engine/src/shaders/mesh-debug-shader.ts\");\n/* harmony import */ var _shaders_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../shaders/shaded-mesh-shader */ \"../engine/src/shaders/shaded-mesh-shader.ts\");\n// purpose: something that is willing to create new Shaders on the fly, to render whatever it gets\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MultiRenderer {\r\n    constructor(gl, shaders) {\r\n        this.gl = gl;\r\n        this.shaders = shaders;\r\n    }\r\n    static new(gl) {\r\n        return new MultiRenderer(gl, new Map());\r\n    }\r\n    set(unit, key) {\r\n        if (!key) {\r\n            key = (0,_math_random__WEBPACK_IMPORTED_MODULE_4__.createRandomGUID)();\r\n        }\r\n        let shader = this.shaders.get(key);\r\n        if (!shader) {\r\n            return this.addShader(key, unit);\r\n        }\r\n        // If the type definitions above are set correctly\r\n        // and if the 'add' procedure went correctly, this will work\r\n        //@ts-ignore\r\n        shader === null || shader === void 0 ? void 0 : shader.set(unit);\r\n        return shader;\r\n    }\r\n    render(c) {\r\n        for (let [key, shader] of this.shaders) {\r\n            shader.render(c);\r\n        }\r\n    }\r\n    addShader(key, unit) {\r\n        let shader;\r\n        let gl = this.gl;\r\n        // determine the RenderableUnit type\r\n        // rely as much on the defaults as possilbe\r\n        if (unit instanceof _data_multi_vector_3__WEBPACK_IMPORTED_MODULE_0__.MultiVector3) {\r\n            shader = new _shaders_dot_shader__WEBPACK_IMPORTED_MODULE_8__.DotShader(gl);\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _mesh_shader_mesh__WEBPACK_IMPORTED_MODULE_7__.ShaderMesh) {\r\n            shader = new _shaders_shaded_mesh_shader__WEBPACK_IMPORTED_MODULE_11__.ShadedMeshShader(gl);\r\n            shader.set(unit);\r\n        }\r\n        else if (unit instanceof _mesh_mesh__WEBPACK_IMPORTED_MODULE_5__.Mesh) {\r\n            shader = new _shaders_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_10__.MeshDebugShader(gl);\r\n            let smesh = unit.ToShaderMesh();\r\n            shader.set(smesh);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.BiSurface) {\r\n            shader = new _shaders_mesh_debug_shader__WEBPACK_IMPORTED_MODULE_10__.MeshDebugShader(gl);\r\n            let smesh = unit.buffer().ToShaderMesh();\r\n            shader.set(smesh);\r\n        }\r\n        else if (unit instanceof _geo_curve_curve__WEBPACK_IMPORTED_MODULE_1__.Curve) {\r\n            shader = new _shaders_line_shader__WEBPACK_IMPORTED_MODULE_9__.LineShader(gl);\r\n            let multiLine = unit.buffer();\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _geo_curve_polyline__WEBPACK_IMPORTED_MODULE_2__.Polyline) {\r\n            shader = new _shaders_line_shader__WEBPACK_IMPORTED_MODULE_9__.LineShader(gl);\r\n            let multiLine = _mesh_multi_line__WEBPACK_IMPORTED_MODULE_6__.MultiLine.fromPolyline(unit);\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.Plane) {\r\n            shader = new _shaders_line_shader__WEBPACK_IMPORTED_MODULE_9__.LineShader(gl);\r\n            let multiLine = _mesh_multi_line__WEBPACK_IMPORTED_MODULE_6__.MultiLine.fromPlane(unit);\r\n            shader.set(multiLine);\r\n        }\r\n        else if (unit instanceof _mesh_multi_line__WEBPACK_IMPORTED_MODULE_6__.MultiLine) {\r\n            shader = new _shaders_line_shader__WEBPACK_IMPORTED_MODULE_9__.LineShader(gl);\r\n            shader.set(unit);\r\n        }\r\n        else {\r\n            console.error(\"MultiRenderer cannot render: \", unit);\r\n            return undefined;\r\n        }\r\n        this.shaders.set(key, shader);\r\n        return shader;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/renderers/multi-renderer.ts?");

/***/ }),

/***/ "../engine/src/shaderprograms/billboard-shader.ts":
/*!********************************************************!*\
  !*** ../engine/src/shaderprograms/billboard-shader.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BillboardShader\": () => (/* binding */ BillboardShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _data_multi_vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/multi-vector */ \"../engine/src/data/multi-vector.ts\");\n/* harmony import */ var _render_low_program__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../render-low/program */ \"../engine/src/render-low/program.ts\");\n/* harmony import */ var _render_low_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../render-low/constants */ \"../engine/src/render-low/constants.ts\");\n// https://webgl.brown37.net/12_advanced_rendering/07_rendering_points.html\r\n// name:    billboard-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: Renderer textures as billboards.\r\n// NOTE: make sure to include something like a center offset, to gain control of if the point is rendered centered, as topleft, etc. etc.\r\n\r\n\r\n\r\n\r\n/**\r\n * Used to render multiple billboards.\r\n * One Texture per billboard.\r\n */\r\nclass BillboardShader extends _render_low_program__WEBPACK_IMPORTED_MODULE_2__.Program {\r\n    constructor(gl, color = [1, 1, 1, 1], radius = 100) {\r\n        let vertexSource = `\r\n        // Vertex Shader\r\n        precision mediump int;\r\n        precision mediump float;\r\n        \r\n        uniform mat4  u_transform;\r\n        uniform vec3  u_camera_position;\r\n        uniform float u_size;\r\n \r\n        attribute vec3 a_vertex;\r\n        attribute vec2 a_uv;\r\n        attribute vec2 a_uv_wh;\r\n        \r\n        varying vec2  uv;\r\n        varying vec2  uv_size;\r\n        varying float point_size;\r\n        \r\n        void main() {\r\n        \r\n            // edit size based on distance from camera\r\n            float value = 15.0; // TODO how to derrive this???\r\n            float dis = distance(a_vertex, u_camera_position);\r\n            float size = u_size / (dis / value);\r\n            gl_PointSize = size;\r\n            point_size = size;\r\n\r\n            // Pass the point's texture coordinate to the fragment shader\r\n            uv = a_uv;\r\n            uv_size = a_uv_wh;\r\n            \r\n            // Transform the location of the vertex.\r\n            gl_Position = u_transform * vec4(a_vertex, 1.0);\r\n        }\r\n\r\n        `;\r\n        let fragmentSource = `\r\n\r\n        precision mediump int;\r\n        precision mediump float;\r\n    \r\n        uniform sampler2D u_texture;\r\n        uniform vec2      u_texture_size;  // delta_s, delta_t\r\n        \r\n        varying vec2  uv;\r\n        varying vec2  uv_size;\r\n        varying float point_size; // can this be replaced with u_size ??\r\n        \r\n        vec2 center = vec2(0.5, 0.5);\r\n        \r\n        void main() {\r\n\r\n            vec2 texture_fraction = 1.0 / u_texture_size;\r\n            vec2 sprite_fraction = 1.0 / uv_size;\r\n            vec2 tex_origin = uv * texture_fraction;\r\n\r\n            vec2 coord = tex_origin + gl_PointCoord * sprite_fraction;\r\n            gl_FragColor = texture2D(u_texture, coord);\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vertexSource, fragmentSource);\r\n        this.uniforms.add(\"u_transform\", 16);\r\n        this.radius = this.uniforms.add(\"u_size\", 1, [radius]);\r\n        this.color = this.uniforms.add(\"u_color\", 4, color);\r\n        this.uniforms.add(\"u_camera_position\", 3);\r\n        this.uniforms.add(\"u_texture_size\", 2, [16, 16]);\r\n        this.uniforms.addTexture(\"u_texture\");\r\n    }\r\n    onInit() {\r\n        this.attributes.add(\"a_vertex\", 3);\r\n        this.attributes.add(\"a_uv\", 2);\r\n        this.attributes.add(\"a_uv_wh\", 2);\r\n        return _render_low_constants__WEBPACK_IMPORTED_MODULE_3__.DrawMode.Points;\r\n    }\r\n    onSet(payload, speed) {\r\n        this.attributes.set(\"a_vertex\", (0,_data_multi_vector__WEBPACK_IMPORTED_MODULE_1__.ToFloatMatrix)(payload.positions).data, speed);\r\n        this.attributes.set(\"a_uv\", (0,_data_multi_vector__WEBPACK_IMPORTED_MODULE_1__.ToFloatMatrix)(payload.uvs).data, speed);\r\n        this.attributes.set(\"a_uv_wh\", (0,_data_multi_vector__WEBPACK_IMPORTED_MODULE_1__.ToFloatMatrix)(payload.uvSizes).data, speed);\r\n        this.uniforms.setTexture(\"u_texture\", payload.texture);\r\n        this.uniforms.set2(\"u_texture_size\", _lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(payload.texture.width, payload.texture.height));\r\n        return payload.positions.count;\r\n    }\r\n    onRender(c) {\r\n        this.uniforms.set3(\"u_camera_position\", c.camera.pos.scaled(-1));\r\n        this.uniforms.setMatrix4(\"u_transform\", c.camera.totalMatrix);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaderprograms/billboard-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders2/dot-shader-2.ts":
/*!**********************************************!*\
  !*** ../engine/src/shaders2/dot-shader-2.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotShader2\": () => (/* binding */ DotShader2)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// jos feenstra\r\n\r\nclass DotShader2 extends _lib__WEBPACK_IMPORTED_MODULE_0__.Shader {\r\n    constructor(gl, size = 5, color = [1, 1, 1, 1], square = true) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\r\n        attribute vec2 a_position;\r\n        \r\n        uniform vec2 u_resolution;\r\n        uniform float u_size;\r\n\r\n        void main() {\r\n            vec2 clipped = ((a_position / u_resolution) * 2.0) - 1.0;\r\n      \r\n            gl_PointSize = u_size;\r\n            gl_Position = vec4(clipped, 0, 1);\r\n            // gl_Position = vec4(0,0,0,1);\r\n        }\r\n        `;\r\n        let fragmentSourceSquare = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_Color;\r\n        vec2 center = vec2(0.5, 0.5);\r\n\r\n        void main() {\r\n            gl_FragColor = vec4(1,1,1,1);\r\n        }\r\n        `;\r\n        let fragmentSourceRound = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_Color;\r\n        vec2 center = vec2(0.5, 0.5);\r\n\r\n        void main() {\r\n            if (distance(center, gl_PointCoord) > 0.5) {\r\n               discard;\r\n            }\r\n            gl_FragColor = vec4(1,1,1,1);\r\n        }\r\n        `;\r\n        // setup program\r\n        if (square) {\r\n            super(gl, vertexSource, fragmentSourceSquare);\r\n        }\r\n        else {\r\n            super(gl, vertexSource, fragmentSourceRound);\r\n        }\r\n        this.u_resolution = gl.getUniformLocation(this.program, \"u_resolution\");\r\n        this.u_size = gl.getUniformLocation(this.program, \"u_size\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.color = color;\r\n        this.size = size;\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set() { }\r\n    render(context) { }\r\n    // render 1 image to the screen\r\n    setAndRender(dots, context) {\r\n        let gl = this.gl;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniform2f(this.u_resolution, gl.canvas.width, gl.canvas.height);\r\n        gl.uniform1f(this.u_size, this.size);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // // Bind the position buffer.\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        // // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0; // start at the beginning of the buffer\r\n        gl.vertexAttribPointer(this.a_position, size, type, normalize, stride, offset);\r\n        // fill with data;\r\n        let data = this.toFloat32Array(dots);\r\n        gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\r\n        // Draw the point.\r\n        var primitiveType = gl.POINTS;\r\n        var offset = 0;\r\n        var count = dots.length;\r\n        gl.drawArrays(primitiveType, offset, count);\r\n    }\r\n    // Fill the buffer with the values that define a rectangle.\r\n    toFloat32Array(dots) {\r\n        let data = new Float32Array(dots.length * 2);\r\n        for (let i = 0; i < dots.length; i++) {\r\n            data[i * 2] = dots[i].x;\r\n            data[i * 2 + 1] = dots[i].y;\r\n        }\r\n        return data;\r\n    }\r\n    randomInt(range) {\r\n        return Math.floor(Math.random() * range);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders2/dot-shader-2.ts?");

/***/ }),

/***/ "../engine/src/shaders/dot-shader.ts":
/*!*******************************************!*\
  !*** ../engine/src/shaders/dot-shader.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DotShader\": () => (/* binding */ DotShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _render_low_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render-low/shader */ \"../engine/src/render-low/shader.ts\");\n// jos feenstra\r\n\r\n\r\nclass DotShader extends _render_low_shader__WEBPACK_IMPORTED_MODULE_1__.Shader {\r\n    constructor(gl, radius = 5, color = [1, 1, 1, 1], square = true) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n        uniform float u_size;\r\n\r\n        attribute vec3 a_vertex;\r\n\r\n        void main() {\r\n            // Set the size of a rendered point.\r\n            gl_PointSize = u_size;\r\n\r\n            // Transform the location of the vertex.\r\n            gl_Position = u_transform * vec4(a_vertex, 1.0);\r\n        }\r\n\r\n        `;\r\n        let fragmentSourceSquare = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        // vec2 center = vec2(0.5, 0.5);\r\n\r\n        void main() {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        let fragmentSourceRound = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        vec2 center = vec2(0.5, 0.5);\r\n\r\n        void main() {\r\n            if (distance(center, gl_PointCoord) > 0.5) {\r\n               discard;\r\n            }\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        if (square) {\r\n            super(gl, vertexSource, fragmentSourceSquare);\r\n        }\r\n        else {\r\n            super(gl, vertexSource, fragmentSourceRound);\r\n        }\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_size = gl.getUniformLocation(this.program, \"u_size\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.color = color;\r\n        this.size = radius;\r\n        this.count = 0;\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_vertex\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set(points, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        gl.useProgram(this.program);\r\n        // convert all possible entries to a general entry\r\n        let array = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.ToFloatMatrix)(points);\r\n        // from some other thing\r\n        this.count = array.count();\r\n        // // Bind the position buffer\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, array.width, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, array.data, speed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        // console.log(matrix.data);\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        gl.uniform1f(this.u_size, this.size);\r\n        gl.uniform4f(this.u_color, this.color[0], this.color[1], this.color[2], this.color[3]);\r\n        // // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        // Draw the point.\r\n        gl.drawArrays(gl.POINTS, 0, this.count);\r\n    }\r\n    setAndRender(data, c) {\r\n        this.set(data, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/dot-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/graph-debug-shader.ts":
/*!***************************************************!*\
  !*** ../engine/src/shaders/graph-debug-shader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphDebugShader\": () => (/* binding */ GraphDebugShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _render_multi_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/multi-shader */ \"../engine/src/render/multi-shader.ts\");\n/* harmony import */ var _dot_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dot-shader */ \"../engine/src/shaders/dot-shader.ts\");\n/* harmony import */ var _line_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line-shader */ \"../engine/src/shaders/line-shader.ts\");\n/* harmony import */ var _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mesh-normals-shader */ \"../engine/src/shaders/mesh-normals-shader.ts\");\n/* harmony import */ var _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./simple-mesh-shader */ \"../engine/src/shaders/simple-mesh-shader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass GraphDebugShader extends _render_multi_shader__WEBPACK_IMPORTED_MODULE_1__.MultiShader {\r\n    constructor(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        super();\r\n        this.faceRend = new _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_5__.SimpleMeshShader(gl, faceColor);\r\n        this.lineRend = new _line_shader__WEBPACK_IMPORTED_MODULE_3__.LineShader(gl, edgeColor);\r\n        this.pointRend = new _dot_shader__WEBPACK_IMPORTED_MODULE_2__.DotShader(gl, 7, edgeColor, false);\r\n        if (renderNormal)\r\n            this.normRend = new _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_4__.NormalShader(gl);\r\n    }\r\n    set(graph, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        //this.faceRend.setMesh(gl, mesh);\r\n        this.pointRend.set(graph.allVertPositions(), speed);\r\n        this.lineRend.set(graph.toLines(), speed);\r\n        // this.normRend?.setWithLists(graph.allVertPositions(), graph.allNorms(), speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        this.pointRend.render(c);\r\n        // this.faceRend.render(gl, camera.totalMatrix);\r\n        this.lineRend.render(c);\r\n        // this.normRend?.render(gl, camera);\r\n    }\r\n    setAndRender(r, context) {\r\n        throw new Error(\"Method not implemented.\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/graph-debug-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/line-shader.ts":
/*!********************************************!*\
  !*** ../engine/src/shaders/line-shader.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineShader\": () => (/* binding */ LineShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _render_low_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render-low/shader */ \"../engine/src/render-low/shader.ts\");\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\nclass LineShader extends _render_low_shader__WEBPACK_IMPORTED_MODULE_1__.Shader {\r\n    constructor(gl, color = [1, 1, 1, 0.5]) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // set uniforms which wont change\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n    }\r\n    set(data, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw, personal = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity()) {\r\n        // save how many faces need to be drawn\r\n        let gl = this.gl;\r\n        let links;\r\n        let verts;\r\n        if (data instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.Mesh) {\r\n            verts = data.verts.slice();\r\n            links = data.links.getData();\r\n        }\r\n        else {\r\n            verts = data.verts;\r\n            links = data.links;\r\n        }\r\n        // console.log(links);\r\n        gl.useProgram(this.program);\r\n        this.count = links.length;\r\n        this.vertCount = verts.width;\r\n        let drawspeed = speed;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, verts.data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, links.buffer, drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // index\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(data, c) {\r\n        this.set(data, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/line-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/mesh-debug-shader.ts":
/*!**************************************************!*\
  !*** ../engine/src/shaders/mesh-debug-shader.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MeshDebugShader\": () => (/* binding */ MeshDebugShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _render_multi_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render/multi-shader */ \"../engine/src/render/multi-shader.ts\");\n/* harmony import */ var _line_shader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-shader */ \"../engine/src/shaders/line-shader.ts\");\n/* harmony import */ var _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mesh-normals-shader */ \"../engine/src/shaders/mesh-normals-shader.ts\");\n/* harmony import */ var _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./simple-mesh-shader */ \"../engine/src/shaders/simple-mesh-shader.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\n\r\n\r\n\r\n\r\nclass MeshDebugShader extends _render_multi_shader__WEBPACK_IMPORTED_MODULE_1__.MultiShader {\r\n    constructor(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        super();\r\n        this.faceRend = new _simple_mesh_shader__WEBPACK_IMPORTED_MODULE_4__.SimpleMeshShader(gl, faceColor);\r\n        this.lineRend = new _line_shader__WEBPACK_IMPORTED_MODULE_2__.LineShader(gl, edgeColor);\r\n        this.personal = _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity();\r\n        if (renderNormal)\r\n            this.normRend = new _mesh_normals_shader__WEBPACK_IMPORTED_MODULE_3__.NormalShader(gl);\r\n    }\r\n    static new(gl, faceColor = [1, 0, 0, 0.25], edgeColor = [1, 0, 0, 1], renderNormal = true) {\r\n        return new MeshDebugShader(gl, faceColor, edgeColor, renderNormal);\r\n    }\r\n    set(data, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        var _a;\r\n        this.personal = data.position;\r\n        this.faceRend.set(data.mesh);\r\n        this.lineRend.set(_lib__WEBPACK_IMPORTED_MODULE_0__.MultiLine.fromMesh(data), speed);\r\n        (_a = this.normRend) === null || _a === void 0 ? void 0 : _a.set(data, speed);\r\n    }\r\n    render(c) {\r\n        var _a;\r\n        this.faceRend.render(c);\r\n        this.lineRend.render(c);\r\n        (_a = this.normRend) === null || _a === void 0 ? void 0 : _a.render(c);\r\n    }\r\n    setAndRender(r, c) {\r\n        this.set(r, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(c);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/mesh-debug-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/mesh-normals-shader.ts":
/*!****************************************************!*\
  !*** ../engine/src/shaders/mesh-normals-shader.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NormalShader\": () => (/* binding */ NormalShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _render_low_shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../render-low/shader */ \"../engine/src/render-low/shader.ts\");\n// name:    simple-line-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of lines.\r\n\r\n\r\nclass NormalShader extends _render_low_shader__WEBPACK_IMPORTED_MODULE_1__.Shader {\r\n    constructor(gl) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_vertex;\r\n        attribute vec4 a_vertex_color;\r\n\r\n        uniform mat4 u_transform;\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_vertex;\r\n            v_color = a_vertex_color;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        varying vec4 v_color;\r\n\r\n        void main () {\r\n            gl_FragColor = v_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        // we need 2 buffers\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_vertex\");\r\n        this.a_color = gl.getAttribLocation(this.program, \"a_vertex_color\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.a_color_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.vertCount = 0;\r\n        this.scale = 0.4;\r\n    }\r\n    // take a general render mesh, and extract normals\r\n    set(rend, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        // save how many verts need to be drawn\r\n        let gl = this.gl;\r\n        gl.useProgram(this.program);\r\n        let drawspeed = speed;\r\n        this.vertCount = 3;\r\n        let lineverts;\r\n        let normals;\r\n        // different buffer fills based upon normal kind\r\n        let normalKind = rend.getNormalType();\r\n        if (normalKind == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Face) {\r\n            let faceCount = rend.mesh.links.count();\r\n            this.count = faceCount * 2;\r\n            lineverts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            normals = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            for (let f = 0; f < faceCount; f++) {\r\n                let center = rend.getFaceVertices(f).average();\r\n                let normal = rend.norms.get(f);\r\n                let i1 = f * 2;\r\n                let i2 = f * 2 + 1;\r\n                lineverts.set(i1, center);\r\n                lineverts.set(i2, center.add(normal.scaled(this.scale)));\r\n                let color = normal.add(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1).div(2));\r\n                normals.set(i1, color);\r\n                normals.set(i2, color);\r\n            }\r\n        }\r\n        else if (normalKind == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Vertex) {\r\n            let vertCount = rend.mesh.verts.count;\r\n            this.count = vertCount * 2;\r\n            lineverts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            normals = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            for (let i = 0; i < vertCount; i++) {\r\n                let center = rend.mesh.verts.get(i);\r\n                let normal = rend.norms.get(i);\r\n                let i1 = i * 2;\r\n                let i2 = i * 2 + 1;\r\n                lineverts.set(i1, center);\r\n                lineverts.set(i2, center.add(normal.scaled(this.scale)));\r\n                let color = normal.add(new _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1)).div(2);\r\n                normals.set(i1, color);\r\n                normals.set(i2, color);\r\n            }\r\n            // console.log(normals);\r\n        }\r\n        else {\r\n            // console.warn(\"no normals for type\", normalKind);\r\n            this.count = 0;\r\n            return;\r\n        }\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, lineverts.slice().data, drawspeed);\r\n        // normals\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_color_buffer);\r\n        gl.enableVertexAttribArray(this.a_color);\r\n        gl.vertexAttribPointer(this.a_color, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, normals.slice().data, drawspeed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getDefaultIndices)(this.count), drawspeed);\r\n    }\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        let camera = c.camera;\r\n        // Tell it to use our program (pair of shaders)\r\n        // POINTERS MUST ALSO BE SET, DO EVERYTHING EXCEPT GL.BUFFERDATA\r\n        gl.useProgram(this.program);\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.vertexAttribPointer(this.a_position, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_color_buffer);\r\n        gl.enableVertexAttribArray(this.a_color);\r\n        gl.vertexAttribPointer(this.a_color, this.vertCount, gl.FLOAT, false, 0, 0);\r\n        // index buffer\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.LINES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/mesh-normals-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/rectangle-shader.ts":
/*!*************************************************!*\
  !*** ../engine/src/shaders/rectangle-shader.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RectangleShader\": () => (/* binding */ RectangleShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// jos feenstra\r\n\r\nclass RectangleShader extends _lib__WEBPACK_IMPORTED_MODULE_0__.Shader {\r\n    constructor(gl) {\r\n        // note: I like vertex & fragments to be included in the script itself.\r\n        // when you change vertex or fragment, this class has to deal with it.\r\n        // putting them somewhere else doesnt make sense to me,\r\n        // they are coupled 1 to 1.\r\n        let vertexSource = `\r\n        attribute vec2 a_position;\r\n\r\n        uniform vec2 u_resolution;\r\n\r\n        void main() {\r\n            // convert the rectangle from pixels to 0.0 to 1.0\r\n            vec2 zeroToOne = ((a_position / u_resolution) * 2.0) - 1.0;\r\n\r\n            // convert from 0->1 to 0->2\r\n            // vec2 zeroToTwo = zeroToOne * 2.0;\r\n\r\n            // convert from 0->2 to -1->+1 (clipspace)\r\n            // vec2 clipSpace = zeroToTwo - 1.0;\r\n\r\n            gl_Position = vec4(zeroToOne * vec2(1, -1), 0, 1);\r\n        }\r\n        `;\r\n        let fragmentSource = `\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n        \r\n        void main() {\r\n           gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vertexSource, fragmentSource);\r\n        // look up where the vertex data needs to go.\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.u_resolution = gl.getUniformLocation(this.program, \"u_resolution\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        // Create a buffer to put three 2d clip space points in\r\n        // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n    }\r\n    set() {\r\n        throw \"not used\";\r\n    }\r\n    render() {\r\n        throw \"not used!\";\r\n    }\r\n    setAndRender(rs, c) {\r\n        // Clear the canvas\r\n        let gl = this.gl;\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        // Turn on the attribute\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.uniform2f(this.u_resolution, gl.canvas.width, gl.canvas.height);\r\n        // Bind the position buffer.\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)\r\n        var size = 2; // 2 components per iteration\r\n        var type = gl.FLOAT; // the data is 32bit floats\r\n        var normalize = false; // don't normalize the data\r\n        var stride = 0; // 0 = move forward size * sizeof(type) each iteration to get the next position\r\n        var offset = 0; // start at the beginning of the buffer\r\n        gl.vertexAttribPointer(this.a_position, size, type, normalize, stride, offset);\r\n        // draw 50 random rectangles in random colors\r\n        for (let r of rs) {\r\n            // Setup a random rectangle\r\n            // This will write to positionBuffer because\r\n            // its the last thing we bound on the ARRAY_BUFFER\r\n            // bind point\r\n            this.setRectangle(gl, r);\r\n            // Set a random color.\r\n            gl.uniform4f(this.u_color, Math.random(), Math.random(), Math.random(), 1);\r\n            // Draw the rectangle.\r\n            var primitiveType = gl.TRIANGLES;\r\n            var offset = 0;\r\n            var count = 6;\r\n            gl.drawArrays(primitiveType, offset, count);\r\n        }\r\n    }\r\n    // Fill the buffer with the values that define a rectangle.\r\n    setRectangle(gl, r) {\r\n        let verts = r.getVertices();\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n            verts[0].x,\r\n            verts[0].y,\r\n            verts[1].x,\r\n            verts[1].y,\r\n            verts[2].x,\r\n            verts[2].y,\r\n            verts[2].x,\r\n            verts[2].y,\r\n            verts[1].x,\r\n            verts[1].y,\r\n            verts[3].x,\r\n            verts[3].y,\r\n        ]), gl.STATIC_DRAW);\r\n    }\r\n    randomInt(range) {\r\n        return Math.floor(Math.random() * range);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/rectangle-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/shaded-mesh-shader.ts":
/*!***************************************************!*\
  !*** ../engine/src/shaders/shaded-mesh-shader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ShadedMeshShader\": () => (/* binding */ ShadedMeshShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: A shader wrapper for rendering shaded, textured, meshes\r\n\r\nclass ShadedMeshShader extends _lib__WEBPACK_IMPORTED_MODULE_0__.Shader {\r\n    constructor(gl) {\r\n        const vs = `\r\n\r\n        attribute vec4 a_vertex_position;\r\n        attribute vec3 a_vertex_normal;\r\n        attribute float a_vertex_ambi;\r\n    \r\n        uniform mat4 u_normal_matrix;\r\n        uniform mat4 u_personal_matrix;\r\n        uniform mat4 u_model_view_matrix;\r\n        uniform mat4 u_projection_matrix;\r\n\r\n        // should be uniforms constances\r\n        uniform vec3 u_ambient_light;\r\n        uniform vec3 u_dir_light_color;\r\n        uniform vec3 u_dir_light_vector;  \r\n\r\n        // varying vec2 v_texture_coord;\r\n        varying vec3 v_lighting;\r\n    \r\n        void main(void) {\r\n\r\n            gl_Position = u_projection_matrix * u_model_view_matrix * u_personal_matrix * a_vertex_position;\r\n            // v_texture_coord = a_texture_coord;\r\n        \r\n            // Apply lighting effect\r\n            // highpr is removed\r\n            vec4 transformedNormal = u_normal_matrix * vec4(a_vertex_normal, 1.0);\r\n            float directional = max(dot(transformedNormal.xyz, u_dir_light_vector), 0.0);\r\n            v_lighting = (u_ambient_light + (u_dir_light_color * directional));\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump float;\r\n\r\n        // Calculates the diffuse factor produced by the light illumination  \r\n        // if done like this, color could look nicer\r\n        // float diffuseFactor(vec3 normal, vec3 light_direction) {\r\n        //     float df = dot(normalize(normal), normalize(light_direction));\r\n        //     if (gl_FrontFacing) {\r\n        //         df = -df;\r\n        //     }\r\n        //     return max(0.0, df);\r\n        // }\r\n\r\n        varying vec3 v_lighting;\r\n\r\n        void main() {\r\n\r\n            // Fragment shader output\r\n            gl_FragColor = vec4(v_lighting, 1.0);\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // init uniforms\r\n        this.u_normal_matrix = gl.getUniformLocation(this.program, \"u_normal_matrix\");\r\n        this.u_model_view_matrix = gl.getUniformLocation(this.program, \"u_model_view_matrix\");\r\n        this.u_projection_matrix = gl.getUniformLocation(this.program, \"u_projection_matrix\");\r\n        this.u_personal_matrix = gl.getUniformLocation(this.program, \"u_personal_matrix\");\r\n        // light uniforms\r\n        this.u_ambient_light = gl.getUniformLocation(this.program, \"u_ambient_light\");\r\n        this.u_dir_light_color = gl.getUniformLocation(this.program, \"u_dir_light_color\");\r\n        this.u_dir_light_vector = gl.getUniformLocation(this.program, \"u_dir_light_vector\");\r\n        // init attributes: verts | normals | ambi\r\n        this.a_vertex_position = gl.getAttribLocation(this.program, \"a_vertex_position\");\r\n        this.a_vertex_postition_buffer = gl.createBuffer();\r\n        this.a_vertex_normal = gl.getAttribLocation(this.program, \"a_vertex_normal\");\r\n        this.a_vertex_normal_buffer = gl.createBuffer();\r\n        this.a_vertex_ambi = gl.getAttribLocation(this.program, \"a_vertex_ambi\");\r\n        this.a_vertex_ambi_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(rend, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        // NOTE: processing time is longer: we use DrawArray instead of DrawElements, to deal with normals & uv data\r\n        let gl = this.gl;\r\n        this.setShallow(gl, rend);\r\n        let normalType = rend.getNormalType();\r\n        if (normalType == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Face) {\r\n            // save how many verts need to be drawn\r\n            gl.useProgram(this.program);\r\n            this.count = rend.mesh.links.data.length;\r\n            // convert to non-indexed verts & norms\r\n            let verts = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            let norms = _lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector3.new(this.count);\r\n            let ambi = new Float32Array(this.count);\r\n            let faceCount = rend.mesh.links.count();\r\n            for (let i = 0; i < rend.mesh.links.count(); i++) {\r\n                let norm = rend.norms.get(i);\r\n                rend.mesh.links.getRow(i).forEach((v, j) => {\r\n                    let id = i * 3 + j;\r\n                    verts.set(id, rend.mesh.verts.get(v));\r\n                    norms.set(id, norm);\r\n                    ambi[id] = 1;\r\n                });\r\n            }\r\n            // buffer 1\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, verts.slice().data.buffer, speed);\r\n            // buffer 2\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, norms.slice().data.buffer, speed);\r\n            // buffer 3\r\n            // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n            // gl.vertexAttribPointer(this.a_vertex_ambi, 1, gl.FLOAT, false, 0, 0);\r\n            // gl.bufferData(gl.ARRAY_BUFFER, ambi, ds);\r\n            // index\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getDefaultIndices)(this.count), speed);\r\n        }\r\n        else if (normalType == _lib__WEBPACK_IMPORTED_MODULE_0__.NormalKind.Vertex) {\r\n            // save how many verts need to be drawn\r\n            gl.useProgram(this.program);\r\n            let ds = speed;\r\n            // convert to non-indexed verts & norms\r\n            let ambi = rend.ambi;\r\n            let faceCount = rend.mesh.links.count();\r\n            this.count = rend.mesh.links.data.length;\r\n            // console.log(rend.mesh.links);\r\n            // buffer 1\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, rend.mesh.verts.slice().data, ds);\r\n            // buffer 2\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n            gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n            gl.bufferData(gl.ARRAY_BUFFER, rend.norms.slice().data, ds);\r\n            // buffer 3\r\n            // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n            // gl.vertexAttribPointer(this.a_vertex_ambi, 1, gl.FLOAT, false, 0, 0);\r\n            // gl.bufferData(gl.ARRAY_BUFFER, ambi, ds);\r\n            // index\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, rend.mesh.links.data, ds);\r\n        }\r\n        else {\r\n            console.log(\"cannot render with this normal data\");\r\n        }\r\n        // never render more than possible\r\n        // NOTE : THIS IS INCORRECT. OFTEN WE CAN JUST RENDER IT NO PROBLEM\r\n        // TODO : CREATE SOMETHING LIKE AN AUTOMATIC OVERFLOW SHADER WHICH RENDERS THE REST\r\n        // if (this.count > Const.MAX_U16) {\r\n        //     this.count = Const.MAX_U16;\r\n        //     console.warn(\"mesh max reached.\");\r\n        // }\r\n    }\r\n    // set only the basic elements.\r\n    // use this to dynamicly alter things like position and color,\r\n    // without refilling all buffers with it\r\n    setShallow(gl, rend) {\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // position\r\n        gl.uniformMatrix4fv(this.u_personal_matrix, false, rend.position.data);\r\n        // color\r\n        let color = rend.color;\r\n        // shift shadow to darker, slightly to blue\r\n        let shadowColor = color.map((x) => x * 0.25);\r\n        shadowColor[2] = Math.min(1, shadowColor[2] * 1.05);\r\n        // shift bright color slightly to yellow\r\n        let brightColor = color.map((x) => x);\r\n        brightColor[0] = Math.min(1, brightColor[0] * 1.05);\r\n        brightColor[1] = Math.min(1, brightColor[1] * 1.05);\r\n        brightColor[2] = Math.min(1, brightColor[2] * 1);\r\n        gl.uniform3fv(this.u_ambient_light, shadowColor.slice(0, 3));\r\n        gl.uniform3fv(this.u_dir_light_color, brightColor.slice(0, 3));\r\n    }\r\n    // render the previous set data to the screen\r\n    render(c) {\r\n        // console.log(\"rendering..\");\r\n        let gl = this.gl;\r\n        let camera = c.camera;\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_normal_matrix, false, _lib__WEBPACK_IMPORTED_MODULE_0__.Matrix4.newIdentity().data);\r\n        gl.uniformMatrix4fv(this.u_model_view_matrix, false, camera.worldMatrix.data);\r\n        gl.uniformMatrix4fv(this.u_projection_matrix, false, camera.projectMatrix.data);\r\n        // set light direction\r\n        let vec = camera.getMouseWorldRay(gl.canvas.width, gl.canvas.height, false).normal;\r\n        gl.uniform3fv(this.u_dir_light_vector, _lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitX().add(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitY()).add(_lib__WEBPACK_IMPORTED_MODULE_0__.Vector3.unitZ()).normalize().toArray());\r\n        // buffer 1\r\n        gl.enableVertexAttribArray(this.a_vertex_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_postition_buffer);\r\n        gl.vertexAttribPointer(this.a_vertex_position, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.enableVertexAttribArray(this.a_vertex_normal);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_normal_buffer);\r\n        gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 3\r\n        // gl.enableVertexAttribArray(this.a_vertex_ambi);\r\n        // gl.bindBuffer(gl.ARRAY_BUFFER, this.a_vertex_ambi_buffer);\r\n        // gl.vertexAttribPointer(this.a_vertex_normal, 3, gl.FLOAT, false, 0, 0);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // draw!\r\n        // NOTE: We can increase the number of triangles we can maximally draw!!!!\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/drawElements\r\n        // When using the OES_element_index_uint extension:\r\n        // gl.UNSIGNED_INT;\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/shaded-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/simple-mesh-shader.ts":
/*!***************************************************!*\
  !*** ../engine/src/shaders/simple-mesh-shader.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SimpleMeshShader\": () => (/* binding */ SimpleMeshShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\nclass SimpleMeshShader extends _lib__WEBPACK_IMPORTED_MODULE_0__.Shader {\r\n    constructor(gl, color = [1, 0, 0, 0.25]) {\r\n        const vs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        uniform mat4 u_transform;\r\n        uniform vec4 u_color;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump int;\r\n        precision mediump float;\r\n\r\n        uniform vec4 u_color;\r\n\r\n        void main () {\r\n            gl_FragColor = u_color;\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        gl.useProgram(this.program);\r\n        gl.uniform4f(this.u_color, color[0], color[1], color[2], color[3]);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // we need 2 buffers\r\n        // -> 1 float buffer for the positions of all vertices.\r\n        // -> 1 int buffer for the index of all triangles\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n    }\r\n    set(mesh, speed = _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.StaticDraw) {\r\n        let gl = this.gl;\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = mesh.links.data.length;\r\n        // vertices\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        this.size = 3;\r\n        var type = gl.FLOAT;\r\n        var normalize = false;\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, mesh.verts.slice().data, speed);\r\n        // indices\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, mesh.links.data, speed);\r\n    }\r\n    // render 1 image to the screen\r\n    render(c) {\r\n        let gl = this.gl;\r\n        let matrix = c.camera.totalMatrix;\r\n        // Tell it to use our program (pair of shaders)\r\n        gl.useProgram(this.program);\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, this.size, gl.FLOAT, false, 0, 0);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // Draw the point.\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/simple-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/shaders/texture-mesh-shader.ts":
/*!****************************************************!*\
  !*** ../engine/src/shaders/texture-mesh-shader.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextureMeshShader\": () => (/* binding */ TextureMeshShader)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib */ \"../engine/src/lib.ts\");\n// name:    mesh-renderer.ts\r\n// author:  Jos Feenstra\r\n// purpose: WebGL based rendering of a mesh.\r\n\r\nclass TextureMeshShader extends _lib__WEBPACK_IMPORTED_MODULE_0__.Shader {\r\n    constructor(gl) {\r\n        const vs = `\r\n        // precision mediump int;\r\n        // precision mediump float;\r\n\r\n        attribute vec4 a_position;\r\n        attribute vec2 a_texcoord;\r\n\r\n        uniform mat4 u_transform;\r\n\r\n        varying vec2 v_texcoord;\r\n\r\n        void main() {\r\n            gl_Position = u_transform * a_position;\r\n            v_texcoord = a_texcoord;\r\n        }\r\n        `;\r\n        const fs = `\r\n        precision mediump float;\r\n\r\n        varying vec2 v_texcoord;\r\n\r\n        uniform sampler2D u_texture;\r\n\r\n        void main() {\r\n            gl_FragColor = texture2D(u_texture, v_texcoord);\r\n        }\r\n        `;\r\n        // setup program\r\n        super(gl, vs, fs);\r\n        gl.useProgram(this.program);\r\n        this.count = 0;\r\n        this.size = 0;\r\n        // init uniforms\r\n        this.u_transform = gl.getUniformLocation(this.program, \"u_transform\");\r\n        this.u_texture = gl.getUniformLocation(this.program, \"u_texture\");\r\n        // init three buffers: verts | uvs | links\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.a_position_buffer = gl.createBuffer();\r\n        this.a_texcoord = gl.getAttribLocation(this.program, \"a_texcoord\");\r\n        this.a_texcoord_buffer = gl.createBuffer();\r\n        this.index_buffer = gl.createBuffer();\r\n        // init texture\r\n        this.texture_id = _lib__WEBPACK_IMPORTED_MODULE_0__.HelpGl.getNextTextureID();\r\n        this.texture = gl.createTexture();\r\n    }\r\n    static new(gl) {\r\n        return new TextureMeshShader(gl);\r\n    }\r\n    set(r, speed) {\r\n        let gl = this.gl;\r\n        if (!r.texture) {\r\n            console.warn(\"Mesh does not contain a texture!\");\r\n            return;\r\n        }\r\n        // save how many faces need to be drawn\r\n        gl.useProgram(this.program);\r\n        this.count = r.mesh.links.data.length;\r\n        // buffer 1\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, r.mesh.verts.slice().data, speed);\r\n        // buffer 2\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        gl.bufferData(gl.ARRAY_BUFFER, r.uvs.toMatrixSlice().data, speed);\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(r.mesh.links.data), speed);\r\n        // texture\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, r.texture);\r\n        // alternative texture -> Fill the texture with a 1x1 blue pixel.\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 128, 128, 255]));\r\n        // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, mesh.texture.data);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.generateMipmap(gl.TEXTURE_2D);\r\n    }\r\n    render(context) {\r\n        let gl = this.gl;\r\n        let camera = context.camera;\r\n        let matrix = camera.totalMatrix;\r\n        // console.log(\"rendering..\");\r\n        // use the program\r\n        gl.useProgram(this.program);\r\n        // set uniforms\r\n        gl.uniformMatrix4fv(this.u_transform, false, matrix.data);\r\n        // set texture\r\n        gl.uniform1i(this.u_texture, this.texture_id);\r\n        gl.activeTexture(gl.TEXTURE0 + this.texture_id);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        // buffer 1\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_position_buffer);\r\n        gl.vertexAttribPointer(this.a_position, 3, gl.FLOAT, false, 0, 0);\r\n        // buffer 2\r\n        gl.enableVertexAttribArray(this.a_texcoord);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.a_texcoord_buffer);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, false, 0, 0);\r\n        // buffer 3\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.index_buffer);\r\n        // draw!\r\n        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);\r\n    }\r\n    setAndRender(r, context) {\r\n        this.set(r, _lib__WEBPACK_IMPORTED_MODULE_0__.DrawSpeed.DynamicDraw);\r\n        this.render(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/shaders/texture-mesh-shader.ts?");

/***/ }),

/***/ "../engine/src/system/core.ts":
/*!************************************!*\
  !*** ../engine/src/system/core.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Core\": () => (/* binding */ Core)\n/* harmony export */ });\n/* harmony import */ var _input_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input-state */ \"../engine/src/system/input-state.ts\");\n/* harmony import */ var _fps_counter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fps-counter */ \"../engine/src/system/fps-counter.ts\");\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui */ \"../engine/src/system/ui.ts\");\n// Author: Jos Feenstra\r\n// Purpose: The Core app. This can hold multiple other apps with their own Update and Draw calls.\r\n// Use this to switch between Apps, or run multiple Apps.\r\n\r\n\r\n\r\nclass Core {\r\n    constructor(canvas, gl, uiFrame) {\r\n        this.fullscreen = true;\r\n        this.fpsInTitle = true;\r\n        this.canvas = canvas;\r\n        this.gl = gl;\r\n        this.state = new _input_state__WEBPACK_IMPORTED_MODULE_0__.InputState(canvas);\r\n        this.fpsCounter = new _fps_counter__WEBPACK_IMPORTED_MODULE_1__.FpsCounter();\r\n        this.ui = new _ui__WEBPACK_IMPORTED_MODULE_2__.UI(uiFrame);\r\n        this.apps = new Map();\r\n    }\r\n    // todo: cycle through apps\r\n    addApp(app) {\r\n        this.apps.set(app.name, app);\r\n        this.activateApp(app);\r\n    }\r\n    removeApp(appName) {\r\n        this.ui.removeContext(appName);\r\n        this.apps.delete(appName);\r\n    }\r\n    activateApp(app) {\r\n        this.ui.addContext(app.name);\r\n        this.ui.addText(app.description);\r\n        app.ui(this.ui);\r\n        app.start();\r\n    }\r\n    update(time) {\r\n        this.state.preUpdate(time);\r\n        this.fpsCounter.update(this.state);\r\n        this.apps.forEach((app) => {\r\n            app.update(this.state);\r\n        });\r\n        this.state.postUpdate();\r\n    }\r\n    draw() {\r\n        const canvas = this.canvas;\r\n        const gl = this.gl;\r\n        // put fps in the title\r\n        if (this.fpsInTitle) {\r\n            document.title = \"fps: \" + this.fpsCounter.getFps();\r\n        }\r\n        if (this.fullscreen) {\r\n            // pre-gl business\r\n            if (window.innerHeight != canvas.height || window.innerWidth != canvas.width) {\r\n                canvas.height = window.innerHeight;\r\n                // canvas.clientHeight = window.innerHeight;\r\n                canvas.style.height = window.innerHeight.toString();\r\n                canvas.width = window.innerWidth;\r\n                // canvas.clientWidth = window.innerWidth;\r\n                canvas.style.width = window.innerWidth.toString();\r\n                gl.viewport(0, 0, window.innerWidth, window.innerHeight);\r\n            }\r\n        }\r\n        else {\r\n        }\r\n        this.gl.clearColor(0, 0, 0, 0);\r\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\r\n        // render all apps\r\n        // TODO : reverse order\r\n        this.apps.forEach((app) => {\r\n            app.draw(this.gl);\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/system/core.ts?");

/***/ }),

/***/ "../engine/src/system/domwrappers.ts":
/*!*******************************************!*\
  !*** ../engine/src/system/domwrappers.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addDropFileEventListeners\": () => (/* binding */ addDropFileEventListeners),\n/* harmony export */   \"loadTextFromFile\": () => (/* binding */ loadTextFromFile),\n/* harmony export */   \"loadJSONFromFile\": () => (/* binding */ loadJSONFromFile),\n/* harmony export */   \"loadImageFromFile\": () => (/* binding */ loadImageFromFile),\n/* harmony export */   \"loadImageFromBlob\": () => (/* binding */ loadImageFromBlob),\n/* harmony export */   \"loadImageFromSrc\": () => (/* binding */ loadImageFromSrc)\n/* harmony export */ });\n// domwrappers.ts\r\n// author : Jos Feenstra\r\n// purpuse : wrap certain DOM functionalities\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nfunction addDropFileEventListeners(canvas, filesCallback) {\r\n    console.log(\"setting up drag events...\");\r\n    canvas.addEventListener(\"dragenter\", function (ev) {\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"entering entering...\");\r\n        return true;\r\n    }, true);\r\n    // setup file upload\r\n    canvas.addEventListener(\"dragover\", function (ev) {\r\n        //add hover class when drag over\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"over drag....\");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener(\"dragleave\", function (ev) {\r\n        //remove hover class when drag out\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"leaving drag....\");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener(\"drop\", function (ev) {\r\n        //prevent browser from open the file when drop off\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n        //retrieve uploaded files data\r\n        var files = ev.dataTransfer.files;\r\n        filesCallback(files);\r\n        return true;\r\n    }, true);\r\n}\r\nfunction loadImageTest(files) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let image = yield loadImageFromFile(files.item(0));\r\n    });\r\n}\r\nfunction loadTextFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(reader.result);\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\nfunction loadJSONFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(JSON.parse(reader.result));\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\nfunction loadImageFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(file);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\nfunction loadImageFromBlob(blob) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(blob);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\nfunction loadImageFromSrc(src) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement(\"img\");\r\n        img.src = src;\r\n        img.onload = () => resolve(loadImageHelper2(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction loadImageHelper1(fileReader) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement(\"img\");\r\n        img.src = fileReader.result;\r\n        img.onload = () => resolve(loadImageHelper2(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction loadImageHelper2(image) {\r\n    var _a;\r\n    // turn it into image data by building a complete canvas and sampling it\r\n    let canvas = document.createElement(\"canvas\");\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    let ctx = canvas.getContext(\"2d\");\r\n    ctx.drawImage(image, 0, 0);\r\n    let data = ctx.getImageData(0, 0, image.width, image.height);\r\n    (_a = canvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(canvas);\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/system/domwrappers.ts?");

/***/ }),

/***/ "../engine/src/system/fps-counter.ts":
/*!*******************************************!*\
  !*** ../engine/src/system/fps-counter.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"FpsCounter\": () => (/* binding */ FpsCounter)\n/* harmony export */ });\nclass FpsCounter {\r\n    constructor() {\r\n        this.fps = 0;\r\n        this.updateEveryXTicks = 100;\r\n        this.elapsed = 0;\r\n        this.frames = 0;\r\n    }\r\n    static new() {\r\n        return new FpsCounter();\r\n    }\r\n    _update(dt) {\r\n        this.frames += 1;\r\n        this.elapsed += dt;\r\n        if (this.elapsed > this.updateEveryXTicks) {\r\n            this.setFps();\r\n            this.elapsed = 0;\r\n            this.frames = 0;\r\n        }\r\n    }\r\n    update(state) {\r\n        this._update(state.tick);\r\n    }\r\n    setFps() {\r\n        this.fps = Math.round((this.frames / this.elapsed) * 1000);\r\n    }\r\n    getFps() {\r\n        return this.fps;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/system/fps-counter.ts?");

/***/ }),

/***/ "../engine/src/system/input-state.ts":
/*!*******************************************!*\
  !*** ../engine/src/system/input-state.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"InputState\": () => (/* binding */ InputState)\n/* harmony export */ });\n/* harmony import */ var _math_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/vector */ \"../engine/src/math/vector.ts\");\n// CanvasInputHandler.ts\r\n// author : Jos Feenstra\r\n// purpose : handle all input events.\r\n\r\nvar Key;\r\n(function (Key) {\r\n    Key[Key[\"A\"] = 0] = \"A\";\r\n    Key[Key[\"B\"] = 1] = \"B\";\r\n    Key[Key[\"C\"] = 2] = \"C\";\r\n    Key[Key[\"D\"] = 3] = \"D\";\r\n    Key[Key[\"E\"] = 4] = \"E\";\r\n    Key[Key[\"F\"] = 5] = \"F\";\r\n    Key[Key[\"G\"] = 6] = \"G\";\r\n    Key[Key[\"H\"] = 7] = \"H\";\r\n    Key[Key[\"I\"] = 8] = \"I\";\r\n    Key[Key[\"J\"] = 9] = \"J\";\r\n    Key[Key[\"K\"] = 10] = \"K\";\r\n    Key[Key[\"L\"] = 11] = \"L\";\r\n    Key[Key[\"M\"] = 12] = \"M\";\r\n    Key[Key[\"N\"] = 13] = \"N\";\r\n    Key[Key[\"O\"] = 14] = \"O\";\r\n    Key[Key[\"P\"] = 15] = \"P\";\r\n    Key[Key[\"Q\"] = 16] = \"Q\";\r\n    Key[Key[\"R\"] = 17] = \"R\";\r\n    Key[Key[\"S\"] = 18] = \"S\";\r\n    Key[Key[\"T\"] = 19] = \"T\";\r\n    Key[Key[\"U\"] = 20] = \"U\";\r\n    Key[Key[\"V\"] = 21] = \"V\";\r\n    Key[Key[\"W\"] = 22] = \"W\";\r\n    Key[Key[\"X\"] = 23] = \"X\";\r\n    Key[Key[\"Y\"] = 24] = \"Y\";\r\n    Key[Key[\"Z\"] = 25] = \"Z\";\r\n    Key[Key[\"Up\"] = 26] = \"Up\";\r\n    Key[Key[\"Down\"] = 27] = \"Down\";\r\n    Key[Key[\"Left\"] = 28] = \"Left\";\r\n    Key[Key[\"Right\"] = 29] = \"Right\";\r\n    Key[Key[\"Space\"] = 30] = \"Space\";\r\n    Key[Key[\"Control\"] = 31] = \"Control\";\r\n    Key[Key[\"Alt\"] = 32] = \"Alt\";\r\n    Key[Key[\"Shift\"] = 33] = \"Shift\";\r\n    Key[Key[\"Enter\"] = 34] = \"Enter\";\r\n    Key[Key[\"Esc\"] = 35] = \"Esc\";\r\n    Key[Key[\"N1\"] = 36] = \"N1\";\r\n    Key[Key[\"N2\"] = 37] = \"N2\";\r\n    Key[Key[\"N3\"] = 38] = \"N3\";\r\n    Key[Key[\"N4\"] = 39] = \"N4\";\r\n    Key[Key[\"N5\"] = 40] = \"N5\";\r\n    Key[Key[\"N6\"] = 41] = \"N6\";\r\n    Key[Key[\"N7\"] = 42] = \"N7\";\r\n    Key[Key[\"N8\"] = 43] = \"N8\";\r\n    Key[Key[\"N9\"] = 44] = \"N9\";\r\n    Key[Key[\"N0\"] = 45] = \"N0\";\r\n    Key[Key[\"Plus\"] = 46] = \"Plus\";\r\n    Key[Key[\"Minus\"] = 47] = \"Minus\";\r\n    Key[Key[\"Backspace\"] = 48] = \"Backspace\";\r\n})(Key || (Key = {}));\r\nfunction toMapping(key) {\r\n    switch (key) {\r\n        case Key.A:\r\n            return 1;\r\n        case Key.B:\r\n            return 2;\r\n        case Key.C:\r\n            return 3;\r\n        case Key.D:\r\n            return 4;\r\n        case Key.E:\r\n            return 5;\r\n        case Key.F:\r\n            return 6;\r\n        default:\r\n            return 0;\r\n    }\r\n}\r\nclass InputState {\r\n    constructor(canvas) {\r\n        this.mousePos = _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mousePosBuffered = _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mousePosPrev = _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mouseDelta = _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        this.mouseLeftDown = false;\r\n        this.mouseLeftPressed = false;\r\n        this.mouseLeftPrev = false;\r\n        this.mouseRightDown = false;\r\n        this.mouseRightPressed = false;\r\n        this.mouseRightPrev = false;\r\n        this.mouseMiddleDown = false;\r\n        this.mouseMiddlePressed = false;\r\n        this.mouseMiddlePrev = false;\r\n        this.keysDown = {};\r\n        this.keysPressed = [];\r\n        this.scrollValue = 0;\r\n        this.scrollValuePrevious = 0;\r\n        this.mouseScrollDelta = 0;\r\n        this.mouseScrollBuffered = 0;\r\n        // link\r\n        this.canvas = canvas;\r\n        // time\r\n        this.tick = 0;\r\n        this.oldTime = Date.now();\r\n        this.newTime = this.oldTime;\r\n        this.startTime = Date.now();\r\n        this.minimumTick = 1000 / 144;\r\n        // pointer\r\n        // if (window.PointerEvent) {\r\n        //     console.log(\"pointer events\")\r\n        //     canvas.addEventListener(\"pointerdown\", this.onPointerDown.bind(this));\r\n        //     canvas.addEventListener(\"pointerup\", this.onPointerUp.bind(this));\r\n        //     canvas.addEventListener(\"pointermove\", this.onPointerMove.bind(this));\r\n        // } else {\r\n        canvas.addEventListener(\"mousedown\", this.onMouseDown.bind(this));\r\n        canvas.addEventListener(\"mouseup\", this.onMouseUp.bind(this));\r\n        canvas.addEventListener(\"contextmenu\", (e) => {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        });\r\n        document.addEventListener(\"mousemove\", this.onMouseMove.bind(this));\r\n        canvas.addEventListener(\"wheel\", this.setMouseScroll.bind(this));\r\n        canvas.addEventListener(\"touchstart\", this.onTouchDown.bind(this));\r\n        canvas.addEventListener(\"touchend\", this.onTouchUp.bind(this));\r\n        canvas.addEventListener(\"touchmove\", this.onTouchMove.bind(this));\r\n        // }\r\n        // for (let i = 0; i < 223; i++) this.keysDown[i] = false;\r\n        // keyboard\r\n        canvas.addEventListener(\"keydown\", this.onKeyDown.bind(this));\r\n        // canvas.addEventListener(\"keypressed\", this.onKeyPressed.bind(this));\r\n        canvas.addEventListener(\"keyup\", this.onKeyUp.bind(this));\r\n        // final\r\n        canvas.focus();\r\n    }\r\n    static new(canvas) {\r\n        return new InputState(canvas);\r\n    }\r\n    preUpdate(tick) {\r\n        // this must be called every tick within whatever context this is used\r\n        // update time\r\n        this.newTime = Date.now();\r\n        this.oldTime = this.newTime;\r\n        this.tick = tick;\r\n        // update mouse pos \r\n        if (!this.mousePosBuffered.equals(this.mousePos)) {\r\n            // mouse has moved during previous frame\r\n            this.mousePos = this.mousePosBuffered.clone();\r\n            this.mouseDelta = this.mousePos.subbed(this.mousePosPrev);\r\n            this.mousePosPrev = this.mousePos.clone();\r\n        }\r\n        else {\r\n            this.mouseDelta = _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2.zero();\r\n        }\r\n        // update mouse buttons\r\n        this.mouseLeftPressed = this.mouseLeftPrev != this.mouseLeftDown && this.mouseLeftDown;\r\n        this.mouseRightPressed = this.mouseRightPrev != this.mouseRightDown && this.mouseRightDown;\r\n        this.mouseMiddlePressed =\r\n            this.mouseMiddlePrev != this.mouseMiddleDown && this.mouseMiddleDown;\r\n        // update scrolling\r\n        // normalize all scrolling behaviour\r\n        if (this.mouseScrollBuffered != 0) {\r\n            // we are scrolling\r\n            let value = 0.1;\r\n            if (this.mouseScrollBuffered < 0)\r\n                value = -0.1;\r\n            this.scrollValue = Math.max(0, this.scrollValue + value);\r\n            this.mouseScrollDelta = value;\r\n            this.mouseScrollBuffered = 0;\r\n        }\r\n        else {\r\n            // this.mouseScrollBuffered = 0;\r\n            this.mouseScrollDelta = 0;\r\n        }\r\n    }\r\n    setScrollValue(value) {\r\n        this.scrollValue = Math.max(0, value);\r\n    }\r\n    postUpdate() {\r\n        // this also must be called for keyIsPressed to work\r\n        this.mouseLeftPrev = this.mouseLeftDown;\r\n        this.mouseRightPrev = this.mouseRightDown;\r\n        this.mouseMiddlePrev = this.mouseMiddleDown;\r\n        // refresh keypresses\r\n        this.keysPressed = [];\r\n    }\r\n    IsKeyDown(key) {\r\n        return this.keysDown[key];\r\n    }\r\n    IsKeyPressed(key) {\r\n        for (let k of this.keysPressed) {\r\n            if (k === key) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    onKeyDown(e) {\r\n        let key = e.key.toLowerCase();\r\n        if (this.keysDown[key] == true)\r\n            return;\r\n        // console.log(key);\r\n        this.keysDown[key] = true;\r\n        this.keysPressed.push(key);\r\n    }\r\n    onKeyUp(e) {\r\n        let key = e.key.toLowerCase();\r\n        this.keysDown[key] = false;\r\n    }\r\n    onKeyPressed(e) {\r\n        // NOTE: i made a different system to handle this, see onKeyDown\r\n    }\r\n    setMouseScroll(e) {\r\n        this.mouseScrollBuffered = e.deltaY;\r\n    }\r\n    setMousePos(x, y) {\r\n        this.mousePosBuffered = new _math_vector__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);\r\n    }\r\n    onMouseUp(e) {\r\n        let code = e.buttons;\r\n        if (code < 4) {\r\n            this.mouseMiddleDown = false;\r\n        }\r\n        if (code < 2) {\r\n            this.mouseRightDown = false;\r\n        }\r\n        if (code < 1) {\r\n            this.mouseLeftDown = false;\r\n            if (this.onMouseLeftUp)\r\n                this.onMouseLeftUp();\r\n        }\r\n    }\r\n    onMouseMove(e) {\r\n        // this is a bit messy, BUT, multiply by camera parameters\r\n        this.setMousePos(e.clientX, e.clientY);\r\n    }\r\n    onMouseDown(e) {\r\n        e.preventDefault();\r\n        // e.stopPropagation();\r\n        this.canvas.focus();\r\n        let code = e.buttons;\r\n        if (code >= 4) {\r\n            code -= 4;\r\n            this.mouseMiddleDown = true;\r\n        }\r\n        if (code >= 2) {\r\n            code -= 2;\r\n            this.mouseRightDown = true;\r\n        }\r\n        if (code >= 1) {\r\n            code -= 1;\r\n            this.mouseLeftDown = true;\r\n        }\r\n        return false;\r\n    }\r\n    onTouchDown(e) {\r\n        let buttons = 0;\r\n        if (e.touches.length > 0) {\r\n            buttons += 1;\r\n        }\r\n        if (e.touches.length > 11) {\r\n            buttons += 2;\r\n        }\r\n        let mouseEvent = new MouseEvent(\"mousedown\", { buttons });\r\n        this.canvas.dispatchEvent(mouseEvent);\r\n        let clientX = e.touches[0].clientX;\r\n        let clientY = e.touches[0].clientY;\r\n        let mouseEvent2 = new MouseEvent(\"mousemove\", { clientX, clientY });\r\n        this.canvas.dispatchEvent(mouseEvent2);\r\n        e.stopPropagation();\r\n    }\r\n    onTouchMove(e) {\r\n        let clientX = e.touches[0].clientX;\r\n        let clientY = e.touches[0].clientY;\r\n        let mouseEvent = new MouseEvent(\"mousemove\", { clientX, clientY });\r\n        this.canvas.dispatchEvent(mouseEvent);\r\n    }\r\n    onTouchUp(e) {\r\n        let mouseEvent = new MouseEvent(\"mouseup\", {});\r\n        this.canvas.dispatchEvent(mouseEvent);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/system/input-state.ts?");

/***/ }),

/***/ "../engine/src/system/stopwatch.ts":
/*!*****************************************!*\
  !*** ../engine/src/system/stopwatch.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stopwatch\": () => (/* binding */ Stopwatch)\n/* harmony export */ });\nclass Stopwatch {\r\n    constructor(oldTime, newTime) {\r\n        this.oldTime = oldTime;\r\n        this.newTime = newTime;\r\n    }\r\n    static new() {\r\n        let s = new Stopwatch(0, 0);\r\n        s.time();\r\n        return s;\r\n    }\r\n    time() {\r\n        this.newTime = this.getTime();\r\n        let timePast = this.newTime - this.oldTime;\r\n        this.oldTime = this.newTime;\r\n        return timePast;\r\n    }\r\n    log(event) {\r\n        console.log(`${event} took: ${this.time()} ms`);\r\n    }\r\n    getTime() {\r\n        return new Date().getTime();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/system/stopwatch.ts?");

/***/ }),

/***/ "../engine/src/system/ui.ts":
/*!**********************************!*\
  !*** ../engine/src/system/ui.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"UI\": () => (/* binding */ UI),\n/* harmony export */   \"Parameter\": () => (/* binding */ Parameter),\n/* harmony export */   \"EnumParameter\": () => (/* binding */ EnumParameter)\n/* harmony export */ });\n/* harmony import */ var _math_domain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/domain */ \"../engine/src/math/domain.ts\");\n/* harmony import */ var _math_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/math */ \"../engine/src/math/math.ts\");\n// name:    ui.js\r\n// author:  Jos Feenstra\r\n// purpose: lets create the UI using html & dom api, because why the hell not\r\n\r\n\r\nclass UI {\r\n    constructor(frame) {\r\n        this.globalContext = frame;\r\n        this.currentContext = frame;\r\n    }\r\n    static new(frame) {\r\n        return new UI(frame);\r\n    }\r\n    // the context system makes sure that ui additions appear under the currently active,\r\n    // selected app, and that these ui elements are removed when switching to another app.\r\n    toggleVisibility() {\r\n        // simple toggle\r\n        if (this.globalContext.hidden) {\r\n            this.show();\r\n        }\r\n        else {\r\n            this.hide();\r\n        }\r\n    }\r\n    clear() {\r\n        let context = this.currentContext;\r\n        while (context.hasChildNodes()) {\r\n            context.removeChild(context.lastChild);\r\n        }\r\n    }\r\n    hide() {\r\n        this.globalContext.hidden = true;\r\n    }\r\n    show() {\r\n        this.globalContext.hidden = false;\r\n    }\r\n    addContext(appName) {\r\n        this.currentContext = this.globalContext;\r\n        let appDiv = this.addDiv(appName + \" app-interface\");\r\n        this.currentContext = appDiv;\r\n    }\r\n    setContext(appName) {\r\n        this.globalContext.getElementsByClassName(appName);\r\n    }\r\n    removeContext(appName) {\r\n        this.setContext(appName);\r\n        let count = this.currentContext.childElementCount;\r\n        for (let i = count - 1; i >= 0; i -= 1) {\r\n            this.currentContext.removeChild(this.currentContext.children.item(i));\r\n        }\r\n        let temp = this.currentContext;\r\n        this.currentContext = this.globalContext;\r\n        this.currentContext.removeChild(temp);\r\n    }\r\n    addElement(element, className = \"\") {\r\n        let el = document.createElement(element);\r\n        el.className = className;\r\n        this.currentContext.appendChild(el);\r\n        return el;\r\n    }\r\n    addDiv(classname, items = []) {\r\n        let div = this.addElement(\"div\", classname);\r\n        items.forEach((item) => {\r\n            div.appendChild(item);\r\n        });\r\n        return div;\r\n    }\r\n    addBooleanParameter(param, onInput = () => { }) {\r\n        // create hacky button\r\n        // <label class=\"check-container\">\r\n        //   <input type=\"checkbox\" checked=\"checked\">\r\n        //   <span class=\"checkmark\"></span>\r\n        // </label>\r\n        let checkbox = this.addElement(\"input\", \"checkbox\");\r\n        checkbox.type = \"checkbox\";\r\n        checkbox.addEventListener(\"change\", () => {\r\n            let state = checkbox.checked;\r\n            param.set(state ? 1 : 0);\r\n            onInput(checkbox.valueAsNumber);\r\n            text1.innerText = param.name;\r\n        });\r\n        checkbox.checked = param.get() == 1;\r\n        // this needs to be done to make css happy\r\n        let checkcontainer = this.addElement(\"label\", \"check-container\");\r\n        let checkmark = this.addElement(\"span\", \"checkmark\");\r\n        checkcontainer.appendChild(checkbox);\r\n        checkcontainer.appendChild(checkmark);\r\n        // text\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        text1.innerText = param.name;\r\n        // TODO update beyond our control\r\n        // param.onset = () => {\r\n        //     // console.log(\"TODO\");\r\n        // };\r\n        this.addDiv(\"control\", [text1, checkcontainer]);\r\n        return checkbox;\r\n    }\r\n    addParameter(param, onInput = () => { }) {\r\n        let p;\r\n        if (param instanceof EnumParameter) {\r\n            p = param.p;\r\n        }\r\n        else {\r\n            p = param;\r\n        }\r\n        // create slider itself\r\n        let slider = this.addRangeInput(p, onInput);\r\n        // create slider title\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        text1.innerText = p.name;\r\n        // create slider value indicator\r\n        let text2 = this.addElement(\"p\", \"control-value\");\r\n        if (param instanceof EnumParameter) {\r\n            text2.innerText = param.getName();\r\n        }\r\n        else {\r\n            text2.innerText = slider.value;\r\n        }\r\n        // put them all together\r\n        this.addDiv(\"control\", [text1, slider, text2]);\r\n        // on reverse update\r\n        param.setSliderAndText(slider, text2);\r\n        // on update by user\r\n        slider.oninput = () => {\r\n            p.set(slider.valueAsNumber, false);\r\n            onInput(slider.valueAsNumber);\r\n            if (param instanceof EnumParameter) {\r\n                text2.innerText = param.getName();\r\n            }\r\n            else {\r\n                text2.innerText = slider.value;\r\n            }\r\n        };\r\n        return slider;\r\n    }\r\n    addRangeInput(param, onInput = () => { }) {\r\n        // a slider looks like this : <input type=\"range\" min=\"1\" max=\"100\" step=\"1\" value=\"50\">\r\n        let slider = this.addElement(\"input\", \"control-slider\");\r\n        slider.type = \"range\";\r\n        slider.min = param.min.toString();\r\n        slider.max = param.max.toString();\r\n        slider.valueAsNumber = param.state;\r\n        slider.step = param.step.toString();\r\n        return slider;\r\n    }\r\n    addText(text) {\r\n        let p = this.addElement(\"p\", \"ui-text\");\r\n        p.innerText = text;\r\n    }\r\n    addButton(name, callback) {\r\n        let button = this.addElement(\"button\", \"control-button\");\r\n        button.innerText = name;\r\n        button.addEventListener(\"click\", callback);\r\n        let text1 = this.addElement(\"p\", \"control-text\");\r\n        let control = this.addDiv(\"control\", [text1, button]);\r\n        return control;\r\n    }\r\n    addDropdown(enumParam, onchange) {\r\n        // <select>\r\n        //  <option>Cappuccino</option>\r\n        //  <option>Mocha</option>\r\n        // </select>\r\n        let count = enumParam.values.length;\r\n        let dropdownSelector = this.addElement(\"select\", \"enum-selector dropdown-select\");\r\n        for (let i = 0; i < count; i++) {\r\n            let o = this.addElement(\"option\", \"enum-item\");\r\n            o.innerText = enumParam.values[i];\r\n            dropdownSelector.appendChild(o);\r\n        }\r\n        // console.log(e);\r\n        dropdownSelector.addEventListener(\"change\", (e) => {\r\n            let target = e.target;\r\n            let i = target.selectedIndex;\r\n            enumParam.set(i);\r\n            onchange(i);\r\n        });\r\n        this.addDiv(\"dropdown-dark\", [dropdownSelector]);\r\n        return dropdownSelector;\r\n    }\r\n}\r\n// a slider parameter\r\nclass Parameter {\r\n    constructor(name, state, min = -Infinity, max = Infinity, step = 0.1) {\r\n        this.name = name;\r\n        this.min = min;\r\n        this.max = max;\r\n        this.step = step;\r\n        this.state = state;\r\n        this.set(this.state);\r\n    }\r\n    static new(name, state, min = -Infinity, max = Infinity, step = 0.1) {\r\n        return new Parameter(name, state, min, max, step);\r\n    }\r\n    static newBoolean(name, state) {\r\n        return new Parameter(name, state ? 1 : 0, 0, 1, 1);\r\n    }\r\n    get() {\r\n        return this.state;\r\n    }\r\n    getDomain() {\r\n        return _math_domain__WEBPACK_IMPORTED_MODULE_0__.Domain.new(this.min, this.max);\r\n    }\r\n    set(state, activateOnSet = true) {\r\n        // something is still wrong here...\r\n        let clamped = _math_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(state, this.min, this.max);\r\n        let rest = state - this.min;\r\n        let times = Math.round(rest / this.step);\r\n        let stepped = this.min + this.step * times;\r\n        this.state = _math_math__WEBPACK_IMPORTED_MODULE_1__.GeonMath.clamp(stepped, this.min, this.max);\r\n        if (activateOnSet)\r\n            this.onset();\r\n    }\r\n    getNPermutations() {\r\n        return Math.min((this.max - this.min) / this.step + 1);\r\n    }\r\n    setSlider(slider) {\r\n        this.slider = slider;\r\n    }\r\n    setSliderAndText(slider, text) {\r\n        this.slider = slider;\r\n        this.text = text;\r\n    }\r\n    onset() {\r\n        if (this.slider)\r\n            this.slider.valueAsNumber = this.state;\r\n        if (this.text)\r\n            this.text.innerText = this.state.toString();\r\n    }\r\n}\r\n// a parameter representing distinct states\r\nclass EnumParameter {\r\n    constructor(p, values) {\r\n        this.p = p;\r\n        this.values = values;\r\n    }\r\n    static new(name, state, descriptions) {\r\n        return new EnumParameter(new Parameter(name, state, 0, descriptions.length - 1, 1), descriptions);\r\n    }\r\n    getName() {\r\n        return this.values[this.get()];\r\n    }\r\n    // passthroughs\r\n    get() {\r\n        return this.p.get();\r\n    }\r\n    set(state) {\r\n        return this.p.set(state);\r\n    }\r\n    getNPermutations() {\r\n        return this.p.getNPermutations();\r\n    }\r\n    setSlider(slider) {\r\n        this.slider = slider;\r\n    }\r\n    setSliderAndText(slider, text) {\r\n        this.slider = slider;\r\n        this.text = text;\r\n    }\r\n    onset() {\r\n        if (this.slider)\r\n            this.slider.valueAsNumber = this.get();\r\n        if (this.text)\r\n            this.text.innerText = this.getName();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/../engine/src/system/ui.ts?");

/***/ }),

/***/ "./src/ctx/ctx-camera.ts":
/*!*******************************!*\
  !*** ./src/ctx/ctx-camera.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CtxCamera\": () => (/* binding */ CtxCamera)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n\r\n/**\r\n * 2d camera for ctx context\r\n */\r\nclass CtxCamera {\r\n    constructor(html_canvas, pos, scale) {\r\n        this.html_canvas = html_canvas;\r\n        this.pos = pos;\r\n        this.scale = scale;\r\n        this.scaleRange = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Domain.new(0.3, 5);\r\n        this.mousePos = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new();\r\n    }\r\n    static new(html_canvas, startPos, startScale) {\r\n        return new CtxCamera(html_canvas, startPos, startScale);\r\n    }\r\n    log() {\r\n        console.log(`camera pos: ${this.pos} scale: ${this.scale}`);\r\n    }\r\n    update(state) {\r\n        let redraw = false;\r\n        // always store mouse \r\n        let worldPos = this.screenToWorld(state.mousePos);\r\n        this.mousePos = worldPos;\r\n        // we have to check these things every frame to make dragging consistent\r\n        // clicking down\r\n        if (state.mouseLeftPressed && this.onMouseDown) {\r\n            this.onMouseDown(worldPos);\r\n        }\r\n        // click lift \r\n        // console.log(state.mouseLeftDown, state.mouseLeftPrev);\r\n        if (!state.mouseLeftDown && state.mouseLeftPrev && this.onMouseUp) {\r\n            this.onMouseUp(worldPos);\r\n        }\r\n        // panning\r\n        if (state.mouseRightDown) {\r\n            this.pos.sub(state.mouseDelta);\r\n            redraw = true;\r\n        }\r\n        // zooming [JF] Lets leave this for later... \r\n        if (state.mouseScrollDelta != 0) {\r\n            // let zoompoint = this.getCenter();\r\n            // let world1 = this.screenToWorld(zoompoint);\r\n            // this.scale = this.scaleRange.comform(this.scale * (1 - state.mouseScrollDelta));\r\n            // // calculate the new top-left point\r\n            // // thanks to zoomchange, this is now different\r\n            // let world2 = this.screenToWorld(zoompoint);\r\n            // let diff = world2.sub(world1);\r\n            // // this.position.add(diff);\r\n            // this.position = this.position.lerp(zoompoint, scalar / 2);\r\n            redraw = true;\r\n        }\r\n        return redraw;\r\n    }\r\n    screenToWorld(sv) {\r\n        sv = sv.clone();\r\n        // translate\r\n        sv.add(this.pos);\r\n        // scale\r\n        return sv.scaled(1 / this.scale);\r\n    }\r\n    worldToScreen(wv) {\r\n        // inv-scale\r\n        wv = wv.clone();\r\n        wv.scale(this.scale);\r\n        // inv-translate\r\n        return wv.sub(this.pos);\r\n    }\r\n    getCenter() {\r\n        let box = this.getBox();\r\n        return box.elevate(_engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(0.5, 0.5));\r\n    }\r\n    moveCtxToState(ctx) {\r\n        ctx.translate(-this.pos.x, -this.pos.y);\r\n        ctx.scale(this.scale, this.scale);\r\n    }\r\n    getBox() {\r\n        let width = this.html_canvas.width;\r\n        let height = this.html_canvas.height;\r\n        return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH(this.pos.x, this.pos.y, width, height);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ctx/ctx-camera.ts?");

/***/ }),

/***/ "./src/ctx/ctx-helpers.ts":
/*!********************************!*\
  !*** ./src/ctx/ctx-helpers.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"resizeCanvas\": () => (/* binding */ resizeCanvas)\n/* harmony export */ });\n// for resizing\r\nfunction resizeCanvas(ctx) {\r\n    // Lookup the size the browser is displaying the canvas in CSS pixels.\r\n    let canvas = ctx.canvas;\r\n    const displayWidth = canvas.clientWidth;\r\n    const displayHeight = canvas.clientHeight;\r\n    // Check if the canvas is not the same size.\r\n    const needResize = ctx.canvas.width !== displayWidth || ctx.canvas.height !== displayHeight;\r\n    if (needResize) {\r\n        // Make the canvas the same size\r\n        ctx.canvas.width = displayWidth;\r\n        ctx.canvas.height = displayHeight;\r\n    }\r\n    // Tell WebGL how to convert from clip space to pixels\r\n    // gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n    return needResize;\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ctx/ctx-helpers.ts?");

/***/ }),

/***/ "./src/graph/cable.ts":
/*!****************************!*\
  !*** ./src/graph/cable.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CableState\": () => (/* binding */ CableState),\n/* harmony export */   \"Cable\": () => (/* binding */ Cable)\n/* harmony export */ });\nvar CableState;\r\n(function (CableState) {\r\n    CableState[CableState[\"On\"] = 0] = \"On\";\r\n    CableState[CableState[\"Off\"] = 1] = \"Off\";\r\n    CableState[CableState[\"Selected\"] = 2] = \"Selected\";\r\n})(CableState || (CableState = {}));\r\nclass Cable {\r\n    constructor(from, _to, state) {\r\n        this.from = from;\r\n        this._to = _to;\r\n        this.state = state;\r\n    }\r\n    static new(a, b) {\r\n        if (a.idx < b.idx) {\r\n            return Cable.new(b, a);\r\n        }\r\n        else {\r\n            let map = new Map();\r\n            map.set(b.toString(), b);\r\n            return new Cable(a, map, CableState.Off);\r\n        }\r\n    }\r\n    get to() {\r\n        return this._to.values();\r\n    }\r\n    add(s) {\r\n        this._to.set(s.toString(), s);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/cable.ts?");

/***/ }),

/***/ "./src/graph/graph-conversion.ts":
/*!***************************************!*\
  !*** ./src/graph/graph-conversion.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"jsToGraph\": () => (/* binding */ jsToGraph),\n/* harmony export */   \"graphToFunction\": () => (/* binding */ graphToFunction),\n/* harmony export */   \"makeOperationsGlobal\": () => (/* binding */ makeOperationsGlobal)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _operations_catalogue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../operations/catalogue */ \"./src/operations/catalogue.ts\");\n/* harmony import */ var _util_permutator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/permutator */ \"./src/util/permutator.ts\");\n/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./graph */ \"./src/graph/graph.ts\");\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./socket */ \"./src/graph/socket.ts\");\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./widget */ \"./src/graph/widget.ts\");\n// author:  Jos Feenstra\r\n// note:    since this graph->js business is very specific and weird, I thought it best to split it away from `graph.ts`\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Create a new Graph from a js function. This function must be a pure function, and can only call other pure functions.\r\n *\r\n * TODO\r\n * - make sure that this could work even without comments\r\n *\r\n * subcomponents:\r\n * - figure out the difference between variable and function\r\n * - figure out which functions are called, and the content of those methods\r\n * - turn functions into Operations\r\n * - create instances of those operations, and figure out where they should be placed on the canvas\r\n *    - enough spacing\r\n *    - x based on dependency depth\r\n *    - y based on call order, spacing\r\n *\r\n * - turn variables into cables, relationships\r\n * - turn inputs into input variables\r\n * - turn output into output variables\r\n */\r\nfunction jsToGraph(js, catalogue) {\r\n    // NOTE: this procedure also heavely relies on regex. Not foolproof!\r\n    let lines = js.split('\\n');\r\n    let all = lines.join(\"\");\r\n    let f = extractDeclareFunctionElements(all);\r\n    if (!f) {\r\n        return undefined;\r\n    }\r\n    let graph = _graph__WEBPACK_IMPORTED_MODULE_3__.NodesGraph.new();\r\n    let cableStarts = new Map();\r\n    let trySpawnNode = (name, type, x, y, lib = \"GEON\", state) => {\r\n        // TODO: catalogue.name == lib;\r\n        if (catalogue.trySelect(lib, name, type)) {\r\n            let node = catalogue.spawn(_engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(x, y));\r\n            if (type == _operations_catalogue__WEBPACK_IMPORTED_MODULE_1__.CoreType.Widget) {\r\n                // @ts-ignore\r\n                node.core.state = state;\r\n            }\r\n            let key = graph.addNode(node);\r\n            catalogue.deselect();\r\n            return key;\r\n        }\r\n        console.warn({ name, type, lib }, \"is undefined!!\");\r\n        return undefined;\r\n    };\r\n    let createCable = (key, nodeKey, idx) => {\r\n        cableStarts.set(key.trim(), _socket__WEBPACK_IMPORTED_MODULE_4__.Socket.new(nodeKey, idx));\r\n    };\r\n    let hookupCable = (key, nodeKey, idx) => {\r\n        let k = key.trim();\r\n        if (cableStarts.has(k)) {\r\n            let start = cableStarts.get(k);\r\n            graph.addCableBetween(start.node, start.idx, nodeKey, idx);\r\n        }\r\n    };\r\n    // ---------\r\n    for (let i = 0; i < f.inputs.length; i++) {\r\n        let line = f.inputs[i];\r\n        let l = extractComment(line);\r\n        if (!l) {\r\n            console.warn(\"bad input!\");\r\n            continue;\r\n        }\r\n        ;\r\n        let name = l.rest;\r\n        let json = commentToJson(l.comment);\r\n        let state = stringToState(json.state);\r\n        console.log(\"state\", state);\r\n        let nodeKey = trySpawnNode(json.widget, _operations_catalogue__WEBPACK_IMPORTED_MODULE_1__.CoreType.Widget, json.x, json.y, \"widgets\", state);\r\n        createCable(name, nodeKey, 0);\r\n    }\r\n    for (let i = 0; i < f.body.length; i++) {\r\n        let line = f.body[i];\r\n        let l = extractComment(line);\r\n        if (!l)\r\n            continue;\r\n        let rest = l.rest;\r\n        let json = commentToJson(l.comment);\r\n        // console.log({rest, json});\r\n        let call = extractCallFunctionElements(rest);\r\n        console.log(call.lib);\r\n        let nodeKey = trySpawnNode(call.name, _operations_catalogue__WEBPACK_IMPORTED_MODULE_1__.CoreType.Operation, json.x, json.y, call.lib);\r\n        for (let j = 0; j < call.outputs.length; j++) {\r\n            createCable(call.outputs[j], nodeKey, j);\r\n        }\r\n        for (let j = 0; j < call.inputs.length; j++) {\r\n            hookupCable(call.inputs[j], nodeKey, j);\r\n        }\r\n    }\r\n    for (let i = 0; i < f.outputs.length; i++) {\r\n        let line = f.outputs[i];\r\n        let l = extractComment(line);\r\n        if (!l)\r\n            continue;\r\n        let name = l.rest;\r\n        let json = commentToJson(l.comment);\r\n        let nodeKey = trySpawnNode(json.widget, _operations_catalogue__WEBPACK_IMPORTED_MODULE_1__.CoreType.Widget, json.x, json.y, \"widgets\");\r\n        hookupCable(name, nodeKey, 0);\r\n    }\r\n    // graph.log();\r\n    return graph;\r\n}\r\nfunction stringToState(stateString) {\r\n    let s = stateString;\r\n    if (s === \"true\")\r\n        return true;\r\n    if (s === \"false\")\r\n        return false;\r\n    return s;\r\n}\r\nfunction extractComment(str) {\r\n    let regex = /(.*)\\/\\*(.*)\\*\\//.exec(str);\r\n    if (!regex || regex.length != 3) {\r\n        return undefined;\r\n    }\r\n    return { rest: regex[1].trim(), comment: regex[2] };\r\n}\r\nfunction commentToJson(str) {\r\n    // turn it into a json\r\n    let jsonStr = `{${str.replace(/\\|/g, \",\")}}`;\r\n    return JSON.parse(jsonStr);\r\n}\r\nfunction extractCallFunctionElements(str) {\r\n    let functionRegex = /let *\\[(.*)\\] = ([a-zA-Z0-9]*).([a-zA-Z0-9]*)\\((.*)\\)/;\r\n    let res = functionRegex.exec(str);\r\n    if (!res)\r\n        return;\r\n    let outputs = res[1].split(',');\r\n    let lib = res[2];\r\n    let name = res[3];\r\n    let inputs = res[4].split(',');\r\n    return { inputs, lib, name, outputs };\r\n}\r\nfunction extractDeclareFunctionElements(str) {\r\n    let functionRegex = /function (.*)\\((.*)\\).*\\{(.*)return \\[(.*)\\].*\\}/;\r\n    let res = functionRegex.exec(str);\r\n    if (!res || res.length != 5) {\r\n        return undefined;\r\n    }\r\n    let name = res[1];\r\n    let inputs = res[2].split(',');\r\n    let body = res[3].split(';');\r\n    let outputs = res[4].split(',');\r\n    return { name, inputs, body, outputs };\r\n}\r\n/**\r\n * Convert the calculation done by this graph to plain JS\r\n */\r\nfunction graphToFunction(graph, name) {\r\n    var _a;\r\n    console.log(\"rendering html...\");\r\n    let orderedNodeKeys = graph.kahn();\r\n    let inputs = [];\r\n    let processes = [];\r\n    let outputs = [];\r\n    // this is a setup to convert the long cable hashes into names like `a`, `b`, `c`, `aa` etc. \r\n    let lowernames = _util_permutator__WEBPACK_IMPORTED_MODULE_2__.Permutator.newAlphabetPermutator(_util_permutator__WEBPACK_IMPORTED_MODULE_2__.Casing.lower);\r\n    let mapping = new Map(); // key -> cable key. value -> newly generated name\r\n    let toEasyNames = (hashes) => {\r\n        let names = [];\r\n        for (let hash of hashes) {\r\n            if (!mapping.has(hash)) {\r\n                mapping.set(hash, lowernames.next());\r\n            }\r\n            names.push(mapping.get(hash));\r\n        }\r\n        return names;\r\n    };\r\n    //start at the widgets (widget keys are the same as the corresponding node)\r\n    for (let key of orderedNodeKeys) {\r\n        let node = graph.getNode(key);\r\n        if (node.operation) { // A | operation \r\n            let inputs = toEasyNames(node.outputs()).join(\", \");\r\n            let outputs = toEasyNames(node.inputs()).join(\", \");\r\n            let str = `let [${inputs}] = ${node.operation.namespace}.${node.operation.name}(${outputs}) /* \"x\": ${node.position.x} | \"y\": ${node.position.y} */;`;\r\n            processes.push(str);\r\n        }\r\n        else if (node.widget.side == _widget__WEBPACK_IMPORTED_MODULE_5__.WidgetSide.Input) { // B | Input Widget\r\n            for (let str of toEasyNames(node.outputs())) {\r\n                str += ` /* \"widget\": \"${node.widget.name}\" | \"state\": \"${node.widget.state}\" | \"x\": ${node.position.x} | \"y\": ${node.position.y} */`;\r\n                inputs.push(str);\r\n            }\r\n        }\r\n        else if (node.widget.side == _widget__WEBPACK_IMPORTED_MODULE_5__.WidgetSide.Output) { // C | Output Widget \r\n            for (let str of toEasyNames(node.inputs())) {\r\n                str += ` /* \"widget\": \"${(_a = node.widget) === null || _a === void 0 ? void 0 : _a.name}\" | \"x\": ${node.position.x} | \"y\": ${node.position.y} */`;\r\n                outputs.push(str);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"should never happen\");\r\n        }\r\n    }\r\n    let fn = Function(...inputs, `    ${processes.join(\"\\n    \")}\r\n    return [${outputs.join(\", \")}];`);\r\n    Object.defineProperty(fn, \"name\", { value: name });\r\n    // console.log(fn.toString());\r\n    return fn;\r\n}\r\n/**\r\n * To make sure nested operations work, we need to publish the catalogue globally.\r\n */\r\nfunction makeOperationsGlobal(catalogue, namespace = \"GEON\") {\r\n    let space = {};\r\n    Object.defineProperty(window, namespace, { value: space, configurable: true });\r\n    // for (let op of catalogue.allOperations()) {\r\n    //     Object.defineProperty(space, op.func.name, { value: op.func, configurable: true});\r\n    // }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/graph-conversion.ts?");

/***/ }),

/***/ "./src/graph/graph.ts":
/*!****************************!*\
  !*** ./src/graph/graph.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NodesGraph\": () => (/* binding */ NodesGraph)\n/* harmony export */ });\n/* harmony import */ var _engine_src_math_random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/math/random */ \"../engine/src/math/random.ts\");\n/* harmony import */ var _cable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cable */ \"./src/graph/cable.ts\");\n/* harmony import */ var _graph_conversion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graph-conversion */ \"./src/graph/graph-conversion.ts\");\n/* harmony import */ var _socket__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./socket */ \"./src/graph/socket.ts\");\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./widget */ \"./src/graph/widget.ts\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * A Collection of Nodes, Gizmo's & Cables.\r\n * These are doubly linked. (Nodes point to cables, cables point to nodes).\r\n * The Graph makes sure these links remain correct\r\n */\r\nclass NodesGraph {\r\n    constructor(nodes, cables, widgets) {\r\n        this.nodes = nodes;\r\n        this.cables = cables;\r\n        this.widgets = widgets;\r\n    }\r\n    static new(nodes = new Map(), cables = new Map(), widgets = new Map()) {\r\n        return new NodesGraph(nodes, cables, widgets);\r\n    }\r\n    static fromJs(js, catalogue) {\r\n        // TODO\r\n        let graph = (0,_graph_conversion__WEBPACK_IMPORTED_MODULE_2__.jsToGraph)(js, catalogue);\r\n        if (!graph) {\r\n            console.warn(\"could not create graph from js\");\r\n            return NodesGraph.new();\r\n        }\r\n        else {\r\n            return graph;\r\n        }\r\n    }\r\n    toJs(name) {\r\n        return (0,_graph_conversion__WEBPACK_IMPORTED_MODULE_2__.graphToFunction)(this, name);\r\n    }\r\n    // ---- True Graph Business \r\n    /**\r\n     * Calculate the entire graph:\r\n     * - start with the data from input widgets\r\n     * - calculate all operations\r\n     * - store results in output widgets\r\n     * TODO: build something that can recalculate parts of the graph\r\n     */\r\n    calculate() {\r\n        let cache = new Map();\r\n        let orderedNodeKeys = this.kahn();\r\n        let setCache = (key, value) => {\r\n            let cable = this.getCable(key);\r\n            if (!cable) {\r\n                return;\r\n            }\r\n            if (value) {\r\n                cable.state = _cable__WEBPACK_IMPORTED_MODULE_1__.CableState.On;\r\n            }\r\n            else {\r\n                cable.state = _cable__WEBPACK_IMPORTED_MODULE_1__.CableState.Off;\r\n            }\r\n            cache.set(key, value);\r\n        };\r\n        //start at the widgets (widget keys are the same as the corresponding node)\r\n        for (let key of orderedNodeKeys) {\r\n            let node = this.getNode(key);\r\n            // calculate in several ways, depending on the node\r\n            if (node.operation) { // A | operation -> pull cache from cables & push cache to cables\r\n                let inputs = [];\r\n                for (let cable of node.inputs()) { // TODO multiple inputs!!\r\n                    inputs.push(cache.get(cable));\r\n                }\r\n                let outputs = node.operation.run(...inputs);\r\n                let outCables = node.outputs();\r\n                if (typeof outputs !== \"object\") {\r\n                    setCache(outCables[0], outputs);\r\n                }\r\n                else {\r\n                    for (let i = 0; i < node.operation.outputs; i++) {\r\n                        setCache(outCables[i], outputs[i]);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.widget.side == _widget__WEBPACK_IMPORTED_MODULE_4__.WidgetSide.Input) { // B | Input Widget -> push cache to cable\r\n                for (let cable of node.outputs()) {\r\n                    setCache(cable, node.widget.state);\r\n                }\r\n            }\r\n            else if (node.widget.side == _widget__WEBPACK_IMPORTED_MODULE_4__.WidgetSide.Output) { // C | Output Widget -> pull cache from cable\r\n                for (let cable of node.inputs()) { // TODO multiple inputs!!\r\n                    node.widget.state = cache.get(cable);\r\n                }\r\n            }\r\n            else {\r\n                throw new Error(\"should never happen\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * An implementation of kahn's algorithm:\r\n     * https://en.wikipedia.org/wiki/Topological_sorting\r\n     */\r\n    kahn() {\r\n        // fill starting lists\r\n        let L = [];\r\n        let S = [];\r\n        let visitedCables = new Set();\r\n        // use the widgets to identify the starting point\r\n        for (let [key, _] of this.widgets) {\r\n            let widget = this.getNode(key).widget;\r\n            if (widget.side != _widget__WEBPACK_IMPORTED_MODULE_4__.WidgetSide.Input)\r\n                continue;\r\n            S.push(key);\r\n        }\r\n        while (true) {\r\n            let node = S.pop();\r\n            if (node == undefined)\r\n                break;\r\n            L.push(node);\r\n            // for each node m with an edge e from n to m do\r\n            for (let cable of this.getNode(node).outputs()) {\r\n                // 'remove' edge e from the graph\r\n                if (visitedCables.has(cable))\r\n                    continue;\r\n                visitedCables.add(cable);\r\n                // if m has no other incoming edges then\r\n                //    insert m into S\r\n                for (let nb of this.getCable(cable).to) {\r\n                    let m = nb.node;\r\n                    let allVisited = true;\r\n                    for (let c of this.getNode(m).inputs()) {\r\n                        if (!visitedCables.has(c)) {\r\n                            allVisited = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (allVisited) {\r\n                        S.push(m);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return L;\r\n    }\r\n    // ---- Node Management \r\n    addNode(node) {\r\n        let key = (0,_engine_src_math_random__WEBPACK_IMPORTED_MODULE_0__.createRandomGUID)();\r\n        this.nodes.set(key, node);\r\n        if (node.core instanceof _widget__WEBPACK_IMPORTED_MODULE_4__.Widget) {\r\n            this.widgets.set(key, node.core);\r\n        }\r\n        return key;\r\n    }\r\n    getNode(key) {\r\n        return this.nodes.get(key);\r\n    }\r\n    deleteNode(nkey) {\r\n        let node = this.nodes.get(nkey);\r\n        // pull all connections at connectors\r\n        for (let [idx, cable] of node.connections) {\r\n            this.emptySocket(cable, _socket__WEBPACK_IMPORTED_MODULE_3__.Socket.new(nkey, idx));\r\n        }\r\n        // remove the widget pointer\r\n        if (node.core instanceof _widget__WEBPACK_IMPORTED_MODULE_4__.Widget) {\r\n            this.widgets.delete(nkey);\r\n        }\r\n        return this.nodes.delete(nkey);\r\n    }\r\n    getCable(key) {\r\n        return this.cables.get(key);\r\n    }\r\n    fillSocket(ckey, c) {\r\n        let cable = this.cables.get(ckey);\r\n        // remove existing connections\r\n        if (c.side == 1 /* Output */) {\r\n            // take care of this one level higher than this\r\n        }\r\n        else if (c.side == -1 /* Input */) {\r\n            // make sure the socket is empty\r\n            let existingTo = this.getCableAtConnector(c);\r\n            if (existingTo) {\r\n                this.emptySocket(existingTo, c);\r\n            }\r\n        }\r\n        // add the new connection\r\n        this.setNodeCableConnection(ckey, c);\r\n    }\r\n    emptySocket(ckey, c) {\r\n        let cable = this.cables.get(ckey);\r\n        // console.log(\"EMPTYING A SOCKET FROM \"+ this.nodes.get(c.node)?.core.name)\r\n        if (c.side == 1 /* Output */) {\r\n            // if connection is input, delete the entire cable\r\n            // console.log(\"EMPTY Output...\");\r\n            // console.log(\"WE NEED TO DELETE THE ENTIRE CABLE\");\r\n            for (let to of cable.to) {\r\n                this.emptySocket(ckey, to);\r\n            }\r\n            this.cables.delete(ckey);\r\n        }\r\n        else if (c.side == -1 /* Input */) {\r\n            cable._to.delete(c.toString());\r\n            if (cable._to.size == 0) {\r\n                // this will delete the cable as well\r\n                this.emptySocket(ckey, cable.from);\r\n            }\r\n            // console.log(\"WE NEED TO DELETE THE ENTIRE CABLE ONLY IF WE ARE THE LAST\");\r\n        }\r\n        // remove the node pointer \r\n        this.removeNodeConnection(c);\r\n        return true;\r\n    }\r\n    // ---- Cable Management\r\n    addCable(a, b) {\r\n        // before we create the cable, make sure the sockets are free\r\n        let cable = _cable__WEBPACK_IMPORTED_MODULE_1__.Cable.new(a, b);\r\n        // If a cable exist at the start of this cable, do not add a new cable.\r\n        // but add an additional output to this one\r\n        let existingFrom = this.getCableAtConnector(cable.from);\r\n        if (existingFrom) {\r\n            console.log(\"adding to existing...\");\r\n            for (let to of cable.to) {\r\n                if (existingFrom == this.getCableAtConnector(to)) {\r\n                    console.log(\"this full cable exist already\");\r\n                    // if the current 'to' socket is occupied by the same cable, this is meaningless\r\n                    return existingFrom;\r\n                }\r\n                this.fillSocket(existingFrom, to);\r\n            }\r\n            return existingFrom;\r\n        }\r\n        // add the actual cable, floating in the air as it were.\r\n        let cableKey = (0,_engine_src_math_random__WEBPACK_IMPORTED_MODULE_0__.createRandomGUID)();\r\n        this.cables.set(cableKey, cable);\r\n        // now plug it in\r\n        this.fillSocket(cableKey, cable.from);\r\n        for (let to of cable.to) {\r\n            this.fillSocket(cableKey, to);\r\n        }\r\n        return cableKey;\r\n    }\r\n    addCableBetween(a, outputIndex, b, inputIndex) {\r\n        let aComp = outputIndex + 1;\r\n        let bComp = (inputIndex + 1) * -1;\r\n        // console.log({a, outputIndex, b, inputIndex });\r\n        this.addCable(_socket__WEBPACK_IMPORTED_MODULE_3__.Socket.new(a, aComp), _socket__WEBPACK_IMPORTED_MODULE_3__.Socket.new(b, bComp));\r\n    }\r\n    // ---- Connection Management\r\n    getCableAtConnector(c) {\r\n        var _a;\r\n        return (_a = this.nodes.get(c.node)) === null || _a === void 0 ? void 0 : _a.connections.get(c.idx);\r\n    }\r\n    setNodeCableConnection(ckey, c) {\r\n        let cable = this.cables.get(ckey);\r\n        let node = this.nodes.get(c.node);\r\n        if (c.side == -1 /* Input */) {\r\n            // input of node | 'to' / B of cable\r\n            cable.add(c);\r\n            node.connections.set(c.idx, ckey);\r\n        }\r\n        else if (c.side == 1 /* Output */) {\r\n            // output of node | 'from' / A of cable\r\n            cable.from = c;\r\n            node.connections.set(c.idx, ckey);\r\n        }\r\n    }\r\n    removeNodeConnection(c) {\r\n        var _a;\r\n        return (_a = this.nodes.get(c.node)) === null || _a === void 0 ? void 0 : _a.connections.delete(c.idx);\r\n    }\r\n    log() {\r\n        console.log(\"GRAPH\");\r\n        console.log(\"NODES\");\r\n        console.log(\"-----\");\r\n        for (let [nkey, node] of this.nodes) {\r\n            console.log(\" node\");\r\n            console.log(\" L key : \", nkey);\r\n            console.log(\" L name: \", node.core.name);\r\n            console.log(\" L connections: \");\r\n            for (let [k, v] of node.connections) {\r\n                console.log(`   L key: ${k} | value: ${v}`);\r\n            }\r\n        }\r\n        console.log(\"CABLES\");\r\n        console.log(\"-----\");\r\n        for (let [ckey, cable] of this.cables) {\r\n            console.log(\"cable\");\r\n            console.log(\" L from :\", cable.from.toString());\r\n            console.log(\" L to   :\");\r\n            for (let to of cable.to) {\r\n                console.log(\"   L \", to.toString());\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/graph.ts?");

/***/ }),

/***/ "./src/graph/node.ts":
/*!***************************!*\
  !*** ./src/graph/node.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GeonNode\": () => (/* binding */ GeonNode)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _operation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./operation */ \"./src/graph/operation.ts\");\n/* harmony import */ var _widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./widget */ \"./src/graph/widget.ts\");\n\r\n\r\n\r\nclass GeonNode {\r\n    constructor(position, core, // slot for an operation\r\n    connections) {\r\n        this.position = position;\r\n        this.core = core;\r\n        this.connections = connections;\r\n    }\r\n    static new(gridpos, op) {\r\n        return new GeonNode(gridpos, op, new Map());\r\n    }\r\n    static newWidget(gridPos, widget) {\r\n        return new GeonNode(gridPos, widget, new Map());\r\n    }\r\n    run(...args) {\r\n        return this.core.run(...args);\r\n    }\r\n    log() {\r\n        console.log(`chip at ${this.position}`);\r\n        // this.operation.name\r\n        console.log(\"operation: \");\r\n        this.core.log();\r\n    }\r\n    // ---- Getters\r\n    get operation() {\r\n        if (this.core instanceof _operation__WEBPACK_IMPORTED_MODULE_1__.Operation) {\r\n            return this.core;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    get widget() {\r\n        if (this.core instanceof _widget__WEBPACK_IMPORTED_MODULE_2__.Widget) {\r\n            return this.core;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    outputs() {\r\n        let count = this.core.outputs;\r\n        let cables = [];\r\n        for (let i = 0; i < count; i++) {\r\n            let cable = this.connections.get(i + 1);\r\n            if (cable)\r\n                cables.push(cable);\r\n        }\r\n        return cables;\r\n    }\r\n    inputs() {\r\n        let count = this.core.inputs;\r\n        let cables = [];\r\n        for (let i = 0; i < count; i++) {\r\n            let cable = this.connections.get(-(i + 1));\r\n            if (cable)\r\n                cables.push(cable);\r\n        }\r\n        return cables;\r\n    }\r\n    // ---- Selection\r\n    getConnectorGridPosition(c) {\r\n        let gp = this.GetComponentLocalGridPosition(c);\r\n        if (gp === undefined) {\r\n            return undefined;\r\n        }\r\n        return this.position.added(gp);\r\n    }\r\n    GetComponentLocalGridPosition(c) {\r\n        if (c + 1 > -this.core.inputs && c < 0) {\r\n            // input\r\n            let input = (c * -1) - 1;\r\n            return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(0, input);\r\n        }\r\n        else if (c > 0 && c - 1 < this.core.outputs) {\r\n            // output \r\n            let output = c - 1;\r\n            return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(2, output);\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    trySelect(gp) {\r\n        let max = Math.max(this.core.inputs, this.core.outputs);\r\n        let local = gp.subbed(this.position);\r\n        // check if we select the widget\r\n        if (this.core instanceof _widget__WEBPACK_IMPORTED_MODULE_2__.Widget) {\r\n            let result = this.core.trySelect(local);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n        // see if this vector lands on an input socket, an output socket, or the body\r\n        if (local.y < 0 || local.y >= max) {\r\n            // quickly return if we dont even come close\r\n            return undefined;\r\n        }\r\n        else if (local.x == 0) {\r\n            if (local.y < this.core.inputs) {\r\n                return -(local.y + 1); // selected input\r\n            }\r\n            else {\r\n                return 0; // selected body\r\n            }\r\n        }\r\n        else if (local.x == 1) {\r\n            return 0; // selected body\r\n        }\r\n        else if (local.x == 2) {\r\n            if (local.y < this.core.outputs) {\r\n                return local.y + 1; // selected output\r\n            }\r\n            else {\r\n                return 0; // selected body\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    // ---- Connection\r\n    addConnection() {\r\n    }\r\n    hasConnection() {\r\n    }\r\n    removeConnection() {\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/node.ts?");

/***/ }),

/***/ "./src/graph/operation.ts":
/*!********************************!*\
  !*** ./src/graph/operation.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Operation\": () => (/* binding */ Operation)\n/* harmony export */ });\n// Node ---- Operation ----\r\n//             L Gizmo\r\n//                L getState() -> store it in cable\r\n//                L render() \r\n//                L onMouseAtCertainPosition() -> \r\n//                L  \r\n// \r\n/**\r\n * Wraps a function, and delivers some useful information\r\n * This is needed, so we can reason about the functionalities of chips\r\n * Not the same as a Node : Multiple Different Nodes will point to the same Operations\r\n */\r\nclass Operation {\r\n    constructor(func, name, inputs, outputs, namespace) {\r\n        this.func = func;\r\n        this.name = name;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.namespace = namespace;\r\n    }\r\n    static new(func, namespace) {\r\n        let inCount = Operation.countInputs(func);\r\n        let outCount = Operation.countOutputs(func);\r\n        let name = func.name;\r\n        return new Operation(func, name, inCount, outCount, namespace);\r\n    }\r\n    run(...args) {\r\n        return this.func(...args);\r\n    }\r\n    log() {\r\n        console.log(`this: ${this.func}`);\r\n        console.log(`name: ${this.func.name}`);\r\n        console.log(`inputs: ${this.inputs}`);\r\n        console.log(`outputs: ${this.outputs}`);\r\n    }\r\n    // ---- util\r\n    static countInputs(operation) {\r\n        return operation.length;\r\n    }\r\n    static countOutputs(operation) {\r\n        // HACK: its hard to determine the number of inputs, so im directly reading the string of the operation, \r\n        // and derriving it from the number of comma's found in the return statement.\r\n        // this could create some nasty unforseen side effects...\r\n        let getOutput = /return.*(\\[.*\\]).*/;\r\n        let match = getOutput.exec(operation.toString()) || \"\";\r\n        let output = match[1];\r\n        if (!output) {\r\n            return 1;\r\n        }\r\n        if (output == \"[]\") {\r\n            return 0;\r\n        }\r\n        let count = output.split(',').length;\r\n        return count;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/operation.ts?");

/***/ }),

/***/ "./src/graph/socket.ts":
/*!*****************************!*\
  !*** ./src/graph/socket.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* binding */ Socket)\n/* harmony export */ });\n;\r\nclass Socket {\r\n    constructor(node, idx, side) {\r\n        this.node = node;\r\n        this.idx = idx;\r\n        this.side = side;\r\n    }\r\n    static new(node, idx) {\r\n        return new Socket(node, idx, Socket.getSide(idx));\r\n    }\r\n    cloneFrom(other) {\r\n        this.node = other.node;\r\n        this.idx = other.idx;\r\n        this.side = other.side;\r\n    }\r\n    static fromNode(node, normalIndex, side) {\r\n        return Socket.new(node, this.normalIndexToSocketIndex(normalIndex, side));\r\n    }\r\n    static normalIndexToSocketIndex(normalIndex, side) {\r\n        if (side == -1 /* Input */) {\r\n            return (normalIndex + 1) * -1;\r\n        }\r\n        else if (side == 1 /* Output */) {\r\n            return normalIndex + 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    static socketIndexToNormalIndex(idx) {\r\n        let side = this.getSide(idx);\r\n        if (side == -1 /* Input */) {\r\n            return (idx * -1) - 1;\r\n        }\r\n        else if (side == 1 /* Output */) {\r\n            return idx - 1;\r\n        }\r\n        else {\r\n            return 0;\r\n        }\r\n    }\r\n    static getSide(idx) {\r\n        if (idx == 1000 || idx == Infinity) {\r\n            return 1000 /* Widget */;\r\n        }\r\n        else if (idx < 0) {\r\n            return -1 /* Input */;\r\n        }\r\n        else if (idx > 0) {\r\n            return 1 /* Output */;\r\n        }\r\n        else {\r\n            return 0 /* Body */;\r\n        }\r\n    }\r\n    normalIndex() {\r\n        return Socket.socketIndexToNormalIndex(this.idx);\r\n    }\r\n    toString() {\r\n        return `idx: ${this.idx} | node: ${this.node}`;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/socket.ts?");

/***/ }),

/***/ "./src/graph/widget.ts":
/*!*****************************!*\
  !*** ./src/graph/widget.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WidgetSide\": () => (/* binding */ WidgetSide),\n/* harmony export */   \"Widget\": () => (/* binding */ Widget)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n// author:      Jos Feenstra \r\n// purpose:     We make a distinction between 'normal' nodes, and gizmo's. \r\n//              gizmo's are \r\n//                - directly tied to one and only one cable.\r\n//              used as:\r\n//                - global input\r\n//                - global output\r\n//                - visuals\r\n//                - cable management\r\n//\r\n//              also, only gizmo's are allowed to hold state. \r\n//            \r\n\r\nvar WidgetSide;\r\n(function (WidgetSide) {\r\n    WidgetSide[WidgetSide[\"Input\"] = 0] = \"Input\";\r\n    WidgetSide[WidgetSide[\"Output\"] = 1] = \"Output\"; // output: save file, or rendering...\r\n})(WidgetSide || (WidgetSide = {}));\r\n/**\r\n *\r\n * Some Nodes have Widgets.\r\n * Widgets contain state, and react upon\r\n *  widgets are\r\n *    - directly tied to one and only one cable.\r\n *  used as:\r\n *    - global input\r\n *    - global output\r\n *    - debugging\r\n *    - visuals\r\n *    - cable management\r\n *\r\n * Widgets look exactly the same as Operations, and can be used interchangably. BUT, widgets are unique, no two Nodes may point to the same Widget\r\n */\r\nclass Widget {\r\n    constructor(name, side, size, state) {\r\n        this.name = name;\r\n        this.side = side;\r\n        this.size = size;\r\n        this.state = state;\r\n        this.inputs = side == WidgetSide.Input ? 0 : 1;\r\n        this.outputs = side == WidgetSide.Output ? 0 : 1;\r\n        this.bounds = Widget.determineWidgetSize(this.side, this.size);\r\n    }\r\n    static determineWidgetSize(side, size) {\r\n        // sry for this dumb code\r\n        if (!size) {\r\n            if (side == WidgetSide.Input) {\r\n                return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH(0, 0, 1, 1);\r\n            }\r\n            else {\r\n                return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH(2, 0, 1, 1);\r\n            }\r\n        }\r\n        else {\r\n            if (side == WidgetSide.Input) {\r\n                return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH(-(size.x - 1), 0, size.x, size.y);\r\n            }\r\n            else {\r\n                return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Domain2.fromWH(2, 0, size.x, size.y);\r\n            }\r\n        }\r\n    }\r\n    run() {\r\n    }\r\n    log() {\r\n        console.log(`widget: ${this.name}`);\r\n    }\r\n    clone() {\r\n        return new Widget(this.name, this.side, this.size, this.state);\r\n    }\r\n    trySelect(local) {\r\n        if (this.bounds.includesEx(local)) {\r\n            return Infinity;\r\n        }\r\n        return undefined;\r\n    }\r\n    render(ctx, pos, component, cellSize) {\r\n        let size = this.bounds.size().scaled(cellSize);\r\n        pos = pos.clone();\r\n        pos.x += this.bounds.x.t0 * cellSize;\r\n        pos.y += this.bounds.y.t0 * cellSize;\r\n        ctx.fillRect(pos.x + 2, pos.y + 2, size.x - 4, size.y - 4);\r\n        ctx.strokeRect(pos.x + 2, pos.y + 2, size.x - 4, size.y - 4);\r\n        ctx.fillStyle = this.state ? \"#33dd33\" : \"#222222\";\r\n        if (component == Infinity) {\r\n            ctx.fillStyle += \"88\";\r\n        }\r\n        ctx.fillRect(pos.x + 4, pos.y + 4, size.x - 8, size.y - 8);\r\n    }\r\n    // ---- Create Special properties\r\n    /**\r\n     * What to do when the widget actually gets clicked\r\n     */\r\n    onClick(canvas) {\r\n        canvas.deselect();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/graph/widget.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _nodes_canvas_nodes_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nodes-canvas/nodes-canvas */ \"./src/nodes-canvas/nodes-canvas.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n// purpose: entry point\r\n\r\n\r\nfunction main() {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        // get references of all items on the canvas\r\n        const html_canvas = document.getElementById(\"nodes-canvas\");\r\n        const ui = document.getElementById(\"nodes-panel\");\r\n        const stdPath = \"./std.json\";\r\n        // nodes\r\n        const nodes = _nodes_canvas_nodes_canvas__WEBPACK_IMPORTED_MODULE_1__.NodesCanvas.new(html_canvas, ui, stdPath);\r\n        nodes.start();\r\n        // timing\r\n        let acc_time = 0;\r\n        let counter = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.FpsCounter.new();\r\n        // loop\r\n        function loop(elapsed_time) {\r\n            let delta_time = elapsed_time - acc_time;\r\n            acc_time = elapsed_time;\r\n            counter._update(delta_time);\r\n            document.title = \"fps: \" + counter.getFps();\r\n            nodes.update(delta_time);\r\n            nodes.draw();\r\n            requestAnimationFrame(loop);\r\n        }\r\n        requestAnimationFrame(loop);\r\n    });\r\n}\r\nwindow.addEventListener(\"load\", main, false);\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/index.ts?");

/***/ }),

/***/ "./src/nodes-canvas/nodes-canvas.ts":
/*!******************************************!*\
  !*** ./src/nodes-canvas/nodes-canvas.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NodesCanvas\": () => (/* binding */ NodesCanvas)\n/* harmony export */ });\n/* harmony import */ var _ctx_ctx_camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ctx/ctx-camera */ \"./src/ctx/ctx-camera.ts\");\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _ctx_ctx_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ctx/ctx-helpers */ \"./src/ctx/ctx-helpers.ts\");\n/* harmony import */ var _graph_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../graph/graph */ \"./src/graph/graph.ts\");\n/* harmony import */ var _operations_catalogue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../operations/catalogue */ \"./src/operations/catalogue.ts\");\n/* harmony import */ var _nodes_rendering__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./nodes-rendering */ \"./src/nodes-canvas/nodes-rendering.ts\");\n/* harmony import */ var _graph_socket__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../graph/socket */ \"./src/graph/socket.ts\");\n/* harmony import */ var _graph_graph_conversion__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../graph/graph-conversion */ \"./src/graph/graph-conversion.ts\");\n/* harmony import */ var _graph_operation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../graph/operation */ \"./src/graph/operation.ts\");\n/* harmony import */ var _graph_cable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../graph/cable */ \"./src/graph/cable.ts\");\n/* harmony import */ var _util_io__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../util/io */ \"./src/util/io.ts\");\n/* harmony import */ var _operations_module__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../operations/module */ \"./src/operations/module.ts\");\n/* harmony import */ var _ui_menu__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../ui/menu */ \"./src/ui/menu.ts\");\n// author : Jos Feenstra\r\n// purpose: wrapper for dealing with the 'whole of nodes'\r\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Represents the entire canvas of nodes.\r\n * - Controls what happens with the nodes (creation / selection / deletion)\r\n * - Draws the nodes\r\n */\r\nclass NodesCanvas {\r\n    constructor(ctx, camera, input, graph, menu, catalogue, stdPath) {\r\n        this.ctx = ctx;\r\n        this.camera = camera;\r\n        this.input = input;\r\n        this.graph = graph;\r\n        this.menu = menu;\r\n        this.catalogue = catalogue;\r\n        this.stdPath = stdPath;\r\n        this.redrawAll = true;\r\n        this._size = 35;\r\n        // selection state \r\n        this.selectedSockets = [];\r\n        this.mgpStart = _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(); // mouse grid point start of selection\r\n        this.mgpEnd = _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(); // mouse grid point end of selection \r\n        this.mgpHover = _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(); // mouse grid point hover\r\n        // TODO make this nicer...\r\n        this.collapseCounter = 1;\r\n    }\r\n    get size() { return this._size; }\r\n    static new(htmlCanvas, ui, stdPath) {\r\n        const ctx = htmlCanvas.getContext('2d');\r\n        if (!ctx || ctx == null) {\r\n            alert(\"Canvas Rendering not supported in your browser. Try upgrading or switching!\");\r\n            return undefined;\r\n        }\r\n        const camera = _ctx_ctx_camera__WEBPACK_IMPORTED_MODULE_0__.CtxCamera.new(ctx.canvas, _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(-100, -100), 1);\r\n        const state = _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.InputState.new(ctx.canvas);\r\n        const graph = _graph_graph__WEBPACK_IMPORTED_MODULE_3__.NodesGraph.new();\r\n        const catalogue = _operations_catalogue__WEBPACK_IMPORTED_MODULE_4__.Catalogue.newFromStd();\r\n        const menu = _ui_menu__WEBPACK_IMPORTED_MODULE_12__.Menu.new(ui, catalogue, htmlCanvas);\r\n        return new NodesCanvas(ctx, camera, state, graph, menu, catalogue, stdPath);\r\n    }\r\n    start() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // hook up all functions & listeners\r\n            window.addEventListener(\"resize\", () => this.onResize());\r\n            this.onResize();\r\n            this.camera.onMouseDown = (worldPos) => {\r\n                this.onMouseDown(this.toGrid(worldPos));\r\n            };\r\n            this.camera.onMouseUp = (worldPos) => {\r\n                this.onMouseUp(this.toGrid(worldPos));\r\n            };\r\n            this.setupLoadSave();\r\n            this.setupCopyPaste();\r\n            // DEBUG add a standard graph\r\n            yield this.loadModules(this.stdPath);\r\n            this.testGraph();\r\n            // publish catalogue and ui \r\n            this.ui();\r\n        });\r\n    }\r\n    setupLoadSave() {\r\n        document.addEventListener(\"keydown\", (e) => {\r\n            if (e.keyCode == 83 && (navigator.platform.match(\"Mac\") ? e.metaKey : e.ctrlKey)) {\r\n                e.preventDefault();\r\n                let text = this.onCopy();\r\n                _util_io__WEBPACK_IMPORTED_MODULE_10__.IO.promptDownload(\"save.js\", text);\r\n            }\r\n        }, false);\r\n    }\r\n    setupCopyPaste() {\r\n        document.addEventListener(\"copy\", (event) => {\r\n            console.log(\"copy | save\");\r\n            event.clipboardData.setData(\"text/plain\", this.onCopy());\r\n            event.preventDefault();\r\n        });\r\n        document.addEventListener(\"paste\", (event) => {\r\n            console.log(\"paste | load\");\r\n            console.log(event);\r\n            if (!event.clipboardData) {\r\n                // alert(\"I would like a string, please\");\r\n                return;\r\n            }\r\n            if (event.clipboardData.items.length != 1) {\r\n                // alert(\"I would like just one string, please\");\r\n                return;\r\n            }\r\n            event.clipboardData.items[0].getAsString(this.onPaste.bind(this));\r\n        });\r\n    }\r\n    onCopy() {\r\n        return this.graph.toJs(\"GRAPH\").toString();\r\n    }\r\n    onPaste(js) {\r\n        let graph = _graph_graph__WEBPACK_IMPORTED_MODULE_3__.NodesGraph.fromJs(js, this.catalogue);\r\n        this.graph = graph;\r\n        this.requestRedraw();\r\n        this.graph.calculate();\r\n    }\r\n    loadModules(stdPath) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // TODO move this to Catalogue, its catalogue's responsibility to manage modules\r\n            let json = yield _util_io__WEBPACK_IMPORTED_MODULE_10__.IO.fetchJson(stdPath);\r\n            for (let config of json.std) {\r\n                let lib = yield _util_io__WEBPACK_IMPORTED_MODULE_10__.IO.importLibrary(config.path);\r\n                let mod = _operations_module__WEBPACK_IMPORTED_MODULE_11__.NodesModule.fromJsObject(config.name, config.icon, config.fullPath, config.path, lib, this.catalogue);\r\n                this.catalogue.addModule(mod);\r\n            }\r\n            this.ui();\r\n            this.menu.updateCategories(this.catalogue);\r\n        });\r\n    }\r\n    testGraph() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let js = `\r\n        function anonymous(a /* \"widget\": \"button\" | \"state\": \"true\" | \"x\": 4 | \"y\": -1 */,c /* \"widget\": \"button\" | \"state\": \"false\" | \"x\": 4 | \"y\": 1 */\r\n        ) {\r\n            let [b] = bool.NOT(a) /* \"x\": 8 | \"y\": 0 */;\r\n            let [d] = bool.OR(a, c) /* \"x\": 8 | \"y\": 1 */;\r\n            let [e] = bool.AND(b, d) /* \"x\": 11 | \"y\": 0 */;\r\n            return [e /* \"widget\": \"lamp\" | \"x\": 14 | \"y\": -1 */];\r\n        }\r\n        `;\r\n            let graph = _graph_graph__WEBPACK_IMPORTED_MODULE_3__.NodesGraph.fromJs(js, this.catalogue);\r\n            this.graph = graph;\r\n            this.requestRedraw();\r\n            this.graph.calculate();\r\n            return;\r\n        });\r\n    }\r\n    collapseGraphToOperation() {\r\n        let GRAPH = this.graph.toJs(\"GRAPH\" + this.collapseCounter);\r\n        this.collapseCounter += 1;\r\n        // @ts-ignore;\r\n        let graph = _graph_operation__WEBPACK_IMPORTED_MODULE_8__.Operation.new(GRAPH);\r\n        if (this.catalogue.modules.has(\"graphs\")) {\r\n            this.catalogue.modules.get(\"graphs\").operations.push(graph);\r\n        }\r\n        else {\r\n            this.catalogue.addModule(_operations_module__WEBPACK_IMPORTED_MODULE_11__.NodesModule.new(\"graphs\", \"braces\", \"\", [graph], [], this.catalogue));\r\n        }\r\n        this.ui();\r\n    }\r\n    ui() {\r\n        // hook up UI \r\n        this.menu.updateCategories(this.catalogue);\r\n        this.menu.renderNav();\r\n        (0,_graph_graph_conversion__WEBPACK_IMPORTED_MODULE_7__.makeOperationsGlobal)(this.catalogue);\r\n    }\r\n    /**\r\n     * NOTE: this is sort of the main loop of the whole node canvas\r\n     * @param dt\r\n     */\r\n    update(dt) {\r\n        this.input.preUpdate(dt);\r\n        let redraw = this.camera.update(this.input);\r\n        if (redraw) {\r\n            this.requestRedraw();\r\n        }\r\n        // mouse\r\n        this.updateMouse(this.camera.mousePos);\r\n        // keys\r\n        let cancelPresed = (this.input.IsKeyPressed(\"escape\") ||\r\n            this.input.IsKeyPressed(\" \") ||\r\n            this.input.IsKeyPressed(\"backspace\"));\r\n        if (cancelPresed) {\r\n            this.catalogue.deselect();\r\n            this.deselect();\r\n            this.requestRedraw();\r\n        }\r\n        if (this.input.IsKeyPressed(\"delete\")) {\r\n            if (this.selectedSockets.length > 0) {\r\n                for (let socket of this.selectedSockets) {\r\n                    this.graph.deleteNode(socket.node);\r\n                    this.requestRedraw();\r\n                }\r\n                this.deselect();\r\n            }\r\n        }\r\n        if (this.input.IsKeyPressed(\" \")) {\r\n            this.collapseGraphToOperation();\r\n        }\r\n        if (this.input.IsKeyPressed(\"p\")) {\r\n            this.graph.log();\r\n        }\r\n        // refresh when placing new operation / node\r\n        if (this.catalogue.selected) {\r\n            // this.requestRedraw();\r\n        }\r\n        this.input.postUpdate();\r\n    }\r\n    requestRedraw() {\r\n        this.redrawAll = true;\r\n    }\r\n    draw() {\r\n        // // draw cursor every frame, regardless\r\n        // let g = this.toGrid(this.camera.mousePos);\r\n        // let pos = this.toWorld(g);\r\n        // redraw everything if we moved the camera, for example\r\n        if (!this.redrawAll) {\r\n            return;\r\n        }\r\n        this.redrawAll = false;\r\n        // prepare\r\n        let ctx = this.ctx;\r\n        let camera = this.camera;\r\n        ctx.save();\r\n        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n        camera.moveCtxToState(ctx);\r\n        let g = this.toGrid(this.camera.mousePos);\r\n        // draw grid \r\n        this.drawGrid(ctx);\r\n        // draw cables \r\n        for (let [key, cable] of this.graph.cables) {\r\n            (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawCable)(ctx, cable, this);\r\n        }\r\n        // draw a cable if we are dragging a new cable\r\n        if (this.mgpStart) {\r\n            for (let socket of this.selectedSockets) {\r\n                let fromNode = this.graph.nodes.get(socket.node);\r\n                let p = fromNode.getConnectorGridPosition(socket.idx);\r\n                if (socket.side == -1 /* Input */) {\r\n                    (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawCableBetween)(ctx, g, p, this, _graph_cable__WEBPACK_IMPORTED_MODULE_9__.CableState.Selected);\r\n                }\r\n                else if (socket.side == 1 /* Output */) {\r\n                    (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawCableBetween)(ctx, p, g, this, _graph_cable__WEBPACK_IMPORTED_MODULE_9__.CableState.Selected);\r\n                }\r\n            }\r\n        }\r\n        // draw nodes \r\n        for (let [key, node] of this.graph.nodes) {\r\n            // TODO: fix the fact we cannot hover the node of the socket we are selecting...\r\n            let selectedSocket = this.tryGetSelectedSocket(key);\r\n            if (selectedSocket) {\r\n                (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawNode)(ctx, node, this, selectedSocket.idx, _nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.DrawState.OpSelected);\r\n            }\r\n            else if (this.hoverSocket && key == this.hoverSocket.node) {\r\n                (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawNode)(ctx, node, this, this.hoverSocket.idx, _nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.DrawState.OpHover);\r\n            }\r\n            else {\r\n                (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawNode)(ctx, node, this, 0, _nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.DrawState.Op);\r\n            }\r\n        }\r\n        // draw selection box\r\n        if (this.boxStart) {\r\n            let a = this.toWorld(this.boxStart);\r\n            let b = this.toWorld(this.mgpHover);\r\n            ctx.fillStyle = \"#ffffff44\";\r\n            ctx.fillRect(a.x, a.y, b.x - a.x, b.y - a.y);\r\n        }\r\n        // draw node if we are placing a new node\r\n        if (this.catalogue.selected) {\r\n            let fakeNode = this.catalogue.spawn(g);\r\n            (0,_nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.drawNode)(ctx, fakeNode, this, 0, _nodes_rendering__WEBPACK_IMPORTED_MODULE_5__.DrawState.OpPlacement);\r\n        }\r\n        else {\r\n        }\r\n        // done drawing\r\n        ctx.restore();\r\n    }\r\n    drawGrid(ctx) {\r\n        let cross = (x, y, s) => {\r\n            ctx.moveTo(x, y - s);\r\n            ctx.lineTo(x, y + s);\r\n            ctx.moveTo(x - s, y);\r\n            ctx.lineTo(x + s, y);\r\n        };\r\n        let box = this.camera.getBox();\r\n        let size = this._size;\r\n        let crosssize = size / 20;\r\n        let topleft = _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(box.x.t0, box.y.t0);\r\n        let gridStart = this.toWorld(this.toGrid(topleft));\r\n        ctx.save();\r\n        ctx.fillStyle = '#111111';\r\n        ctx.lineWidth = 0.5;\r\n        ctx.beginPath();\r\n        for (let x = gridStart.x; x < box.x.t1; x += size) {\r\n            for (let y = gridStart.y; y < box.y.t1; y += size) {\r\n                // ctx.fillRect(x,y,1,1);\r\n                // ctx.arc(x,y,1, 0, Math.PI*2);\r\n                /// ctx.fill();\r\n                ctx.moveTo(x, y);\r\n                cross(x, y, crosssize);\r\n            }\r\n        }\r\n        ctx.stroke();\r\n        ctx.restore();\r\n    }\r\n    // -----\r\n    toGrid(wv) {\r\n        return _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Vector2.new(Math.round((wv.x - (this._size / 2)) / this._size), Math.round((wv.y - (this._size / 2)) / this._size));\r\n    }\r\n    toWorld(gv) {\r\n        return gv.scaled(this._size);\r\n    }\r\n    // ----- --------------------- -----\r\n    // -----       Selection       -----\r\n    // ----- --------------------- -----\r\n    hover(s) {\r\n        this.hoverSocket = s;\r\n    }\r\n    dehover() {\r\n        this.hoverSocket = undefined;\r\n    }\r\n    select(s) {\r\n        let ex = this.tryGetSelectedSocket(s.node);\r\n        if (!ex) {\r\n            this.selectedSockets.push(s);\r\n        }\r\n        else {\r\n            ex.cloneFrom(s);\r\n        }\r\n    }\r\n    deselect() {\r\n        this.selectedSockets = [];\r\n    }\r\n    tryGetSelectedSocket(key) {\r\n        for (let socket of this.selectedSockets) {\r\n            if (socket.node == key) {\r\n                return socket;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    trySelect(gridPos) {\r\n        for (let [key, value] of this.graph.nodes) {\r\n            let res = value.trySelect(gridPos);\r\n            if (res !== undefined) {\r\n                return _graph_socket__WEBPACK_IMPORTED_MODULE_6__.Socket.new(key, res);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n    updateMouse(worldPos) {\r\n        let g = this.toGrid(worldPos);\r\n        if (!g.equals(this.mgpHover)) {\r\n            this.onMouseGridMove(g);\r\n        }\r\n    }\r\n    startBox(gp) {\r\n        this.boxStart = gp.clone();\r\n    }\r\n    stopBox() {\r\n        if (!this.boxStart) {\r\n            return;\r\n        }\r\n        // if a node falls in the box space, select it\r\n        let a = this.boxStart;\r\n        let b = this.mgpHover;\r\n        let box = _engine_src_lib__WEBPACK_IMPORTED_MODULE_1__.Domain2.fromBounds(a.x, b.x, a.y, b.y);\r\n        for (let [key, node] of this.graph.nodes) {\r\n            if (box.includesEx(node.position)) {\r\n                this.select(_graph_socket__WEBPACK_IMPORTED_MODULE_6__.Socket.new(key, 0));\r\n            }\r\n        }\r\n        // reset the box\r\n        this.boxStart = undefined;\r\n    }\r\n    // ------ Events\r\n    onMouseDown(gp) {\r\n        var _a;\r\n        // console.log(\"down!\");\r\n        this.mgpStart = gp;\r\n        this.mgpEnd = gp;\r\n        if (this.catalogue.selected) {\r\n            // we are placing a new node\r\n            this.graph.addNode(this.catalogue.spawn(gp));\r\n            if (!this.input.IsKeyDown(\"control\")) {\r\n                this.catalogue.deselect();\r\n            }\r\n        }\r\n        else {\r\n            // we clicked at some spot. try to select something \r\n            let socket = this.trySelect(gp);\r\n            if (!socket) {\r\n                // we clicked an empty spot: deselect and draw a box\r\n                this.deselect();\r\n                this.startBox(gp);\r\n                return;\r\n            }\r\n            else {\r\n                // we clicked on a socket! \r\n                let sock = this.tryGetSelectedSocket(socket.node);\r\n                if (sock) {\r\n                    // do nothing if we click on a node we already have selected. This is needed for click and dragging multiple nodes\r\n                }\r\n                else if (!this.input.IsKeyDown(\"shift\")) {\r\n                    this.deselect();\r\n                }\r\n                this.select(socket);\r\n                if ((socket === null || socket === void 0 ? void 0 : socket.side) == 1000 /* Widget */) {\r\n                    // we just clicked a widget! let the widget figure out what to do\r\n                    ((_a = this.graph.getNode(socket.node)) === null || _a === void 0 ? void 0 : _a.core).onClick(this);\r\n                }\r\n            }\r\n        }\r\n        this.requestRedraw();\r\n    }\r\n    onMouseUp(gp) {\r\n        // console.log(\"up!\");\r\n        // possibly create a line\r\n        // see if the line drawn is indeed from input to output, or vise versa\r\n        if (this.selectedSockets.length == 1 && this.hoverSocket) {\r\n            let selectedSocket = this.selectedSockets[0];\r\n            if ((selectedSocket.side == -1 /* Input */ && this.hoverSocket.side == 1 /* Output */) ||\r\n                (selectedSocket.side == 1 /* Output */ && this.hoverSocket.side == -1 /* Input */)) {\r\n                console.log(\"adding cable...\");\r\n                this.graph.addCable(selectedSocket, this.hoverSocket);\r\n                this.deselect();\r\n                this.requestRedraw();\r\n                // new line means recalculation\r\n                this.graph.calculate();\r\n            }\r\n        }\r\n        // reset\r\n        this.stopBox();\r\n        this.mgpStart = undefined;\r\n        this.mgpEnd = undefined;\r\n        this.requestRedraw();\r\n    }\r\n    /**\r\n     * fires when the mouse moves over to a new gridcell\r\n     */\r\n    onMouseGridMove(gp) {\r\n        // console.log(\"move!\");\r\n        // hovering\r\n        this.hover(this.trySelect(gp));\r\n        this.requestRedraw();\r\n        // if mouse is down and we are selecting a node \r\n        if (this.mgpStart && this.selectedSockets.length > 0) {\r\n            let delta = gp.subbed(this.mgpEnd);\r\n            for (let socket of this.selectedSockets) {\r\n                if (socket.side == 0 /* Body */) {\r\n                    // dragging node\r\n                    let node = this.graph.nodes.get(socket.node);\r\n                    node === null || node === void 0 ? void 0 : node.position.add(delta);\r\n                }\r\n                else {\r\n                    // dragging line\r\n                    // console.log(\"drag line\");\r\n                }\r\n            }\r\n        }\r\n        // update at end, so we can use mgpEnd as a delta for dragging\r\n        this.mgpHover = gp;\r\n        this.mgpEnd = gp;\r\n    }\r\n    onSidePanelButtonPressed(idx, type) {\r\n        // THIS NEEDS TO BE HOOKED UP AGAIN\r\n        // this.catalogue.select(idx, type);\r\n        this.deselect();\r\n        // we must focus on the canvas after interacting with the html UI.\r\n        // NOTE: this is another reason why we might want to hack HTML instead of this ctx canvas approach...\r\n        this.input.canvas.focus();\r\n    }\r\n    onResize() {\r\n        (0,_ctx_ctx_helpers__WEBPACK_IMPORTED_MODULE_2__.resizeCanvas)(this.ctx);\r\n        this.requestRedraw();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/nodes-canvas/nodes-canvas.ts?");

/***/ }),

/***/ "./src/nodes-canvas/nodes-rendering.ts":
/*!*********************************************!*\
  !*** ./src/nodes-canvas/nodes-rendering.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DrawState\": () => (/* binding */ DrawState),\n/* harmony export */   \"StyleSet\": () => (/* binding */ StyleSet),\n/* harmony export */   \"drawNode\": () => (/* binding */ drawNode),\n/* harmony export */   \"drawCable\": () => (/* binding */ drawCable),\n/* harmony export */   \"drawCableBetween\": () => (/* binding */ drawCableBetween)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _graph_cable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/cable */ \"./src/graph/cable.ts\");\n/* harmony import */ var _graph_widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graph/widget */ \"./src/graph/widget.ts\");\n// purpose: bunch of 'pure' functions to render nodes & cables\r\n\r\n\r\n\r\nconst NODE_GRID_WIDTH = 3;\r\nvar DrawState;\r\n(function (DrawState) {\r\n    DrawState[DrawState[\"Op\"] = 0] = \"Op\";\r\n    DrawState[DrawState[\"OpHover\"] = 1] = \"OpHover\";\r\n    DrawState[DrawState[\"OpSelected\"] = 2] = \"OpSelected\";\r\n    DrawState[DrawState[\"OpPlacement\"] = 3] = \"OpPlacement\";\r\n})(DrawState || (DrawState = {}));\r\nclass StyleSet {\r\n    constructor(text, stroke, fill, line) { }\r\n    static new(text, stroke, fill, line) {\r\n        return new StyleSet(text, stroke, fill, line);\r\n    }\r\n}\r\nfunction drawNode(ctx, node, canvas, component, style) {\r\n    // convert style \r\n    let isWidget = node.core instanceof _graph_widget__WEBPACK_IMPORTED_MODULE_2__.Widget;\r\n    let pos = canvas.toWorld(node.position);\r\n    const BAR_WIDTH = 5;\r\n    ctx.beginPath();\r\n    // draw body\r\n    setStyle(ctx, style, component, 0, isWidget);\r\n    let textCenters = nodeShape(ctx, pos, node.core.inputs, node.core.outputs, canvas.size);\r\n    ctx.fill();\r\n    ctx.stroke();\r\n    // draw operation text\r\n    if (!isWidget) {\r\n        ctx.fillStyle = ctx.strokeStyle;\r\n        ctx.font = '15px courier new';\r\n        // ctx.rotate\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        let op_center = textCenters.get(0);\r\n        // ctx.translate(op_center.x, op_center.y);\r\n        // ctx.rotate(Math.PI*-0.5);\r\n        ctx.fillText(node.core.name, op_center.x, op_center.y);\r\n    }\r\n    // draw input text\r\n    ctx.font = '12px courier new';\r\n    for (let i = 0; i < node.core.inputs; i++) {\r\n        setStyle(ctx, style, component, -1 - i, isWidget); // -1 signals input1, -2 signals input2, etc...\r\n        let vec = textCenters.get(1 + i);\r\n        // ctx.fillText('|', vec.x, vec.y);\r\n        ctx.fillRect(vec.x - 2 - (2 * ctx.lineWidth), vec.y - BAR_WIDTH, 2 * ctx.lineWidth, BAR_WIDTH * 2);\r\n    }\r\n    // draw output text\r\n    for (let i = 0; i < node.core.outputs; i++) {\r\n        setStyle(ctx, style, component, i + 1, isWidget);\r\n        let vec = textCenters.get(1 + node.core.inputs + i);\r\n        ctx.fillRect(vec.x + 2, vec.y - BAR_WIDTH, 2 * ctx.lineWidth, BAR_WIDTH * 2);\r\n        // ctx.fillText('|', vec.x, vec.y);\r\n    }\r\n    // render widget\r\n    if (isWidget) {\r\n        let widget = node.core;\r\n        setStyle(ctx, style, component, 0, isWidget);\r\n        widget.render(ctx, pos, component, canvas.size);\r\n    }\r\n}\r\nfunction drawCable(ctx, cable, canvas) {\r\n    // use the components in the graph to figure out the from and to position\r\n    let fromNode = canvas.graph.nodes.get(cable.from.node);\r\n    let fromGridPos = fromNode.getConnectorGridPosition(cable.from.idx);\r\n    for (let to of cable.to) {\r\n        let toNode = canvas.graph.nodes.get(to.node);\r\n        let toGridPos = toNode.getConnectorGridPosition(to.idx);\r\n        drawCableBetween(ctx, fromGridPos, toGridPos, canvas, cable.state);\r\n    }\r\n}\r\n/**\r\n *  line goes : (a) --- hor --- (b) --- diagonal --- (c) --- ver --- (d) --- diagonal --- (e) --- hor --- (f)\r\n */\r\nfunction drawCableBetween(ctx, fromGridPos, toGridPos, canvas, state) {\r\n    let size = canvas.size;\r\n    let hgs = canvas.size / 2;\r\n    let a = canvas.toWorld(fromGridPos).addn(hgs, hgs);\r\n    let f = canvas.toWorld(toGridPos).addn(hgs, hgs);\r\n    let delta = toGridPos.subbed(fromGridPos);\r\n    let distanceFromSocket = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(0, 0);\r\n    let distanceToSocket = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(0, 0);\r\n    let fillet = size * 0.5;\r\n    if (delta.x == 0 && delta.y == 0) {\r\n        return;\r\n    }\r\n    // make the horizontal line break move correctly \r\n    let xBreak = 1;\r\n    if (delta.x < 1) {\r\n        xBreak = 1;\r\n    }\r\n    else if (delta.x == 1) {\r\n        fillet = size * 0.25;\r\n        // xBreak = 0.5;\r\n    }\r\n    else if (delta.x <= 4) {\r\n        xBreak = delta.x / 2;\r\n    }\r\n    else if (delta.x > 4) {\r\n        xBreak = 2;\r\n    }\r\n    // make the vertical line break move correctly  \r\n    let yBreak = 1;\r\n    let line;\r\n    // apply horizontal line break\r\n    distanceFromSocket.x = xBreak;\r\n    distanceToSocket.x = -(delta.x - xBreak);\r\n    if (delta.x == 1) {\r\n        distanceFromSocket.x = 0.5;\r\n        distanceToSocket.x = -0.5;\r\n    }\r\n    else if (delta.x < 2) {\r\n        distanceToSocket.x = -xBreak;\r\n    }\r\n    // apply vertical line break\r\n    if (delta.x < 1) {\r\n        fillet = size * 0.25;\r\n        if (delta.y == -1 || delta.y == 1) {\r\n            yBreak = 0.5;\r\n        }\r\n        if (delta.y < 0) {\r\n            yBreak *= -1;\r\n        }\r\n        // distanceFromSocket.y = yBreak;\r\n        // distanceToSocket.y = -delta.y + yBreak;\r\n        distanceFromSocket.y = delta.y - yBreak;\r\n        distanceToSocket.y = -yBreak;\r\n        // \r\n        let b = a.clone();\r\n        let c = a.clone();\r\n        let d = f.clone();\r\n        let e = f.clone();\r\n        // figure out b and c \r\n        b.x += distanceFromSocket.x * size;\r\n        c.x += distanceFromSocket.x * size;\r\n        c.y += distanceFromSocket.y * size;\r\n        d.x += distanceToSocket.x * size;\r\n        d.y += distanceToSocket.y * size;\r\n        e.x += distanceToSocket.x * size;\r\n        line = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList([\r\n            a,\r\n            b,\r\n            c,\r\n            d,\r\n            e,\r\n            f,\r\n        ]);\r\n    }\r\n    else {\r\n        // \r\n        let b = a.clone();\r\n        let e = f.clone();\r\n        // figure out b and c \r\n        b.x += distanceFromSocket.x * size;\r\n        e.x += distanceToSocket.x * size;\r\n        line = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.fromList([\r\n            a,\r\n            b,\r\n            e,\r\n            f,\r\n        ]);\r\n    }\r\n    line = filletPolyline(line, fillet);\r\n    if (state == _graph_cable__WEBPACK_IMPORTED_MODULE_1__.CableState.On) {\r\n        ctx.strokeStyle = \"#33dd33\";\r\n    }\r\n    else if (state == _graph_cable__WEBPACK_IMPORTED_MODULE_1__.CableState.Selected) {\r\n        ctx.strokeStyle = \"white\";\r\n    }\r\n    else {\r\n        ctx.strokeStyle = \"#222222\";\r\n    }\r\n    ctx.lineCap = \"round\";\r\n    // ctx.lineJoin = \"bevel\";\r\n    ctx.lineWidth = 8;\r\n    drawPolyline(ctx, line);\r\n}\r\nfunction filletPolyline(line, radius) {\r\n    let count = line.count + (line.count - 2);\r\n    let verts = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(count);\r\n    // set first and last\r\n    verts.set(0, line.get(0));\r\n    verts.set(count - 1, line.get(Math.ceil((count - 1) / 2)));\r\n    // set in betweens\r\n    for (let i = 1; i < count - 1; i++) {\r\n        let half = i / 2;\r\n        let pointsToPrevious = (half % 1 != 0);\r\n        let j = Math.ceil(half); // index in original \r\n        let vert = line.get(j);\r\n        // apply fillet\r\n        if (pointsToPrevious) {\r\n            // to \r\n            let prev = line.get(j - 1);\r\n            vert.add(prev.subbed(vert).setLength(radius));\r\n        }\r\n        else {\r\n            let next = line.get(j + 1);\r\n            vert.add(next.subbed(vert).setLength(radius));\r\n        }\r\n        verts.set(i, vert);\r\n    }\r\n    return verts;\r\n}\r\nfunction drawPolyline(ctx, pl) {\r\n    ctx.beginPath();\r\n    let v = pl.get(0);\r\n    ctx.moveTo(v.x, v.y);\r\n    for (let i = 1; i < pl.count; i++) {\r\n        let v = pl.get(i);\r\n        ctx.lineTo(v.x, v.y);\r\n    }\r\n    ctx.stroke();\r\n}\r\nfunction setStyle(ctx, state, component, componentDrawn, isWidget) {\r\n    ctx.strokeStyle = \"#ffffff\";\r\n    ctx.fillStyle = \"#222222\";\r\n    ctx.lineWidth = 1;\r\n    if (state == DrawState.OpSelected && component == componentDrawn) {\r\n        ctx.strokeStyle = \"#ff0000\";\r\n        ctx.fillStyle = \"#332222\";\r\n        ctx.lineWidth = 4;\r\n    }\r\n    else if (state == DrawState.OpHover && component == componentDrawn) {\r\n        ctx.strokeStyle = \"#dd0000\";\r\n        ctx.lineWidth = 2;\r\n    }\r\n    else if (state == DrawState.OpPlacement) {\r\n        ctx.lineWidth = 0.5;\r\n        ctx.strokeStyle = ctx.strokeStyle + \"44\";\r\n    }\r\n    if (componentDrawn != 0) {\r\n        ctx.fillStyle = ctx.strokeStyle;\r\n    }\r\n    if (isWidget) {\r\n        let temp = ctx.fillStyle;\r\n        ctx.fillStyle = ctx.strokeStyle;\r\n        ctx.strokeStyle = temp;\r\n    }\r\n}\r\nfunction getStyle(state) {\r\n    // ctx.strokeStyle = \"#aaaaaa\";\r\n    // ctx.fillStyle = \"#222222\";\r\n    // ctx.lineWidth = 1;\r\n    switch (state) {\r\n        case DrawState.Op:\r\n            return new StyleSet(\"white\", \"#aaaaaa\", \"#222222\", 1);\r\n        case DrawState.OpHover:\r\n            return new StyleSet(\"white\", \"#aaaaaa\", \"#222222\", 1);\r\n        case DrawState.OpSelected:\r\n            return new StyleSet(\"white\", \"#aaaaaa\", \"#222222\", 1);\r\n        case DrawState.OpPlacement:\r\n            return new StyleSet(\"white\", \"#aaaaaa\", \"#222222\", 1);\r\n    }\r\n}\r\nfunction gizmoShape(ctx, pos, input, output, wh, size) {\r\n    let part = 5;\r\n    let step = size / part;\r\n    let coord = (x, y) => {\r\n        return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(pos.x + y * step, pos.y + x * step);\r\n    };\r\n    let moveTo = (x, y) => {\r\n        ctx.moveTo(pos.x + y * step, pos.y + x * step);\r\n    };\r\n    let lineTo = (x, y) => {\r\n        ctx.lineTo(pos.x + y * step, pos.y + x * step);\r\n    };\r\n}\r\n/**\r\n * Draw the chip shape\r\n * returns\r\n */\r\nfunction nodeShape(ctx, pos, inputs, outputs, size) {\r\n    let max = Math.max(inputs, outputs);\r\n    let part = 5;\r\n    let step = size / part;\r\n    let height = max * part;\r\n    let width = 15;\r\n    let cola = 2.5;\r\n    let colb = 3;\r\n    let colc = 3;\r\n    let cold = 12;\r\n    let cole = 12;\r\n    let colf = 12.5;\r\n    let coord = (x, y) => {\r\n        return _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(pos.x + y * step, pos.y + x * step);\r\n    };\r\n    let moveTo = (x, y) => {\r\n        ctx.moveTo(pos.x + y * step, pos.y + x * step);\r\n    };\r\n    let lineTo = (x, y) => {\r\n        ctx.lineTo(pos.x + y * step, pos.y + x * step);\r\n    };\r\n    // calculate coorindates of input, output, and body centers\r\n    let vecs = _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.MultiVector2.new(inputs + outputs + 1);\r\n    vecs.set(0, coord(height / 2, width / 2));\r\n    // top\r\n    moveTo(0.5, cole);\r\n    lineTo(0.5, cold);\r\n    lineTo(0.5, colc);\r\n    lineTo(0.5, colb);\r\n    // draw inputs\r\n    for (let i = 0; i < max; i++) {\r\n        let offset = i * 5;\r\n        if (i < inputs) {\r\n            // store center\r\n            vecs.set(1 + i, coord(offset + 2.5, colc));\r\n            // draw zig-zag\r\n            lineTo(offset + 1, cola);\r\n            lineTo(offset + 4, cola);\r\n            lineTo(offset + 4.5, colb);\r\n            if (i != max - 1)\r\n                lineTo(offset + 5.5, colb);\r\n        }\r\n        else {\r\n            // draw straight line\r\n            // lineTo(offset+4.5, colb);\r\n        }\r\n    }\r\n    // bottom\r\n    // lineTo(width-0.5, 4); // colb\r\n    lineTo(height - 0.5, 5); // colc\r\n    lineTo(height - 0.5, 10); // cold\r\n    // lineTo(width-0.5, 6); // cole\r\n    // draw outputs\r\n    moveTo(0.5, cole);\r\n    for (let i = 0; i < max; i++) {\r\n        let offset = i * 5;\r\n        if (i < outputs) {\r\n            // store center\r\n            vecs.set(1 + inputs + i, coord(offset + 2.5, cold));\r\n            // draw zig-zag\r\n            lineTo(offset + 1, colf);\r\n            lineTo(offset + 4, colf);\r\n            lineTo(offset + 4.5, cole);\r\n            if (i != max - 1)\r\n                lineTo(offset + 5.5, cole);\r\n        }\r\n        else {\r\n            // draw straight line\r\n            // lineTo(offset+4.5,cole);\r\n        }\r\n    }\r\n    lineTo(height - 0.5, 10); // cold\r\n    return vecs;\r\n}\r\nfunction drawCicle(ctx, pos, size) {\r\n    let hs = size / 2;\r\n    ctx.beginPath();\r\n    ctx.arc(pos.x + hs, pos.y + hs, hs, 0, Math.PI * 2);\r\n    ctx.fill();\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/nodes-canvas/nodes-rendering.ts?");

/***/ }),

/***/ "./src/operations/catalogue.ts":
/*!*************************************!*\
  !*** ./src/operations/catalogue.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CoreType\": () => (/* binding */ CoreType),\n/* harmony export */   \"Catalogue\": () => (/* binding */ Catalogue)\n/* harmony export */ });\n/* harmony import */ var _graph_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graph/operation */ \"./src/graph/operation.ts\");\n/* harmony import */ var _graph_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/node */ \"./src/graph/node.ts\");\n/* harmony import */ var _graph_widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../graph/widget */ \"./src/graph/widget.ts\");\n/* harmony import */ var _widgets_button_widget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../widgets/button-widget */ \"./src/widgets/button-widget.ts\");\n/* harmony import */ var _widgets_display_widget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../widgets/display-widget */ \"./src/widgets/display-widget.ts\");\n/* harmony import */ var _widgets_lamp_widget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../widgets/lamp-widget */ \"./src/widgets/lamp-widget.ts\");\n/* harmony import */ var _widgets_text_widget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../widgets/text-widget */ \"./src/widgets/text-widget.ts\");\n/* harmony import */ var _module__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./module */ \"./src/operations/module.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// TODO rename CORE to TYPE\r\n//      rename NODE to INSTANCE maybe\r\nvar CoreType;\r\n(function (CoreType) {\r\n    CoreType[CoreType[\"Operation\"] = 0] = \"Operation\";\r\n    CoreType[CoreType[\"Widget\"] = 1] = \"Widget\";\r\n})(CoreType || (CoreType = {}));\r\n/**\r\n * Catalogue containing all cores\r\n * Cores contain functionality of a node\r\n *\r\n * In the future, this would make creating a menu easier\r\n * TODO: Categories\r\n */\r\nclass Catalogue {\r\n    constructor(modules) {\r\n        this.modules = modules;\r\n    }\r\n    static new() {\r\n        return new Catalogue(new Map());\r\n    }\r\n    static newFromStd() {\r\n        let widgets = [\r\n            _widgets_button_widget__WEBPACK_IMPORTED_MODULE_3__.ButtonWidget.new(false),\r\n            _widgets_text_widget__WEBPACK_IMPORTED_MODULE_6__.TextWidget.new(\"hello world\"),\r\n            _widgets_lamp_widget__WEBPACK_IMPORTED_MODULE_5__.LampWidget.new(false),\r\n            _widgets_display_widget__WEBPACK_IMPORTED_MODULE_4__.ConsoleWidget.new(false),\r\n        ];\r\n        let wmap = new Map();\r\n        for (let w of widgets) {\r\n            wmap.set(w.name, w);\r\n        }\r\n        let cat = Catalogue.new();\r\n        let widMod = _module__WEBPACK_IMPORTED_MODULE_7__.NodesModule.new(\"widgets\", \"lightning-charge-fill\", \"\", [], widgets, cat);\r\n        cat.addModule(widMod);\r\n        return cat;\r\n    }\r\n    allOperations() {\r\n    }\r\n    trySelect(lib, key, type) {\r\n        let mod = this.modules.get(lib);\r\n        if (!mod) {\r\n            throw new Error(`no module is called: ${lib}`);\r\n        }\r\n        mod.select(key, type);\r\n        return this.selected;\r\n    }\r\n    selectCore(core) {\r\n        this.selected = core;\r\n    }\r\n    select(lib, key, type) {\r\n        this.modules.get(lib).select(key, type);\r\n    }\r\n    deselect() {\r\n        this.selected = undefined;\r\n    }\r\n    /**\r\n     * Spawn an instance of the selected node at a location\r\n     */\r\n    spawn(gp) {\r\n        if (this.selected instanceof _graph_operation__WEBPACK_IMPORTED_MODULE_0__.Operation) {\r\n            return _graph_node__WEBPACK_IMPORTED_MODULE_1__.GeonNode.new(gp, this.selected);\r\n        }\r\n        else if (this.selected instanceof _graph_widget__WEBPACK_IMPORTED_MODULE_2__.Widget) {\r\n            return _graph_node__WEBPACK_IMPORTED_MODULE_1__.GeonNode.newWidget(gp, this.selected.clone());\r\n        }\r\n    }\r\n    addModule(mod) {\r\n        this.modules.set(mod.name, mod);\r\n        mod.publishGlobally();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/operations/catalogue.ts?");

/***/ }),

/***/ "./src/operations/module.ts":
/*!**********************************!*\
  !*** ./src/operations/module.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NodesModule\": () => (/* binding */ NodesModule)\n/* harmony export */ });\n/* harmony import */ var _graph_operation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../graph/operation */ \"./src/graph/operation.ts\");\n/* harmony import */ var _util_misc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/misc */ \"./src/util/misc.ts\");\n/* harmony import */ var _catalogue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./catalogue */ \"./src/operations/catalogue.ts\");\n// purpose: module, or library representation\r\n\r\n\r\n\r\nclass NodesModule {\r\n    constructor(name, icon, fullPath, operations, widgets, catalogue) {\r\n        this.name = name;\r\n        this.icon = icon;\r\n        this.fullPath = fullPath;\r\n        this.operations = operations;\r\n        this.widgets = widgets;\r\n        this.catalogue = catalogue;\r\n    }\r\n    select(key, type) {\r\n        console.log(`select name: ${key} type: ${type}`);\r\n        let core;\r\n        if (type == _catalogue__WEBPACK_IMPORTED_MODULE_2__.CoreType.Operation) {\r\n            core = (0,_util_misc__WEBPACK_IMPORTED_MODULE_1__.tryFilter)(this.operations, (item) => { return item.name == key; });\r\n        }\r\n        else {\r\n            core = (0,_util_misc__WEBPACK_IMPORTED_MODULE_1__.tryFilter)(this.widgets, (item) => { return item.name == key; });\r\n        }\r\n        this.catalogue.selectCore(core);\r\n    }\r\n    static new(name, icon, fullPath, operations, widgets, catalogue) {\r\n        return new NodesModule(name, icon, fullPath, operations, widgets, catalogue);\r\n    }\r\n    /**\r\n     * extract the object. If it contains defined functions, fill it\r\n     */\r\n    static fromJsObject(name, icon, fullPath, origin, obj, catalogue) {\r\n        let ops = [];\r\n        for (const key in obj) {\r\n            let value = obj[key];\r\n            if (value instanceof Function) {\r\n                let f = value;\r\n                let op = _graph_operation__WEBPACK_IMPORTED_MODULE_0__.Operation.new(f, name);\r\n                ops.push(op);\r\n            }\r\n        }\r\n        return new NodesModule(name, icon, fullPath, ops, [], catalogue);\r\n    }\r\n    /**\r\n     * publish this module globally\r\n     */\r\n    publishGlobally() {\r\n        let space = {};\r\n        for (let op of this.operations) {\r\n            Object.defineProperty(space, op.name, { value: op.func, configurable: true });\r\n        }\r\n        Object.defineProperty(window, this.name, { value: space, configurable: true });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/operations/module.ts?");

/***/ }),

/***/ "./src/ui/category-main.ts":
/*!*********************************!*\
  !*** ./src/ui/category-main.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MenuContentMain\": () => (/* binding */ MenuContentMain)\n/* harmony export */ });\nclass MenuContentMain {\r\n    constructor() {\r\n    }\r\n    render(dom) {\r\n        dom.addDiv(\"text-white\");\r\n        dom.addText(\"New\").up();\r\n        dom.addText(\"Load\").up();\r\n        dom.addText(\"Save\").up();\r\n        dom.addText(\"Export\").up();\r\n        dom.up();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ui/category-main.ts?");

/***/ }),

/***/ "./src/ui/category-operators.ts":
/*!**************************************!*\
  !*** ./src/ui/category-operators.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MenuContentOperations\": () => (/* binding */ MenuContentOperations)\n/* harmony export */ });\n/* harmony import */ var _operations_catalogue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../operations/catalogue */ \"./src/operations/catalogue.ts\");\n\r\nclass MenuContentOperations {\r\n    constructor(cat, mod, canvas) {\r\n        this.cat = cat;\r\n        this.mod = mod;\r\n        this.canvas = canvas;\r\n    }\r\n    render(dom) {\r\n        renderCores(dom, this.mod.operations, this.mod.widgets, this.mod.select.bind(this.mod), this.canvas);\r\n    }\r\n}\r\nfunction renderCores(d, ops, wid, onPress, canvas) {\r\n    // operations\r\n    d.add('div', \"core-list\");\r\n    for (let i = 0; i < ops.length; i++) {\r\n        d.addButton(\"create-node-button m-1\", () => {\r\n            onPress(ops[i].name, _operations_catalogue__WEBPACK_IMPORTED_MODULE_0__.CoreType.Operation);\r\n            canvas.focus();\r\n        }).addText(ops[i].name);\r\n        d.up().up();\r\n    }\r\n    // gizmo's\r\n    for (let i = 0; i < wid.length; i++) {\r\n        d.addDiv(\"create-gizmo-button-wrapper\");\r\n        d.addButton(\"button\", () => {\r\n            onPress(wid[i].name, _operations_catalogue__WEBPACK_IMPORTED_MODULE_0__.CoreType.Widget);\r\n            canvas.focus();\r\n        }).addText(wid[i].name);\r\n        d.up().up().up();\r\n    }\r\n    d.up();\r\n    return d;\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ui/category-operators.ts?");

/***/ }),

/***/ "./src/ui/category-settings.ts":
/*!*************************************!*\
  !*** ./src/ui/category-settings.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MenuContentSettings\": () => (/* binding */ MenuContentSettings)\n/* harmony export */ });\nclass MenuContentSettings {\r\n    constructor() {\r\n    }\r\n    render(dom) {\r\n        dom.addDiv(\"text-white bg-dark w-100 h-100 m-0 p-0\");\r\n        dom.addText(\"darkmode\").up();\r\n        dom.addText(\"auto-render\").up();\r\n        dom.addText(\"display-mode\").up();\r\n        dom.up();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ui/category-settings.ts?");

/***/ }),

/***/ "./src/ui/category.ts":
/*!****************************!*\
  !*** ./src/ui/category.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MenuCategory\": () => (/* binding */ MenuCategory),\n/* harmony export */   \"MenuContent\": () => (/* binding */ MenuContent)\n/* harmony export */ });\nclass MenuCategory {\r\n    constructor(name, icon, selected, content) {\r\n        this.name = name;\r\n        this.icon = icon;\r\n        this.selected = selected;\r\n        this.content = content;\r\n    }\r\n}\r\nclass MenuContent {\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ui/category.ts?");

/***/ }),

/***/ "./src/ui/menu.ts":
/*!************************!*\
  !*** ./src/ui/menu.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Menu\": () => (/* binding */ Menu)\n/* harmony export */ });\n/* harmony import */ var _util_dom_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/dom-writer */ \"./src/util/dom-writer.ts\");\n/* harmony import */ var _category__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./category */ \"./src/ui/category.ts\");\n/* harmony import */ var _category_main__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./category-main */ \"./src/ui/category-main.ts\");\n/* harmony import */ var _category_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./category-operators */ \"./src/ui/category-operators.ts\");\n/* harmony import */ var _category_settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./category-settings */ \"./src/ui/category-settings.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Menu {\r\n    constructor(container, catalogue, canvas) {\r\n        this.container = container;\r\n        this.selected = \"\";\r\n        this.canvas = canvas;\r\n        this.categories = this.gererateCategories(catalogue);\r\n    }\r\n    static new(parent, catalogue, canvas) {\r\n        return new Menu(parent, catalogue, canvas);\r\n    }\r\n    updateCategories(catalogue) {\r\n        this.categories = this.gererateCategories(catalogue);\r\n        this.renderNav();\r\n    }\r\n    gererateCategories(catalogue) {\r\n        let items = [];\r\n        items.push(new _category__WEBPACK_IMPORTED_MODULE_1__.MenuCategory(\"geofront\", \"globe2\", true, new _category_main__WEBPACK_IMPORTED_MODULE_2__.MenuContentMain()));\r\n        for (let mod of catalogue.modules.values()) {\r\n            let ops = [];\r\n            for (let op of mod.operations.values()) {\r\n                ops.push(op);\r\n            }\r\n            // let content = renderCores(ops, [], onPress)\r\n            items.push(new _category__WEBPACK_IMPORTED_MODULE_1__.MenuCategory(mod.name, mod.icon, false, new _category_operators__WEBPACK_IMPORTED_MODULE_3__.MenuContentOperations(catalogue, mod, this.canvas)));\r\n        }\r\n        items.push(new _category__WEBPACK_IMPORTED_MODULE_1__.MenuCategory(\"settings\", \"gear\", true, new _category_settings__WEBPACK_IMPORTED_MODULE_4__.MenuContentSettings()));\r\n        return items;\r\n    }\r\n    renderSelected() {\r\n    }\r\n    renderNav() {\r\n        let d = _util_dom_writer__WEBPACK_IMPORTED_MODULE_0__.dom.body;\r\n        d.to(this.container);\r\n        d.clear();\r\n        d.addDiv(\"container px-0 mx-0\").style(\"width: 200px;'\");\r\n        d.addDiv(\"row\");\r\n        d.addDiv(\"col-6 d-flex flex-column\");\r\n        for (let cat of this.categories) {\r\n            let f = (ev) => {\r\n                this.select(cat.name);\r\n                this.canvas.focus();\r\n                ev.stopPropagation();\r\n            };\r\n            d.addButton(`menu-category ${cat.name}`, f).style(\"width: 100%; height: 60px\");\r\n            d.addBoostrapIcon(cat.icon).up();\r\n            d.addText(cat.name).up();\r\n            d.up();\r\n        }\r\n        d.up();\r\n        d.addDiv(\"container category-panel col-6\").style(\"height: max-content;\");\r\n        d.up();\r\n        d.up();\r\n        d.up();\r\n        // d.innerHTML = VerticalTabList.new(items).toHtml();\r\n        // b.up();\r\n    }\r\n    rerenderNav() {\r\n        // colorize buttons correctly\r\n        let bootstrapHighlightClasses = [\"bg-white\", \"text-danger\", \"border-danger\"];\r\n        let els = this.container.querySelectorAll('.menu-category');\r\n        for (let el of els) {\r\n            if (el.classList.contains(this.selected)) {\r\n                el.classList.add(...bootstrapHighlightClasses);\r\n            }\r\n            else {\r\n                el.classList.remove(...bootstrapHighlightClasses);\r\n            }\r\n        }\r\n        // render the side panel\r\n        let d = _util_dom_writer__WEBPACK_IMPORTED_MODULE_0__.dom.body.to(this.container);\r\n        d.toQuery(\".category-panel\");\r\n        d.clear();\r\n        if (this.selected != \"\") {\r\n            // d.addDiv(\"bg-white\").style(\"height: 100%\")\r\n            let cat = this.categories.filter((cat) => {\r\n                return cat.name == this.selected;\r\n            })[0];\r\n            cat.content.render(d);\r\n        }\r\n    }\r\n    select(name) {\r\n        if (name == this.selected) {\r\n            this.selected = \"\";\r\n        }\r\n        else {\r\n            this.selected = name;\r\n        }\r\n        this.rerenderNav();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/ui/menu.ts?");

/***/ }),

/***/ "./src/util/dom-writer.ts":
/*!********************************!*\
  !*** ./src/util/dom-writer.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DomHead\": () => (/* binding */ DomHead),\n/* harmony export */   \"DomWriter\": () => (/* binding */ DomWriter),\n/* harmony export */   \"Dom\": () => (/* binding */ Dom),\n/* harmony export */   \"dom\": () => (/* binding */ dom)\n/* harmony export */ });\n// author : Jos Feenstra \r\n// purpose: sort of jquery \r\nclass DomHead {\r\n    constructor() {\r\n    }\r\n    static new() {\r\n        return new DomHead();\r\n    }\r\n    addCss(fileName) {\r\n        // add a style sheet to the document\r\n        var head = document.head;\r\n        var link = document.createElement(\"link\");\r\n        link.type = \"text/css\";\r\n        link.rel = \"stylesheet\";\r\n        link.href = fileName;\r\n        link.className = fileName;\r\n        head.appendChild(link);\r\n    }\r\n    removeCss(fileName) {\r\n        // TODO\r\n        var links = document.querySelectorAll(\"link\");\r\n        links.forEach(link => {\r\n            if (link.className == fileName)\r\n                link.remove();\r\n        });\r\n    }\r\n}\r\n/**\r\n * A class to write DOM with.\r\n * It is created as a hierarchical writer: use `down` and `up` to traverse the DOM.\r\n * Almost all methods return `this` to make function chaining easy.\r\n */\r\nclass DomWriter {\r\n    constructor(cursor) {\r\n        this.cursor = cursor;\r\n    }\r\n    static new(pointer = document) {\r\n        return new DomWriter(pointer);\r\n    }\r\n    /**\r\n     * Go a step up the DOM hierachy\r\n     */\r\n    up() {\r\n        if (this.cursor.parentElement == null) {\r\n            throw new Error(\"no parent!!\");\r\n        }\r\n        this.cursor = this.cursor.parentElement;\r\n        return this;\r\n    }\r\n    /**\r\n     * Go a step down the DOM hierachy\r\n     */\r\n    down(index = 0) {\r\n        if (index < 0 || index >= this.cursor.childElementCount) {\r\n            throw new Error(\"index out of range!\");\r\n        }\r\n        this.cursor = this.cursor.children.item(index);\r\n        return this;\r\n    }\r\n    /**\r\n     * Go a step down the DOM hierachy\r\n     */\r\n    downFirst() {\r\n        if (this.cursor.firstElementChild == null) {\r\n            throw new Error(\"no first!!\");\r\n        }\r\n        this.cursor = this.cursor.firstElementChild;\r\n        return this;\r\n    }\r\n    /**\r\n     * Go a step down the DOM hierachy\r\n     */\r\n    downLast() {\r\n        if (this.cursor.lastElementChild == null) {\r\n            throw new Error(\"no first!!\");\r\n        }\r\n        this.cursor = this.cursor.lastElementChild;\r\n        return this;\r\n    }\r\n    get() {\r\n        return this.cursor;\r\n    }\r\n    to(obj) {\r\n        this.cursor = obj;\r\n        return this;\r\n    }\r\n    toId(id) {\r\n        this.cursor = document.getElementById(id);\r\n        return this;\r\n    }\r\n    toQuery(selector) {\r\n        this.cursor = document.querySelector(selector);\r\n        return this;\r\n    }\r\n    clear() {\r\n        while (this.cursor.firstChild) {\r\n            // let child = element.firstChild as HTMLElement;\r\n            // child.style.animation = 'hide 300ms';\r\n            this.cursor.removeChild(this.cursor.firstChild);\r\n        }\r\n        return this;\r\n    }\r\n    show() {\r\n        this.style(\"\");\r\n        return this.attr(\"hidden\", \"false\");\r\n    }\r\n    hide() {\r\n        return this.attr(\"hidden\", \"true\");\r\n    }\r\n    attr(attribute, value) {\r\n        if (this.cursor instanceof Document) {\r\n            throw new Error(\"not possible with document selected!\");\r\n        }\r\n        this.cursor.setAttribute(attribute, value);\r\n        return this;\r\n    }\r\n    get innerHTML() {\r\n        if (this.cursor instanceof Document) {\r\n            throw new Error(\"not possible with document selected!\");\r\n        }\r\n        return this.cursor.innerHTML;\r\n    }\r\n    set innerHTML(str) {\r\n        if (this.cursor instanceof Document) {\r\n            throw new Error(\"not possible with document selected!\");\r\n        }\r\n        this.cursor.innerHTML = str;\r\n    }\r\n    get innerText() {\r\n        if (this.cursor instanceof Document) {\r\n            throw new Error(\"not possible with document selected!\");\r\n        }\r\n        return this.cursor.innerText;\r\n    }\r\n    set innerText(str) {\r\n        if (this.cursor instanceof Document) {\r\n            throw new Error(\"not possible with document selected!\");\r\n        }\r\n        this.cursor.innerText = str;\r\n    }\r\n    style(str) {\r\n        return this.attr(\"style\", str);\r\n    }\r\n    // ---- various adders ----\r\n    append(el) {\r\n        this.cursor.appendChild(el);\r\n        this.downLast();\r\n        return this;\r\n    }\r\n    add(type, classes = \"\", content = \"\") {\r\n        let el = document.createElement(type);\r\n        el.innerText = content;\r\n        el.className = classes;\r\n        return this.append(el);\r\n    }\r\n    addLink(ref = \"#\", inner = \"link\", classes = \"\") {\r\n        let el = document.createElement(\"a\");\r\n        el.href = ref;\r\n        el.className = classes;\r\n        el.innerHTML = inner;\r\n        return this.append(el);\r\n    }\r\n    addDiv(classes = \"\") {\r\n        let el = document.createElement(\"div\");\r\n        el.className = classes;\r\n        return this.append(el);\r\n    }\r\n    addH1(inner, classes = \"\") {\r\n        let el = document.createElement(\"h1\");\r\n        el.innerText = inner;\r\n        el.className = classes;\r\n        return this.append(el);\r\n    }\r\n    addH2(message, classes = \"\") {\r\n        let el = document.createElement(\"h2\");\r\n        el.innerText = message;\r\n        el.className = classes;\r\n        return this.append(el);\r\n    }\r\n    addText(message, classes = \"\") {\r\n        let el = document.createElement(\"p\");\r\n        el.className = classes;\r\n        let text = document.createTextNode(message);\r\n        el.appendChild(text);\r\n        return this.append(el);\r\n    }\r\n    addButton(classes = \"\", callback) {\r\n        this.add(\"button\", classes);\r\n        this.cursor.addEventListener(\"click\", callback);\r\n        return this;\r\n    }\r\n    addComponentButton(name = \"button\", classes = \"\", callback) {\r\n        this.addDiv(\"control\").add(\"button\", \"control-button\");\r\n        this.innerText = name;\r\n        this.cursor.addEventListener(\"click\", callback);\r\n        this.up().add(\"p\", \"control-text\");\r\n        return this;\r\n    }\r\n    addBoostrapIcon(icon) {\r\n        this.add('i', `bi bi-${icon}`);\r\n        return this;\r\n    }\r\n}\r\nclass Dom {\r\n    constructor(head = DomHead.new(), body = DomWriter.new()) {\r\n        this.head = head;\r\n        this.body = body;\r\n    }\r\n}\r\nconst dom = new Dom();\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/util/dom-writer.ts?");

/***/ }),

/***/ "./src/util/io.ts":
/*!************************!*\
  !*** ./src/util/io.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"IO\": () => (/* binding */ IO),\n/* harmony export */   \"addDropFileEventListeners\": () => (/* binding */ addDropFileEventListeners),\n/* harmony export */   \"loadTextFromFile\": () => (/* binding */ loadTextFromFile),\n/* harmony export */   \"loadJSONFromFile\": () => (/* binding */ loadJSONFromFile),\n/* harmony export */   \"loadImageFromFile\": () => (/* binding */ loadImageFromFile),\n/* harmony export */   \"loadImageFromBlob\": () => (/* binding */ loadImageFromBlob),\n/* harmony export */   \"loadImageFromSrc\": () => (/* binding */ loadImageFromSrc)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nclass IO {\r\n    static importLibrary(path) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // let lib2 = await require(/* webpackIgnore: true */ location + path);\r\n            // console.log(lib2);\r\n            // NOTE: I'm forced to do this really convoluted, hacky stuff, \r\n            // because the above wont work for some reason \r\n            // const response = await fetch(location + path);\r\n            // const text = await response.text();   \r\n            return yield IO.loadLibrary(yield IO.fetchText(path));\r\n        });\r\n    }\r\n    static loadLibrary(libaryContent) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const dataUri = 'data:text/javascript;charset=utf-8,' + libaryContent;\r\n            //@ts-ignore\r\n            let res = yield import(/* webpackIgnore: true */ dataUri);\r\n            console.log('response', res);\r\n            return res;\r\n        });\r\n    }\r\n    static fetchText(path) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const response = yield fetch(location + path);\r\n            return yield response.text();\r\n        });\r\n    }\r\n    static fetchJson(path) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const response = yield fetch(location + path);\r\n            return yield response.json();\r\n        });\r\n    }\r\n    static promptDownload(file, text) {\r\n        var element = document.createElement(\"a\");\r\n        element.setAttribute(\"href\", \"data:text/plain;charset=utf-8, \" + encodeURIComponent(text));\r\n        element.setAttribute(\"download\", file);\r\n        document.body.appendChild(element);\r\n        element.click();\r\n        document.body.removeChild(element);\r\n    }\r\n}\r\nfunction addDropFileEventListeners(canvas, filesCallback) {\r\n    console.log(\"setting up drag events...\");\r\n    canvas.addEventListener(\"dragenter\", function (ev) {\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"entering entering...\");\r\n        return true;\r\n    }, true);\r\n    // setup file upload\r\n    canvas.addEventListener(\"dragover\", function (ev) {\r\n        //add hover class when drag over\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"over drag....\");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener(\"dragleave\", function (ev) {\r\n        //remove hover class when drag out\r\n        // ev.stopPropagation();\r\n        ev.preventDefault();\r\n        console.log(\"leaving drag....\");\r\n        return true;\r\n    }, true);\r\n    canvas.addEventListener(\"drop\", function (ev) {\r\n        //prevent browser from open the file when drop off\r\n        ev.stopPropagation();\r\n        ev.preventDefault();\r\n        //retrieve uploaded files data\r\n        var files = ev.dataTransfer.files;\r\n        filesCallback(files);\r\n        return true;\r\n    }, true);\r\n}\r\nfunction loadImageTest(files) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let image = yield loadImageFromFile(files.item(0));\r\n    });\r\n}\r\nfunction loadTextFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(reader.result);\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\nfunction loadJSONFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsText(file);\r\n        reader.onload = () => {\r\n            // console.log(reader.result);\r\n            resolve(JSON.parse(reader.result));\r\n        };\r\n        reader.onerror = (error) => reject(error);\r\n    });\r\n}\r\nfunction loadImageFromFile(file) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(file);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\nfunction loadImageFromBlob(blob) {\r\n    return new Promise((resolve, reject) => {\r\n        let reader = new FileReader();\r\n        reader.readAsDataURL(blob);\r\n        reader.onload = () => loadImageHelper1(reader).then((imageData) => resolve(imageData), (error) => reject(error));\r\n    });\r\n}\r\nfunction loadImageFromSrc(src) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement(\"img\");\r\n        img.src = src;\r\n        img.onload = () => resolve(loadImageHelper2(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction loadImageHelper1(fileReader) {\r\n    return new Promise(function (resolve, reject) {\r\n        let img = document.createElement(\"img\");\r\n        img.src = fileReader.result;\r\n        img.onload = () => resolve(loadImageHelper2(img));\r\n        img.onerror = () => reject(new Error(`Script load error for ${img}`));\r\n    });\r\n}\r\nfunction loadImageHelper2(image) {\r\n    var _a;\r\n    // turn it into image data by building a complete canvas and sampling it\r\n    let canvas = document.createElement(\"canvas\");\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    let ctx = canvas.getContext(\"2d\");\r\n    ctx.drawImage(image, 0, 0);\r\n    let data = ctx.getImageData(0, 0, image.width, image.height);\r\n    (_a = canvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(canvas);\r\n    return data;\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/util/io.ts?");

/***/ }),

/***/ "./src/util/misc.ts":
/*!**************************!*\
  !*** ./src/util/misc.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"tryFilter\": () => (/* binding */ tryFilter)\n/* harmony export */ });\nfunction tryFilter(array, predicate, thisArg) {\r\n    let l = array.filter(predicate);\r\n    if (l.length == 0) {\r\n        return undefined;\r\n    }\r\n    else {\r\n        return l[0];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/util/misc.ts?");

/***/ }),

/***/ "./src/util/permutator.ts":
/*!********************************!*\
  !*** ./src/util/permutator.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Casing\": () => (/* binding */ Casing),\n/* harmony export */   \"Permutator\": () => (/* binding */ Permutator)\n/* harmony export */ });\n// purpose: simple code that spits out unique names\r\n// note:    the stripped sequences are not perfect, please forgive me :)\r\nvar Casing;\r\n(function (Casing) {\r\n    Casing[Casing[\"lower\"] = 0] = \"lower\";\r\n    Casing[Casing[\"upper\"] = 1] = \"upper\";\r\n})(Casing || (Casing = {}));\r\nconst LOWER = \"abcdefghijklmnopqrstuvwxyz\";\r\nconst UPPER = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\r\nclass Permutator {\r\n    constructor(sequence, maxSize = 6, counter = 0, stripping = true, len = sequence.length) {\r\n        this.sequence = sequence;\r\n        this.maxSize = maxSize;\r\n        this.counter = counter;\r\n        this.stripping = stripping;\r\n        this.len = len;\r\n    }\r\n    static new() {\r\n    }\r\n    static newAlphabetPermutator(casing = Casing.lower, maxSize = 6) {\r\n        let alphabet = casing == Casing.lower ? LOWER : UPPER;\r\n        return new Permutator(alphabet, maxSize);\r\n    }\r\n    next() {\r\n        let name = this.generate(this.counter);\r\n        this.counter += 1;\r\n        return name;\r\n    }\r\n    generate(n) {\r\n        let str = \"\";\r\n        let size = this.stripping ? this.degree(n) : this.maxSize;\r\n        for (let i = size - 1; i > -1; i -= 1) {\r\n            let den = Math.pow(this.len, i);\r\n            let count = Math.floor(n / den);\r\n            str += this.sequence[count % this.len];\r\n        }\r\n        return str;\r\n    }\r\n    degree(n) {\r\n        for (let i = 1; i < this.maxSize; i++) {\r\n            if (n < Math.pow(this.len, i)) {\r\n                return i;\r\n            }\r\n        }\r\n        return 3;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/util/permutator.ts?");

/***/ }),

/***/ "./src/widgets/button-widget.ts":
/*!**************************************!*\
  !*** ./src/widgets/button-widget.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ButtonWidget\": () => (/* binding */ ButtonWidget)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _graph_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/widget */ \"./src/graph/widget.ts\");\n\r\n\r\nclass ButtonWidget extends _graph_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\r\n    // we must copy-paste `new` and `clone` to make sure the type stays consistent\r\n    static new(state) {\r\n        return new ButtonWidget(\"button\", _graph_widget__WEBPACK_IMPORTED_MODULE_1__.WidgetSide.Input, _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(1, 1), state);\r\n    }\r\n    clone() {\r\n        return ButtonWidget.new(this.state);\r\n    }\r\n    onClick(canvas) {\r\n        this.state = !this.state;\r\n        canvas.deselect();\r\n        canvas.graph.calculate();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/widgets/button-widget.ts?");

/***/ }),

/***/ "./src/widgets/display-widget.ts":
/*!***************************************!*\
  !*** ./src/widgets/display-widget.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ConsoleWidget\": () => (/* binding */ ConsoleWidget)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _graph_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/widget */ \"./src/graph/widget.ts\");\n/* harmony import */ var _text_widget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./text-widget */ \"./src/widgets/text-widget.ts\");\n\r\n\r\n\r\nclass ConsoleWidget extends _graph_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\r\n    static new(state) {\r\n        return new ConsoleWidget(\"console\", _graph_widget__WEBPACK_IMPORTED_MODULE_1__.WidgetSide.Output, _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(5, 1), state);\r\n    }\r\n    clone() {\r\n        return ConsoleWidget.new(this.state);\r\n    }\r\n    render(ctx, pos, component, cellSize) {\r\n        (0,_text_widget__WEBPACK_IMPORTED_MODULE_2__.renderTextInWidget)(this, `${this.state}`, ctx, pos, component, cellSize);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/widgets/display-widget.ts?");

/***/ }),

/***/ "./src/widgets/lamp-widget.ts":
/*!************************************!*\
  !*** ./src/widgets/lamp-widget.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LampWidget\": () => (/* binding */ LampWidget)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _graph_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/widget */ \"./src/graph/widget.ts\");\n\r\n\r\nclass LampWidget extends _graph_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\r\n    static new(state) {\r\n        return new LampWidget(\"lamp\", _graph_widget__WEBPACK_IMPORTED_MODULE_1__.WidgetSide.Output, _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(1, 1), state);\r\n    }\r\n    clone() {\r\n        return LampWidget.new(this.state);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/widgets/lamp-widget.ts?");

/***/ }),

/***/ "./src/widgets/text-widget.ts":
/*!************************************!*\
  !*** ./src/widgets/text-widget.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TextWidget\": () => (/* binding */ TextWidget),\n/* harmony export */   \"renderTextInWidget\": () => (/* binding */ renderTextInWidget)\n/* harmony export */ });\n/* harmony import */ var _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../engine/src/lib */ \"../engine/src/lib.ts\");\n/* harmony import */ var _graph_widget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../graph/widget */ \"./src/graph/widget.ts\");\n\r\n\r\nclass TextWidget extends _graph_widget__WEBPACK_IMPORTED_MODULE_1__.Widget {\r\n    static new(state) {\r\n        return new TextWidget(\"text\", _graph_widget__WEBPACK_IMPORTED_MODULE_1__.WidgetSide.Input, _engine_src_lib__WEBPACK_IMPORTED_MODULE_0__.Vector2.new(4, 1), state);\r\n    }\r\n    clone() {\r\n        return TextWidget.new(this.state);\r\n    }\r\n    render(ctx, pos, component, cellSize) {\r\n        renderTextInWidget(this, `${this.state}`, ctx, pos, component, cellSize);\r\n    }\r\n    onClick(canvas) {\r\n        let text = prompt(\"Input:\", \"data\");\r\n        if (text) {\r\n            this.state = text;\r\n        }\r\n        canvas.deselect();\r\n        canvas.graph.calculate();\r\n    }\r\n}\r\nfunction renderTextInWidget(w, text, ctx, pos, component, cellSize) {\r\n    let size = w.bounds.size().scaled(cellSize);\r\n    pos = pos.clone();\r\n    pos.x += w.bounds.x.t0 * cellSize;\r\n    pos.y += w.bounds.y.t0 * cellSize;\r\n    let center = pos.added(w.size.scaled(0.5));\r\n    // border\r\n    ctx.fillRect(pos.x + 2, pos.y + 2, size.x - 4, size.y - 4);\r\n    ctx.strokeRect(pos.x + 2, pos.y + 2, size.x - 4, size.y - 4);\r\n    // surface\r\n    ctx.fillStyle = \"#222222\";\r\n    ctx.fillRect(pos.x + 4, pos.y + 4, size.x - 8, size.y - 8);\r\n    // text\r\n    ctx.strokeStyle = \"white\";\r\n    ctx.lineWidth = 1.0;\r\n    ctx.font = \"consolas\";\r\n    ctx.textAlign = 'left';\r\n    ctx.textBaseline = 'top';\r\n    // let text = \"henkkagtijogrjoigtrjopokpokpokpigas\";\r\n    ctx.strokeText(text, pos.x + 10, pos.y + 10);\r\n}\r\n\n\n//# sourceURL=webpack://geon-vpl/./src/widgets/text-widget.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;